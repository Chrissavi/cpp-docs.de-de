---
title: Compilerfehler C3500 bis C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: eddadeeeb014c6b64376554f7ff025a06e8935c9
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/17/2020
ms.locfileid: "79446937"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Compilerfehler C3500 bis C3999

In den Artikeln in diesem Abschnitt der Dokumentation wird eine Teilmenge der Fehlermeldungen erläutert, die vom Compiler generiert werden.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Fehlermeldungen

|Fehler|`Message`|
|-----------|-------------|
|[Compilerfehler C3500](compiler-error-c3500.md)|Ungültige ProgID "*ProgID*"|
|[Compilerfehler C3501](compiler-error-c3501.md)|Es ist kein Export der Typbibliothek für die ProgID "*ProgID*" registriert.|
|Compilerfehler C3502|LIBID kann für ProgID "*ProgID*" nicht abgerufen werden.|
|Compilerfehler C3503|das Zeichen ' 0x-*Wert*' ist in einem unformatierten Zeichenfolgenliteral|
|Compilerfehler C3504|aus der Zeichenfolge "*String*" kann keine GUID erstellt werden.|
|[Compilerfehler C3505](compiler-error-c3505.md)|die Typbibliothek "*Library*" kann nicht geladen werden.|
|[Compilerfehler C3506](compiler-error-c3506.md)|Es ist kein Export der Typbibliothek für LIBID '*Library*' registriert.|
|[Compilerfehler C3507](compiler-error-c3507.md)|eine ProgID kann nicht mehr als 39 Zeichen "*ProgID*" aufweisen. und enthalten keine Interpunktions Zeichen außer "."; und nicht mit einer Ziffer beginnen|
|[Compilerfehler C3508](compiler-error-c3508.md)|"*Typ*": ist kein gültiger Automatisierungstyp.|
|[Compilerfehler C3509](compiler-error-c3509.md)|"*Typ*": Ungültiger Automatisierungs Rückgabetyp. Wenn ein Parameter als "retval" gekennzeichnet ist, muss der Rückgabetyp "void", "HRESULT" oder "SCODE" lauten.|
|[Compilerfehler C3510](compiler-error-c3510.md)|die *Bibliothek der abhängigen Typbibliothek wurde* nicht gefunden.|
|Compilerfehler C3511|"*Bezeichner*": ein Delegat Delegatkonstruktor muss der einzige Member-Initialisierer sein.|
|Compilerfehler C3512|die Trennzeichen Sequenz für ein unformatierten Zeichenfolgenliterals darf nicht mehr als 16 Zeichen enthalten.|
|Compilerfehler C3513|"*String*": nicht unterstütztes Trennzeichen für unformatierte Zeichen folgen Literale|
|Compilerfehler C3514|'*Character*' (*Wert*): nicht unterstütztes Zeichen folgen-literaltrennzeichen|
|Compilerfehler C3515|Wenn es sich bei einem Argument für eine partielle Spezialisierung einer Klassen Vorlage um eine Paket Erweiterung handelt, muss es das letzte Argument sein.|
|Compilerfehler C3516|beim Verarbeiten des rohzeichenfolgenliterals wurde ein unerwartetes Dateiende gefunden. Die Trenn*Zeichenfolge "String*" wurde nicht abgeglichen.|
|Compilerfehler C3517|"*Bezeichner*": eine Alias Deklaration darf keinen Typ aufweisen, der "Auto" enthält.|
|Compilerfehler C3518|'*Bezeichner*': in einem direkt Listen Initialisierungs Kontext kann der Typ für '*Type*' nur aus einem einzelnen initialisiererausdruck abgeleitet werden.|
|[Compilerfehler C3519](compiler-error-c3519.md)|'*Parameter*': Ungültiger Parameter für embedded_idl Attribut.|
|Compilerfehler C3520|"*Bezeichner*": das Parameter Paket muss in diesem Kontext erweitert werden.|
|Compilerfehler C3521|"*Identifier*" ist kein Parameter Paket.|
|Compilerfehler C3522|"*Typ*": das Parameter Paket kann in diesem Kontext nicht erweitert werden.|
|Compilerfehler C3523|"sizeof..." erfordert als Argument ein nicht erweitertes Parameter Paket|
|Compilerfehler C3524|'*Identifier*': ' sizeof ' kann nicht auf ein Parameter Paket angewendet werden. Wollten Sie "sizeof..." verwenden?|
|Compilerfehler C3525|"*Parameter*": Wenn eine Klassen Vorlage über ein Vorlagen Parameter Paket verfügt, muss Sie am Ende der Vorlagen Parameterliste angezeigt werden.|
|Compilerfehler C3526|'...' kann nicht auf "This" angewendet werden.|
|Compilerfehler C3527|"*Identifier*" ist kein gültiger Operand für "sizeof...". Meinten Sie, dass "sizeof" verwendet werden soll?|
|Compilerfehler C3528|"*Bezeichner1*": die Anzahl der Elemente in dieser Paket Erweiterung stimmt nicht mit der Anzahl der Elemente in "*Bezeichner2*" ab.|
|Compilerfehler C3529|"*Parameter*": ein Vorlagen Parameter Paket kann kein Standardargument aufweisen.|
|[Compilerfehler C3530](compiler-error-c3530.md)|'*Type*' kann nicht mit einem anderen Typspezifizierer kombiniert werden.|
|[Compilerfehler C3531](compiler-error-c3531.md)|"*Bezeichner*": ein Symbol, dessen Typ "*Typ*" enthält, muss einen Initialisierer aufweisen.|
|[Compilerfehler C3532](compiler-error-c3532.md)|der Elementtyp eines Arrays kann kein Typ sein, der "*Type*" enthält.|
|[Compilerfehler C3533](compiler-error-c3533.md)|ein Parameter darf keinen Typ aufweisen, der "*Type*" enthält.|
|Compilerfehler C3534|Veraltet.|
|[Compilerfehler C3535](compiler-error-c3535.md)|der Typ für "*Typ1*" kann nicht von "*Typ2*" abgeleitet werden.|
|[Compilerfehler C3536](compiler-error-c3536.md)|"*Identifier*": kann nicht verwendet werden, bevor es initialisiert wird.|
|[Compilerfehler C3537](compiler-error-c3537.md)|eine Umwandlung in einen Typ, der '*Type*' enthält, ist nicht möglich.|
|[Compilerfehler C3538](compiler-error-c3538.md)|in einer Deklaratorliste muss "*Type*" immer in denselben Typ hergeleitet werden.|
|[Compilerfehler C3539](compiler-error-c3539.md)|ein Vorlagen Argument kann kein Typ sein, der "*Type*" enthält.|
|[Compilerfehler C3540](compiler-error-c3540.md)|"sizeof" kann nicht auf einen Typ angewendet werden, der "*Type*" enthält.|
|[Compilerfehler C3541](compiler-error-c3541.md)|typeid kann nicht auf einen Typ angewendet werden, der "*Type*" enthält.|
|Compilerfehler C3542|"*Bezeichner*": eine virtuelle Member-Funktion darf keinen Rückgabetyp aufweisen, der "*Type*" enthält.|
|Compilerfehler C3543|"*Typ*": enthält kein Parameter Paket.|
|Compilerfehler C3544|"*Parameter*": das Parameter Paket erwartet ein typvorlagen Argument.|
|Compilerfehler C3545|"*Parameter*": das Parameter Paket erwartet ein Nichttyp-Vorlagen Argument.|
|Compilerfehler C3546|"...": Es sind keine zu erweiternden Parameter Pakete verfügbar.|
|Compilerfehler C3547|der Vorlagen Parameter "*Parameter*" kann nicht verwendet werden, da er einem Vorlagen Parameter Paket folgt und nicht aus den Funktionsparametern von "*Function*" abgeleitet werden kann.|
|Compilerfehler C3548|"*Bezeichner*": das Parameter Paket kann in diesem Kontext nicht verwendet werden.|
|Compilerfehler C3549|"*value*": ein Funktionsparameter Paket kann kein Standardargument aufweisen.|
|[Compilerfehler C3550](compiler-error-c3550.md)|In diesem Kontext ist nur ein einfaches "decltype(auto)" zulässig.|
|[Compilerfehler C3551](compiler-error-c3551.md)|Wenn ein nach stehender Rückgabetyp verwendet wird, muss der führende Rückgabetyp der einzelne Typspezifizierer "Auto" sein (nicht "*Type*").|
|[Compilerfehler C3552](compiler-error-c3552.md)|"decltype (Auto)" erwartet|
|[Compilerfehler C3553](compiler-error-c3553.md)|"decltype" erwartet einen Ausdruck und keinen Typ.|
|[Compilerfehler C3554](compiler-error-c3554.md)|'*Type*' kann nicht mit einem anderen Typspezifizierer kombiniert werden.|
|[Compilerfehler C3555](compiler-error-c3555.md)|Falsches Argument für "decltype"|
|[Compilerfehler C3556](compiler-error-c3556.md)|"*Ausdruck*": falsches Argument für "decltype"|
|Compilerfehler C3557|Veraltet.|
|Compilerfehler c3558 erzeugt|Veraltet.|
|Compilerfehler C3559|rekursiver Aufruf von '*Function*': beim Kompilieren des Aufruf Diagramms für die Parallelität::p arallel_for_each unter: '*Function*' wurde eine Rekursion erkannt.|
|Compilerfehler C3560|"*Function*": Il ist nicht verfügbar, wenn der Aufruf Graph für die Parallelität kompiliert wird::p arallel_for_each an: "*Function*"|
|Compilerfehler C3561|der Kachel Sperrungs Vorgang wurde in der Ablauf Steuerung gefunden, die beim Kompilieren des Aufruf Diagramms für die Parallelität::p arallel_for_each unter: '*Function*' keine Kachel-Uniform ist.|
|Compilerfehler C3562|die intrinsische Funktion "*Function*" darf nicht mehr als *Zahlen* Parameter aufweisen.|
|Compilerfehler C3563|Unendliche Schleife beim Kompilieren des Aufruf Diagramms für die Parallelität::p arallel_for_each unter: "*Function*" erkannt.|
|Compilerfehler C3564|der nicht initialisierte Wert wird beim Kompilieren des Aufruf Diagramms für die neben läufigkeits::p arallel_for_each unter: "*Function*" gelesen.|
|Compilerfehler C3565|Die Gesamtmenge an tile_static Arbeitsspeicher *(Byte* ) überschreitet die *Anzahl* der Bytes, die beim Kompilieren des Aufruf Diagramms für die Parallelität::p arallel_for_each|
|Compilerfehler C3566|Blöcke mit Nebeneffekten sind beim Kompilieren des Aufruf Diagramms für die Parallelität zu tief geschachtelt::p arallel_for_each bei: "*Function*".|
|Compilerfehler C3567|beim Kompilieren des Aufruf Diagramms für die Parallelität::p arallel_for_each auf: "*Function*" wurde eine Teilung oder ein mod durch Null erkannt.|
|Compilerfehler C3568|die Summe der Register überschreitet den Grenzwert von *Number* beim Kompilieren des Aufruf Diagramms für die Parallelität::p arallel_for_each. Vereinfachen Sie Ihr Programm.|
|Compilerfehler C3569|Racebedingung beim Kompilieren des Aufruf Diagramms für die Parallelität::p arallel_for_each unter: "*Function*" erkannt|
|Compilerfehler C3570|Unzulässige Verwendung des eingeschränkten amp-Bereichs beim Kompilieren mit/CLR|
|Compilerfehler C3571|'*Typ*': unzulässiges Compute-Domänen Argument; kein Klassentyp|
|Compilerfehler C3572|'*Typ*': unzulässiges Compute-Domänen Argument; fehlender öffentlicher Member: "statischer konstanter int-Rang" oder Rangwert ist nicht positiv|
|Compilerfehler C3573|Die Anzahl der Instanzen von Parallelität:: Graphics:: Sampler, die an die Parallelität übergebenen werden::p arallel_for_each die *Zahl* nicht überschreiten darf.|
|Compilerfehler C3574|'*Typ*': unzulässige Kachel Blöcke: muss positiv und (1) Z < = *Number*; sein. (2) Z*Y*X < = *Zahl*|
|Compilerfehler C3575|'*Typ*': unzulässiges Compute-Domänen Argument; Fehlendes öffentliches Mitglied: ' parallelcurrency:: Index <*Number*> _map_index (Konstante Parallelität:: Index <*Number*> &) einschränken (amp) "|
|Compilerfehler C3576|'*Typ*': Parallelität::d etails:: _Parallel_for_each Argument #*Number* weist einen nicht unterstützten Typ auf.|
|Compilerfehler C3577|Parallelität::p arallel_for_each Kernel Argument ist unzulässig: der Rückruf des Members "void Operator () (*Type*) Einschränkung (amp)" kann nicht aufgelöst werden.|
|Compilerfehler C3578|Die Größe des an die Parallelität übergebenen Funktions Objekts::p arallel_for_each kann nicht länger als die *Anzahl* der Bytes sein.|
|Compilerfehler C3579|Die Anzahl der schreibgeschützten Instanzen von parallelcurrency:: Array und parallelcurrency:: Graphics:: Texture an die Parallelität::p arallel_for_each die *Zahl* nicht überschreiten darf.|
|Compilerfehler C3580|Die Anzahl der beschreibbaren Instanzen von parallelcurrency:: Array und parallelcurrency:: Graphics:: Texture, die an die Parallelität übergebenen werden::p arallel_for_each darf die *Zahl* nicht überschreiten.|
|Compilerfehler C3581|"*Typ*": nicht unterstützter Typ in eingeschränktem amp-Code.|
|Compilerfehler C3582|Veraltet.|
|Compilerfehler C3583|'*Identifier*': die Größe der Variablen (*Anzahl* Bytes) ist größer als die maximale Größe (*Anzahl* Bytes), die in eingeschränktem amp-Code unterstützt wird.|
|Compilerfehler C3584|nicht unterstützte Verwendung von tile_static für "*Identifier*".|
|Compilerfehler C3585|"*Identifier*" weist im eingeschränkten amp-Code eine nicht unterstützte Speicher Klasse auf.|
|Compilerfehler C3586|"*Bezeichner*": die Verwendung von globalen oder statischen Variablen wird in eingeschränktem amp-Code nicht unterstützt.|
|Compilerfehler C3587|dynamic_cast wird in eingeschränktem amp-Code nicht unterstützt.|
|Compilerfehler C3588|die Umwandlung von '*Typ1*' in '*Typ2*' wird in eingeschränktem amp-Code nicht unterstützt.|
|Compilerfehler C3589|"*String*": nicht unterstützte Verwendung von Zeichenfolgenliteralen in eingeschränktem amp-Code.|
|Compilerfehler C3590|"*Token*": nach Verweis Erfassung oder "This"-Erfassung wird nicht unterstützt, wenn der Lambda-Parameter "amp Restricted" ist|
|Compilerfehler C3591|typeid-Operator wird in eingeschränktem amp-Code nicht unterstützt.|
|Compilerfehler C3592|Die systemeigene Inline Assembly ("__asm") wird in eingeschränktem amp-Code nicht unterstützt.|
|Compilerfehler C3593|"goto" wird in eingeschränktem amp-Code nicht unterstützt.|
|Compilerfehler C3594|Ausnahmebehandlung (try, catch, Throw usw.) wird in eingeschränktem amp-Code nicht unterstützt.|
|Compilerfehler C3595|der Konstante Wert liegt in eingeschränktem amp-Code außerhalb des unterstützten Bereichs.|
|Compilerfehler C3596|'*Parameter*' ('*Type*'): die von Lambda erfasste Variable weist einen nicht unterstützten Typ in eingeschränktem amp-Code auf.|
|Compilerfehler C3597|'*Parameter*': '*Identifier*' darf nicht als Wert aufgezeichnet werden, wenn der Lambda-Wert amp-eingeschränkt ist.|
|Compilerfehler C3598|die Label-Anweisung wird in eingeschränktem amp-Code nicht unterstützt|
|Compilerfehler C3599|"*Operator*": Zeigerarithmetik für Zeiger auf bool in eingeschränktem amp-Code kann nicht durchgeführt werden.|
|Compilerfehler C3600|"*Funktion*": die Verwendung von Kachel\_statischem Speicher, die beim Kompilieren des Aufruf Diagramms für die nicht-tige-Parallelität erkannt wurde::p arallel\_for_each an: "*Function*"|
|Compilerfehler C3601|"*Typ*": Ungültiger Argumenttyp für amp-Diagnosefunktion "*Function*".|
|Compilerfehler C3602|Beim Kompilieren des Aufruf Diagramms für die Parallelität::p arallel_for_each unter "*Function*" wurde eine nicht unterstützte Ablauf Steuerung erkannt.|
|[Compilerfehler C3603](compiler-error-c3603.md)|'*Symbol*': Typ '*Typ*' wird noch nicht unterstützt.|
|Compilerfehler C3604|"*Bezeichner*": Es kann nur ein verwaltetes Objekt auf dem GC-Heap erstellt werden.|
|Compilerfehler C3605|Die Gesamtanzahl der samplz (mit der*Zahl* aufgezeichnet und der vordefinierten *Zahl* ) überschreitet die *Anzahl* beim Kompilieren des Aufruf Diagramms für die Parallelität::p arallel_for_each bei: "*Function*".|
|Compilerfehler C3606|Veraltet.|
|Compilerfehler C3607|Veraltet.|
|Compilerfehler C3608|Veraltet.|
|[Compilerfehler C3609](compiler-error-c3609.md)|"*Bezeichner*": eine "Sealed/Final"-Funktion muss virtuell sein.|
|[Compilerfehler C3610](compiler-error-c3610.md)|'*Identifier*': der Werttyp muss ' Boxed ' sein, bevor die Methode '*method*' aufgerufen werden kann.|
|[Compilerfehler C3611](compiler-error-c3611.md)|'*Identifier*': eine versiegelte Funktion kann keinen reinen Spezifizierer aufweisen.|
|[Compilerfehler C3612](compiler-error-c3612.md)|"*Bezeichner*": eine versiegelte Klasse kann keine reinen virtuellen Methoden aufweisen.|
|Compilerfehler C3613|fehlender Rückgabetyp nach '-> ' (' int ' wird angenommen)|
|Compilerfehler C3614|Abweichende Werte für die Paketgröße innerhalb derselben Klasse; Previous war '*value*', neuer Wert ist '*value*'.|
|[Compilerfehler C3615](compiler-error-c3615.md)|die constexpr-Funktion "*Function*" kann keinen konstanten Ausdruck ergeben.|
|Compilerfehler C3616|Veraltet.|
|Compilerfehler C3617|Veraltet.|
|[Compilerfehler C3618](compiler-error-c3618.md)|"*Declaration*": eine mit "DllImport" markierte Methode kann nicht definiert werden.|
|[Compilerfehler C3619](compiler-error-c3619.md)|eine Vorlage kann nicht innerhalb eines verwalteten/WinRT-Typs deklariert werden.|
|Compilerfehler C3620|"*Typ*": das Festlegen der Ausrichtung ist für WinRT-Typen nicht zulässig.|
|Compilerfehler C3621|"*Typ*": für WinRT-Typen ist nur der standardmäßige Verpackungs Wert (*Number*) zulässig.|
|[Compilerfehler C3622](compiler-error-c3622.md)|*Typ*": eine Klasse, die als '*Schlüsselwort*' deklariert wurde, kann nicht instanziiert werden.|
|[Compilerfehler C3623](compiler-error-c3623.md)|"*Bezeichner*": Bitfelder werden in verwalteten/WinRT-Typen nicht unterstützt.|
|[Compilerfehler C3624](compiler-error-c3624.md)|'*Typ*': für die Verwendung dieses Typs ist ein Verweis auf die Assembly/das Modul '*Identifier*' erforderlich.|
|[Compilerfehler C3625](compiler-error-c3625.md)|"*Klasse*": ein System eigener Typ kann nicht von einem verwalteten/WinRT-Typ "*Typ*" abgeleitet werden.|
|[Compilerfehler C3626](compiler-error-c3626.md)|'*Identifier*': '*Schlüssel*Wort '-Schlüsselwort kann nur für COM-Schnittstellen, Element Funktionen und Datenmember verwendet werden, die Zeiger auf Delegaten sind|
|[Compilerfehler C3627](compiler-error-c3627.md)|Nur ein Werttyp kann per Boxing versehen werden.|
|[Compilerfehler C3628](compiler-error-c3628.md)|"*Class*": verwaltete/WinRT-Klassen unterstützen nur die öffentliche Vererbung.|
|Compilerfehler C3629|"*Token*": ein Erfassungs Standard kann nur am Anfang einer Lambda Erfassungs Liste angezeigt werden.|
|[Compilerfehler C3630](compiler-error-c3630.md)|Fehler beim Verarbeiten des Tokens "*Token*".|
|[Compilerfehler C3631](compiler-error-c3631.md)|"*Ereignis*": verwaltete/WinRT-Ereignisse können nicht überladen werden.|
|[Compilerfehler C3632](compiler-error-c3632.md)|"*Ereignis*": Unzulässiger Stil des Ereignisses für das *Konstrukt*|
|[Compilerfehler C3633](compiler-error-c3633.md)|'*Identifier*' kann nicht als Member der verwalteten '*Class*' definiert werden.|
|[Compilerfehler C3634](compiler-error-c3634.md)|"*Member*": eine abstrakte Methode einer verwalteten/WinRT-Klasse kann nicht definiert werden.|
|Compilerfehler C3635|"*Bezeichner*": kann nicht auf eine verwaltete/WinRT-Klasse angewendet werden (verwenden Sie stattdessen "*Identifier*").|
|Compilerfehler C3636|"*Bezeichner*": kann nicht auf diesen Typ angewendet werden.|
|[Compilerfehler C3637](compiler-error-c3637.md)|"*Function*": die Definition einer Friend-Funktion darf keine Spezialisierung einer Funktions Vorlage/generischen Funktion sein.|
|[Compilerfehler C3638](compiler-error-c3638.md)|'*Operator*': die standardmäßigen Boxing-und Unboxing-Konvertierungs Operatoren können nicht neu definiert werden|
|Compilerfehler C3639|Veraltet.|
|[Compilerfehler C3640](compiler-error-c3640.md)|"*Member*": eine referenzierte oder virtuelle Member-Funktion einer lokalen Klasse muss definiert werden.|
|[Compilerfehler C3641](compiler-error-c3641.md)|"*Function*": Ungültige Aufruf Konvention "*Konvention*" für eine mit/CLR: pure oder/CLR: safe kompilierte Funktion|
|[Compilerfehler C3642](compiler-error-c3642.md)|"*Function*": eine Funktion kann nicht mit __clrcall Aufruf Konvention aus System eigenem Code aufgerufen werden.|
|Compilerfehler C3643|Veraltet.|
|[Compilerfehler C3644](compiler-error-c3644.md)|"*Funktion*": die Funktion kann nicht kompiliert werden, um verwalteten Code zu generieren.|
|[Compilerfehler C3645](compiler-error-c3645.md)|"*Function*": __clrcall kann nicht für Funktionen verwendet werden, die in System eigenem Code kompiliert wurden.|
|[Compilerfehler C3646](compiler-error-c3646.md)|"*Bezeichner*": Unbekannter Überschreibungsspezifizierer|
|Compilerfehler C3647|Veraltet.|
|[Compilerfehler C3648](compiler-error-c3648.md)|Diese explizite Überschreibungs Syntax wird für verwaltete Typen nicht unterstützt.|
|Compilerfehler C3649|Diese explizite Überschreibungs Syntax ist in/ZW nicht zulässig.|
|[Compilerfehler C3650](compiler-error-c3650.md)|"*Member*": kann nicht als explizite Überschreibung verwendet werden, muss eine virtuelle Member-Funktion einer Basisklasse sein.|
|[Compilerfehler C3651](compiler-error-c3651.md)|"*Member*": kann nicht als explizite Überschreibung verwendet werden, muss ein Member einer Basisklasse sein.|
|[Compilerfehler C3652](compiler-error-c3652.md)|"*Member*": eine Funktion, die explizit überschreibt, muss virtuell sein.|
|[Compilerfehler C3653](compiler-error-c3653.md)|"*Identifier*": kann nicht als benannte außer Kraft Setzung verwendet werden: eine Funktion, die überschrieben wird, wurde nicht gefunden. haben Sie vergessen, die Funktion explizit zu benennen, indem Sie einen::-Operator verwenden?|
|[Compilerfehler C3654](compiler-error-c3654.md)|"*Token*": Syntax Fehler in expliziter Überschreibung.|
|[Compilerfehler C3655](compiler-error-c3655.md)|"*Member*": die Funktion wurde bereits explizit überschrieben.|
|[Compilerfehler C3656](compiler-error-c3656.md)|'*Schlüsselwort*': Überschreibungsspezifizierer kann nicht wiederholt|
|[Compilerfehler C3657](compiler-error-c3657.md)|ein debugtor/Finalizer kann nicht explizit überschreiben oder explizit überschrieben werden.|
|Compilerfehler C3658|Veraltet.|
|Compilerfehler C3659|"*Member*": Überschreibungsspezifizierer "*Schlüsselwort*" wird nicht unterstützt.|
|Compilerfehler C3660|"*Member1*": Blendet den geerbten Member "*member2*" aus.|
|[Compilerfehler C3661](compiler-error-c3661.md)|die explizite Überschreibungs Liste hat keine zu über schreibenden Methoden gefunden.|
|[Compilerfehler C3662](compiler-error-c3662.md)|"*Member*": der Überschreibungsspezifizierer "*Keyword*" ist nur für Member-Funktionen von verwalteten/WinRT-Klassen zulässig.|
|Compilerfehler C3663|Veraltet.|
|Compilerfehler C3664|"*Member*": kann nicht als explizite Überschreibung verwendet werden, muss über die Zugriffsmöglichkeiten "Public" oder "Protected" verfügen.|
|[Compilerfehler C3665](compiler-error-c3665.md)|"*Member*": Überschreibungsspezifizierer "*Schlüsselwort*" ist für einen destrukturtor/Finalizer nicht zulässig.|
|[Compilerfehler C3666](compiler-error-c3666.md)|'*Konstruktor*': der Überschreibungsspezifizierer '*Schlüsselwort*' ist für einen Konstruktor nicht zulässig.|
|Compilerfehler C3667|"*Attribut*": das Attribut unterstützt keine Paket Erweiterung.|
|[Compilerfehler C3668](compiler-error-c3668.md)|"*Member*": die Methode mit dem Überschreibungsspezifizierer "override" hat keine Basisklassen Methoden überschrieben.|
|[Compilerfehler C3669](compiler-error-c3669.md)|"*Member*": der Überschreibungsspezifizierer "override" ist für statische Element Funktionen oder Konstruktoren nicht zulässig.|
|[Compilerfehler C3670](compiler-error-c3670.md)|'*Member*': die nicht zugängliche Basisklassen Methode '*Member*' kann nicht überschrieben werden.|
|[Compilerfehler C3671](compiler-error-c3671.md)|"*Member*": die Funktion überschreibt "*Member*" nicht.|
|[Compilerfehler C3672](compiler-error-c3672.md)|der Pseudo destruktorausdruck kann nur als Teil eines Funktions Aufrufes verwendet werden.|
|[Compilerfehler C3673](compiler-error-c3673.md)|"*Class*": die Klasse hat keinen Kopierkonstruktor.|
|Compilerfehler C3674|Das Standard Bibliotheks Modul "*Module*" wurde nicht gefunden.|
|[Compilerfehler C3675](compiler-error-c3675.md)|"*Function*": ist reserviert, da "*Property*" definiert ist.|
|Compilerfehler C3676|"*Klasse*": Verweis Klasse und Basisklasse weisen nicht kompatible Attribute "[*Attribute*]" auf.|
|Compilerfehler C3677|Zeichenfolgenliterale nach "Operator" darf kein Codierungs Präfix|
|Compilerfehler C3678|Zeichenfolgenliterale nach "Operator" muss die leere Zeichenfolge "" "" "" sein.|
|Compilerfehler C3679|Es wurde ein LiteralSuffix-Bezeichner nach "Operator" "" "" erwartet.|
|Compilerfehler C3680|benutzerdefinierte Zeichen folgen Literale können nicht mit nicht übereinstimmenden literalsuffixbezeichern verkettet werden.|
|Compilerfehler C3681|"FallThrough": das Attribut darf nur in einer einschließenden switch-Anweisung enthalten sein.|
|Compilerfehler C3682|"Operator *Bezeichner*": die literaloperator/literaloperatorvorlage kann nicht als "C-Verknüpfung" deklariert werden.|
|Compilerfehler C3683|der unformatierte literaloperator und die literaloperator-Vorlage mit demselben LiteralSuffix-Bezeichner können|
|Compilerfehler C3684|"Operator *Bezeichner*": Deklaration des literaloperators weist eine ungültige Parameterliste auf.|
|Compilerfehler C3685|' Operator *Bezeichner*': die literaloperator-Vorlage darf keine Funktionsparameter aufweisen.|
|Compilerfehler C3686|*Operator-* ID: die literaloperator-Vorlage muss genau einen Vorlagen Parameter aufweisen, bei dem es sich um ein Parameter Paket handelt.|
|Compilerfehler C3687|' Operator *Bezeichner*': die literaloperator-Vorlage muss einen Nichttyp-Vorlagen Parameter vom Typ ' char ' aufweisen.|
|Compilerfehler C3688|Ungültiges LiteralSuffix '*Suffix*'; der literaloperator oder literaloperator-Vorlage "Operator *Identifier*" wurde nicht gefunden.|
|Compilerfehler C3689|*Operator-ID: die*Literale Operator/literaloperator-Vorlage muss sich in einem globalen oder einem Namespace Bereich befinden.|
|Compilerfehler C3690|Es wurde ein Zeichenfolgenliteral erwartet, stattdessen wurde jedoch ein benutzerdefiniertes Zeichen folgen|
|Compilerfehler C3691|Ungültiges literalpräfix "*prefix*".|
|Compilerfehler C3692|Veraltet.|
|Compilerfehler C3693|Veraltet.|
|Compilerfehler C3694|Veraltet.|
|Compilerfehler C3695|Veraltet.|
|Compilerfehler C3696|'*Schlüsselwort*': dieser Qualifizierer kann nicht für '% ' verwendet werden.|
|[Compilerfehler C3697](compiler-error-c3697.md)|"*Schlüsselwort*": dieser Qualifizierer kann nicht für "^" verwendet werden.|
|[Compilerfehler C3698](compiler-error-c3698.md)|"*Typ*": dieser Typ kann nicht als Argument von "*Operator*" verwendet werden.|
|[Compilerfehler C3699](compiler-error-c3699.md)|"*Operator*": Diese Dereferenzierung kann nicht für den Typ "*Typ*" verwendet werden.|
|Compilerfehler C3700|Veraltet.|
|[Compilerfehler C3701](compiler-error-c3701.md)|"*Function*": Ereignis Quelle hat keine Ereignisse|
|[Compilerfehler C3702](compiler-error-c3702.md)|ATL ist für COM-Ereignisse erforderlich.|
|[Compilerfehler C3703](compiler-error-c3703.md)|'*event_handler*': eine Ereignishandlermethode muss dieselbe Speicher Klasse wie die Quelle '*Ereignis*' aufweisen.|
|[Compilerfehler C3704](compiler-error-c3704.md)|"*Member*": eine vararg-Methode kann keine Ereignisse auslösen.|
|[Compilerfehler C3705](compiler-error-c3705.md)|"*Funktion*": ereigentienschnittstelle kann nicht gefunden werden.|
|[Compilerfehler C3706](compiler-error-c3706.md)|"*Function*": muss eine COM-Schnittstelle zum Auslösen von COM-Ereignissen sein.|
|[Compilerfehler C3707](compiler-error-c3707.md)|"*Member*": die dispinterface-Methode muss eine "DISPID" aufweisen.|
|[Compilerfehler C3708](compiler-error-c3708.md)|'*Function*': Ungültige Verwendung von '*Schlüsselwort*'; muss ein Member einer kompatiblen Ereignis Quelle sein.|
|[Compilerfehler C3709](compiler-error-c3709.md)|"*Function*": Ungültige Syntax zum Angeben eines Ereignisses in __hook/__unhook|
|[Compilerfehler C3710](compiler-error-c3710.md)|"*Function*": Ungültige Syntax zum Angeben eines Ereignis Handlers in __hook/__unhook|
|[Compilerfehler C3711](compiler-error-c3711.md)|"*Ereignis*": eine nicht verwaltete Ereignis Quell Methode muss "void" oder einen ganzzahligen Typ zurückgeben.|
|[Compilerfehler C3712](compiler-error-c3712.md)|"*event_handler*": eine Ereignishandlermethode muss denselben Typ wie die Quelle "*Ereignis*" zurückgeben.|
|[Compilerfehler C3713](compiler-error-c3713.md)|'*event_handler*': eine Ereignishandlermethode muss dieselben Funktionsparameter wie die Quelle '*Ereignis*' aufweisen.|
|[Compilerfehler C3714](compiler-error-c3714.md)|'*event_handler*': eine Ereignishandlermethode muss dieselbe Aufruf Konvention wie die Quelle '*Ereignis*' aufweisen.|
|[Compilerfehler C3715](compiler-error-c3715.md)|'*Pointer*': muss ein Zeiger auf '*Type*' sein.|
|Compilerfehler C3716|Veraltet.|
|[Compilerfehler C3717](compiler-error-c3717.md)|"*Member*": eine Methode, die Ereignisse auslöst, kann nicht definiert werden.|
|[Compilerfehler C3718](compiler-error-c3718.md)|"__-*Schlüsselwort*" kann nur im Kontext einer Member-Funktion der empfangenden Klasse aufgerufen werden.|
|[Compilerfehler C3719](compiler-error-c3719.md)|"*Member*": eine Schnittstellen basierte Ereignis Quelle kann nur für COM-Ereignisse verwendet werden.|
|Compilerfehler C3720|"*Typ*": IDispatch kann nur in einem Dual-oder dispinterface-Element implementiert werden.|
|[Compilerfehler C3721](compiler-error-c3721.md)|"*Signature*": inkompatible Signatur für Ereignis|
|[Compilerfehler C3722](compiler-error-c3722.md)|ein generisches Ereignis ist nicht zulässig.|
|[Compilerfehler C3723](compiler-error-c3723.md)|"*Funktion*": Ereignis konnte nicht aufgelöst werden.|
|[Compilerfehler C3724](compiler-error-c3724.md)|\<Windows. h-> muss für die Verwendung von Multithreading mit Ereignissen #include werden.|
|Compilerfehler C3725|Veraltet.|
|Compilerfehler C3726|Veraltet.|
|[Compilerfehler C3727](compiler-error-c3727.md)|"*Ereignis*": ein verwaltetes Ereignis muss eine Member-Funktion oder ein Datenmember sein, der ein Zeiger auf einen Delegaten ist.|
|[Compilerfehler C3728](compiler-error-c3728.md)|"*Ereignis*": das Ereignis hat keine Raise-Methode.|
|Compilerfehler C3729|Veraltet.|
|Compilerfehler C3730|Veraltet.|
|[Compilerfehler C3731](compiler-error-c3731.md)|Inkompatibles Ereignis '*Ereignis*' und Handler '*event_handler*'; Ereignis Quelle und Ereignishandler müssen den gleichen Ereignistyp aufweisen|
|[Compilerfehler C3732](compiler-error-c3732.md)|'*Schnittstelle*': eine benutzerdefinierte Schnittstelle, die com-Ereignisse auslöst, kann nicht von IDispatch erben|
|[Compilerfehler C3733](compiler-error-c3733.md)|"*Ereignis*": falsche Syntax zum Angeben eines com-Ereignisses. haben Sie "__interface" vergessen?|
|[Compilerfehler C3734](compiler-error-c3734.md)|"*Class*": eine verwaltete/WinRT-Klasse kann keine Co-Klasse sein.|
|Compilerfehler C3735|Veraltet.|
|[Compilerfehler C3736](compiler-error-c3736.md)|"*Member*": muss eine Methode sein, oder, im Falle von verwalteten Ereignissen, optional ein Datenmember.|
|[Compilerfehler C3737](compiler-error-c3737.md)|"*Bezeichner*": ein Delegat hat möglicherweise keine explizite Aufruf Konvention.|
|[Compilerfehler C3738](compiler-error-c3738.md)|'*Konvention*': die Aufruf Konvention der expliziten Instanziierung muss mit der der instanziierten Vorlage übereinstimmen.|
|[Compilerfehler C3739](compiler-error-c3739.md)|'*Class*': die Syntax wird nur unterstützt, wenn der Parameter ' Layout\_abhängig ' von event_receiver den Wert ' true ' hat.|
|[Compilerfehler C3740](compiler-error-c3740.md)|"*Template*": Vorlagen können keine Ereignisse abrufen oder empfangen.|
|[Compilerfehler C3741](compiler-error-c3741.md)|"*Class*": muss eine Co-Klasse sein, wenn der "Layout\_abhängige" Parameter von event_receiver "true" ist.|
|Compilerfehler C3742|'*ttoken1*': unausgeglichene tokensequenz im Attribut Argument von '*Attribut*', erwartet wurde '*Token2*'.|
|[Compilerfehler C3743](compiler-error-c3743.md)|eine gesamte Schnittstelle kann nur ein Hook/unhook erhalten werden, wenn der Parameter "layout_dependent" event_receiver "true" ist.|
|[Compilerfehler C3744](compiler-error-c3744.md)|__unhook müssen mindestens 3 Argumente für verwaltete Ereignisse aufweisen.|
|[Compilerfehler C3745](compiler-error-c3745.md)|"*Function*": nur ein Ereignis kann "Raised" sein.|
|Compilerfehler C3746|Das Standard Attribut "*Identifier*" darf höchstens einmal in einer Attribut Liste vorkommen.|
|[Compilerfehler C3747](compiler-error-c3747.md)|fehlende Standardvorlage/generischer Parameter: Parameter *Nummer*|
|[Compilerfehler C3748](compiler-error-c3748.md)|'*Schnittstelle*': nicht verwaltete Schnittstellen lösen möglicherweise keine Ereignisse aus|
|[Compilerfehler C3749](compiler-error-c3749.md)|"*Attribut*": ein benutzerdefiniertes Attribut darf nicht innerhalb einer Funktion verwendet werden.|
|Compilerfehler C3750|"*Token*": Unerwartetes Token in der Attribut Liste|
|Compilerfehler C3751|"*Bezeichner*": Unerwarteter Bezeichner in der Attribut Liste|
|[Compilerfehler C3752](compiler-error-c3752.md)|"*Attribut*": das Attribut kann nicht klassifiziert werden. "*Schlüsselwort*" sollte in diesem Kontext nicht verwendet werden.|
|[Compilerfehler C3753](compiler-error-c3753.md)|eine generische Eigenschaft ist nicht zulässig.|
|[Compilerfehler C3754](compiler-error-c3754.md)|Delegatkonstruktor: die Member-Funktion "*Member*" kann nicht für eine Instanz vom Typ "*Typ*" aufgerufen werden.|
|[Compilerfehler C3755](compiler-error-c3755.md)|"*Bezeichner*": ein Delegat kann nicht definiert werden.|
|Compilerfehler C3756|Veraltet.|
|Compilerfehler C3757|'*Typ*': der Typ ist für die ' constexpr '-Funktion nicht zulässig.|
|Compilerfehler C3758|"*Member*": virtuelle Funktion kann nicht als "constexpr" deklariert werden.|
|Compilerfehler C3759|"*Member*": die Member-Funktion eines nicht literalen Typs kann nicht als "constexpr" deklariert werden.|
|Compilerfehler C3760|Verwenden Sie __property-Schlüsselwort, um die Eigenschaft in Managed/WinRT '*Class*' zu deklarieren.|
|[Compilerfehler C3761](compiler-error-c3761.md)|"*Function*": "retval" kann nur im letzten Argument einer Funktion angezeigt werden.|
|[Compilerfehler C3762](compiler-error-c3762.md)|das Attribut "*Attribut*" kann nicht verarbeitet werden.|
|[Compilerfehler C3763](compiler-error-c3763.md)|"*Type*": "retval" und "out" können nur für einen Daten Zeigertyp angezeigt werden.|
|[Compilerfehler C3764](compiler-error-c3764.md)|'*Member*': die Basisklassen Methode '*Member*' kann nicht überschrieben werden.|
|[Compilerfehler C3765](compiler-error-c3765.md)|"*Ereignis*": ein Ereignis in einer Klasse/Struktur "*Type*", die als Event_receiver gekennzeichnet ist, kann nicht definiert werden.|
|[Compilerfehler C3766](compiler-error-c3766.md)|"*Type*" muss eine Implementierung für die Schnittstellen Methode "*Function*" bereitstellen.|
|[Compilerfehler C3767](compiler-error-c3767.md)|"*Funktion*": auf mögliche Funktion (en) kann nicht zugegriffen werden.|
|[Compilerfehler C3768](compiler-error-c3768.md)|die Adresse einer virtuellen vararg-Funktion in reinem verwaltetem Code kann nicht übernommen werden.|
|[Compilerfehler C3769](compiler-error-c3769.md)|"*Bezeichner*": eine in eine Klasse eingefügte Klasse kann nicht den gleichen Namen wie die unmittelbar einschließende Klasse haben.|
|Compilerfehler C3770|"*Typ*": ist keine gültige Basisklasse|
|[Compilerfehler C3771](compiler-error-c3771.md)|"*Bezeichner*": die Friend-Deklaration kann im nächsten Namespace Bereich nicht gefunden werden.|
|[Compilerfehler C3772](compiler-error-c3772.md)|"*Identifier*": Ungültige Friend-Vorlagen Deklaration.|
|Compilerfehler C3773|Verwenden Sie den/await-Compilerschalter zum Aktivieren von Coroutinen.|
|Compilerfehler C3774|"*Scope*::*Identifier*" wurde nicht gefunden: Bitte schließen Sie den *Header* Header ein.|
|Compilerfehler C3775|der Rückgabetyp von '*Function*' sollte nicht '*Type*' sein.|
|Compilerfehler C3776|ein Ausdruck vom Typ "void" kann in einer Coroutine mit einem unvoid-Rückgabetyp nicht zurückgegeben werden.|
|Compilerfehler C3777|"*Function*": eine Coroutine kann keine Variablen Argumentliste verwenden.|
|Compilerfehler C3778|"Zuweisung": kann nicht in einer Coroutine verwendet werden.|
|Compilerfehler C3779|"*Function*": eine Funktion, die "*Type*" zurückgibt, kann nicht verwendet werden, bevor Sie definiert ist.|
|Compilerfehler C3780|"*Function*": eine Konvertierungs Funktion, die "*Type*" zurückgibt, kann nicht verwendet werden, bevor Sie definiert ist.|
|Compilerfehler C3781|'*Schlüsselwort*': darf nicht in einer Coroutine vom Typ '*Type*' verwendet werden. Im zugeordneten promise_type muss entweder ein *Schlüsselwort* oder ein *Schlüsselwort* vorhanden sein|
|Compilerfehler C3782|*Type*: die Zusage einer Coroutine darf nicht sowohl das *Schlüsselwort* und das *Schlüsselwort* enthalten.|
|Compilerfehler C3783|'*Identifier*': darf keine Coroutine sein.|
|Compilerfehler C3784|ein *Schlüsselwort* Ausdruck kann in diesem Kontext nicht angezeigt werden.|
|Compilerfehler C3785|das erste Vorlagen Argument für "Std:: integer_sequence" muss ein ganzzahliger Typ sein.|
|Compilerfehler C3786|Das zweite Vorlagen Argument für "Std:: make_integer_sequence" muss eine ganzzahlige Konstante sein, die größer oder gleich 0 (null) ist.|
|Compilerfehler C3787|der Rückgabetyp dieser Coroutine kann nicht abgeleitet werden.|
|Compilerfehler C3788|Veraltet.|
|Compilerfehler C3789|Veraltet.|
|Compilerfehler C3790|Veraltet.|
|Compilerfehler C3791|Veraltet.|
|Compilerfehler C3792|Veraltet.|
|Compilerfehler C3793|Veraltet.|
|Compilerfehler C3794|Veraltet.|
|Compilerfehler C3795|Veraltet.|
|Compilerfehler C3796|Veraltet.|
|[Compilerfehler C3797](compiler-error-c3797.md)|'*Schlüsselwort*': die Ereignis Deklaration darf keinen Überschreibungsspezifizierer aufweisen (sollte stattdessen auf dem Ereignis Add/Remove/Raise-Methoden platziert werden)|
|[Compilerfehler C3798](compiler-error-c3798.md)|'*Schlüsselwort*': die Eigenschafts Deklaration darf keinen Überschreibungsspezifizierer aufweisen (sollte stattdessen auf Get/Set-Methoden der Eigenschaft platziert werden|
|[Compilerfehler C3799](compiler-error-c3799.md)|eine indizierte Eigenschaft darf keine leere Parameterliste aufweisen.|
|[Compilerfehler C3800](compiler-error-c3800.md)|'*Deklaration*': Eigenschaften und Ereignisse können nicht gemischt werden.|
|Compilerfehler C3801|"*Attribut*": das Attribut darf keine Argument-Klausel aufweisen.|
|Compilerfehler C3802|Veraltet.|
|[Compilerfehler C3803](compiler-error-c3803.md)|'*Property*': die Eigenschaft weist einen Typ auf, der mit einem der Accessoren '*Accessor*' nicht kompatibel ist.|
|[Compilerfehler C3804](compiler-error-c3804.md)|"*Member*": die Accessormethoden für eine Eigenschaft müssen entweder alle statisch oder alle nicht statisch sein.|
|[Compilerfehler C3805](compiler-error-c3805.md)|'*Token*': Unerwartetes Token, es wurde entweder '} ' oder ', ' erwartet.|
|Compilerfehler C3806|"*Token*": Unerwartetes Token, es wurde entweder ein "{" oder ein Member-Initialisierer erwartet.|
|[Compilerfehler C3807](compiler-error-c3807.md)|'*Typ*': eine Klasse mit dem ComImport-Attribut kann nicht von '*Type*' abgeleitet werden, es ist nur eine Schnittstellen Implementierung zulässig.|
|[Compilerfehler C3808](compiler-error-c3808.md)|"*Typ*": eine Klasse mit dem ComImport-Attribut kann Member "*Member*" nicht definieren, es sind nur abstrakte Funktionen oder DllImport-Funktionen zulässig.|
|[Compilerfehler C3809](compiler-error-c3809.md)|"*Typ*": ein verwalteter oder WinRT-Typ darf keine Friend-Funktionen/-Klassen/-Schnittstellen aufweisen.|
|Compilerfehler C3810|Veraltet.|
|Compilerfehler C3811|Veraltet.|
|[Compilerfehler C3812](compiler-error-c3812.md)|' __property ' muss das erste Token in einer Eigenschafts Deklaration sein.|
|[Compilerfehler C3813](compiler-error-c3813.md)|eine Eigenschafts Deklaration kann nur in der Definition eines verwalteten/WinRT-Typs angezeigt werden.|
|Compilerfehler C3814|Veraltet.|
|[Compilerfehler C3815](compiler-error-c3815.md)|der Rückgabetyp der Methode "*Member*" muss mit dem Typ des letzten Parameters eines Setter identisch sein.|
|[Compilerfehler C3816](compiler-error-c3816.md)|"class/struct *Member*" wurde zuvor mit einem anderen verwalteten/WinRT-Modifizierer deklariert oder definiert.|
|[Compilerfehler C3817](compiler-error-c3817.md)|'*Declaration*': die Eigenschaft kann nur auf eine Funktion angewendet werden.|
|[Compilerfehler C3818](compiler-error-c3818.md)|die Array Eigenschafts Deklaration "*Property*" darf eine Index Eigenschaft "*Property*" nicht überladen.|
|Compilerfehler C3819|Veraltet.|
|[Compilerfehler C3820](compiler-error-c3820.md)|"*Bezeichner*": Initialisierer müssen verwaltet werden.|
|[Compilerfehler C3821](compiler-error-c3821.md)|"*Funktion*": ein verwalteter Typ oder eine verwaltete Funktion kann nicht in einer nicht verwalteten Funktion verwendet werden.|
|Compilerfehler C3822|Veraltet.|
|Compilerfehler C3823|Veraltet.|
|[Compilerfehler C3824](compiler-error-c3824.md)|'*Typ*': dieser Typ kann nicht in diesem Kontext (Funktionsparameter, Rückgabetyp oder statischer Member) vorkommen.|
|[Compilerfehler C3825](compiler-error-c3825.md)|"*Typ*": eine verwaltete/WinRT-Klasse kann nur verwaltete/WinRT-Ereignisse unterstützen.|
|Compilerfehler C3826|Veraltet.|
|Compilerfehler C3827|Das Standard Attribut ' deprecated ' kann entweder keine Argumente oder ein Zeichenfolgenliteral enthalten, das den Grund beschreibt|
|[Compilerfehler C3828](compiler-error-c3828.md)|Platzierungs Argumente können nicht für einen "*Keyword*"-Ausdruck für den Typ "*Type*" angegeben werden.|
|Compilerfehler C3829|Das Standard Attribut "noreturn" kann nur auf Funktionen angewendet werden.|
|[Compilerfehler C3830](compiler-error-c3830.md)|"*Typ1*": erbt nicht von "*Typ2*". Werttypen können nur von Schnittstellen Klassen erben.|
|[Compilerfehler C3831](compiler-error-c3831.md)|'*Identifier*': '*Type*' kann kein angeheftete Datenmember oder eine Member-Funktion aufweisen, die einen Fixierungs Zeiger zurückgibt.|
|[Compilerfehler C3832](compiler-error-c3832.md)|'*Export der Typbibliothek*': die Typbibliothek sieht so aus, als ob Sie für 32-Bit-Zeiger erstellt wurde. Ändern Sie den "ptrsize"-Qualifizierer.|
|[Compilerfehler C3833](compiler-error-c3833.md)|"*Typ*": Ungültiger Zieltyp für den *Bezeichner* .|
|[Compilerfehler C3834](compiler-error-c3834.md)|Ungültige explizite Umwandlung in einen anheften-Zeiger. Verwenden Sie stattdessen eine angeheftete lokale Variable.|
|Compilerfehler C3835|Veraltet.|
|[Compilerfehler C3836](compiler-error-c3836.md)|ein statischer Konstruktor darf keine Member-Initialisiererliste aufweisen.|
|Compilerfehler C3837|Attribute sind in diesem Kontext nicht zulässig.|
|[Compilerfehler C3838](compiler-error-c3838.md)|von '*Type*' kann nicht geerbt werden.|
|[Compilerfehler C3839](compiler-error-c3839.md)|die Ausrichtung in einem verwalteten/WinRT-Typ kann nicht geändert werden.|
|Compilerfehler C3840|Veraltet.|
|Compilerfehler C3841|Veraltet.|
|[Compilerfehler C3842](compiler-error-c3842.md)|"*Bezeichner*": "Konstante" und "flüchtige" Qualifizierer für Member-Funktionen verwalteter/WinRT-Typen werden nicht unterstützt.|
|Compilerfehler C3843|"*Bezeichner*": Ref-Qualifizierer für Member-Funktionen verwalteter/WinRT-Typen werden nicht unterstützt.|
|Compilerfehler C3844|'*Bezeichner*': das Symbol kann nicht aus '*Quelle*' importiert werden: da '*Identifier*' bereits im aktuellen Gültigkeitsbereich vorhanden ist.|
|Compilerfehler C3845|Veraltet.|
|[Compilerfehler C3846](compiler-error-c3846.md)|'*Bezeichner*': das Symbol kann nicht aus '*Quelle*' importiert werden: da '*Identifier*' bereits aus einer anderen Assembly '*Assembly*' importiert wurde.|
|Compilerfehler C3847|Veraltet.|
|[Compilerfehler C3848](compiler-error-c3848.md)|ein Ausdruck mit dem Typ "*Type*" verliert einige konstant flüchtige Qualifizierer, um "*Identifier*" aufzurufen.|
|[Compilerfehler C3849](compiler-error-c3849.md)|Funktions Stil Aufrufe für einen Ausdruck vom Typ "*Typ*" verlieren Konstante und/oder flüchtige Qualifizierer *für alle verfüg* baren Operator Überladungen.|
|[Compilerfehler C3850](compiler-error-c3850.md)|"*Token*": ein universeller Zeichen Name gibt ein ungültiges Zeichen an.|
|[Compilerfehler C3851](compiler-error-c3851.md)|"*Token*": ein universeller Zeichen Name darf kein Zeichen im Basis Zeichensatz bezeichnen.|
|[Compilerfehler C3852](compiler-error-c3852.md)|'*Member*' mit Typ '*Type*': die Aggregat Initialisierung konnte diesen Member nicht initialisieren.|
|[Compilerfehler C3853](compiler-error-c3853.md)|"=": das erneute Initialisieren eines Verweises oder einer Zuweisung über eine Verweis-zu-Funktion ist unzulässig.|
|[Compilerfehler C3854](compiler-error-c3854.md)|Ausdruck auf der linken Seite von "=" ergibt eine Funktion. Eine Zuweisung zu einer Funktion ist nicht möglich (eine Funktion ist kein l-Wert).|
|[Compilerfehler C3855](compiler-error-c3855.md)|"*Function*": der Vorlagen-/generische Parameter "*Bezeichner*" ist mit der Deklaration nicht kompatibel.|
|[Compilerfehler C3856](compiler-error-c3856.md)|"*Class*": Klasse ist keine Klassen Vorlage/generische Klasse|
|[Compilerfehler C3857](compiler-error-c3857.md)|"*Template*": mehrere Vorlagen/generische Parameterlisten sind nicht zulässig.|
|[Compilerfehler C3858](compiler-error-c3858.md)|"*Bezeichner*": kann im aktuellen Bereich nicht erneut deklariert werden.|
|[Compilerfehler C3859](compiler-error-c3859.md)|virtueller Speicherbereich für PCH überschritten; Kompilieren Sie erneut mit einer Befehlszeilenoption von "-ZM*Number*" oder höher.|
|[Compilerfehler C3860](compiler-error-c3860.md)|Vorlage/generische Argumentliste nach Klassen Vorlage/generischer Name muss Parameter in der in Vorlagen/generischen Parameterliste verwendeten Reihenfolge auflisten|
|[Compilerfehler C3861](compiler-error-c3861.md)|"*Bezeichner*": der Bezeichner wurde nicht gefunden.|
|[Compilerfehler C3862](compiler-error-c3862.md)|"*Function*": eine nicht verwaltete Funktion kann nicht mit/CLR: pure oder/CLR: safe kompiliert werden.|
|Compilerfehler C3863|der Arraytyp "*Type*" kann nicht zugewiesen werden.|
|Compilerfehler C3864|Veraltet.|
|[Compilerfehler C3865](compiler-error-c3865.md)|'*Schlüsselwort*': kann nur für Native Member-Funktionen verwendet werden.|
|[Compilerfehler C3866](compiler-error-c3866.md)|der debugtor/Finalizer-Rückruf fehlt die Argumentliste.|
|[Compilerfehler C3867](compiler-error-c3867.md)|"*Function*": nicht standardmäßige Syntax; Verwenden von "&" zum Erstellen eines Zeigers auf ein Element|
|[Compilerfehler C3868](compiler-error-c3868.md)|"*Type*": Einschränkungen für den generischen Parameter "*Parameter*" unterscheiden sich von denen in der Deklaration.|
|[Compilerfehler C3869](compiler-error-c3869.md)|in der gcnew-Einschränkung fehlt die leere Parameterliste "()".|
|Compilerfehler C3870|'*Parameter*': ' __declspec (*Spezifizierer*) ' kann nur auf Parameter des ganzzahligen Typs angewendet werden.|
|Compilerfehler C3871|"*Parameter*": "__declspec (Guard (Overflow))" wird nur für die ersten 64-Parameter einer Funktion unterstützt.|
|[Compilerfehler C3872](compiler-error-c3872.md)|"0x-*Wert*": dieses Zeichen ist in einem Bezeichner nicht zulässig.|
|[Compilerfehler C3873](compiler-error-c3873.md)|"0x-*Wert*": dieses Zeichen ist nicht als erstes Zeichen eines Bezeichners zulässig.|
|[Compilerfehler C3874](compiler-error-c3874.md)|der Rückgabetyp von "*Identifier*" muss "*Typ1*" anstelle von "*Typ2*" lauten.|
|Compilerfehler C3875|der Aufrufe einer nicht statischen Member-Funktion fehlt die Argumentliste.|
|Compilerfehler C3876|Veraltet.|
|Compilerfehler C3877|Veraltet.|
|Compilerfehler C3878|Veraltet.|
|Compilerfehler C3879|"*Member*": kann kein initonly-Datenmember sein.|
|[Compilerfehler C3880](compiler-error-c3880.md)|"*Member*": darf kein literaldatenmember sein.|
|Compilerfehler C3881|der Konstruktor kann nur von der direkten Basis geerbt werden.|
|Compilerfehler C3882|"*Class*": der Konstruktor wurde bereits von "*Class*" geerbt.|
|Compilerfehler C3883|"*Member*": ein statischer initonly-Datenmember muss initialisiert werden.|
|Compilerfehler C3884|"*Typ*": ein Array mit unbekannter Größe kann nicht mit einem Wert initialisiert werden.|
|Compilerfehler C3885|"*Typ*": ein Array mit unbekannter Größe kann nicht mit einer leeren Initialisiererliste initialisiert werden.|
|[Compilerfehler C3886](compiler-error-c3886.md)|"*Member*": ein literaldatenmember muss initialisiert werden.|
|[Compilerfehler C3887](compiler-error-c3887.md)|"*Member*": der Initialisierer für einen literaldatenmember muss ein konstanter Ausdruck sein.|
|[Compilerfehler C3888](compiler-error-c3888.md)|"*Member*": der diesem literaldatenmember zugeordnete Konstantenausdruck wird von C++/CLI nicht unterstützt.|
|Compilerfehler C3889|Veraltet.|
|[Compilerfehler C3890](compiler-error-c3890.md)|"*Member*": Sie können die Adresse eines literalen Datenmembers nicht übernehmen.|
|[Compilerfehler C3891](compiler-error-c3891.md)|"*Member*": ein literaldatenmember kann nicht als l-Wert verwendet werden.|
|[Compilerfehler C3892](compiler-error-c3892.md)|'*Variable*': eine Zuweisung zu einer Variablen, die konstant ist, ist nicht möglich.|
|[Compilerfehler C3893](compiler-error-c3893.md)|"*Member*": die Verwendung des l-Werts des initonly-Datenmembers ist nur in einem Instanzkonstruktor der Klasse "*Class*" zulässig.|
|[Compilerfehler C3894](compiler-error-c3894.md)|"*Member*": die Verwendung des l-Werts eines statischen Initonly-Datenmembers ist nur im Klassenkonstruktor der Klasse "*Class*" zulässig.|
|[Compilerfehler C3895](compiler-error-c3895.md)|"*Member*": *Typdatenmember* können nicht "volatile" sein.|
|[Compilerfehler C3896](compiler-error-c3896.md)|"*Member*": Unzulässiger Initialisierer: dieser literaldatenmember kann nur mit "nullptr" initialisiert werden.|
|Compilerfehler C3897|Veraltet.|
|[Compilerfehler C3898](compiler-error-c3898.md)|"*Member*": *Typdatenmember* können nur Member von verwalteten Typen sein.|
|[Compilerfehler C3899](compiler-error-c3899.md)|"*Member*": die Verwendung des l-Werts eines initonly-Datenmembers ist nicht direkt innerhalb eines parallelen Bereichs in der Klasse "*Class*" zulässig.|
|[Compilerfehler C3900](compiler-error-c3900.md)|"*Member*": ist im aktuellen Gültigkeitsbereich nicht zulässig.|
|[Compilerfehler C3901](compiler-error-c3901.md)|"*Function*": muss den Rückgabetyp "*Typ*" aufweisen.|
|[Compilerfehler C3902](compiler-error-c3902.md)|'*Function*': der Typ des letzten Parameters muss '*Type*' sein.|
|[Compilerfehler C3903](compiler-error-c3903.md)|"*Property*": hat keine Set-oder Get-Methode.|
|[Compilerfehler C3904](compiler-error-c3904.md)|"*Property*": muss *Zahlen* Parameter angeben.|
|Compilerfehler C3905|nicht ausgerichtete Zugriffe werden für den systeminternen Typ "*Typ*" nicht unterstützt.|
|Compilerfehler C3906|der systeminterne Typ "*Typ*" ist kein unterstützter Rückgabe-oder Argumenttyp für vararg-oder unprototypisierte Funktionen.|
|Compilerfehler C3907|Veraltet.|
|[Compilerfehler C3908](compiler-error-c3908.md)|die Zugriffsebene ist weniger restriktiv als die von "*Identifier*".|
|[Compilerfehler C3909](compiler-error-c3909.md)|eine verwaltete/WinRT-Ereignis Deklaration muss in einem verwalteten/WinRT-Typ auftreten.|
|[Compilerfehler C3910](compiler-error-c3910.md)|"*Ereignis*": der Member "*Member*" muss definiert werden.|
|[Compilerfehler C3911](compiler-error-c3911.md)|"*Member*": die Funktion muss den Typ "*Typ*" aufweisen.|
|[Compilerfehler C3912](compiler-error-c3912.md)|"*Ereignis*": Ereignistyp muss ein Delegattyp sein.|
|[Compilerfehler C3913](compiler-error-c3913.md)|eine Standard Eigenschaft muss indiziert werden.|
|[Compilerfehler C3914](compiler-error-c3914.md)|eine Standard Eigenschaft kann nicht statisch sein.|
|[Compilerfehler C3915](compiler-error-c3915.md)|"*Identifier*" hat keine indizierte Standard Eigenschaft (Klassenindexer).|
|Compilerfehler C3916|Veraltet.|
|[Compilerfehler C3917](compiler-error-c3917.md)|"*Token*": veralteter *konstruktionsstil* (wollten Sie stattdessen "[' ']" verwenden?)|
|[Compilerfehler C3918](compiler-error-c3918.md)|die Verwendung erfordert, dass "*Identifier*" ein Datenmember ist.|
|[Compilerfehler C3919](compiler-error-c3919.md)|"*Function*": die Funktion muss den Typ "*return_type* (*Typ*)" aufweisen.|
|[Compilerfehler C3920](compiler-error-c3920.md)|"*Operator*": ein postfix-Inkrement-/Dekrement-CLR/WinRT-Operator, der den Postfix CLR/WinRT-Operator aufruft, kann nicht definiert werden. dabei wird der entsprechende Präfix CLR/WinRT-Operator (op_Increment/op_Decrement) mit Postfix-Semantik aufgerufen|
|Compilerfehler C3921|Veraltet.|
|Compilerfehler C3922|Veraltet.|
|[Compilerfehler C3923](compiler-error-c3923.md)|"*Member*": lokale Klassen-, Struktur-oder Union-Definitionen sind in einer Member-Funktion einer verwalteten/WinRT-Klasse nicht zulässig.|
|Compilerfehler C3924|Fehler in Argument #*Number* of delegatkonstruktoraufruf '*Konstruktor*':|
|Compilerfehler C3925|Es wurde eine Schleife (for, while oder do)*nach Direktive*Direktive erwartet.|
|Compilerfehler C3926|Ungültige Konstante in "parallel"-Direktive|
|Compilerfehler C3927|"->": ein nach stehender Rückgabetyp ist nach einem nicht Funktions Deklarator nicht zulässig.|
|Compilerfehler C3928|"->": ein nach stehender Rückgabetyp ist nach einem Deklarator in Klammern nicht zulässig.|
|Compilerfehler C3929|Veraltet.|
|Compilerfehler C3930|"*Function*": keine überladene Funktion verfügt über einschränkungsspezifizierer, die mit dem Ambient-Kontext "*context*" kompatibel sind|
|Compilerfehler C3931|"*Typ*": eine Funktion mit einschränkungsspezifizierern, die mit dem Ambient-Kontext nicht kompatibel sind, kann nicht aufgerufen werden|
|Compilerfehler C3932|Veraltet.|
|Compilerfehler C3933|"*Class*": die einschränkungsspezifizierer des Dekonstruktors müssen die Union der Einschränkungen für alle Konstruktoren abdecken.|
|Compilerfehler C3934|eine Funktion, die in einer beliebigen Form von "Main" ist, darf keine einschränkungsspezifizierer außer "einschränken" (CPU) aufweisen|
|Compilerfehler C3935|"*Bezeichner*": Neudefinition; überlappende Einschränkungs Bearbeiter|
|Compilerfehler C3936|'*Identifier*': Unbekannter einschränkungsspezifizierer|
|Compilerfehler C3937|ein leerer einschränkungsspezifizierer ist nicht zulässig.|
|Compilerfehler C3938|"*Bezeichner*": mehrere einschränkungsspezifizierer werden für externe \042c\042-Funktionen nicht unterstützt.|
|Compilerfehler C3939|'*Identifier*': Zeiger auf Element Funktionen, Funktionszeiger, Verweise auf Funktionen mit dem einschränkungsspezifizierer ' amp ' sind nicht zulässig.|
|Compilerfehler C3940|"*Bezeichner*": der Bezeichner wurde nicht gefunden-mögliche Konflikte zwischen den Compilerversionen und den Bibliotheksversionen. Stellen Sie sicher, dass "vccorlib. h/. lib, vccorlib120. dll" und "c1xx. dll" Stimmen.|
|Compilerfehler C3941|"*Condition*": erfordert die Befehlszeilenoption "/CLR".|
|Compilerfehler C3942|Veraltet.|
|Compilerfehler C3943|Veraltet.|
|Compilerfehler C3944|Veraltet.|
|Compilerfehler C3945|"*Typ*": ein WinRT-Objekt, das nicht von Platform:: Exception abgeleitet ist, kann nicht ausgelöst oder abgefangen werden.|
|Compilerfehler C3946|"*Typ*": typeid kann nicht auf diesen Typ angewendet werden.|
|Compilerfehler C3947|"*typeid*": typeid kann nicht auf eine Paket Erweiterung angewendet werden.|
|Compilerfehler C3948|'*Schlüsselwort*': eine Paket Erweiterung kann in diesem Kontext nicht angezeigt werden.|
|Compilerfehler C3949|eine Paket Erweiterung, "...", darf nicht in einem abstrakten Deklarator in Klammern vorkommen.|
|Compilerfehler C3950|Veraltet.|
|Compilerfehler C3951|"Pointer-to-Member" kann nicht im projizierten WinRT-Typ "*Typ*" verwendet werden. Verwenden Sie stattdessen einen Delegaten.|
|Compilerfehler C3952|"*Typ*": WinRT unterstützt keine ' in/out '-Arrays. Verwenden Sie ' Konstanten Array\<t > ^ ' für ' in ' und ' Write-onlyarray\<t > ' oder ' Array\<t > ^ * ' für ' out ' auf öffentlichen APIs.|
|Compilerfehler C3953|Die verwaltete Klasse '*Type*' kann nicht im WinRT-Modul verwendet werden.|
|Compilerfehler C3954|'*Type*': ein Array, das von einer veröffentlichten Methode für einen WinRT-Typ zurückgegeben wird, muss das Formular ' Array\<t > ^ ' verwenden.|
|Compilerfehler C3955|"*Typ*": ein öffentlicher Konstruktor kann keinen "out"-Parameter oder "Write-onlyarray\<t >" enthalten.|
|Compilerfehler C3956|'*Typ*': der Typ ist als exklusiv für '*Type*' gekennzeichnet und kann nicht als Basis von '*derived_type*' verwendet werden.|
|Compilerfehler C3957|"*Typ*": "New" kann nicht für einen WinRT-Typ verwendet werden. Verwenden Sie stattdessen "Ref New".|
|Compilerfehler C3958|"*Typ*": "gcnew" kann nicht für einen WinRT-Typ verwendet werden. Verwenden Sie stattdessen "Ref New".|
|Compilerfehler C3959|"Ref New" darf nur zum Erstellen eines Objekts mit WinRT-Typ verwendet werden.|
|Compilerfehler C3960|Veraltet.|
|Compilerfehler C3961|statischer Konstruktor wird nicht unterstützt.|
|Compilerfehler C3962|generische Klasse wird nicht unterstützt.|
|Compilerfehler C3963|mehrdimensionales Array wird nicht unterstützt.|
|Compilerfehler C3964|Jagged Array wird nicht unterstützt.|
|Compilerfehler C3965|Das Parameter Array wird nicht unterstützt.|
|Compilerfehler C3966|"*Function*": generische Funktion wird nicht unterstützt.|
|Compilerfehler C3967|Fehler beim Importieren von "*Identifier*" aus Modul "*Module*".|
|Compilerfehler C3968|Das Token "*Token*" ist nicht als Trennzeichen für das Modulname gültig. Verwenden Sie stattdessen den Zeitraum (".").|
|Compilerfehler C3969|inkonsistente Modulnamen: '*Module1*' und '*Module1*'|
|Compilerfehler C3970|'*Identifier*': '*Schlüsselwort*' kann nur im globalen Gültigkeitsbereich oder im Namespace-Gültigkeitsbereich auf ' ref class ' oder ' ref struct ' angewendet werden.|
|Compilerfehler C3971|"*Typ*": eine partielle Definition kann nicht nach der vollständigen Definition stehen|
|Compilerfehler C3972|"*Type*": "Partial" kann nur auf Klassen Deklarationen oder Definitionen angewendet werden.|
|Compilerfehler C3973|Veraltet.|
|Compilerfehler C3974|Veraltet.|
|Compilerfehler C3975|"Klassen- */Strukturbezeichner*" wurde zuvor mit einem anderen Modifizierer deklariert oder definiert.|
|Compilerfehler C3976|"*Bezeichner1*" muss als "Public" deklariert werden, damit "*Bezeichner2*" verwendet werden darf.|
|Compilerfehler C3977|Die Verwendung erfordert einen Verweis auf eine Assembly, die "*Identifier*" definiert.|
|Compilerfehler C3978|"*Bezeichner*": eine statische Eigenschaft ist nicht als Member einer WinRT-Schnittstelle oder eines Werttyps zulässig.|
|Compilerfehler C3979|"*Typ*": Verwenden Sie das Attribut "*Attribut*" anstelle von "*Wert*".|
|Compilerfehler C3980|"*Type*" kann nicht in Metadaten ausgegeben werden.|
|Compilerfehler C3981|"*Typ*": ein Werttyp darf keine statischen Datenmember "*Bezeichner*" aufweisen.|
|Compilerfehler C3982|"*Typ*": ein Werttyp darf keine nicht öffentlichen Datenmember "*Bezeichner*" aufweisen.|
|Compilerfehler C3983|'*Typ*': ein Werttyp darf keine öffentlichen nicht-Datenmember '*Bezeichner*' aufweisen.|
|Compilerfehler C3984|'*Typ*': ein nicht-Werttyp darf keine öffentlichen Datenmember '*Bezeichner*' aufweisen.|
|Compilerfehler C3985|"*Bezeichner*": die Signatur des öffentlichen Members enthält den privaten Typ "*Member*".|
|Compilerfehler C3986|"*Bezeichner*": die Signatur des öffentlichen Members enthält den systemeigenen Typ "*Member*".|
|Compilerfehler C3987|"*Bezeichner*": die Signatur des öffentlichen Members enthält den systemeigenen Typ "*Typ*".|
|Compilerfehler C3988|"*Typ*": ein System eigener Typ kann nicht öffentlich sein.|
|Compilerfehler C3989|"*Typ*": ein Typ kann nicht öffentlich sein.|
|Compilerfehler C3990|'*Typ*': das Attribut '*Attribut*' kann nicht privat oder nicht eingebettet sein.|
|Compilerfehler C3991|"*Typ*": die nicht öffentliche oder die nicht öffentliche Schnittstelle "*Schnittstelle*" kann nicht implementiert werden.|
|Compilerfehler C3992|"*Bezeichner*": die Signatur des öffentlichen Members enthält den ungültigen Typ "*Typ*".|
|Compilerfehler C3993|"*Typ*": ein Werttyp muss mindestens ein öffentliches Feld enthalten.|
|Compilerfehler C3994|"*Typ*": ein Werttyp kann keine Schnittstellen implementieren oder über virtuelle Funktionen verfügen.|
|Compilerfehler C3995|"*Typ*": ein Werttyp darf keine Ereignismember "*Bezeichner*" aufweisen.|
|Compilerfehler C3996|Veraltet.|
|Compilerfehler C3998|"c++*Version*": nicht unter C++ stützte Version; standardmäßig auf "c++*Version*"|
|Compilerfehler C3999|Unbekannter Fehler: Wählen Sie im Menü "visuelle C++ Hilfe" den Befehl "technischer Support", oder öffnen Sie die Hilfedatei für technischen Support, um weitere Informationen zu erhalten|

## <a name="see-also"></a>Weitere Informationen

[Fehler undC++ Warnungen für C/Compiler und Buildtools](../compiler-errors-1/c-cpp-build-errors.md) \
[Compilerfehler C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
