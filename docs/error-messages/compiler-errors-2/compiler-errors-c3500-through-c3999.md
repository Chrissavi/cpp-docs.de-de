---
title: Compilerfehler C3500 bis C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: c5cb482804dac90a278036d594dc92e7be33e2bf
ms.sourcegitcommit: 283cb64fd7958a6b7fbf0cd8534de99ac8d408eb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/28/2019
ms.locfileid: "64857713"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Compilerfehler C3500 bis C3999

Die Artikel in diesem Abschnitt der Dokumentation wird erläutert, eine Teilmenge der Fehlermeldungen, die vom Compiler generiert werden.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Fehlermeldungen

|Fehler|Meldung|
|-----------|-------------|
|[Compilerfehler C3500](compiler-error-c3500.md)|Unzulässige ProgID "*progid*"|
|[Compilerfehler C3501](compiler-error-c3501.md)|Es ist keine Typbibliothek registriert, die für die ProgID "*progid*"|
|Compilerfehler C3502|LIBID kann nicht abgerufen werden, für die ProgID "*progid*"|
|Compilerfehler C3503|Zeichen "0 X*Wert*' kann nicht in ein raw String literal|
|Compilerfehler C3504|GUID kann nicht erstellt werden, aus der Zeichenfolge "*Zeichenfolge*"|
|[Compilerfehler C3505](compiler-error-c3505.md)|Typbibliothek kann nicht geladen werden kann '*Bibliothek*"|
|[Compilerfehler C3506](compiler-error-c3506.md)|Es ist keine Typbibliothek registriert für LIBID "*Bibliothek*"|
|[Compilerfehler C3507 generiert](compiler-error-c3507.md)|eine ProgID kann nicht mehr als 39 Zeichen haben*progid*"; darf keine Zeichensetzung außer '.'; mit einer Ziffer beginnen|
|[Compilerfehler C3508 generiert](compiler-error-c3508.md)|"*Typ*": ist kein gültiger Automationstyp|
|[Compilerfehler C3509](compiler-error-c3509.md)|"*Typ*': Ungültiger Automatisierungs-Rückgabetyp, wenn der Parameter"Retval"gekennzeichnet ist, der Rückgabetyp muss"void","HRESULT"oder"SCODE"|
|[Compilerfehler C3510 generiert](compiler-error-c3510.md)|Suchen Sie abhängige Typbibliothek kann nicht *Bibliothek*|
|Compilerfehler C3511|"*Bezeichner*": ein Aufruf an einen delegierenden Konstruktor soll der einzige Member-Initialisierer sein|
|Compilerfehler C3512|die begrenzenden Zeichensequenz für ein unformatiertes Zeichenfolgenliteral darf nicht mehr als 16 Zeichen lang sein.|
|Compilerfehler C3513|"*Zeichenfolge*': nicht unterstütztes schließendes Zeichen für rohzeichenfolgenliteral|
|Compilerfehler C3514|"*Zeichen*" (*Wert*): nicht unterstütztes schließendes Zeichen für rohzeichenfolgenliteral|
|Compilerfehler C3515|ein Argument für eine teilweise Spezialisierung einer Klassenvorlage ist eine paketerweiterung muss es das letzte Argument sein.|
|Compilerfehler C3516|Unerwartetes Ende-des-Datei bei der Verarbeitung von unformatierten Zeichenfolgenliterals gefunden; Trennzeichen-Reihenfolge "*Zeichenfolge*' wurde nicht zugeordnet.|
|Compilerfehler C3517 generiert|"*Bezeichner*" eine Aliasdeklaration darf keinen Typ, der "auto" enthält aufweisen|
|Compilerfehler c3518 generiert|"*Bezeichner*': in einem Direct-List-Initialization-Kontext der Typ für"*Typ*' können nur aus einem einzelnen Initialisierungsausdruck hergeleitet werden|
|[Compilerfehler C3519 generiert](compiler-error-c3519.md)|"*Parameter*': Ungültiger Parameter für das Embedded_idl-Attribut|
|Compilerfehler C3520|"*Bezeichner*': in diesem Kontext muss das parameterpaket erweitert werden|
|Compilerfehler C3521|"*Bezeichner*' ist kein parameterpaket|
|Compilerfehler C3522|"*Typ*': in diesem Kontext kann nicht das parameterpaket erweitert werden|
|Compilerfehler C3523|"Sizeof..." erfordert als Argument ein parameterpaket|
|Compilerfehler C3524|"*Bezeichner*": "Sizeof" kann nicht auf ein parameterpaket angewendet werden. Wollten Sie "Sizeof..." verwenden?|
|Compilerfehler C3525|"*Parameter*": Wenn eine Klassenvorlage ein vorlagenparameterpaket verfügt, muss am Ende der Vorlagenparameterliste|
|Compilerfehler C3526|"..." kann nicht auf "this" angewendet werden|
|Compilerfehler C3527|"*Bezeichner*' ist kein gültiger Operand für"Sizeof...". Wollten Sie "Sizeof" verwenden?|
|Compilerfehler C3528|"*Bezeichner1*': die Anzahl der Elemente dieser paketerweiterung entspricht nicht der Anzahl der Elemente in"*Bezeichner2*"|
|Compilerfehler C3529|"*Parameter*": ein vorlagenparameterpaket kann nicht kein Standardargument aufweisen|
|[Compilerfehler C3530](compiler-error-c3530.md)|"*Typ*' kann nicht mit einem anderen Typspezifizierer kombiniert werden|
|[Compilerfehler C3531](compiler-error-c3531.md)|"*Bezeichner*": ein Symbol, dessen Typ enthält "*Typ*' muss einen Initialisierer aufweisen|
|[Compilerfehler C3532](compiler-error-c3532.md)|der Elementtyp eines Arrays handelt es sich nicht um einen Typ mit "*Typ*"|
|[Compilerfehler C3533](compiler-error-c3533.md)|ein Parameter kann kein haben einen Typ mit "*Typ*"|
|Compilerfehler C3534|Veraltet.|
|[Compilerfehler C3535](compiler-error-c3535.md)|kann nicht hergeleitet werden. Typ '*type1*'von'*Typ2*"|
|[Compilerfehler C3536](compiler-error-c3536.md)|"*Bezeichner*": kann nicht verwendet werden, bevor es initialisiert wird|
|[Compilerfehler C3537 erzeugt](compiler-error-c3537.md)|Sie können nicht eine Umwandlung in einen Typ mit "*Typ*"|
|[Compilerfehler C3538](compiler-error-c3538.md)|in einer Deklaratorliste "*Typ*" muss immer in denselben Typ hergeleitet werden|
|[Compilerfehler C3539](compiler-error-c3539.md)|ein Vorlagenargument handelt es sich nicht um einen Typ mit "*Typ*"|
|[Compilerfehler C3540](compiler-error-c3540.md)|"sizeof" kann nicht angewendet werden, um einen Typ mit "*Typ*"|
|[Compilerfehler C3541](compiler-error-c3541.md)|Typeid kann nicht angewendet werden, um einen Typ mit "*Typ*"|
|Compilerfehler C3542|"*Bezeichner*': eine virtuelle Memberfunktion darf keinen Rückgabetyp aufweisen, der enthält"*Typ*"|
|Compilerfehler C3543|"*Typ*": enthält kein parameterpaket|
|Compilerfehler C3544|"*Parameter*': parameterpaket erwartet, dass ein typvorlagenargument|
|Compilerfehler C3545|"*Parameter*': parameterpaket erwartet, dass ein Nichttyp-Vorlagenargument|
|Compilerfehler C3546|"...": Es gibt keine parameterpakete verfügbar, um zu erweitern|
|Compilerfehler C3547|Vorlagenparameter "*Parameter*"kann nicht verwendet werden, da er einem vorlagenparameterpaket folgt und nicht werden, aus den Funktionsparametern von hergeleitet kann"*Funktion*"|
|Compilerfehler C3548|"*Bezeichner*': parameterpaket kann nicht in diesem Kontext nicht verwendet werden|
|Compilerfehler C3549|"*Wert*": ein funktionsparameterpaket kann nicht kein Standardargument aufweisen|
|[Compilerfehler C3550](compiler-error-c3550.md)|In diesem Kontext ist nur ein einfaches "decltype(auto)" zulässig.|
|[Compilerfehler C3551](compiler-error-c3551.md)|Wenn ein nachstehender Rückgabetyp verwendet wird der voranstehende Rückgabetyp muss der einzelne Typbezeichner "Auto" sein (nicht "*Typ*")|
|[Compilerfehler c3552 verursacht](compiler-error-c3552.md)|expected 'decltype(auto)'|
|[Compilerfehler c3553 verursacht](compiler-error-c3553.md)|"decltype" erwartet einen Ausdruck und keinen Typ.|
|[Compilerfehler C3554](compiler-error-c3554.md)|"*Typ*' kann nicht mit einem anderen Typspezifizierer kombiniert werden|
|[Compilerfehler C3555](compiler-error-c3555.md)|Falsches Argument für "decltype"|
|[Compilerfehler C3556](compiler-error-c3556.md)|"*Ausdruck*": falsches Argument für "Decltype"|
|Compilerfehler C3557|Veraltet.|
|Compilerfehler C3558|Veraltet.|
|Compilerfehler C3559|rekursiver Aufruf an "*Funktion*": wurde eine Rekursion festgestellt beim Kompilieren des Aufrufdiagramms für: "*Funktion*"|
|Compilerfehler C3560|"*Funktion*": IL ist beim Kompilieren des Aufrufdiagramms für nicht verfügbar: "*Funktion*"|
|Compilerfehler C3561|Tile Barrier-Vorgang finden Sie in der ablaufsteuerung, der nicht Tile-angepasst ist, beim Kompilieren des Aufrufdiagramms für: "*Funktion*"|
|Compilerfehler C3562|systeminterne Funktion "*Funktion*" ist auf keine mehr als *Anzahl* Parameter|
|Compilerfehler C3563|Unendliche Schleife, die beim Kompilieren des Aufrufdiagramms für erkannt: "*Funktion*"|
|Compilerfehler C3564|nicht initialisierter Wert gelesen wird, beim Kompilieren des Aufrufdiagramms für: "*Funktion*"|
|Compilerfehler C3565|Die Gesamtmenge des Tile_static-Speichers (*Anzahl* Bytes) überschreitet den Grenzwert von *Anzahl* Bytes, die beim Kompilieren des Aufrufdiagramms für|
|Compilerfehler C3566|Blöcke mit Nebeneffekten zu tief geschachtelt beim Kompilieren des Aufrufdiagramms für graph-: "*Funktion*"|
|Compilerfehler C3567|Division oder Modulo durch 0 (null), die beim Kompilieren des Aufrufdiagramms für erkannt: "*Funktion*"|
|Compilerfehler C3568|Summe der Register überschreitet das Limit von *Anzahl* beim Kompilieren des Aufrufdiagramms für. Vereinfachen Sie Ihr Programm|
|Compilerfehler C3569|eine Racebedingung festgestellt wird, beim Kompilieren des Aufrufdiagramms für: "*Funktion*"|
|Compilerfehler C3570|Unzulässige Verwendung des eingeschränkten Amp Bereichs beim Kompilieren mit/CLR|
|Compilerfehler C3571|"*Typ*": Unzulässiges Compute-domänenargument; kein Klassentyp|
|Compilerfehler C3572|"*Typ*": Unzulässiges Compute-domänenargument; öffentlicher Member fehlt: "static const Int Rank" oder Rangwert ist nicht positiv|
|Compilerfehler C3573|Die Anzahl der Instanzen des Concurrency::graphics::sampler parallel_for_each übergeben nicht überschreiten. *Anzahl*|
|Compilerfehler C3574|"*Typ*": Unzulässige kachelgrößen: muss positiv und (1) Z < = *Anzahl*; (2) Z*Y*X < = *Anzahl*|
|Compilerfehler C3575|'*type*': illegal compute domain argument; missing public member: 'concurrency::index<*number*> _map_index(const concurrency::index<*number*>&) restrict(amp)'|
|Compilerfehler C3576|"*Typ*': Concurrency::details::_Parallel_for_each Argument #*Anzahl* wird nicht unterstützt.|
|Compilerfehler C3577|Concurrency:: parallel_for_each Kernel Argument ist nicht zulässig: Aufruf für Member kann nicht aufgelöst werden kann ' void Operator()((*Typ*) Restrict(amp)""|
|Compilerfehler C3578|Die Größe des parallel_for_each übergebenen Funktionsobjekts darf nicht überschreiten. *Anzahl* Bytes|
|Compilerfehler C3579|Die Anzahl der schreibgeschützten Instanzen von Concurrency:: Array und Concurrency:: parallel_for_each übergeben Concurrency::graphics::texture nicht überschreiten. *Anzahl*|
|Compilerfehler C3580|Die Anzahl der schreibbaren Instanzen von Concurrency:: Array und Concurrency:: parallel_for_each übergeben Concurrency::graphics::texture nicht überschreiten. *Anzahl*|
|Compilerfehler C3581|"*Typ*': nicht unterstützter Typ in eingeschränktem Amp Code|
|Compilerfehler C3582|Veraltet.|
|Compilerfehler C3583|"*Bezeichner*': die Größe der Variablen (*Anzahl* Bytes) überschreitet die maximale Größe (*Anzahl* Bytes) in eingeschränktem Amp-Code unterstützt.|
|Compilerfehler C3584|nicht unterstützte Verwendung von Tile_static für "*Bezeichner*"|
|Compilerfehler C3585|"*Bezeichner*" verfügt über eingeschränktem nicht unterstützte Speicherklasse in Amp-Code|
|Compilerfehler C3586|"*Bezeichner*": Verwendung von globalen oder statischen Variablen wird nicht unterstützt werden, in eingeschränktem Amp-Code|
|Compilerfehler C3587|Dynamic_cast wird in eingeschränktem Amp-Code nicht unterstützt.|
|Compilerfehler C3588|Das Umwandeln von "*type1*'to'*Typ2*" wird in eingeschränktem Amp-Code nicht unterstützt|
|Compilerfehler C3589|"*Zeichenfolge*': nicht unterstützte Verwendung von Zeichenfolgenliteralen in Amp eingeschränktem-Code|
|Compilerfehler C3590|"*token*': Verweis erfasst, oder auf"this"erfassen wird nicht unterstützt, wenn beim Lambda um eingeschränkten Amp-Code handelt.|
|Compilerfehler C3591|Typeid-Operator wird in eingeschränktem Amp-Code nicht unterstützt.|
|Compilerfehler C3592|Systemeigene Inlineassemblys ("__asm") wird in eingeschränktem Amp-Code nicht unterstützt.|
|Compilerfehler C3593|"Goto" wird in eingeschränktem Amp-Code nicht unterstützt.|
|Compilerfehler C3594|Ausnahmebehandlung (Try, Catch, Throw usw.) wird in eingeschränktem Amp-Code nicht unterstützt.|
|Compilerfehler C3595|konstanter Wert liegt außerhalb des unterstützten Bereichs, in eingeschränktem Amp-code|
|Compilerfehler C3596|"*Parameter*' ('*Typ*'): von Lambda erfasste Variable weist eine nicht unterstützte Typ in eingeschränktem Amp-Code|
|Compilerfehler C3597|"*Parameter*': '*Bezeichner*' darf nicht nach Wert erfasst werden, wenn beim Lambda um eingeschränkten Amp-Code handelt.|
|Compilerfehler C3598|die Label-Anweisung wird in eingeschränktem Amp-Code nicht unterstützt.|
|Compilerfehler C3599|"*Operator*': Zeigerarithmetik kann nicht auf Zeiger in" bool ", in eingeschränktem Amp-Code|
|Compilerfehler C3600|"*Funktion*": Verwenden der Kachel\_statischer Arbeitsspeicher erkannt wird, beim Kompilieren des Aufrufdiagramms für die ohne Tiling concurrency::parallel\_For_each an: "*Funktion*"|
|Compilerfehler C3601|"*Typ*': Ungültiger Argumenttyp für Amp-Diagnosefunktion"*Funktion*"|
|Compilerfehler C3602|Nicht unterstützte ablaufsteuerung festgestellt wird, beim Kompilieren des Aufrufdiagramms für: "*Funktion*"|
|[Compilerfehler C3603](compiler-error-c3603.md)|"*Symbol*': Typ"*Typ*"noch nicht unterstützt|
|Compilerfehler C3604|"*Bezeichner*": ein verwaltetes Objekt kann nur auf dem gc-Heap erstellen|
|Compilerfehler C3605|Die Gesamtzahl an Samplern (*Anzahl* erfasst und *Anzahl* vordefinierte) überschreiten *Anzahl* beim Kompilieren des Aufrufdiagramms für: " *Funktion*"|
|Compilerfehler C3606|Veraltet.|
|Compilerfehler C3607|Veraltet.|
|Compilerfehler C3608|Veraltet.|
|[Compilerfehler C3609](compiler-error-c3609.md)|"*Bezeichner*': eine ' versiegelt/Final'-Funktion muss virtuell sein|
|[Compilerfehler C3610](compiler-error-c3610.md)|"*Bezeichner*': Werttyp muss geschachtelt werden, bevor die Methode"*Methode*"aufgerufen werden kann|
|[Compilerfehler C3611 generiert](compiler-error-c3611.md)|"*Bezeichner*': eine versiegelte Funktion sind keine keinen pure-Spezifizierer|
|[Compilerfehler C3612 generiert](compiler-error-c3612.md)|"*Bezeichner*': eine versiegelte Klasse kann nicht keine reinen virtuellen Methoden aufweisen|
|Compilerfehler C3613|Fehlende Rückgabetyp nach '('Int' davon ausgegangen, dass) ->'|
|Compilerfehler C3614|Unterschiedliche Werte für die Paketgröße in der gleichen Klasse zuvor wurde '*Wert*', neue Wert ist'*Wert*"|
|[Compilerfehler C3615](compiler-error-c3615.md)|Constexpr-Funktion "*Funktion*' kann nicht in einem konstanten Ausdruck ergeben|
|Compilerfehler C3616|Veraltet.|
|Compilerfehler C3617|Veraltet.|
|[Compilerfehler C3618 generiert](compiler-error-c3618.md)|"*Deklaration*': eine DllImport gekennzeichnete Methode nicht definiert werden|
|[Compilerfehler C3619](compiler-error-c3619.md)|eine Vorlage kann nicht innerhalb eines verwalteten/WinRT-Typs deklariert werden|
|Compilerfehler C3620|"*Typ*': Festlegen der Ausrichtung ist für WinRT-Typen nicht zulässig|
|Compilerfehler C3621|"*Typ*': nur der standardpaketwert (*Anzahl*) ist für WinRT-Typen zulässig|
|[Compilerfehler C3622 generiert](compiler-error-c3622.md)|*Typ*': eine Klasse deklariert als '*Schlüsselwort*' kann nicht instanziiert werden|
|[Compilerfehler C3623](compiler-error-c3623.md)|"*Bezeichner*": Bitfelder werden in verwalteten/WinRT-Typen nicht unterstützt|
|[Compilerfehler C3624 generiert](compiler-error-c3624.md)|"*Typ*": Verwendung dieses Typs erfordert einen Verweis auf Assembly-/Modulebene "*Bezeichner*"|
|[Compilerfehler C3625](compiler-error-c3625.md)|"*Klasse*": ein systemeigener Typ kann nicht abgeleitet werden, von einem verwalteten/WinRT-Typ '*Typ*"|
|[Compilerfehler C3626 generiert](compiler-error-c3626.md)|"*Bezeichner*': '*Schlüsselwort*"-Schlüsselwort kann nur verwendet werden, auf die COM-Schnittstellen, Memberfunktionen und Datenmember, die Zeiger auf Delegate sind|
|[Compilerfehler C3627](compiler-error-c3627.md)|Nur ein Werttyp kann geschachtelt werden|
|[Compilerfehler C3628](compiler-error-c3628.md)|"*Klasse*': verwaltete/WinRT-Klassen unterstützen nur öffentliche Vererbung|
|Compilerfehler C3629|"*token*': der Standardwert für die Erfassung kann nur am Anfang einer lambdaerfassungsliste auftreten verwendet werden.|
|[Compilerfehler C3630](compiler-error-c3630.md)|Fehler beim Verarbeiten von Token "*token*"|
|[Compilerfehler C3631](compiler-error-c3631.md)|"*Ereignis*": kann verwaltet/WinRT-Ereignisse nicht überladen|
|[Compilerfehler C3632](compiler-error-c3632.md)|"*Ereignis*": Unzulässiger Ereignisstil für *erstellen*|
|[Compilerfehler C3633 generiert](compiler-error-c3633.md)|kann nicht definiert "*Bezeichner*"als Mitglied der verwaltet werden kann'*Klasse*"|
|[Compilerfehler C3634](compiler-error-c3634.md)|"*Member*": kann nicht definiert eine abstrakte Methode einer verwalteten/WinRT-Klasse|
|Compilerfehler C3635|"*Bezeichner*": kann nicht auf eine verwaltete/WinRT-Klasse angewendet werden (verwenden Sie '*Bezeichner*"stattdessen)|
|Compilerfehler C3636|"*Bezeichner*": kann nicht auf diesen Typ angewendet werden|
|[Compilerfehler C3637](compiler-error-c3637.md)|"*Funktion*': die Definition einer Friend-Funktion darf keine Funktion Vorlagen-/generische Spezialisierung sein|
|[Compilerfehler C3638 generiert](compiler-error-c3638.md)|"*Operator*': die Boxing- und unboxing Konvertierungsoperatoren nicht neu definiert werden|
|Compilerfehler C3639|Veraltet.|
|[Compilerfehler C3640](compiler-error-c3640.md)|"*Member*': eine referenzierte oder virtuelle Memberfunktion einer lokalen Klasse muss definiert werden|
|[Compilerfehler C3641 generiert](compiler-error-c3641.md)|"*Funktion*': ungültige Aufrufkonvention"*Konvention*"für die Funktion, die mit/CLR kompiliert: pure oder/clr: safe|
|[Compilerfehler C3642 generiert](compiler-error-c3642.md)|"*Funktion*': eine Funktion kann nicht aufgerufen werden, mit der __clrcall-Aufrufkonvention aus systemeigenem Code|
|Compilerfehler C3643|Veraltet.|
|[Compilerfehler C3644 generiert](compiler-error-c3644.md)|"*Funktion*': die Funktion zum Generieren von verwalteten Codes kann nicht kompiliert werden.|
|[Compilerfehler C3645 generiert](compiler-error-c3645.md)|"*Funktion*": __clrcall kann nicht verwendet werden, auf die Funktionen, die in nativen Code kompiliert|
|[Compilerfehler C3646 generiert](compiler-error-c3646.md)|"*Bezeichner*": Unbekannter Überschreibungsspezifizierer|
|Compilerfehler C3647|Veraltet.|
|[Compilerfehler C3648 generiert](compiler-error-c3648.md)|Diese explizite Überschreibungssyntax wird für verwaltete Typen nicht unterstützt.|
|Compilerfehler C3649|Diese explizite Überschreibungssyntax ist in/Zw nicht zulässig.|
|[Compilerfehler C3650 generiert](compiler-error-c3650.md)|"*Member*": kann nicht als explizite Überschreibung verwendet werden, muss eine virtuelle Memberfunktion einer Basisklasse|
|[Compilerfehler C3651 generiert](compiler-error-c3651.md)|"*Member*": kann nicht als explizite Überschreibung verwendet werden, muss ein Member einer Basisklasse sein|
|[Compilerfehler C3652 generiert](compiler-error-c3652.md)|"*Member*': eine Funktion, die explizite überschreibungen durchführt, muss virtuell sein|
|[Compilerfehler C3653 generiert](compiler-error-c3653.md)|"*Bezeichner*": kann nicht als benannte Überschreibung verwendet werden: eine Funktion, die überschrieben wurde nicht gefunden; haben Sie vergessen, auf den Funktionsnamen explizit unter Verwendung von folgendem: Operator?|
|[Compilerfehler C3654 generiert](compiler-error-c3654.md)|"*token*": Syntaxfehler in expliziter Überschreibung|
|[Compilerfehler C3655](compiler-error-c3655.md)|"*Member*': Funktion wurde bereits explizit überschrieben.|
|[Compilerfehler C3656 generiert](compiler-error-c3656.md)|"*Schlüsselwort*": Überschreiben der Bezeichner kann nicht wiederholt werden|
|[Compilerfehler C3657 generiert](compiler-error-c3657.md)|ein Destruktor/Finalizer kann nicht explizit außer Kraft setzen oder explizit überschrieben werden.|
|Compilerfehler C3658 generiert|Veraltet.|
|Compilerfehler C3659|"*Member*': Überschreibungsspezifizierer '*Schlüsselwort*" wird nicht unterstützt|
|Compilerfehler C3660|"*member1*": Blendet den geerbten Member "*member2*"|
|[Compilerfehler C3661](compiler-error-c3661.md)|Liste mit expliziten überschreibungen hat keine zu überschreibenden Methoden gefunden.|
|[Compilerfehler C3662](compiler-error-c3662.md)|"*Member*': Überschreibungsspezifizierer '*Schlüsselwort*" nur für Memberfunktionen von verwalteten/WinRT-Klassen zulässig.|
|Compilerfehler C3663|Veraltet.|
|Compilerfehler C3664|"*Member*": kann nicht als explizite Überschreibung verwendet werden, benötigen Sie Zugriff auf "public" oder "protected"|
|[Compilerfehler C3665 generiert](compiler-error-c3665.md)|"*Member*': Überschreibungsspezifizierer '*Schlüsselwort*" für einen Destruktor/Finalizer nicht zulässig|
|[Compilerfehler C3666 generiert](compiler-error-c3666.md)|"*Konstruktor*': Überschreibungsspezifizierer '*Schlüsselwort*" für einen Konstruktor nicht zulässig.|
|Compilerfehler C3667|"*Attribut*": Attribut unterstützt keine paketerweiterung|
|[Compilerfehler C3668 generiert](compiler-error-c3668.md)|"*Member*': die Methode mit dem Überschreibungsspezifizierer"Override"hat keine Basisklassenmethoden überschrieben|
|[Compilerfehler C3669 generiert](compiler-error-c3669.md)|"*Member*': Der Überschreibungsspezifizierer"override"ist für statische Memberfunktionen oder Konstruktoren nicht zulässig|
|[Compilerfehler C3670 generiert](compiler-error-c3670.md)|"*Member*": darf nicht außer Kraft setzen Basisklassenmethode nicht zugegriffen werden kann '*Member*"|
|[Compilerfehler C3671 generiert](compiler-error-c3671.md)|"*Member*': Funktion wird nicht überschrieben werden. '*Member*"|
|[Compilerfehler C3672 generiert](compiler-error-c3672.md)|ein Pseudodestruktorausdruck kann nur als Teil eines Funktionsaufrufs verwendet werden|
|[Compilerfehler C3673 generiert](compiler-error-c3673.md)|"*Klasse*": Klasse hat keinen Kopierkonstruktor|
|Compilerfehler C3674|Das standardbibliotheksmodul wurde nicht gefunden "*Modul*"|
|[Compilerfehler C3675 generiert](compiler-error-c3675.md)|"*Funktion*": ist reserviert, da "*Eigenschaft*" definiert ist|
|Compilerfehler C3676|"*Klasse*": Verweisklasse und Basisklasse weisen nicht kompatible Attribute "[*Attribut*]"|
|Compilerfehler C3677|Zeichenfolgenliteral nach "Operator" kein codierungspräfix aufweisen, nicht möglich|
|Compilerfehler C3678|Zeichenfolgenliteral nach "Operator" eine leere Zeichenfolge sein muss "" "" "|
|Compilerfehler C3679|erwartet LiteralSuffix-Bezeichner nach "Operator" "" "|
|Compilerfehler C3680|eine benutzerdefinierte Zeichenfolgenliterale mit nicht übereinstimmenden LiteralSuffix-Bezeichner können nicht verkettet werden.|
|Compilerfehler C3681|"Fallthrough": Attribut darf nur in einer einschließenden Switch-Anweisung|
|Compilerfehler C3682|' Operator *Bezeichner*": Vorlage für den literalen Operator/Literal kann nicht deklariert werden, damit"C-Bindung"|
|Compilerfehler C3683|kann nicht sowohl das unformatierte literaloperator literaloperator-Vorlage mit demselben LiteralSuffix-Bezeichner definieren.|
|Compilerfehler C3684|' Operator *Bezeichner*": Deklaration des literaloperators weist eine ungültige Parameterliste|
|Compilerfehler C3685|' Operator *Bezeichner*": literaloperator-Vorlage darf keine Funktionsparameter aufweisen|
|Compilerfehler C3686|' Operator *Bezeichner*": literaloperator-Vorlage muss exakt einen Vorlagenparameter, der ein parameterpaket ist haben|
|Compilerfehler C3687|' Operator *Bezeichner*": literaloperator-Vorlage müssen Nichttyp-Vorlagenparameter des Typs"Char"|
|Compilerfehler c3688 generiert|Ungültiges LiteralSuffix "*Suffix*"; literal Operator oder literaloperatorvorlage "Operator *Bezeichner*" wurde nicht gefunden|
|Compilerfehler C3689|' Operator *Bezeichner*": Vorlage für den literalen Operator/Literal muss sich in einem globalen oder einem Namespace-Gültigkeitsbereich|
|Compilerfehler C3690|Zeichenfolgenliteral erwartet, gefunden wurde jedoch eine benutzerdefinierte Zeichenfolge literal stattdessen|
|Compilerfehler C3691|Ungültiges Literalpräfix "*Präfix*"|
|Compilerfehler C3692|Veraltet.|
|Compilerfehler C3693|Veraltet.|
|Compilerfehler C3694|Veraltet.|
|Compilerfehler C3695|Veraltet.|
|Compilerfehler C3696|"*Schlüsselwort*': dieser Qualifizierer kann für '% s' nicht verwendet|
|[Compilerfehler C3697 generiert](compiler-error-c3697.md)|'*Schlüsselwort*': dieser Qualifizierer kann bei nicht verwendet ' ^'|
|[Compilerfehler C3698 generiert](compiler-error-c3698.md)|"*Typ*": Verwenden Sie diesen Typ kann nicht als Argument der "*Operator*"|
|[Compilerfehler C3699 generiert](compiler-error-c3699.md)|"*Operator*": kann nicht, führen Sie diese Dereferenzierung für Typ '*Typ*"|
|Compilerfehler C3700|Veraltet.|
|[Compilerfehler C3701 generiert](compiler-error-c3701.md)|"*Funktion*': Ereignisquelle hat keine Ereignisse|
|[Compilerfehler C3702 generiert](compiler-error-c3702.md)|ATL ist erforderlich, damit COM-Ereignisse|
|[Compilerfehler C3703 generiert](compiler-error-c3703.md)|"*Event_handler*': eine Ereignishandlermethode muss dieselbe Speicherklasse wie die Quelle haben"*Ereignis*"|
|[Compilerfehler C3704 generiert](compiler-error-c3704.md)|"*Member*': eine Vararg-Methode kann keine Ereignisse auslösen|
|[Compilerfehler C3705 generiert](compiler-error-c3705.md)|"*Funktion*': ereignisauslösende Schnittstelle konnte nicht gefunden|
|[Compilerfehler C3706 generiert](compiler-error-c3706.md)|"*Funktion*": muss eine COM-Schnittstelle zum Auslösen von COM-Ereignisse|
|[Compilerfehler C3707 generiert](compiler-error-c3707.md)|"*Member*": Dispinterface-Methode müssen eine Dispid|
|[Compilerfehler C3708 generiert](compiler-error-c3708.md)|"*Funktion*': eine unsachgemäße Verwendung des"*Schlüsselwort*"; muss ein Mitglied einer kompatiblen Ereignisquelle sein|
|[Compilerfehler C3709 generiert](compiler-error-c3709.md)|"*Funktion*': Ungültige Syntax zur Bestimmung des Ereignisses in __hook/__unhook|
|[Compilerfehler C3710](compiler-error-c3710.md)|"*Funktion*': Ungültige Syntax zur Bestimmung der Ereignishandler in __hook/__unhook|
|[Compilerfehler C3711 generiert](compiler-error-c3711.md)|"*Ereignis*': eine nicht verwaltete Ereignisquellmethode muss" void "oder einen ganzzahligen Typ zurückgeben.|
|[Compilerfehler C3712 generiert](compiler-error-c3712.md)|"*Event_handler*': eine Ereignishandlermethode muss denselben Typ wie die Quelle zurückgeben"*Ereignis*"|
|[Compilerfehler C3713 generiert](compiler-error-c3713.md)|"*Event_handler*': eine Ereignishandlermethode muss dieselben Funktionsparameter wie die Quelle haben"*Ereignis*"|
|[Compilerfehler C3714 generiert](compiler-error-c3714.md)|"*Event_handler*': eine Ereignishandlermethode muss dieselbe Aufrufkonvention wie die Quelle haben"*Ereignis*"|
|[Compilerfehler C3715](compiler-error-c3715.md)|"*Zeiger*": muss ein Zeiger auf "*Typ*"|
|Compilerfehler C3716|Veraltet.|
|[Compilerfehler C3717 generiert](compiler-error-c3717.md)|"*Member*': eine Methode, die Ereignisse auslöst, kann nicht definiert werden|
|[Compilerfehler C3718](compiler-error-c3718.md)|kann nur aufrufen ' __*Schlüsselwort*"im Kontext einer Memberfunktion der erhaltenen Klasse|
|[Compilerfehler C3719 generiert](compiler-error-c3719.md)|"*Member*': eine Ereignisquelle für die Schnittstelle basiert kann nur für COM-Ereignisse verwendet werden|
|Compilerfehler C3720|"*Typ*": IDispatch kann nur auf einem dualen oder Dispinterface implementiert|
|[Compilerfehler C3721](compiler-error-c3721.md)|"*Signatur*': nicht kompatible Signatur für das Ereignis|
|[Compilerfehler C3722 generiert](compiler-error-c3722.md)|ein generisches Ereignis ist nicht zulässig.|
|[Compilerfehler C3723 generiert](compiler-error-c3723.md)|"*Funktion*': Ereignis konnte nicht aufgelöst|
|[Compilerfehler C3724](compiler-error-c3724.md)|muss #include \<windows.h > Verwendung von Multithreading mit Ereignissen|
|Compilerfehler C3725|Veraltet.|
|Compilerfehler C3726|Veraltet.|
|[Compilerfehler C3727 generiert](compiler-error-c3727.md)|"*Ereignis*": ein verwaltetes Ereignis muss eine Memberfunktion oder ein Datenmember, die einen Zeiger auf ein Delegat ist.|
|[Compilerfehler C3728](compiler-error-c3728.md)|"*Ereignis*': Ereignis hat keine Raise-Methode|
|Compilerfehler C3729|Veraltet.|
|Compilerfehler C3730|Veraltet.|
|[Compilerfehler C3731 generiert](compiler-error-c3731.md)|Inkompatibles Ereignis "*Ereignis*"und der Handler"*Event_handler*"; Ereignisquelle und Ereignishandler müssen vom selben Ereignistyp sein|
|[Compilerfehler C3732](compiler-error-c3732.md)|"*Schnittstelle*': eine benutzerdefinierte Schnittstelle, die COM-Ereignisse auslöst, kann nicht von IDispatch erben|
|[Compilerfehler C3733 generiert](compiler-error-c3733.md)|"*Ereignis*': Ungültige Syntax zur Spezifizierung eines COM-Ereignisses; haben Sie" __interface"vergessen?|
|[Compilerfehler C3734](compiler-error-c3734.md)|"*Klasse*': eine verwaltete/WinRT-Klasse handelt es sich nicht um einen Co-Klasse|
|Compilerfehler C3735|Veraltet.|
|[Compilerfehler C3736 generiert](compiler-error-c3736.md)|"*Member*": muss eine Methode sein, oder, im Fall von verwalteten Ereignissen, optional ein Datenmember|
|[Compilerfehler C3737 generiert](compiler-error-c3737.md)|"*Bezeichner*": ein Delegat kann keine explizite Aufrufkonvention|
|[Compilerfehler C3738 generiert](compiler-error-c3738.md)|"*Konvention*': die Aufrufkonvention der expliziten Instanziierung muss mit der der instanziierten Vorlage übereinstimmen|
|[Compilerfehler C3739 generiert](compiler-error-c3739.md)|"*Klasse*': Syntax wird nur unterstützt, wenn die" Layout\_abhängige "-Parameter des Event_receiver" true "ist|
|[Compilerfehler C3740 generiert](compiler-error-c3740.md)|"*Vorlage*": Vorlagen können keine Datenquelle, oder Empfangen von Ereignissen|
|[Compilerfehler C3741](compiler-error-c3741.md)|"*Klasse*": muss eine Co-Klasse bei der die "Layout\_abhängige"-Parameter des Event_receiver "true" ist|
|Compilerfehler C3742|"*ttoken1*": unausgeglichene tokensequenz im Attributargument von "*Attribut*', erwartet'*token2*"|
|[Compilerfehler C3743 generiert](compiler-error-c3743.md)|Hook/unhook kann nur auf eine gesamte Schnittstelle angewendet werden, wenn der "Layout_dependent"-Parameter des Event_receiver "true" ist.|
|[Compilerfehler C3744](compiler-error-c3744.md)|__unhook muss wenigstens 3 Argumente für verwaltete Ereignisse haben.|
|[Compilerfehler C3745 generiert](compiler-error-c3745.md)|"*Funktion*': nur ein-Ereignis ausgelöst werden kann'"|
|Compilerfehler C3746|das Standardattribut "*Bezeichner*" darf höchstens einmal in einer Attributliste|
|[Compilerfehler C3747 generiert](compiler-error-c3747.md)|standardmäßige Vorlagen-/generische Parameter fehlt: Parameter *Anzahl*|
|[Compilerfehler C3748 generiert](compiler-error-c3748.md)|"*Schnittstelle*': nicht verwaltete Schnittstellen lösen möglicherweise keine Ereignisse|
|[Compilerfehler C3749 generiert](compiler-error-c3749.md)|"*Attribut*": ein benutzerdefiniertes Attribut kann nicht innerhalb einer Funktion verwendet werden|
|Compilerfehler C3750|"*token*': Unerwartetes Token in der Attributliste|
|Compilerfehler C3751|"*Bezeichner*": Unerwarteter Bezeichner im Attributliste|
|[Compilerfehler C3752](compiler-error-c3752.md)|"*Attribut*": Attribut kann nicht klassifiziert werden. "*Schlüsselwort*" sollte in diesem Kontext nicht verwendet werden|
|[Compilerfehler C3753 generiert](compiler-error-c3753.md)|eine generische Eigenschaft ist nicht zulässig.|
|[Compilerfehler C3754 generiert](compiler-error-c3754.md)|Delegatkonstruktor: Member-Funktion "*Member*"kann nicht auf eine Instanz des Typs aufgerufen werden"*Typ*"|
|[Compilerfehler C3755](compiler-error-c3755.md)|"*Bezeichner*": ein Delegat ist möglicherweise nicht definiert|
|Compilerfehler C3756 generiert|Veraltet.|
|Compilerfehler C3757|"*Typ*': Typ ist für"Constexpr"-Funktion nicht zulässig.|
|Compilerfehler C3758|"*Member*": virtuelle Funktion kann nicht "Constexpr" deklariert werden|
|Compilerfehler C3759|"*Member*': Memberfunktion eines nicht literalen Typs kann nicht"Constexpr"deklariert werden|
|Compilerfehler C3760|Verwenden Sie Schlüsselwort "__property", Eigenschaft in verwalteten/WinRT deklarieren "*Klasse*"|
|[Compilerfehler C3761 generiert](compiler-error-c3761.md)|"*Funktion*": "Retval" kann nur für das letzte Argument einer Funktion verwendet werden.|
|[Compilerfehler C3762](compiler-error-c3762.md)|Attribut kann nicht verarbeitet '*Attribut*"|
|[Compilerfehler C3763 generiert](compiler-error-c3763.md)|"*Typ*": "Retval" und "Out" kann nur in einem Datenzeigertyp angezeigt werden.|
|[Compilerfehler C3764](compiler-error-c3764.md)|"*Member*": Basisklassenmethode kann nicht überschrieben werden "*Member*"|
|[Compilerfehler C3765 generiert](compiler-error-c3765.md)|"*Ereignis*": ein Ereignis kann nicht in einer Klasse/Struktur definiert "*Typ*" als ein Event_receiver gekennzeichnet|
|[Compilerfehler C3766 generiert](compiler-error-c3766.md)|"*Typ*"müssen eine Implementierung für die Schnittstellenmethode bereitstellen"*Funktion*"|
|[Compilerfehler C3767](compiler-error-c3767.md)|"*Funktion*": mögliche Funktion(en) kann nicht zugegriffen werden|
|[Compilerfehler C3768 generiert](compiler-error-c3768.md)|die Adresse einer virtuellen Vararg-Funktion in reinem verwaltetem Code kann nicht übernommen werden.|
|[Compilerfehler C3769 generiert](compiler-error-c3769.md)|"*Bezeichner*': eine geschachtelte Klasse kann nicht den gleichen Namen wie die Sie unmittelbar umschließende Klasse aufweisen|
|Compilerfehler C3770|"*Typ*": ist keine gültige Basisklasse|
|[Compilerfehler C3771](compiler-error-c3771.md)|"*Bezeichner*': die Friend-Deklaration wurde im nächsten Namespacebereich nicht gefunden|
|[Compilerfehler C3772](compiler-error-c3772.md)|"*Bezeichner*': Ungültige Friend-Vorlagendeklaration|
|Compilerfehler C3773|Bitte verwenden Sie "/ await" Compilerschalter um Coroutinen zu aktivieren.|
|Compilerfehler C3774|wurde nicht gefunden "*Bereich*::*Bezeichner*": Geben Sie *Header* Header|
|Compilerfehler C3775|der Rückgabetyp des '*Funktion*'sollte nicht'*Typ*"|
|Compilerfehler C3776|können kein Ausdrucks vom Typ in einer Coroutine mit nicht-Void-Rückgabetyp "void" zurückgeben|
|Compilerfehler C3777|"*Funktion*': eine Coroutine keine Variable Argumentliste übernehmen|
|Compilerfehler C3778|Alloca: kann nicht in einer Coroutine verwendet werden|
|Compilerfehler C3779|"*Funktion*': eine Funktion, die zurückgegeben"*Typ*' kann nicht verwendet werden, bevor sie definiert ist|
|Compilerfehler C3780|"*Funktion*': eine Konvertierungsfunktion, die gibt*Typ*' kann nicht verwendet werden, bevor sie definiert ist|
|Compilerfehler C3781|"*Schlüsselwort*": kann nicht in einer Coroutine vom Typ verwendet werden kann '*Typ*". Entweder *Schlüsselwort* oder *Schlüsselwort* muss im zugehörigen "promise_type" vorhanden sein|
|Compilerfehler C3782|*Typ*: der Coroutine Promise dürfen nicht beide *Schlüsselwort* und *Schlüsselwort*|
|Compilerfehler C3783|"*Bezeichner*': eine Coroutine nicht möglich|
|Compilerfehler C3784|*Schlüsselwort* Ausdruck kann nicht in diesem Kontext verwendet werden|
|Compilerfehler C3785|das erste Vorlagenargument für "Std:: integer_sequence" muss ein ganzzahliger Typ sein.|
|Compilerfehler C3786|Das zweite Vorlagenargument für "Std:: make_integer_sequence" muss eine ganzzahlige Konstante größer als oder gleich 0 (null) sein.|
|Compilerfehler C3787|den Rückgabetyp dieser coroutine kann nicht hergeleitet werden.|
|Compilerfehler C3788|Veraltet.|
|Compilerfehler C3789|Veraltet.|
|Compilerfehler C3790|Veraltet.|
|Compilerfehler C3791|Veraltet.|
|Compilerfehler C3792|Veraltet.|
|Compilerfehler C3793|Veraltet.|
|Compilerfehler C3794|Veraltet.|
|Compilerfehler C3795|Veraltet.|
|Compilerfehler C3796|Veraltet.|
|[Compilerfehler C3797 generiert](compiler-error-c3797.md)|"*Schlüsselwort*': Ereignisdeklaration darf keinen Überschreibungsspezifizierer (sollte platziert werden. auf Ereignis hinzufügen/entfernen/Raise-Methoden stattdessen)|
|[Compilerfehler C3798](compiler-error-c3798.md)|"*Schlüsselwort*': Eigenschaftendeklaration darf keinen Überschreibungsspezifizierer (sollte in der Eigenschaft Get/Set-Methoden stattdessen platziert werden)|
|[Compilerfehler C3799 generiert](compiler-error-c3799.md)|indizierte Eigenschaft kann keine leere Parameterliste aufweisen.|
|[Compilerfehler C3800](compiler-error-c3800.md)|"*Deklaration*": kann nicht mischen, Eigenschaften und Ereignisse|
|Compilerfehler C3801|"*Attribut*': das Attribut kann keine Argument-Klausel vorhanden|
|Compilerfehler C3802|Veraltet.|
|[Compilerfehler C3803 generiert](compiler-error-c3803.md)|"*Eigenschaft*": Eigenschaft hat einen Typ ist nicht mit einem seiner Accessoren*Accessor*"|
|[Compilerfehler C3804 generiert](compiler-error-c3804.md)|"*Member*': die Zugriffsmethoden eine Eigenschaft müssen entweder werden alle statisch oder alle nicht statischen|
|[Compilerfehler C3805](compiler-error-c3805.md)|"*token*': Unerwartetes Token erwartet entweder '}"oder ein","|
|Compilerfehler C3806|"*token*': Unerwartetes Token erwartet wird entweder eine ' {' oder ein Member-Initialisierer|
|[Compilerfehler C3807 generiert](compiler-error-c3807.md)|"*Typ*': eine Klasse mit dem ComImport-Attribut kann nicht abgeleitet werden, von"*Typ*", nur eine schnittstellenimplementierung ist zulässig.|
|[Compilerfehler C3808 generiert](compiler-error-c3808.md)|"*Typ*': eine Klasse mit dem ComImport-Attribut die Member kann nicht definiert"*Member*", nur abstrakte oder Dllimport-Funktionen sind zulässig|
|[Compilerfehler C3809](compiler-error-c3809.md)|"*Typ*": ein verwaltet/WinRT-Typ kein Friend-Funktionen/-Klassen /-schittstellen aufweisen|
|Compilerfehler C3810|Veraltet.|
|Compilerfehler C3811|Veraltet.|
|[Compilerfehler C3812](compiler-error-c3812.md)|"__property" muss das erste Token in einer Eigenschaftendeklaration sein.|
|[Compilerfehler C3813](compiler-error-c3813.md)|eine Eigenschaftendeklaration kann nur innerhalb der Definition eines verwalteten/WinRT-Typs verwendet werden.|
|Compilerfehler C3814|Veraltet.|
|[Compilerfehler C3815](compiler-error-c3815.md)|Rückgabetyp der Methode "*Member*" Typ des letzten Parameters des Setter übereinstimmen|
|[Compilerfehler C3816](compiler-error-c3816.md)|' Klasse bzw. Struktur *Member*' wurde bereits deklariert oder definiert, die mit einem anderen verwalteten/WinRT-Modifizierer|
|[Compilerfehler C3817](compiler-error-c3817.md)|"*Deklaration*": Eigenschaft kann nur auf eine Funktion angewendet werden|
|[Compilerfehler C3818](compiler-error-c3818.md)|Array-Eigenschaftsdeklaration "*Eigenschaft*"eine Index-Eigenschaft keine überladen"*Eigenschaft*"|
|Compilerfehler C3819|Veraltet.|
|[Compilerfehler C3820](compiler-error-c3820.md)|"*Bezeichner*": Initialisierer müssen verwaltet sein|
|[Compilerfehler C3821](compiler-error-c3821.md)|"*Funktion*': verwaltete Typ oder die Funktion kann nicht in eine nicht verwaltete Funktion verwendet werden|
|Compilerfehler C3822|Veraltet.|
|Compilerfehler C3823|Veraltet.|
|[Compilerfehler C3824 generiert](compiler-error-c3824.md)|"*Typ*': Dieser Typ kann nicht verwendet werden, in diesem Kontext (Funktionsparameter, Rückgabetyp oder einen statischen Member)|
|[Compilerfehler C3825](compiler-error-c3825.md)|"*Typ*': eine verwaltete/WinRT-Klasse unterstützt nur verwaltete/WinRT-Ereignisse|
|Compilerfehler C3826|Veraltet.|
|Compilerfehler C3827|Standardattribut "deprecated" kann keine Argumente oder ein Zeichenfolgenliteral mit Beschreibung der Ursache haben.|
|[Compilerfehler C3828](compiler-error-c3828.md)|Positionierungsargumente können nicht angegeben werden, für eine "*Schlüsselwort*"Ausdruck für den Typ"*Typ*"|
|Compilerfehler C3829|das Standardattribut "Noreturn" kann nur auf Funktionen angewendet werden|
|[Compilerfehler C3830 generiert](compiler-error-c3830.md)|"*type1*": kann nicht von erben "*Typ2*', Werttypen können nur von Schnittstellenklassen erben|
|[Compilerfehler C3831 generiert](compiler-error-c3831.md)|"*Bezeichner*': '*Typ*' kann kein keinen festen Datenmember oder eine Memberfunktion, die einen festen Zeiger zurückgibt|
|[Compilerfehler C3832](compiler-error-c3832.md)|"*Typelib*': Typ Bibliothek sieht, als ob sie für 32-Bit-Zeiger; erstellt wurde ändern den Qualifizierer 'Ptrsize'|
|[Compilerfehler C3833 generiert](compiler-error-c3833.md)|"*Typ*': Ungültiger Zieltyp für *Bezeichner*|
|[Compilerfehler C3834 generiert](compiler-error-c3834.md)|Unzulässige explizite Umwandlung zu einem festen Zeiger; Verwenden Sie stattdessen eine angeheftete lokale variable|
|Compilerfehler C3835|Veraltet.|
|[Compilerfehler C3836 generiert](compiler-error-c3836.md)|ein statischer Konstruktor darf keine Memberinitialisiererliste haben.|
|Compilerfehler C3837|Attribute sind in diesem Kontext nicht zulässig.|
|[Compilerfehler C3838 generiert](compiler-error-c3838.md)|von kann nicht geerbt "*Typ*"|
|[Compilerfehler C3839](compiler-error-c3839.md)|Ausrichtung in einem verwalteten/WinRT-Typ kann nicht geändert werden.|
|Compilerfehler C3840 generiert|Veraltet.|
|Compilerfehler C3841|Veraltet.|
|[Compilerfehler C3842](compiler-error-c3842.md)|"*Bezeichner*': 'const' und 'volatile'-Qualifizierer für Memberfunktionen von verwalteten/WinRT-Typen werden nicht unterstützt.|
|Compilerfehler C3843|"*Bezeichner*": Ref-Qualifizierer für Memberfunktionen von verwalteten/WinRT-Typen werden nicht unterstützt.|
|Compilerfehler C3844|"*Bezeichner*": Symbol aus kann nicht importiert "*Quelle*': als*Bezeichner*' ist im aktuellen Bereich bereits vorhanden.|
|Compilerfehler C3845 generiert|Veraltet.|
|[Compilerfehler C3846 generiert](compiler-error-c3846.md)|"*Bezeichner*": Symbol aus kann nicht importiert "*Quelle*': als*Bezeichner*'wurde bereits importiert aus einer anderen Assembly'*Assembly*'|
|Compilerfehler C3847|Veraltet.|
|[Compilerfehler C3848](compiler-error-c3848.md)|Ausdruck mit Typ '*Typ*"verlieren würden einige Const-Volatile-Qualifizierer für den Aufruf"*Bezeichner*"|
|[Compilerfehler C3849](compiler-error-c3849.md)|Funktion-Style-Aufruf an ein Ausdruck vom Typ "*Typ*" für alle const- und/oder volatile-Qualifizierer verlieren *Anzahl* verfügbaren operatorüberladungen|
|[Compilerfehler C3850](compiler-error-c3850.md)|"*token*': eine universelle Zeichenname gibt ein ungültiges Zeichen|
|[Compilerfehler C3851](compiler-error-c3851.md)|"*token*': eine universelle Zeichenname darf kein Zeichen im Basiszeichensatz bezeichnen|
|[Compilerfehler C3852](compiler-error-c3852.md)|"*Member*'mit Typ'*Typ*": aggregatsinitialisierung konnte diesen Member nicht initialisieren|
|[Compilerfehler C3853](compiler-error-c3853.md)|"=": erneute Initialisieren, einen Verweis oder die Zuweisung über einen Verweis auf Funktion ist nicht zulässig|
|[Compilerfehler C3854 generiert](compiler-error-c3854.md)|Ausdruck links von '=' wird als Funktion ausgewertet. Eine Funktion kann nicht zugewiesen (eine Funktion ist kein l-Wert)|
|[Compilerfehler C3855](compiler-error-c3855.md)|"*Funktion*': Vorlagen-/generische Parameter"*Bezeichner*' ist nicht kompatibel mit der Deklaration|
|[Compilerfehler C3856](compiler-error-c3856.md)|"*Klasse*": Klasse ist nicht mit einer Klasse Vorlagen-/generische|
|[Compilerfehler C3857](compiler-error-c3857.md)|"*Vorlage*": mehrere Vorlagen-/generische Parameterlisten sind nicht zulässig.|
|[Compilerfehler C3858 generiert](compiler-error-c3858.md)|"*Bezeichner*': nicht im aktuellen Bereich nicht erneut deklariert werden|
|[Compilerfehler C3859](compiler-error-c3859.md)|Virtueller Speicherbereich für PCH wurde überschritten; Kompilieren Sie erneut mit einer Befehlszeilenoption von "-Zm*Anzahl*' oder höher|
|[Compilerfehler C3860](compiler-error-c3860.md)|Vorlagen-/generische Argumentliste nach Klasse Vorlagen-/generische Namen muss die Parameter in der Reihenfolge, in der Parameterliste Vorlagen-/generische verwendet auflisten.|
|[Compilerfehler C3861](compiler-error-c3861.md)|"*Bezeichner*": Bezeichner wurde nicht gefunden.|
|[Compilerfehler C3862 generiert](compiler-error-c3862.md)|"*Funktion*": kann nicht kompiliert werden eine nicht verwaltete Funktion mit/clr: pure oder/clr: safe|
|Compilerfehler C3863|Arraytyp "*Typ*' kann nicht zugewiesen werden|
|Compilerfehler C3864|Veraltet.|
|[Compilerfehler C3865 generiert](compiler-error-c3865.md)|"*Schlüsselwort*": kann nur für systemeigene Memberfunktionen verwendet werden|
|[Compilerfehler C3866 generiert](compiler-error-c3866.md)|fehlt die Argumentliste Destruktor/Finalizer-Aufruf|
|[Compilerfehler C3867](compiler-error-c3867.md)|"*Funktion*": keine Standardsyntax; verwenden Sie stattdessen '&', um einen Zeiger auf Member zu erstellen.|
|[Compilerfehler C3868 generiert](compiler-error-c3868.md)|"*Typ*": Einschränkungen für den generischen Parameter '*Parameter*"unterscheiden sich von den in der Deklaration|
|[Compilerfehler C3869 generiert](compiler-error-c3869.md)|Gcnew-Einschränkung fehlt die leere Parameterliste Liste '(')|
|Compilerfehler C3870|"*Parameter*": "__declspec (*Spezifizierer*)" kann nur auf Parameter vom ganzzahligen Typ angewendet werden|
|Compilerfehler C3871|"*Parameter*": "__declspec(Guard(Overflow))""wird nur unterstützt, auf die ersten 64 Parameter einer Funktion|
|[Compilerfehler C3872](compiler-error-c3872.md)|"0 X*Wert*": Dieses Zeichen wird in einem Bezeichner nicht zulässig.|
|[Compilerfehler C3873](compiler-error-c3873.md)|"0 X*Wert*": Dieses Zeichen wird als erstes Zeichen eines Bezeichners nicht zulässig.|
|[Compilerfehler C3874 generiert](compiler-error-c3874.md)|der Rückgabetyp des '*Bezeichner*'muss'*type1*"anstelle von"*Typ2*"|
|Compilerfehler C3875|Aufruf einer nicht statischen Memberfunktion fehlt die Argumentliste|
|Compilerfehler C3876|Veraltet.|
|Compilerfehler C3877|Veraltet.|
|Compilerfehler C3878|Veraltet.|
|Compilerfehler C3879|"*Member*": ein Initonly-Datenmembers nicht möglich|
|[Compilerfehler C3880 generiert](compiler-error-c3880.md)|"*Member*": Ein literal-Datenmember nicht möglich|
|Compilerfehler C3881|kann nur Konstruktor aus direkter Basis erben werden.|
|Compilerfehler C3882|"*Klasse*": Konstruktor wurde bereits geerbt von "*Klasse*"|
|Compilerfehler C3883|"*Member*": ein statischer Initonly-Datenmember muss initialisiert werden|
|Compilerfehler C3884|"*Typ*": Ein Array Unbekannter Größe kann nicht wertinitialisiert sein|
|Compilerfehler C3885|"*Typ*": Ein Array Unbekannter Größe kann nicht mit einer leeren Initialisiererliste initialisiert werden|
|[Compilerfehler C3886 generiert](compiler-error-c3886.md)|"*Member*": Ein literal-Datenmember muss initialisiert werden|
|[Compilerfehler C3887 generiert](compiler-error-c3887.md)|"*Member*': der Initialisierer für ein literal-Datenmembers muss ein konstanter Ausdruck sein|
|[Compilerfehler C3888](compiler-error-c3888.md)|"*Member*': der diesem literal-Datenmember zugeordnete Konstantenausdruck wird nicht unterstützt, von C++ / CLI|
|Compilerfehler C3889|Veraltet.|
|[Compilerfehler C3890 generiert](compiler-error-c3890.md)|"*Member*': Sie können die Adresse eines literal-Datenmembers nicht übernehmen|
|[Compilerfehler C3891 generiert](compiler-error-c3891.md)|"*Member*": Ein literal-Datenmember kann nicht als l-Wert verwendet werden|
|[Compilerfehler C3892 generiert](compiler-error-c3892.md)|"*Variable*': Sie können nicht für eine Variable, die eine Konstante ist zuweisen|
|[Compilerfehler C3893 generiert](compiler-error-c3893.md)|"*Member*": Verwendung l-Wertes eines Initonly-Datenmembers ist nur zulässig, in einem Instanzenkonstruktor der Klasse*Klasse*"|
|[Compilerfehler C3894 generiert](compiler-error-c3894.md)|"*Member*': l-Wert-Verwendung der statischen Initonly-Datenmembers ist nur zulässig, in den Konstruktor der Klasse Klasse*Klasse*"|
|[Compilerfehler C3895 generiert](compiler-error-c3895.md)|"*Member*': *Typ* Datenmember darf nicht"volatile"sein|
|[Compilerfehler C3896 generiert](compiler-error-c3896.md)|"*Member*": Fehlerhafte Initialisierung: Dieser literal-Datenmember kann nur mit "Nullptr" initialisiert werden|
|Compilerfehler C3897 generiert|Veraltet.|
|[Compilerfehler C3898 generiert](compiler-error-c3898.md)|"*Member*': *Typ* -Datenmember können nur Member von verwalteten Typen sein|
|[Compilerfehler C3899 generiert](compiler-error-c3899.md)|"*Member*": Verwendung l-Wertes eines Initonly-Datenmembers ist nicht zulässig, direkt innerhalb eines parallelen Bereichs in der Klasse*Klasse*"|
|[Compilerfehler C3900 generiert](compiler-error-c3900.md)|"*Member*": im aktuellen Bereich nicht zulässig.|
|[Compilerfehler C3901 generiert](compiler-error-c3901.md)|"*Funktion*": Rückgabetyp haben muss '*Typ*"|
|[Compilerfehler C3902 generiert](compiler-error-c3902.md)|"*Funktion*': Typ des letzten Parameters muss '*Typ*"|
|[Compilerfehler C3903 generiert](compiler-error-c3903.md)|"*Eigenschaft*": ist nicht festgelegt haben, oder get-Methode|
|[Compilerfehler C3904 generiert](compiler-error-c3904.md)|"*Eigenschaft*": Geben Sie die müssen *Anzahl* Parameter (n)|
|Compilerfehler C3905|nicht ausgerichtete Zugriffe werden nicht unterstützt, für den systeminternen Typ "*Typ*"|
|Compilerfehler C3906|systeminternen Typ "*Typ*' ist kein unterstützter Rückgabe-Typ für Vararg oder ohne Prototyp-Funktion|
|Compilerfehler C3907|Veraltet.|
|[Compilerfehler C3908 generiert](compiler-error-c3908.md)|die Zugriffsebene ist weniger restriktiv als die von "*Bezeichner*"|
|[Compilerfehler C3909](compiler-error-c3909.md)|eine verwaltete/WinRT-Ereignisdeklaration muss in einen verwalteten/WinRT-Typ vorhanden sein.|
|[Compilerfehler C3910 generiert](compiler-error-c3910.md)|"*Ereignis*": Element definieren muss '*Member*"|
|[Compilerfehler C3911 generiert](compiler-error-c3911.md)|"*Member*': Funktion muss einen Typ aufweisen '*Typ*"|
|[Compilerfehler C3912 generiert](compiler-error-c3912.md)|"*Ereignis*': Typ des Ereignisses muss ein Delegattyp sein|
|[Compilerfehler C3913](compiler-error-c3913.md)|eine Standardeigenschaft muss indiziert sein|
|[Compilerfehler C3914 generiert](compiler-error-c3914.md)|eine Standardeigenschaft kann nicht statisch sein.|
|[Compilerfehler C3915](compiler-error-c3915.md)|"*Bezeichner*' ist keine indizierte Standardeigenschaft (Klassenindexer)|
|Compilerfehler C3916|Veraltet.|
|[Compilerfehler C3917](compiler-error-c3917.md)|"*token*': veraltet *erstellen* Deklarationsstil (wollten Sie verwenden" [""] "stattdessen?)|
|[Compilerfehler C3918](compiler-error-c3918.md)|Die Syntax muss "*Bezeichner*" ein Datenmember sein.|
|[Compilerfehler C3919 generiert](compiler-error-c3919.md)|"*Funktion*': Funktion muss einen Typ aufweisen '*Return_type* (*Typ*)"|
|[Compilerfehler C3920](compiler-error-c3920.md)|"*Operator*": kann nicht definiert eine Postfix-Inkrement/Dekrement CLR/WinRT-Operator Aufrufen des Postfix CLR/WinRT-Operator Ruft das entsprechende Präfix CLR/WinRT-Operator (Op_Increment/op_Decrement) aufgerufen, jedoch mit Postfix Semantik|
|Compilerfehler C3921|Veraltet.|
|Compilerfehler C3922|Veraltet.|
|[Compilerfehler C3923](compiler-error-c3923.md)|"*Member*": lokale Klasse, Struktur oder union-Definitionen dürfen nicht in einer Memberfunktion einer verwalteten/WinRT-Klasse|
|Compilerfehler C3924|Fehler in Argument #*Anzahl* des Delegatkonstruktoraufrufs "*Konstruktor*":|
|Compilerfehler C3925|erwartet eine Schleife (for, while oder do) folgenden "*Richtlinie*" Richtlinie|
|Compilerfehler C3926|Ungültige Konstante in "parallel"-Direktive|
|Compilerfehler C3927|"->": nachstehender Rückgabetyp ist nach einem nichtfunktionsdeklarator nicht zulässig|
|Compilerfehler C3928|"->": nachstehender Rückgabetyp ist nach einem Deklarator in Klammern nicht zulässig|
|Compilerfehler C3929|Veraltet.|
|Compilerfehler C3930|"*Funktion*": keine überladene Funktion verfügt über einschränkungsspezifizierer, die kompatibel mit dem ambient-Kontext sind "*Kontext*"|
|Compilerfehler C3931|"*Typ*": kann nicht Aufrufen einer Funktion mit einschränkungsspezifizierern, die mit dem ambient-Kontext nicht kompatibel sind|
|Compilerfehler C3932|Veraltet.|
|Compilerfehler C3933|"*Klasse*': einschränkungsspezifizierer des Destruktors müssen die Union der einschränkungsspezifizierer auf allen Konstruktoren abdecken|
|Compilerfehler C3934|eine Funktion, die in irgendeiner Form von "Main" ist keine einschränkungsspezifizierer als restrict(cpu)|
|Compilerfehler C3935|"*Bezeichner*": Neudefinition; überlappende einschränkungsspezifizierer|
|Compilerfehler C3936|"*Bezeichner*": Unbekannter einschränkungsspezifizierer|
|Compilerfehler C3937|leere einschränkungsspezifizierer ist nicht zulässig.|
|Compilerfehler C3938|"*Bezeichner*": Spezifizierer mit mehreren Einschränkungen werden nicht unterstützt, auf externe \042C\042-Funktionen|
|Compilerfehler C3939|"*Bezeichner*': Zeiger auf Member-Funktionen, Funktionszeiger, Verweise auf Funktionen mit"Amp"-einschränkungsverweis sind nicht zulässig.|
|Compilerfehler C3940|"*Bezeichner*": Bezeichner nicht gefunden – möglicherweise fehlende Übereinstimmung zwischen Compiler und Bibliotheksversionen. Stellen Sie sicher vccorlib.h/.lib, vccorlib120.dll und c1xx.dll übereinstimmen|
|Compilerfehler C3941|"*Bedingung*": erfordert "/ Clr" Befehlszeilenoption|
|Compilerfehler C3942|Veraltet.|
|Compilerfehler C3943|Veraltet.|
|Compilerfehler C3944|Veraltet.|
|Compilerfehler C3945|"*Typ*": kann nicht ausgelöst oder ein Winrt-Objekt, die von Platform:: Exception abgeleitet werden nicht abgefangen|
|Compilerfehler C3946|"*Typ*": Typeid kann nicht auf diesen Typ angewendet werden|
|Compilerfehler C3947|"*Typeid*": Typeid kann nicht auf eine paketerweiterung angewendet werden|
|Compilerfehler C3948|"*Schlüsselwort*': eine paketerweiterung kann nicht in diesem Kontext verwendet werden|
|Compilerfehler C3949|eine paketerweiterung, "..." kann nicht in einem abstrakten Deklarator von in Klammern angezeigt werden.|
|Compilerfehler C3950|Veraltet.|
|Compilerfehler C3951|Pointer-to-Member kann in projizierten WinRT-Typ nicht verwendet '*Typ*". Verwenden Sie stattdessen einen Delegaten.|
|Compilerfehler C3952|"*Typ*": WinRT wird "in/Out" Arrays nicht unterstützt werden. Verwenden "const Array<T>^' für"in"und" WriteOnlyArray<T>"oder" Array<T>^ *' für 'Out' auf öffentlichen APIs|
|Compilerfehler C3953|Können keine verwalteten Klasse*Typ*"im WinRT-Modul.|
|Compilerfehler C3954|"*Typ*": Ein Array von einer veröffentlichten Methode für einen WinRT-Typ zurückgegeben wird. verwenden Sie das Formular muss ' Array<T>^'|
|Compilerfehler C3955|"*Typ*": Ein öffentlicher Konstruktor darf keinen 'Out'-Parameter enthalten oder "WriteOnlyArray<T>"|
|Compilerfehler C3956|"*Typ*": Typ ist als exklusiv für markiert "*Typ*'und kann nicht als Basis verwendet werden kann'*Derived_type*"|
|Compilerfehler C3957|"*Typ*": kann nicht verwendet 'new' in einem WinRT geben; verwenden Sie stattdessen "Ref new"|
|Compilerfehler C3958|"*Typ*": Verwenden Sie "Gcnew" kann nicht auf eine WinRT geben; verwenden Sie stattdessen "Ref new"|
|Compilerfehler C3959|"Ref new" kann nur zum Erstellen eines Objekts mit WinRT-Typ verwendet werden|
|Compilerfehler C3960|Veraltet.|
|Compilerfehler C3961|statischer Konstruktor wird nicht unterstützt.|
|Compilerfehler C3962|generische Klasse wird nicht unterstützt.|
|Compilerfehler C3963|ein mehrdimensionales Array wird nicht unterstützt.|
|Compilerfehler C3964|verzweigtes Array wird nicht unterstützt.|
|Compilerfehler C3965|Parameterarray wird nicht unterstützt.|
|Compilerfehler C3966|"*Funktion*': generische Funktion wird nicht unterstützt.|
|Compilerfehler C3967|Fehler beim Importieren der "*Bezeichner*"aus dem Modul"*Modul*"|
|Compilerfehler C3968|Das Token "*token*' ist kein gültiger modulnamentrennzeichen; Punkt ('. ') stattdessen|
|Compilerfehler C3969|Inkonsistente Modulnamen: "*module1*'und'*module1*"|
|Compilerfehler C3970|"*Bezeichner*': '*Schlüsselwort*' kann nur"Ref Class"oder"Ref Struct"im globalen Gültigkeitsbereich oder Namespacebereich angewendet werden|
|Compilerfehler C3971|"*Typ*': partielle Deklaration darf nicht nach vollständigen Definition|
|Compilerfehler C3972|"*Typ*": "partial" kann nur auf Klassendeklarationen oder Definitionen angewendet werden|
|Compilerfehler C3973|Veraltet.|
|Compilerfehler C3974|Veraltet.|
|Compilerfehler C3975|' Klasse bzw. Struktur *Bezeichner*' wurde bereits deklariert oder definiert, die mit einem anderen Modifizierer|
|Compilerfehler C3976|"*Bezeichner1*"muss deklariert werden, um zu verwenden als "public" "*Bezeichner2*"|
|Compilerfehler C3977|Nutzung erfordert einen Verweis auf eine Assembly, die definiert, "*Bezeichner*"|
|Compilerfehler C3978|"*Bezeichner*': eine statische Eigenschaft darf nicht als Member einer WinRT-Schnittstelle oder eines Werttyps|
|Compilerfehler C3979|"*Typ*": Verwenden Sie Attribut '*Attribut*"anstelle von"*Wert*"|
|Compilerfehler C3980|"*Typ*' kann nicht in Metadaten ausgegeben werden|
|Compilerfehler C3981|"*Typ*": ein Werttyp sind keine statischen Datenmember*Bezeichner*"|
|Compilerfehler C3982|"*Typ*": ein Werttyp sind keine nicht öffentlichen Datenmember*Bezeichner*"|
|Compilerfehler C3983|"*Typ*": ein Werttyp ist keine öffentlichen statischen Datenmember*Bezeichner*"|
|Compilerfehler C3984|"*Typ*": ein Werttyp keine öffentlichen statischen Datenmember sind keine*Bezeichner*"|
|Compilerfehler C3985|"*Bezeichner*': die Signatur des öffentlichen Members enthält den privaten Typ"*Member*"|
|Der Compilerfehler C3986|"*Bezeichner*': die Signatur des öffentlichen Members enthält den systemeigenen Typ"*Member*"|
|Compilerfehler C3987|"*Bezeichner*': die Signatur des öffentlichen Members enthält den systemeigenen Typ"*Typ*"|
|Compilerfehler C3988|"*Typ*": ein systemeigener Typ kann nicht öffentlich sein|
|Compilerfehler C3989|"*Typ*": ein geschachtelter Typ kann nicht öffentlich sein|
|Compilerfehler C3990|"*Typ*": Attribut '*Attribut*' kann nicht privat oder geschachtelt sein|
|Compilerfehler C3991|"*Typ*': eine nicht öffentliche oder geschachtelte Schnittstelle kann nicht implementiert '*Schnittstelle*"|
|Compilerfehler C3992|"*Bezeichner*': die Signatur des öffentlichen Members enthält einen ungültigen Typ"*Typ*"|
|Compilerfehler C3993|"*Typ*": ein Werttyp muss mindestens ein öffentliches Feld enthalten|
|Compilerfehler C3994|"*Typ*": ein Werttyp kann keine Schnittstellen implementieren oder über virtuelle Funktionen verfügen|
|Compilerfehler C3995|"*Typ*": ein Werttyp keine keine Ereignismember*Bezeichner*"|
|Compilerfehler C3996|Veraltet.|
|Compilerfehler C3998|"C ++*Version*': nicht unterstützte C++-Version; Standardwert ' C ++*Version*"|
|Compilerfehler C3999|UNBEKANNTER Fehler wählen Sie den technischen Supportbefehl im Visual C++-Hilfemenü, oder öffnen Sie die Hilfedatei für technischen Support für Weitere Informationen|

## <a name="see-also"></a>Siehe auch

[C /C++ Compiler- und Build tools, Fehler und Warnungen](../compiler-errors-1/c-cpp-build-errors.md) \
[Compilerfehler C2000 - C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
