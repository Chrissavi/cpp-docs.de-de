---
title: Compilerfehler C3400 bis C3499
ms.date: 04/21/2019
f1_keywords:
- C3401
- C3402
- C3403
- C3404
- C3405
- C3406
- C3407
- C3410
- C3411
- C3416
- C3419
- C3422
- C3424
- C3425
- C3426
- C3427
- C3428
- C3429
- C3430
- C3431
- C3432
- C3433
- C3434
- C3435
- C3436
- C3437
- C3438
- C3439
- C3440
- C3441
- C3442
- C3443
- C3444
- C3445
- C3446
- C3471
- C3472
- C3473
- C3474
- C3475
- C3476
- C3477
- C3478
- C3479
- C3486
- C3494
- C3497
helpviewer_keywords:
- C3401
- C3402
- C3403
- C3404
- C3405
- C3406
- C3407
- C3410
- C3411
- C3416
- C3419
- C3422
- C3424
- C3425
- C3426
- C3427
- C3428
- C3429
- C3430
- C3431
- C3432
- C3433
- C3434
- C3435
- C3436
- C3437
- C3438
- C3439
- C3440
- C3441
- C3442
- C3443
- C3444
- C3445
- C3446
- C3471
- C3472
- C3473
- C3474
- C3475
- C3476
- C3477
- C3478
- C3479
- C3486
- C3494
- C3497
ms.assetid: a5651dfb-c402-4e01-b3ae-28f371e51d6a
ms.openlocfilehash: 587b28cedb0ab8b11c244be4278c7dc17d1f4247
ms.sourcegitcommit: 283cb64fd7958a6b7fbf0cd8534de99ac8d408eb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/28/2019
ms.locfileid: "64857377"
---
# <a name="compiler-errors-c3400-through-c3499"></a>Compilerfehler C3400 bis C3499

Die Artikel in diesem Abschnitt der Dokumentation wird erläutert, eine Teilmenge der Fehlermeldungen, die vom Compiler generiert werden.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Fehlermeldungen

|Fehler|Meldung|
|-----------|-------------|
|[Compilerfehler C3400](compiler-error-c3400.md)|Zirkuläre Einschränkung Abhängigkeit mit "*einschränkung1*'und'*einschränkung2*"|
|Compilerfehler C3401|"*Spezifizierer*': Ungültiger Assembler-Zugriffsspezifizierer - nur"private"ist zulässig, für Klassenvorlagen|
|Compilerfehler C3402|"*Funktion*": Überladung im aktuellen Bereich kann nicht aufgelöst werden.|
|Compilerfehler C3403|Thread_local kann nicht verwendet werden, mit/clr: pure oder/clr: safe|
|Compilerfehler C3404|"*erstellen*": Unerwarteter Syntaxfehler|
|Compilerfehler C3405|"*Funktion*": Überladung ohne vollständigen Deskriptor kann nicht aufgelöst werden.|
|Compilerfehler C3406|"*Schlüsselwort*': in ausführlichen Typbezeichnern nicht verwendet werden|
|Compilerfehler C3407|"*Typ*' kann nicht in diesem Kontext nicht verwendet werden|
|[Compilerfehler C3408](compiler-error-c3408.md)|"*Attribut*": Attribut ist für Vorlagendefinitionen nicht zulässig.|
|[Compilerfehler C3409](compiler-error-c3409.md)|ein leerer Attributblock ist nicht zulässig.|
|Compilerfehler C3410|"*Bezeichner*': der Typ der expliziten Instanziierung"*Typ*"entspricht nicht dem Typ der variablenvorlage"*Typ*"|
|Compilerfehler C3411|"*Typ*' ist nicht als die Größe eines Arrays ungültig, da es sich nicht um ein ganzzahliger Typ ist|
|[Compilerfehler C3412 generiert](compiler-error-c3412.md)|"*Spezialisierung*": Vorlage im aktuellen Bereich kann nicht spezialisiert|
|[Compilerfehler C3413](compiler-error-c3413.md)|"*Vorlage*': Ungültige explizite Instanziierung|
|[Compilerfehler C3414 generiert](compiler-error-c3414.md)|"*Funktion*': importierte Memberfunktion kann nicht definiert werden|
|[Compilerfehler C3415](compiler-error-c3415.md)|mehrere '*Abschnitt*' Abschnitte mit unterschiedlichen Attributen gefunden ("0 X*Wert*")|
|Compilerfehler C3416|Veraltet.|
|[Compilerfehler C3417](compiler-error-c3417.md)|"*Deklarator*": Werttypen können keine benutzerdefinierten speziellen Memberfunktionen enthalten|
|[Compilerfehler C3418](compiler-error-c3418.md)|Zugriffsspezifizierer '*Spezifizierer*"wird nicht unterstützt|
|Compilerfehler C3419|Veraltet.|
|[Compilerfehler C3420](compiler-error-c3420.md)|"*Funktion*": ein Finalizer kann nicht virtuell sein|
|[Compilerfehler C3421](compiler-error-c3421.md)|"*Funktion*': Sie können den Finalizer für diese Klasse nicht aufrufen, da es entweder ist nicht zugegriffen werden kann oder nicht vorhanden|
|Compilerfehler C3422|"*Deklaration*': nicht übereinstimmende Typen*Typ*'und'*Typ*"|
|Compilerfehler C3423|Veraltet.|
|Compilerfehler C3424|"*Typ*': eine Umwandlung im Funktionsstil in einen Arraytyp ist nicht zulässig.|
|Compilerfehler C3425|Zeiger kann nicht ausgelöst werden, um das Objekt des unvollständigen Typs "*Typ*"|
|Compilerfehler C3426|Objekt des unvollständigen Typs kann nicht ausgelöst werden kann '*Typ*"|
|Compilerfehler C3427|"*Kontext*': '*Schlüsselwort*' kann nicht verwendet werden, mit Layout_version (*Anzahl*)|
|Compilerfehler C3428|"*Kontext*': '*Schlüsselwort*' kann nur auf Klassendeklarationen oder Definitionen angewendet werden|
|Compilerfehler C3429|"*Kontext*': '*Schlüsselwort*' kann nicht auf eine Union angewendet werden|
|Compilerfehler C3430|eine Bereichsbezogene Enumeration muss einen Namen haben.|
|Compilerfehler C3431|"*Bezeichner*': *type1* nicht erneut deklariert werden, als *Typ2*|
|Compilerfehler C3432|"*Bezeichner*': eine Vorwärtsdeklaration einer Enumeration ohne bereichseinschränkung müssen einen zugrunde liegenden Typ|
|Compilerfehler C3433|"*Bezeichner*": alle Deklarationen einer Enumeration müssen den gleichen zugrunde liegenden Typ, wurde "*type1*"jetzt"*Typ2*"|
|Compilerfehler C3434|"*Kontext*': Enumeratorwert"*Anzahl*"kann nicht als dargestellt werden"*Typ*', Wert ist'*Anzahl*"|
|Compilerfehler C3435|Zeichensatz "*Namen*" wird nicht unterstützt|
|Compilerfehler C3436|#pragma Setlocale wird nicht unterstützt, wenn/Source-Charset "," / Execution-CharSet, oder "/utf-8 angegeben wurde.|
|Compilerfehler C3437|#pragma Execution_character_set wird nicht unterstützt, wenn/Source-Charset "," / Execution-CharSet, oder "/utf-8 angegeben wurde.|
|Compilerfehler C3438|"*Kontext*': '*Wert*' kann nicht angewendet werden, um eine verwaltete/WinRT-Klasse|
|Compilerfehler C3439|Layout_version (*Anzahl*): Ungültige Versionsnummer|
|Compilerfehler C3440|"*Deklaration*': Layout_version (*Anzahl*) mit einer vorherigen Deklaration nicht kompatibel.|
|Compilerfehler C3441|"*Deklaration*': '*Schlüsselwort*' kann nicht angewendet werden, nachdem die Klasse definiert wurde|
|Compilerfehler C3442|Mehrere Member der Union initialisiert: "*member1*'und'*member2*"|
|Compilerfehler C3443|Der standardmemberinitialisierer für "*Klasse*' ist rekursiv|
|Compilerfehler C3444|Leere Aggregatklasse*Klasse*"muss mit initialisiert werden"{}"|
|[Compilerfehler C3445](compiler-error-c3445.md)|Copy-List-Initialisierung von "*Typ*' können keine expliziten Konstruktor|
|[Compilerfehler C3446](compiler-error-c3446.md)|"*Klasse*": ein standardmemberinitialisierer ist für einen Member einer Wertklasse unzulässig|
|Compilerfehler C3447|Veraltet.|
|Compilerfehler C3448|Veraltet.|
|Compilerfehler C3449|Veraltet.|
|[Compilerfehler C3450](compiler-error-c3450.md)|"*Typ*': kein Attribut; nicht angeben [System:: AttributeUsageAttribute] / [Windows::Foundation::Metadata::AttributeUsageAttribute]|
|[Compilerfehler C3451](compiler-error-c3451.md)|"*Attribut*': nicht verwaltetes Attribut kann nicht angewendet werden kann '*Typ*"|
|[Compilerfehler C3452](compiler-error-c3452.md)|Der Listenargumentmember ist keine Konstante.|
|[Compilerfehler C3453](compiler-error-c3453.md)|"*Attribut*": Attribut wurde nicht angewendet werden, da Qualifizierer '*Qualifizierer*"stimmte nicht überein|
|[Compilerfehler C3454](compiler-error-c3454.md)|[attribut] ist in der Klassendeklaration nicht zulässig|
|[Compilerfehler C3455](compiler-error-c3455.md)|"*Attribut*': keiner der Attributkonstruktoren stimmte mit den Argumenten überein|
|[Compilerfehler C3456](compiler-error-c3456.md)|[Source\_Annotation_attribute] für verwaltete/WinRT-Klassendeklaration unzulässig|
|[Compilerfehler C3457](compiler-error-c3457.md)|"*Attribut*": Attribut unterstützt keine unbenannten Argumente|
|[Compilerfehler C3458](compiler-error-c3458.md)|"[*Attribut*]": Attribut ' [*Attribut*] "bereits für die angegebene '*Bezeichner*"|
|[Compilerfehler C3459](compiler-error-c3459.md)|"[*Attribut*]": Attribut darf nur für den Klassenindexer (indizierte Standardeigenschaft)|
|[Compilerfehler C3460](compiler-error-c3460.md)|"*Typ*': nur ein benutzerdefinierten Typ kann weitergeleitet werden.|
|[Compilerfehler C3461](compiler-error-c3461.md)|"*Typ*': nur ein verwaltet/WinRT-Typ kann weitergeleitet werden.|
|[Compilerfehler C3462](compiler-error-c3462.md)|"*Typ*': nur ein importierter Typ kann weitergeleitet werden.|
|[Compilerfehler C3463](compiler-error-c3463.md)|"*Typ*': Typ ist im Attribut"Implements"nicht zulässig.|
|[Compilerfehler C3464](compiler-error-c3464.md)|"*Typ*" ein geschachtelter Typ kann nicht weitergeleitet werden.|
|[Compilerfehler C3465](compiler-error-c3465.md)|mit Typ '*Typ*"Sie müssen die Assembly verweisen"*Assembly*"|
|[Compilerfehler C3466](compiler-error-c3466.md)|"*Typ*': eine Spezialisierung einer generischen Klasse kann nicht weitergeleitet werden.|
|[Compilerfehler C3467](compiler-error-c3467.md)|"*Typ*': Dieser Typ wurde bereits weitergeleitet|
|[Compilerfehler C3468](compiler-error-c3468.md)|"*Typ*': Sie können nur einen Typ in einer Assembly weiterleiten:"*Bezeichner*' ist keine Assembly.|
|[Compilerfehler C3469](compiler-error-c3469.md)|"*Typ*': eine generische Klasse kann nicht weitergeleitet werden.|
|[Compilerfehler C3470](compiler-error-c3470.md)|"*Klasse*': eine Klasse keine gleichzeitig einen Indexer (indizierte Standardeigenschaft) und einen []-Operator|
|Compilerfehler C3471|neue Modulname *Namen* (für die Befehlszeile festgelegt) steht in Konflikt mit dem vorherigen Namen *Name*|
|Compilerfehler C3472|neue Ausgabedateiname *Filename* (für die Befehlszeile festgelegt) steht in Konflikt mit vorheriger Dateiname *Dateiname*|
|Compilerfehler C3473|keine Ausgabe ausgabepfadname oder Modulname Protokollierungsname angegeben.|
|Compilerfehler C3474|Ausgabedatei konnte nicht geöffnet werden "*Filename*"|
|Compilerfehler C3475|Syntaxfehler in der Eingabedatei "*Filename*"|
|Compilerfehler C3476|Datei konnte nicht geöffnet "*Filename*" für die Eingabe|
|Compilerfehler C3477|ein Lambda-Ausdruck kann nicht in einem nicht ausgewerteten Kontext angezeigt werden.|
|Compilerfehler C3478|"*Bezeichner*": ein Array kann nicht nach Kopie erfasst werden|
|Compilerfehler C3479|SAL-Anmerkungen in Lambdas werden nicht unterstützt.|
|[Compilerfehler C3480](compiler-error-c3480.md)|"*Variable*': eine lambdaerfassungsvariable muss aus einem einschließenden Funktionsbereich|
|[Compilerfehler C3481](compiler-error-c3481.md)|"*Bezeichner*': lambdaerfassungsvariable wurde nicht gefunden.|
|[Compilerfehler Fehler C3482](compiler-error-c3482.md)|"this" kann nur als Lambdaerfassung innerhalb einer nicht statischen Memberfunktion verwendet werden.|
|[Compilerfehler C3483](compiler-error-c3483.md)|"*Bezeichner*' ist bereits Teil der lambdaerfassungsliste|
|[Compilerfehler C3484](compiler-error-c3484.md)|Syntaxfehler: "->" vor dem Rückgabetyp erwartet|
|[Compilerfehler c3485 erzeugt](compiler-error-c3485.md)|Eine Lambdadefinition kann keine CV-Qualifizierer aufweisen.|
|Compilerfehler C3486|Veraltet.|
|[Compilerfehler C3487](compiler-error-c3487.md)|"*Typ*": alle zurückgeben Rückgabeausdrücke müssen in denselben Typ hergeleitet werden: zuvor war es "*Typ*"|
|[Compilerfehler C3488](compiler-error-c3488.md)|' &*Bezeichner*' ist nicht zulässig, wenn der standarderfassungsmodus ein Modus nach Verweis ist.|
|[Compilerfehler C3489](compiler-error-c3489.md)|' &*Bezeichner*"ist erforderlich, wenn der standarderfassungsmodus ein Modus nach Kopie ist.|
|[Compilerfehler C3490](compiler-error-c3490.md)|"*Bezeichner*' kann nicht geändert werden, da sie über ein konstantenobjekt darauf zugegriffen wird|
|[Compilerfehler C3491](compiler-error-c3491.md)|"*Bezeichner*': eine über das Kopieren von Capture in einem nicht änderbaren Lambda nicht geändert werden|
|[Compilerfehler C3492](compiler-error-c3492.md)|"*Bezeichner*": ein Member einer anonymen Union kann nicht erfasst|
|[Compilerfehler C3493](compiler-error-c3493.md)|"*Bezeichner*' kann nicht implizit erfasst werden, da kein standarderfassungsmodus angegeben wurde|
|Compilerfehler C3494|"this" kann nicht explizit erfasst werden, da ein umschließender Erfassungsmodus dies nicht zulässt|
|[Compilerfehler C3495](compiler-error-c3495.md)|"*Bezeichner*": Bezeichner bei der Erfassung muss eine Variable mit automatischer Speicherdauer im Lambda-Gültigkeitsbereich deklariert werden|
|[Compilerfehler C3496](compiler-error-c3496.md)|"this" wird immer nach Wert erfasst: "&" wird ignoriert.|
|Compilerfehler c3497 generiert|eine Instanz eines Lambda-Ausdrucks kann nicht erstellt werden.|
|[Compilerfehler C3498](compiler-error-c3498.md)|"*Bezeichner*': eine Variable, deren verwaltet/WinRT-Typ kann nicht erfasst|
|[Compilerfehler C3499](compiler-error-c3499.md)|Ein Lambda, für das ein Void-Rückgabetyp angegeben wurde, kann keinen Wert zurückgeben.|

## <a name="see-also"></a>Siehe auch

[C /C++ Compiler- und Build tools, Fehler und Warnungen](../compiler-errors-1/c-cpp-build-errors.md) \
[Compilerfehler C2000 - C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
