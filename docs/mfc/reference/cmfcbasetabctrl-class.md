---
title: CMFCBaseTabCtrl Class
ms.date: 11/04/2016
f1_keywords:
- CMFCBaseTabCtrl
- AFXBASETABCTRL/CMFCBaseTabCtrl
- AFXBASETABCTRL/CMFCBaseTabCtrl::AddIcon
- AFXBASETABCTRL/CMFCBaseTabCtrl::AddTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::ApplyRestoredTabInfo
- AFXBASETABCTRL/CMFCBaseTabCtrl::AutoDestroyWindow
- AFXBASETABCTRL/CMFCBaseTabCtrl::CalcRectEdit
- AFXBASETABCTRL/CMFCBaseTabCtrl::CleanUp
- AFXBASETABCTRL/CMFCBaseTabCtrl::ClearImageList
- AFXBASETABCTRL/CMFCBaseTabCtrl::DetachTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::EnableActivateLastActive
- AFXBASETABCTRL/CMFCBaseTabCtrl::EnableAutoColor
- AFXBASETABCTRL/CMFCBaseTabCtrl::EnableCustomToolTips
- AFXBASETABCTRL/CMFCBaseTabCtrl::EnableInPlaceEdit
- AFXBASETABCTRL/CMFCBaseTabCtrl::EnableTabDetach
- AFXBASETABCTRL/CMFCBaseTabCtrl::EnableTabSwap
- AFXBASETABCTRL/CMFCBaseTabCtrl::EnsureVisible
- AFXBASETABCTRL/CMFCBaseTabCtrl::EnterDragMode
- AFXBASETABCTRL/CMFCBaseTabCtrl::FindTargetWnd
- AFXBASETABCTRL/CMFCBaseTabCtrl::FireChangeActiveTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::FireChangingActiveTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetActiveTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetActiveTabColor
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetActiveTabTextColor
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetActiveWnd
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetAutoColors
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetFirstVisibleTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetFirstVisibleTabNum
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetHighlightedTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetImageList
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetImageSize
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetLastVisibleTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetLocation
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetMaxWindowSize
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabArea
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabBkColor
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabBorderSize
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabByID
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabCloseButton
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabFromHwnd
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabFromPoint
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabFullWidth
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabHicon
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabID
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabIcon
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabLabel
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabRect
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabsHeight
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabsRect
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabTextColor
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabWnd
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabWndNoWrapper
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetTabsNum
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetToolTipCtrl
- AFXBASETABCTRL/CMFCBaseTabCtrl::GetVisibleTabsNum
- AFXBASETABCTRL/CMFCBaseTabCtrl::HasImage
- AFXBASETABCTRL/CMFCBaseTabCtrl::HideSingleTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::InsertTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::InvalidateTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsActiveTabCloseButton
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsAutoColor
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsAutoDestroyWindow
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsColored
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsDialogControl
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsDrawNoPrefix
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsFlatFrame
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsFlatTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsHideSingleTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsIconAdded
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsInPlaceEdit
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsLeftRightRounded
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsMDITab
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsOneNoteStyle
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsPtInTabArea
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsTabCloseButtonHighlighted
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsTabCloseButtonPressed
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsTabDetachable
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsTabIconOnly
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsTabSwapEnabled
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsTabVisible
- AFXBASETABCTRL/CMFCBaseTabCtrl::IsVS2005Style
- AFXBASETABCTRL/CMFCBaseTabCtrl::MoveTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::OnChangeTabs
- AFXBASETABCTRL/CMFCBaseTabCtrl::OnDragEnter
- AFXBASETABCTRL/CMFCBaseTabCtrl::OnDragLeave
- AFXBASETABCTRL/CMFCBaseTabCtrl::OnDragOver
- AFXBASETABCTRL/CMFCBaseTabCtrl::OnDrop
- AFXBASETABCTRL/CMFCBaseTabCtrl::OnRenameTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::PreTranslateMessage
- AFXBASETABCTRL/CMFCBaseTabCtrl::RecalcLayout
- AFXBASETABCTRL/CMFCBaseTabCtrl::RemoveAllTabs
- AFXBASETABCTRL/CMFCBaseTabCtrl::RemoveTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::RenameTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::ResetImageList
- AFXBASETABCTRL/CMFCBaseTabCtrl::Serialize
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetActiveTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetActiveTabColor
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetActiveTabTextColor
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetAutoColors
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetDockingBarWrapperRTC
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetDrawNoPrefix
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetImageList
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetLocation
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetTabBkColor
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetTabBorderSize
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetTabHicon
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetTabIcon
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetTabIconOnly
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetTabLabel
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetTabsHeight
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetTabTextColor
- AFXBASETABCTRL/CMFCBaseTabCtrl::SetTabsOrder
- AFXBASETABCTRL/CMFCBaseTabCtrl::ShowTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::StartRenameTab
- AFXBASETABCTRL/CMFCBaseTabCtrl::SwapTabs
- AFXBASETABCTRL/CMFCBaseTabCtrl::CreateWrapper
- AFXBASETABCTRL/CMFCBaseTabCtrl::m_bActivateTabOnRightClick
- AFXBASETABCTRL/CMFCBaseTabCtrl::m_bAutoDestroyWindow
helpviewer_keywords:
- CMFCBaseTabCtrl [MFC], AddIcon
- CMFCBaseTabCtrl [MFC], AddTab
- CMFCBaseTabCtrl [MFC], ApplyRestoredTabInfo
- CMFCBaseTabCtrl [MFC], AutoDestroyWindow
- CMFCBaseTabCtrl [MFC], CalcRectEdit
- CMFCBaseTabCtrl [MFC], CleanUp
- CMFCBaseTabCtrl [MFC], ClearImageList
- CMFCBaseTabCtrl [MFC], DetachTab
- CMFCBaseTabCtrl [MFC], EnableActivateLastActive
- CMFCBaseTabCtrl [MFC], EnableAutoColor
- CMFCBaseTabCtrl [MFC], EnableCustomToolTips
- CMFCBaseTabCtrl [MFC], EnableInPlaceEdit
- CMFCBaseTabCtrl [MFC], EnableTabDetach
- CMFCBaseTabCtrl [MFC], EnableTabSwap
- CMFCBaseTabCtrl [MFC], EnsureVisible
- CMFCBaseTabCtrl [MFC], EnterDragMode
- CMFCBaseTabCtrl [MFC], FindTargetWnd
- CMFCBaseTabCtrl [MFC], FireChangeActiveTab
- CMFCBaseTabCtrl [MFC], FireChangingActiveTab
- CMFCBaseTabCtrl [MFC], GetActiveTab
- CMFCBaseTabCtrl [MFC], GetActiveTabColor
- CMFCBaseTabCtrl [MFC], GetActiveTabTextColor
- CMFCBaseTabCtrl [MFC], GetActiveWnd
- CMFCBaseTabCtrl [MFC], GetAutoColors
- CMFCBaseTabCtrl [MFC], GetFirstVisibleTab
- CMFCBaseTabCtrl [MFC], GetFirstVisibleTabNum
- CMFCBaseTabCtrl [MFC], GetHighlightedTab
- CMFCBaseTabCtrl [MFC], GetImageList
- CMFCBaseTabCtrl [MFC], GetImageSize
- CMFCBaseTabCtrl [MFC], GetLastVisibleTab
- CMFCBaseTabCtrl [MFC], GetLocation
- CMFCBaseTabCtrl [MFC], GetMaxWindowSize
- CMFCBaseTabCtrl [MFC], GetTabArea
- CMFCBaseTabCtrl [MFC], GetTabBkColor
- CMFCBaseTabCtrl [MFC], GetTabBorderSize
- CMFCBaseTabCtrl [MFC], GetTabByID
- CMFCBaseTabCtrl [MFC], GetTabCloseButton
- CMFCBaseTabCtrl [MFC], GetTabFromHwnd
- CMFCBaseTabCtrl [MFC], GetTabFromPoint
- CMFCBaseTabCtrl [MFC], GetTabFullWidth
- CMFCBaseTabCtrl [MFC], GetTabHicon
- CMFCBaseTabCtrl [MFC], GetTabID
- CMFCBaseTabCtrl [MFC], GetTabIcon
- CMFCBaseTabCtrl [MFC], GetTabLabel
- CMFCBaseTabCtrl [MFC], GetTabRect
- CMFCBaseTabCtrl [MFC], GetTabsHeight
- CMFCBaseTabCtrl [MFC], GetTabsRect
- CMFCBaseTabCtrl [MFC], GetTabTextColor
- CMFCBaseTabCtrl [MFC], GetTabWnd
- CMFCBaseTabCtrl [MFC], GetTabWndNoWrapper
- CMFCBaseTabCtrl [MFC], GetTabsNum
- CMFCBaseTabCtrl [MFC], GetToolTipCtrl
- CMFCBaseTabCtrl [MFC], GetVisibleTabsNum
- CMFCBaseTabCtrl [MFC], HasImage
- CMFCBaseTabCtrl [MFC], HideSingleTab
- CMFCBaseTabCtrl [MFC], InsertTab
- CMFCBaseTabCtrl [MFC], InvalidateTab
- CMFCBaseTabCtrl [MFC], IsActiveTabCloseButton
- CMFCBaseTabCtrl [MFC], IsAutoColor
- CMFCBaseTabCtrl [MFC], IsAutoDestroyWindow
- CMFCBaseTabCtrl [MFC], IsColored
- CMFCBaseTabCtrl [MFC], IsDialogControl
- CMFCBaseTabCtrl [MFC], IsDrawNoPrefix
- CMFCBaseTabCtrl [MFC], IsFlatFrame
- CMFCBaseTabCtrl [MFC], IsFlatTab
- CMFCBaseTabCtrl [MFC], IsHideSingleTab
- CMFCBaseTabCtrl [MFC], IsIconAdded
- CMFCBaseTabCtrl [MFC], IsInPlaceEdit
- CMFCBaseTabCtrl [MFC], IsLeftRightRounded
- CMFCBaseTabCtrl [MFC], IsMDITab
- CMFCBaseTabCtrl [MFC], IsOneNoteStyle
- CMFCBaseTabCtrl [MFC], IsPtInTabArea
- CMFCBaseTabCtrl [MFC], IsTabCloseButtonHighlighted
- CMFCBaseTabCtrl [MFC], IsTabCloseButtonPressed
- CMFCBaseTabCtrl [MFC], IsTabDetachable
- CMFCBaseTabCtrl [MFC], IsTabIconOnly
- CMFCBaseTabCtrl [MFC], IsTabSwapEnabled
- CMFCBaseTabCtrl [MFC], IsTabVisible
- CMFCBaseTabCtrl [MFC], IsVS2005Style
- CMFCBaseTabCtrl [MFC], MoveTab
- CMFCBaseTabCtrl [MFC], OnChangeTabs
- CMFCBaseTabCtrl [MFC], OnDragEnter
- CMFCBaseTabCtrl [MFC], OnDragLeave
- CMFCBaseTabCtrl [MFC], OnDragOver
- CMFCBaseTabCtrl [MFC], OnDrop
- CMFCBaseTabCtrl [MFC], OnRenameTab
- CMFCBaseTabCtrl [MFC], PreTranslateMessage
- CMFCBaseTabCtrl [MFC], RecalcLayout
- CMFCBaseTabCtrl [MFC], RemoveAllTabs
- CMFCBaseTabCtrl [MFC], RemoveTab
- CMFCBaseTabCtrl [MFC], RenameTab
- CMFCBaseTabCtrl [MFC], ResetImageList
- CMFCBaseTabCtrl [MFC], Serialize
- CMFCBaseTabCtrl [MFC], SetActiveTab
- CMFCBaseTabCtrl [MFC], SetActiveTabColor
- CMFCBaseTabCtrl [MFC], SetActiveTabTextColor
- CMFCBaseTabCtrl [MFC], SetAutoColors
- CMFCBaseTabCtrl [MFC], SetDockingBarWrapperRTC
- CMFCBaseTabCtrl [MFC], SetDrawNoPrefix
- CMFCBaseTabCtrl [MFC], SetImageList
- CMFCBaseTabCtrl [MFC], SetLocation
- CMFCBaseTabCtrl [MFC], SetTabBkColor
- CMFCBaseTabCtrl [MFC], SetTabBorderSize
- CMFCBaseTabCtrl [MFC], SetTabHicon
- CMFCBaseTabCtrl [MFC], SetTabIcon
- CMFCBaseTabCtrl [MFC], SetTabIconOnly
- CMFCBaseTabCtrl [MFC], SetTabLabel
- CMFCBaseTabCtrl [MFC], SetTabsHeight
- CMFCBaseTabCtrl [MFC], SetTabTextColor
- CMFCBaseTabCtrl [MFC], SetTabsOrder
- CMFCBaseTabCtrl [MFC], ShowTab
- CMFCBaseTabCtrl [MFC], StartRenameTab
- CMFCBaseTabCtrl [MFC], SwapTabs
- CMFCBaseTabCtrl [MFC], CreateWrapper
- CMFCBaseTabCtrl [MFC], m_bActivateTabOnRightClick
- CMFCBaseTabCtrl [MFC], m_bAutoDestroyWindow
ms.assetid: 7270c55f-6f6e-4dd2-b0d2-291afeac3882
ms.openlocfilehash: 8a1637c77c326ddcfcb7f4dcb834ab6f6b2c0cf1
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/15/2019
ms.locfileid: "69505452"
---
# <a name="cmfcbasetabctrl-class"></a>CMFCBaseTabCtrl Class

Implementiert die Basisfunktionalität für Fenster im Registerkartenformat.
Weitere Informationen finden Sie im Quellcode, der sich im **Ordner\\VC atlmfc\\\\src MFC** Ihrer Visual Studio-Installation befindet.

## <a name="syntax"></a>Syntax

```
class CMFCBaseTabCtrl : public CWnd
```

## <a name="members"></a>Member

### <a name="public-methods"></a>Öffentliche Methoden

|Name|Beschreibung|
|----------|-----------------|
|[CMFCBaseTabCtrl::AddIcon](#addicon)||
|[CMFCBaseTabCtrl::AddTab](#addtab)|Fügt eine neue Registerkarte dem Fenster im Registerkartenformat hinzu.|
|[CMFCBaseTabCtrl::ApplyRestoredTabInfo](#applyrestoredtabinfo)||
|[CMFCBaseTabCtrl::AutoDestroyWindow](#autodestroywindow)||
|[CMFCBaseTabCtrl::CalcRectEdit](#calcrectedit)||
|[CMFCBaseTabCtrl::CleanUp](#cleanup)||
|[CMFCBaseTabCtrl::ClearImageList](#clearimagelist)||
|[CMFCBaseTabCtrl::DetachTab](#detachtab)|Trennt eine Registerkarte von einem Fenster im Registerkartenformat.|
|[CMFCBaseTabCtrl::EnableActivateLastActive](#enableactivatelastactive)||
|[CMFCBaseTabCtrl::EnableAutoColor](#enableautocolor)|Aktiviert oder deaktiviert die automatische Registerkartenfärbung.|
|[CMFCBaseTabCtrl::EnableCustomToolTips](#enablecustomtooltips)|Aktiviert oder deaktiviert benutzerdefinierte  QuickInfos für Registerkarten.|
|[CMFCBaseTabCtrl::EnableInPlaceEdit](#enableinplaceedit)|Aktiviert oder deaktiviert die direkte Bearbeitung von Registerkartenbezeichnungen.|
|[CMFCBaseTabCtrl::EnableTabDetach](#enabletabdetach)|Aktiviert lösbare Registerkarten.|
|[CMFCBaseTabCtrl::EnableTabSwap](#enabletabswap)|Aktiviert oder deaktiviert die Option, mit der der Benutzer die Registerkartenreihenfolge mit der Maus ändern kann.|
|[CMFCBaseTabCtrl::EnsureVisible](#ensurevisible)|Scrollt durch die Registerkarten, bis die angegebene Registerkarte eingeblendet wird. Diese Methode hat keine Auswirkungen, wenn die angegebene Registerkarte bereits eingeblendet wird.|
|[CMFCBaseTabCtrl::EnterDragMode](#enterdragmode)||
|[CMFCBaseTabCtrl::FindTargetWnd](#findtargetwnd)|Gibt einen Bereich zurück, der einen angegebenen Punkt enthält.|
|[CMFCBaseTabCtrl::FireChangeActiveTab](#firechangeactivetab)||
|[CMFCBaseTabCtrl::FireChangingActiveTab](#firechangingactivetab)||
|[CMFCBaseTabCtrl::GetActiveTab](#getactivetab)|Gibt den Index der aktiven Registerkarte zurück.|
|[CMFCBaseTabCtrl::GetActiveTabColor](#getactivetabcolor)|Gibt die Hintergrundfarbe der aktiven Registerkarte zurück.|
|[CMFCBaseTabCtrl::GetActiveTabTextColor](#getactivetabtextcolor)|Gibt die Textfarbe der aktiven Registerkarte zurück.|
|[CMFCBaseTabCtrl::GetActiveWnd](#getactivewnd)|Gibt einen Zeiger auf die aktive Seite des Registerkarten-Steuerelements zurück.|
|[CMFCBaseTabCtrl::GetAutoColors](#getautocolors)|Gibt einen Verweis auf das Array von Farben zurück, das für die automatische Färbung verwendet wird.|
|[CMFCBaseTabCtrl::GetFirstVisibleTab](#getfirstvisibletab)|Gibt einen Zeiger auf die erste eingeblendete Registerkarte zurück.|
|[CMFCBaseTabCtrl::GetFirstVisibleTabNum](#getfirstvisibletabnum)||
|[CMFCBaseTabCtrl::GetHighlightedTab](#gethighlightedtab)|Gibt den Index der aktuell hervorgehobenen Registerkarte.|
|[CMFCBaseTabCtrl::GetImageList](#getimagelist)||
|[CMFCBaseTabCtrl::GetImageSize](#getimagesize)||
|[CMFCBaseTabCtrl::GetLastVisibleTab](#getlastvisibletab)||
|[CMFCBaseTabCtrl::GetLocation](#getlocation)|Gibt eine Variable vom Datentyp LOCATION zurück, der angibt, wo der Registerkartenbereich in Bezug auf das Registerkarten-Steuerelement positioniert ist. Beispielsweise oben oder unten.|
|[CMFCBaseTabCtrl::GetMaxWindowSize](#getmaxwindowsize)||
|[CMFCBaseTabCtrl::GetTabArea](#gettabarea)|Gibt die Größe und Position des Registerkartenbereichs im Fenster im Registerkartenformat zurück. Die Position des Registerkartenbereichs wird mithilfe von Koordinaten definiert.|
|[CMFCBaseTabCtrl::GetTabBkColor](#gettabbkcolor)|Gibt die Hintergrundfarbe der angegebenen Registerkarte zurück.|
|[CMFCBaseTabCtrl::GetTabBorderSize](#gettabbordersize)|Gibt die Größe der Registerkartenrahmen im Registerkarten-Steuerelement zurück.|
|[CMFCBaseTabCtrl::GetTabByID](#gettabbyid)|Gibt den Index der Registerkarte zurück, die durch eine angegebene ID bestimmt wird.|
|[CMFCBaseTabCtrl::GetTabCloseButton](#gettabclosebutton)||
|[CMFCBaseTabCtrl::GetTabFromHwnd](#gettabfromhwnd)|Gibt den Index einer Registerkarte zurück, die ein angegebenes HWND-Objekt enthält.|
|[CMFCBaseTabCtrl::GetTabFromPoint](#gettabfrompoint)|Gibt die Registerkarte zurück, die einen angegebenen Punkt enthält.|
|[CMFCBaseTabCtrl::GetTabFullWidth](#gettabfullwidth)||
|[CMFCBaseTabCtrl::GetTabHicon](#gettabhicon)|Gibt das Symbol zurück, das der angegebenen Registerkarte zugeordnet ist.|
|[CMFCBaseTabCtrl::GetTabID](#gettabid)|Gibt mit dem Index der Registerkarte die ID einer Registerkarte zurück.|
|[CMFCBaseTabCtrl::GetTabIcon](#gettabicon)|Gibt die Symbol-ID für eine angegebene Registerkarte zurück.|
|[CMFCBaseTabCtrl::GetTabLabel](#gettablabel)|Gibt den Text einer angegebene Registerkarte zurück.|
|[CMFCBaseTabCtrl::GetTabRect](#gettabrect)|Ruft die Größe und Position einer angegebenen Registerkarte ab.|
|[CMFCBaseTabCtrl::GetTabsHeight](#gettabsheight)||
|[CMFCBaseTabCtrl::GetTabsRect](#gettabsrect)||
|[CMFCBaseTabCtrl::GetTabTextColor](#gettabtextcolor)|Gibt die Textfarbe einer angegebenen Registerkarte zurück.|
|[CMFCBaseTabCtrl::GetTabWnd](#gettabwnd)|Gibt den Zeiger auf einen Bereich zurück, der sich auf einer angegebenen Registerkartenseite befindet.|
|[CMFCBaseTabCtrl::GetTabWndNoWrapper](#gettabwndnowrapper)|Gibt den direkten Zeiger auf ein Steuerelement zurück, das sich auf einer angegebenen Registerkartenseite befindet, auch wenn das Steuerelement über einen Wrapper verfügt.|
|[CMFCBaseTabCtrl::GetTabsNum](#gettabsnum)|Gibt die Anzahl der Registerkarten im Registerkarten-Steuerelement zurück.|
|[CMFCBaseTabCtrl::GetToolTipCtrl](#gettooltipctrl)|Gibt einen Verweis auf das QuickInfo-Steuerelement zurück, das dem `CMFCBaseTabCtrl` -Objekt zugeordnet ist.|
|[CMFCBaseTabCtrl::GetVisibleTabsNum](#getvisibletabsnum)|Gibt die Anzahl eingeblendeter Registerkarten zurück.|
|[CMFCBaseTabCtrl::HasImage](#hasimage)||
|[CMFCBaseTabCtrl::HideSingleTab](#hidesingletab)|Legt eine Option fest, mit der eine Fensterregisterkarte ausgeblendet wird. Dies geschieht jedoch nur, wenn das Fenster im Registerkartenformat nur über eine eingeblendete Registerkarte verfügt.|
|[CMFCBaseTabCtrl::InsertTab](#inserttab)|Fügt eine neue Registerkarte ein.|
|[CMFCBaseTabCtrl::InvalidateTab](#invalidatetab)||
|[CMFCBaseTabCtrl::IsActiveTabCloseButton](#isactivetabclosebutton)||
|[CMFCBaseTabCtrl::IsAutoColor](#isautocolor)|Gibt einen Wert zurück, der angibt, ob die automatische Färbung für das Fenster im Registerkartenformat aktiviert ist.|
|[CMFCBaseTabCtrl::IsAutoDestroyWindow](#isautodestroywindow)||
|[CMFCBaseTabCtrl::IsColored](#iscolored)||
|[CMFCBaseTabCtrl::IsDialogControl](#isdialogcontrol)||
|[CMFCBaseTabCtrl::IsDrawNoPrefix](#isdrawnoprefix)||
|[CMFCBaseTabCtrl::IsFlatFrame](#isflatframe)|Gibt einen Wert zurück, der angibt, ob der Rahmen für den Registerkartenbereich flach oder dreidimensional ist.|
|[CMFCBaseTabCtrl::IsFlatTab](#isflattab)||
|[CMFCBaseTabCtrl::IsHideSingleTab](#ishidesingletab)|Gibt einen Wert zurück, der angibt, ob das Registerkarten-Steuerelement zum Ausblenden einer Registerkarte konfiguriert ist. Dies ist jedoch nur dann der Fall, wenn ein Fenster im Registerkartenformat über nur eine eingeblendete Registerkarte verfügt.|
|[CMFCBaseTabCtrl::IsIconAdded](#isiconadded)||
|[CMFCBaseTabCtrl::IsInPlaceEdit](#isinplaceedit)|Gibt an, ob Benutzer die Bezeichnung auf einer Registerkarte ändern können.|
|[CMFCBaseTabCtrl::IsLeftRightRounded](#isleftrightrounded)||
|[CMFCBaseTabCtrl::IsMDITab](#ismditab)||
|[CMFCBaseTabCtrl::IsOneNoteStyle](#isonenotestyle)|Gibt an, ob die Registerkarten in einem Fenster im Registerkartenformat im Microsoft OneNote-Format angezeigt werden.|
|[CMFCBaseTabCtrl::IsPtInTabArea](#isptintabarea)|Überprüft, ob ein angegebener Punkt im Registerkartenbereich vorhanden ist.|
|[CMFCBaseTabCtrl::IsTabCloseButtonHighlighted](#istabclosebuttonhighlighted)||
|[CMFCBaseTabCtrl::IsTabCloseButtonPressed](#istabclosebuttonpressed)||
|[CMFCBaseTabCtrl::IsTabDetachable](#istabdetachable)|Gibt an, ob eine Registerkarte gelöst werden kann.|
|[CMFCBaseTabCtrl::IsTabIconOnly](#istabicononly)|Gibt an, ob Symbole, und keine Bezeichnungen, auf den Registerkarten angezeigt werden sollen.|
|[CMFCBaseTabCtrl::IsTabSwapEnabled](#istabswapenabled)|Gibt an, ob Benutzer durch Ziehen von Registerkarten ihre Position ändern können.|
|[CMFCBaseTabCtrl::IsTabVisible](#istabvisible)|Gibt an, ob eine angegebene Registerkarte eingeblendet wird.|
|[CMFCBaseTabCtrl::IsVS2005Style](#isvs2005style)||
|[CMFCBaseTabCtrl::MoveTab](#movetab)||
|[CMFCBaseTabCtrl::OnChangeTabs](#onchangetabs)|Vom Framework aufgerufen, wenn sich die Anzahl der Registerkarten ändert.|
|[CMFCBaseTabCtrl::OnDragEnter](#ondragenter)||
|[CMFCBaseTabCtrl::OnDragLeave](#ondragleave)||
|[CMFCBaseTabCtrl::OnDragOver](#ondragover)||
|[CMFCBaseTabCtrl::OnDrop](#ondrop)||
|[CMFCBaseTabCtrl::OnRenameTab](#onrenametab)||
|[CMFCBaseTabCtrl::PreTranslateMessage](#pretranslatemessage)|Wird von der [CWinApp](../../mfc/reference/cwinapp-class.md) -Klasse verwendet, um Fenstermeldungen zu übersetzen, bevor diese an die Windows-Funktionen [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) und [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) gesendet werden. (Überschreibt [CWnd::PreTranslateMessage](../../mfc/reference/cwnd-class.md#pretranslatemessage).)|
|[CMFCBaseTabCtrl::RecalcLayout](#recalclayout)|Berechnet das interne Layout eines Fensters im Registerkartenformat neu.|
|[CMFCBaseTabCtrl::RemoveAllTabs](#removealltabs)|Entfernt alle Registerkarten aus dem Fenster im Registerkartenformat.|
|[CMFCBaseTabCtrl::RemoveTab](#removetab)|Entfernt alle Registerkarten aus einem Fenster im Registerkartenformat.|
|[CMFCBaseTabCtrl::RenameTab](#renametab)||
|[CMFCBaseTabCtrl::ResetImageList](#resetimagelist)|Setzt die Bildliste zurück, die einem Fenster im Registerkartenformat angefügt ist.|
|[CMFCBaseTabCtrl::Serialize](#serialize)|Liest oder schreibt dieses Objekt aus einem oder in ein Archiv. (Überschreibt [CObject::Serialize](../../mfc/reference/cobject-class.md#serialize).)|
|[CMFCBaseTabCtrl::SetActiveTab](#setactivetab)|Aktiviert eine Registerkarte.|
|[CMFCBaseTabCtrl::SetActiveTabColor](#setactivetabcolor)|Legt die Hintergrundfarbe für die aktuelle aktive Registerkarte fest.|
|[CMFCBaseTabCtrl::SetActiveTabTextColor](#setactivetabtextcolor)|Legt die Textfarbe für aktive Registerkarten fest.|
|[CMFCBaseTabCtrl::SetAutoColors](#setautocolors)|Legt die anzuwendenden Farben für das Registerkarten-Steuerelement fest, wenn automatische Färbung aktiviert ist.|
|[CMFCBaseTabCtrl::SetDockingBarWrapperRTC](#setdockingbarwrapperrtc)|Legt die Wrapperklasse fest, die für nicht von der [CDockablePane Class](../../mfc/reference/cdockablepane-class.md)abgeleitete Objekte verwendet wird.|
|[CMFCBaseTabCtrl::SetDrawNoPrefix](#setdrawnoprefix)|Aktiviert und deaktiviert die Verarbeitung von Präfixzeichen, wenn die Registerkartenbezeichnungen gezeichnet werden.|
|[CMFCBaseTabCtrl::SetImageList](#setimagelist)|Legt die Symbolbildliste fest.|
|[CMFCBaseTabCtrl::SetLocation](#setlocation)||
|[CMFCBaseTabCtrl::SetTabBkColor](#settabbkcolor)|Legt die Hintergrundfarbe für eine angegebene Registerkarte fest.|
|[CMFCBaseTabCtrl::SetTabBorderSize](#settabbordersize)|Legt die Größe für einen neuen Registerkartenrahmen fest.|
|[CMFCBaseTabCtrl::SetTabHicon](#settabhicon)|Legt ein Registerkartensymbol fest.|
|[CMFCBaseTabCtrl::SetTabIcon](#settabicon)|Legt eine Registerkartensymbol-ID fest.|
|[CMFCBaseTabCtrl::SetTabIconOnly](#settabicononly)|Aktiviert und deaktiviert den „Nur Symbol“-Modus für eine angegebene Registerkarte.|
|[CMFCBaseTabCtrl::SetTabLabel](#settablabel)|Legt eine Registerkartenbezeichnung auf einen angegebenen Zeichenfolgenwert fest.|
|[CMFCBaseTabCtrl::SetTabsHeight](#settabsheight)||
|[CMFCBaseTabCtrl::SetTabTextColor](#settabtextcolor)|Legt die Textfarbe für eine angegebene Registerkarte fest.|
|[CMFCBaseTabCtrl::SetTabsOrder](#settabsorder)|Ordnet die Registerkarten in der angegebenen Reihenfolge an.|
|[CMFCBaseTabCtrl::ShowTab](#showtab)|Blendet die angegebene Registerkarte ein oder aus.|
|[CMFCBaseTabCtrl::StartRenameTab](#startrenametab)||
|[CMFCBaseTabCtrl::SwapTabs](#swaptabs)||

### <a name="protected-methods"></a>Geschützte Methoden

|Name|Beschreibung|
|----------|-----------------|
|[CMFCBaseTabCtrl::CreateWrapper](#createwrapper)|Erstellt einen Wrapper für ein von [CWnd](../../mfc/reference/cwnd-class.md) abgeleitetes Objekt, das nicht von `CDockablePane`abgeleitet ist. Um ein `CMFCBaseTabCtrl` -Objekt anzudocken, muss jedes eingebettete Steuerelement entweder über einen andockbaren Wrapper verfügen oder von `CDockablePane`abgeleitet sein.<br /><br /> Sie können mit `SetDockingBayWrapperRTC`die Klasse des Wrappers festlegen.|

### <a name="data-members"></a>Datenmember

|Name|Beschreibung|
|----------|-----------------|
|[CMFCBaseTabCtrl::m_bActivateTabOnRightClick](#m_bactivatetabonrightclick)|Gibt an, ob Registerkarten durch Klicken mit der linken oder rechten Maustaste ausgewählt werden.|
|[CMFCBaseTabCtrl::m_bAutoDestroyWindow](#m_bautodestroywindow)|Gibt an, ob die Bereiche, die auf den Registerkarten enthalten sind, automatisch entfernt werden.|

## <a name="remarks"></a>Hinweise

Die `CMFCBaseTabCtrl` -Klasse stellt eine abstrakte Klasse dar. Daher kann sie nicht instanziiert werden. Um ein Fenster im Registerkartenformat zu erstellen, müssen die eine Klasse von `CMFCBaseTabCtrl`ableiten. Die MFC-Bibliothek enthält einige Beispiele zu abgeleiteten Klassen, zu denen [CMFCTabCtrl Class](../../mfc/reference/cmfctabctrl-class.md) und [CMFCOutlookBarTabCtrl Class](../../mfc/reference/cmfcoutlookbartabctrl-class.md)zählen.

Ab Visual Studio 2015 unterstützt diese Klasse Microsoft Active Accessibility.

## <a name="customization-tips"></a>Anpassungstipps

Die folgenden Tipps beziehen sich auf die `CMFCBaseTabCtrl Class` und alle Klassen, die von dieser erben:

- Behalten Sie keine Zeiger auf Fenster im Registerkartenformat, wenn lösbare Registerkarten aktiviert sind. Diese lösbaren Registerkarten können dynamisch erstellt und entfernt werden. Daher können Zeiger ungültig werden.

- Sie können das Registerkarten-Steuerelement so konfigurieren, dass Benutzer Registerkarten mit der Maus dynamisch auf ein Registerkarten-Steuerelement verschieben können. Diese Funktionalität ist in der `CMFCBaseTabCtrl` -Klasse integriert. Rufen Sie [CMFCBaseTabCtrl::EnableTabSwap](#enabletabswap)auf, um sie zu aktivieren.

- Registerkarten sind standardmäßig lösbar, wenn Sie sie zu einem Registerkarten-Steuerelement hinzufügen. Mit [CMFCBaseTabCtrl::AddTab](#addtab)können Sie auch nicht lösbare Registerkarten hinzufügen. Wenn Sie den `bDetachable` -Parameter auf `FALSE`festlegen, wird die Registerkarte zu einer nicht lösbaren Registerkarte. Sie können auch durch Aufrufen der [CMFCBaseTabCtrl::EnableTabDetach](#enabletabdetach)-Methode festlegen, ob die Registerkarte lösbar sein soll.

- Objekte, die von der [CWnd Class](../../mfc/reference/cwnd-class.md) abgeleitet werden, können auf einer andockbaren Symbolleiste oder Registerkarte platziert werden. Für das gesamte anzudockende Steuerelement muss das `CWnd` -Objekt andockbar sein. Hierzu verwendet MFC eine Wrapperklasse. Diese Wrapperklasse ist die [CDockablePaneAdapter Class](../../mfc/reference/cdockablepaneadapter-class.md). Alle `CWnd` -Objekte, die zu einer andockbaren Symbolleiste oder Registerkarte hinzugefügt werden, werden in ein `CDockablePaneAdapter` -Objekt eingebunden. Sie können den automatischen Umbruch deaktivieren, indem Sie den `m_bEnableWrapping` -Parameter des `CMFCBaseTablCtrl` -Objekts auf `FALSE`festlegen. Sie können auch die Klasse, die die Anwendung als Wrapper verwendet, mit der [CMFCBaseTabCtrl::SetDockingBarWrapperRTC](#setdockingbarwrapperrtc)-Methode ändern.

## <a name="inheritance-hierarchy"></a>Vererbungshierarchie

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWnd](../../mfc/reference/cwnd-class.md)

[CMFCBaseTabCtrl](../../mfc/reference/cmfcbasetabctrl-class.md)

## <a name="requirements"></a>Anforderungen

**Header:** afxbasetabctrl.h

##  <a name="addicon"></a>Cmfcbasetabctrl:: addicon

Fügt der Liste von Symbolen im geschützten `CMap m_mapAddedIcons` Member ein Symbol hinzu.

```
void AddIcon(
    HICON hIcon,
    int iIcon);
```

### <a name="parameters"></a>Parameter

*hIcon*<br/>
in Ein Handle für das hinzu zufügende Symbol.

*iIcon*<br/>
in NULL basierter Index des Symbols im geschützten `CImageList m_Images` Member.

### <a name="remarks"></a>Hinweise

##  <a name="addtab"></a>  CMFCBaseTabCtrl::AddTab

Fügt dem Registerkarten-Steuerelement eine neue Registerkarte hinzu.

```
virtual void AddTab(
    CWnd* pTabWnd,
    LPCTSTR lpszTabLabel,
    UINT uiImageId = (UINT)-1,,
    BOOL bDetachable = TRUE);

virtual void AddTab(
    CWnd* pTabWnd,
    UINT uiResTabLabel,
    UINT uiImageId = (UINT)-1,
    BOOL bDetachable = TRUE);
```

### <a name="parameters"></a>Parameter

*pTabWnd*<br/>
in Ein Zeiger auf das Fenster, das diese Methode als neue Registerkarte darstellt.

*lpszTabLabel*<br/>
in Eine Zeichenfolge, die die Bezeichnung für die neue Registerkarte enthält.

*uiImageId*<br/>
in Eine Image-ID aus der Bildliste. Das Registerkarten-Steuerelement verwendet dieses Bild als Symbol für die neue Registerkarte.

*uiResTabLabel*<br/>
in Die Ressourcen-ID für die Bezeichnung.

*bDetachable*<br/>
in Ein boolescher Parameter, der bestimmt, ob die neue Registerkarte getrennt werden kann.

### <a name="remarks"></a>Hinweise

Wenn *ptabwnd* auf ein Objekt verweist, das nicht von der [CDockablePane-Klasse](../../mfc/reference/cdockablepane-class.md) abgeleitet ist, und wenn *bdetachable* den Wert true hat, erstellt das Framework automatisch einen Wrapper für das *ptabwnd* -Objekt. Der Wrapper bewirkt, dass das *ptabwnd* -Objekt ablösbar ist. Standardmäßig ist der Wrapper eine Instanz der [cdockablepaneadapter-Klasse](../../mfc/reference/cdockablepaneadapter-class.md). Wenn die vom Standard Wrapper angebotene Funktionalität nicht akzeptabel ist, verwenden Sie die [cmfcbasetabctrl:: setdockingbarwrapperrtc](#setdockingbarwrapperrtc) -Methode, um einen anderen Wrapper anzugeben.

##  <a name="applyrestoredtabinfo"></a>Cmfcbasetabctrl:: applyrestoredtabinfo

```
virtual void ApplyRestoredTabInfo(BOOL bUseTabIndexes = FALSE);
```

### <a name="parameters"></a>Parameter

in " *buabtabindexes* "<br/>

### <a name="remarks"></a>Hinweise

##  <a name="autodestroywindow"></a>Cmfcbasetabctrl:: autodestroywindow

```
void AutoDestroyWindow(BOOL bAutoDestroy = TRUE);
```

### <a name="parameters"></a>Parameter

in *Bauto zerstören*<br/>

### <a name="remarks"></a>Hinweise

##  <a name="calcrectedit"></a>Cmfcbasetabctrl:: calcrectedit

```
virtual void CalcRectEdit(CRect& rectEdit);
```

### <a name="parameters"></a>Parameter

in *rectedit*<br/>

### <a name="remarks"></a>Hinweise

##  <a name="cleanup"></a>Cmfcbasetabctrl:: Cleanup

```
virtual void CleanUp();
```

### <a name="remarks"></a>Hinweise

##  <a name="clearimagelist"></a>Cmfcbasetabctrl:: clearimagelist

```
virtual void ClearImageList();
```

### <a name="remarks"></a>Hinweise

##  <a name="createwrapper"></a>Cmfcbasetabctrl:: kreatewrapper

Erstellt einen Wrapper für ein Rahmen Fenster, das von der [CWnd-Klasse](../../mfc/reference/cwnd-class.md) abgeleitet ist, aber nicht von der [CDockablePane-Klasse](../../mfc/reference/cdockablepane-class.md)abgeleitet ist.

```
virtual CWnd* CreateWrapper(
    CWnd* pWndToWrap,
    LPCTSTR lpszTabLabel,
    BOOL bDetachable);
```

### <a name="parameters"></a>Parameter

*pWndToWrap*<br/>
in Ein Zeiger auf das Rahmen Fenster, das umschließt wird.

*lpszTabLabel*<br/>
in Eine Zeichenfolge, die die Bezeichnung für das Fenster enthält.

*bDetachable*<br/>
in Ein boolescher Parameter, der angibt, ob das Fenster getrennt werden kann.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf einen Wrapper, der `CDockablePane` von der `CreateWrapper` -Klasse abgeleitet wird, wenn erfolgreich eine Wrapper Klasse für *pwndtowrap*erstellt. Wenn die Methode fehlschlägt, wird *pwndtowrap*zurückgesetzt.

### <a name="remarks"></a>Hinweise

Ein Fenster im Registerkarten Format kann alle von `CWnd`abgeleiteten Objekte andocken. Damit ein `CMFCBaseTabCtrl Class` -Objekt andockbarer ist, muss jedoch jedes Objekt in der `CMFCBaseTabCtrl` getrennt werden. Daher umschließt `CDockablePane`automatischalle-Objekte, die nicht von abgeleitet sind. `CMFCBaseTabCtrl`

Standardmäßig erstellt die `CMFCBaseTabCtrl` Instanzen der [cdockablepaneadapter-Klasse](../../mfc/reference/cdockablepaneadapter-class.md). Um die Standardklasse des Wrappers zu ändern, müssen Sie [cmfcbasetabctrl:: setdockingbarwrapperrtc](#setdockingbarwrapperrtc)aufrufen.

Wenn *pwndtowrap* von `CDockablePane`abgeleitet ist, erstellt diese Methode keinen Wrapper. Stattdessen schlägt Sie fehl und gibt *pwndtowrap*zurück.

##  <a name="detachtab"></a>Cmfcbasetabctrl::D etachtab

Das Framework ruft diese Methode auf, um eine Registerkarte vom Registerkarten-Steuerelement zu trennen.

```
virtual BOOL DetachTab(
    AFX_DOCK_METHOD dockMethod,
    int nTabNum = -1,
    BOOL bHide = FALSE);
```

### <a name="parameters"></a>Parameter

*dockmethod*<br/>
in Ein enumerierter Datentyp, der von der [cbasepane-Klasse](../../mfc/reference/cbasepane-class.md)bereitgestellt wird. Dieser Datentyp gibt die Methode an, die zum Trennen der Registerkarte verwendet wurde.

*nTabNum*<br/>
in Der null basierte Index der Registerkarte, die getrennt werden soll.

*bHide*<br/>
in Ein boolescher Parameter, der angibt, ob das Framework die getrennte Registerkarte ausblenden soll.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Hinweise

Wenn die von *ntabnum* angegebene Registerkarte nicht getrennt werden kann, schlägt diese Funktion fehl und gibt false zurück.

##  <a name="enableactivatelastactive"></a>Cmfcbasetabctrl:: enableactivatelastactive

```
void EnableActivateLastActive(BOOL bLastActive = TRUE);
```

### <a name="parameters"></a>Parameter

in *blastactive*<br/>

### <a name="remarks"></a>Hinweise

##  <a name="enableautocolor"></a>Cmfcbasetabctrl:: enableautocolor

Steuert, ob das Framework beim Zeichnen einer Registerkarte die automatischen Hintergrundfarben verwendet.

```
void EnableAutoColor(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>Parameter

*bEnable*<br/>
in Ein boolescher Parameter, der bestimmt, ob das Framework automatische Farben verwendet.

### <a name="remarks"></a>Hinweise

Ein Registerkarten-Steuerelement verfügt über ein Array mit mehreren vordefinierten Farben. Wenn das Framework automatische Farben verwendet, wird jeder Registerkarte in einer Reihe von Registerkarten die nächste Farbe aus diesem Array zugewiesen.

Standardmäßig werden die automatischen Farben durch die von der Bibliothek definierten Farben bestimmt. Sie können ein benutzerdefiniertes Array von Farben bereitstellen, indem Sie [cmfcbasetabctrl:: settautocolors](#setautocolors)aufrufen.

##  <a name="enablecustomtooltips"></a>Cmfcbasetabctrl:: enablecustomtooltips

Aktiviert benutzerdefinierte Quick Infos für das Registerkarten-Steuerelement.

```
BOOL EnableCustomToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>Parameter

*bEnable*<br/>
in Ein boolescher Wert, der bestimmt, ob benutzerdefinierte Quick Infos verwendet werden sollen.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Hinweise

Wenn benutzerdefinierte Quick Infos aktiviert sind, sendet das Registerkarten-Steuerelement die AFX_WM_ON_GET_TAB_TOOLTIP-Nachricht an den Hauptframe. Wenn Sie benutzerdefinierte Quick Infos in der Anwendung unterstützen möchten, muss das Hauptrahmen Fenster diese Methode verarbeiten und den benutzerdefinierten QuickInfo-Text bereitstellen. Weitere Informationen zum Bereitstellen von benutzerdefiniertem QuickInfo-Text finden Sie unter [cmfctabtooltipinfo-Struktur](../../mfc/reference/cmfctabtooltipinfo-structure.md).

##  <a name="enableinplaceedit"></a>Cmfcbasetabctrl:: enableinplaceedit

Ermöglicht die direkte Bearbeitung der Registerkarten Bezeichnungen durch den Benutzer.

```
virtual void EnableInPlaceEdit(BOOL bEnable) = 0;
```

### <a name="parameters"></a>Parameter

*bEnable*<br/>
in Ein boolescher Parameter, der angibt, ob die direkte Bearbeitung der Registerkarten Bezeichnungen aktiviert werden soll.

### <a name="remarks"></a>Hinweise

Standardmäßig ist die direkte Bearbeitung der Registerkarten Bezeichnungen für Registerkarten-Steuerelemente deaktiviert.

Sie können die direkte Bearbeitung für eine Teilmenge der Registerkarten des Registerkarten-Steuer Elements aktivieren. Überschreiben Sie dazu die-Methode `CMFCBaseTabCtrl::StartRenameTab`. `StartRenameTab`Gibt einen Wert ungleich 0 (null) für alle Registerkarten zurück, die die direkte Bearbeitung von Registerkarten Bezeichnungen unterstützen

`CMFCBaseTabCtrl Class`In ist diese Methode eine reine virtuelle Funktion und hat keine Implementierung. Wenn Sie eine Klasse von `CMFCBaseTabCtrl`ableiten, müssen Sie diese Funktion implementieren.

##  <a name="enabletabdetach"></a>  CMFCBaseTabCtrl::EnableTabDetach

Aktiviert lösbare Registerkarten.

```
virtual BOOL EnableTabDetach(
    int iTab,
    BOOL bEnable);
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index einer Registerkarte.

*bEnable*<br/>
in Ein boolescher Wert, der angibt, ob die Registerkarte getrennt werden soll.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

##  <a name="enabletabswap"></a>  CMFCBaseTabCtrl::EnableTabSwap

Ermöglicht dem Benutzer das Ändern der Aktivier Reihenfolge mit der Maus.

```
void EnableTabSwap(BOOL bEnable);
```

### <a name="parameters"></a>Parameter

*bEnable*<br/>
in Ein boolescher Wert, der angibt, ob das Austauschen von Registerkarten aktiviert werden soll.

### <a name="remarks"></a>Hinweise

Wenn das Austauschen von Registerkarten aktiviert ist, kann der Benutzer eine Registerkarte ziehen und seine relative Position im Registerkarten-Steuerelement ändern.

##  <a name="ensurevisible"></a>Cmfcbasetabctrl:: EnsureVisible

Scrollt durch die Registerkarten, bis die angegebene Registerkarte eingeblendet wird.

```
virtual BOOL EnsureVisible(int iTab);
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index einer Registerkarte.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Hinweise

Diese Methode hat keine Auswirkung, wenn die von *ITAB* angezeigte Registerkarte bereits sichtbar ist.

Standardmäßig wird diese Methode von `CMFCBaseTabCtrl Class`nicht unterstützt. Sie sollten diese Funktion in einer benutzerdefinierten Klasse implementieren, `CMFCBaseTabCtrl` die von abgeleitet wird, wenn das benutzerdefinierte Registerkarten-Steuerelement den Tab- Diese Methode wird von der [cmfctabctrl-Klasse](../../mfc/reference/cmfctabctrl-class.md)unterstützt.

##  <a name="enterdragmode"></a>Cmfcbasetabctrl:: enterdragmode

```
void EnterDragMode();
```

### <a name="remarks"></a>Hinweise

##  <a name="findtargetwnd"></a>Cmfcbasetabctrl:: findtargetwnd

Identifiziert den Bereich, der einen angegebenen Punkt enthält.

```
virtual CWnd* FindTargetWnd(const CPoint& pt) = 0;
```

### <a name="parameters"></a>Parameter

*pt*<br/>
in Ein Punkt, der mithilfe von Client Bereichs Koordinaten des [cmfcbasetabctrl](../../mfc/reference/cmfcbasetabctrl-class.md) -Objekts definiert wird.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf ein [CWnd](../../mfc/reference/cwnd-class.md) -Objekt, wenn erfolgreich. andernfalls NULL.

### <a name="remarks"></a>Hinweise

In der `CMFCBaseTabCtrl` -Klasse ist diese Methode eine reine virtuelle Funktion: Sie müssen Sie implementieren, wenn Sie eine Klasse von `CMFCBaseTabCtrl`ableiten.

##  <a name="firechangeactivetab"></a>Cmfcbasetabctrl:: firechangeactivetab

```
virtual void FireChangeActiveTab(int nNewTab);
```

### <a name="parameters"></a>Parameter

in *nnewtab*<br/>

### <a name="remarks"></a>Hinweise

##  <a name="firechangingactivetab"></a>Cmfcbasetabctrl:: firechangingactivetab

```
virtual BOOL FireChangingActiveTab(int nNewTab);
```

### <a name="parameters"></a>Parameter

in *nnewtab*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="getactivetab"></a>Cmfcbasetabctrl:: getactivetab

Ruft den Index der derzeit aktiven Registerkarte ab.

```
virtual int GetActiveTab() const;
```

### <a name="return-value"></a>Rückgabewert

Der null basierte Index der aktiven Registerkarte. -1, wenn keine aktive Registerkarte vorhanden ist.

##  <a name="getactivetabcolor"></a>Cmfcbasetabctrl:: getactivetabcolor

Ruft die Hintergrundfarbe der aktuell aktiven Registerkarte ab.

```
virtual COLORREF GetActiveTabColor() const;
```

### <a name="return-value"></a>Rückgabewert

Ein [COLORREF](/windows/win32/gdi/colorref) -Wert, der die Hintergrundfarbe der aktiven Registerkarte angibt.

### <a name="remarks"></a>Hinweise

Standardmäßig ist die Hintergrundfarbe der aktiven Registerkarte COLOR_WINDOW. Sie können die Hintergrundfarbe für die aktive Registerkarte ändern, indem Sie die [cmfcbasetabctrl:: setactivetabcolor](#setactivetabcolor)-Methode verwenden.

##  <a name="getactivetabtextcolor"></a>Cmfcbasetabctrl:: getactivetabtextcolor

Ruft die Textfarbe für die aktive Registerkarte ab.

```
virtual COLORREF GetActiveTabTextColor() const;
```

### <a name="return-value"></a>Rückgabewert

Ein [COLORREF](/windows/win32/gdi/colorref) -Wert, der die Textfarbe der aktiven Registerkarte angibt.

### <a name="remarks"></a>Hinweise

Standardmäßig ist die Textfarbe für aktive Registerkarten COLOR_WINDOWTEXT. Sie können die Textfarbe mit der [cmfcbasetabctrl::](#setactivetabtextcolor)-Methode ändern, indem Sie die-Methode ausführen.

##  <a name="getactivewnd"></a>Cmfcbasetabctrl:: getactivewnd

Ruft einen Zeiger auf das momentan aktive Registerkarten Fenster ab.

```
virtual CWnd* GetActiveWnd() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf ein Fenster.

##  <a name="getautocolors"></a>Cmfcbasetabctrl:: getautocolors

Ruft das Array von Farben ab, die für die automatische Farbgebung verwendet werden.

```
const CArray<COLORREF,COLORREF>& GetAutoColors() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Verweis auf ein Array von [COLORREF](/windows/win32/gdi/colorref) -Werten, die vom [cmfcbasetabctrl](../../mfc/reference/cmfcbasetabctrl-class.md) -Objekt für automatische Registerkarten Färbung verwendet werden.

### <a name="remarks"></a>Hinweise

Standardmäßig initialisiert das Framework das Array von Farben mit den von der Bibliothek definierten Farben. Sie können ein benutzerdefiniertes Array von Farben bereitstellen, indem Sie die-Methode [cmfcbasetabctrl:: settautocolors](#setautocolors)aufrufen.

##  <a name="getfirstvisibletab"></a>Cmfcbasetabctrl:: getfirstvisibletab

Ruft einen Zeiger auf die erste sichtbare Registerkarte ab.

```
virtual CWnd* GetFirstVisibleTab(int& iTabNum);

virtual CWnd* GetFirstVisibleTab(
    int iStartFrom,
    int& iTabNum);
```

### <a name="parameters"></a>Parameter

*iTabNum*<br/>
vorgenommen Ein Verweis auf eine ganze Zahl. Diese Methode schreibt den NULL basierten Index der ersten sichtbaren Registerkarte in diesen Parameter.

*iStartFrom*<br/>
in Der null basierte Index der ersten zu Überprüfungen enden Registerkarte.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf die erste sichtbare Registerkarte, wenn erfolgreich. andernfalls NULL.

### <a name="remarks"></a>Hinweise

Wenn diese Methode fehlschlägt, wird der Wert-1 in *istartfrom*geschrieben.

Wenn *istartfrom* größer oder gleich der Anzahl der Registerkarten im Registerkarten-Steuerelement ist `GetFirstVisibleTab` , schlägt automatisch fehl.

##  <a name="getfirstvisibletabnum"></a>Cmfcbasetabctrl:: getfirstvisibletabnum

```
virtual int GetFirstVisibleTabNum() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="gethighlightedtab"></a>Cmfcbasetabctrl:: gethighlightedtab

Ruft den Index der aktuell markierten Registerkarte ab.

```
int GetHighlightedTab() const;
```

### <a name="return-value"></a>Rückgabewert

Der null basierte Index der hervorgehobenen Registerkarte.

##  <a name="getimagelist"></a>Cmfcbasetabctrl:: GetImageList

```
virtual const CImageList* GetImageList() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="getimagesize"></a>Cmfcbasetabctrl:: getimagesize

```
virtual CSize GetImageSize() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="getlastvisibletab"></a>Cmfcbasetabctrl:: getlastvisibletab

```
virtual CWnd* GetLastVisibleTab(int& iTabNum);
```

### <a name="parameters"></a>Parameter

[in] *iTabNum*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="getlocation"></a>Cmfcbasetabctrl:: getLocation

Ruft den Speicherort des Registerkarten Bereichs Teils des Registerkarten-Steuer Elements ab.

```
Location GetLocation() const;
```

### <a name="return-value"></a>Rückgabewert

Der Speicherort des Registerkarten Bereichs.

### <a name="remarks"></a>Hinweise

Mögliche Werte für den Tabstopp Bereich sind LOCATION_BOTTOM und LOCATION_TOP.

##  <a name="getmaxwindowsize"></a>Cmfcbasetabctrl:: getmaxwindowsize

```
virtual CSize GetMaxWindowSize() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="gettabarea"></a>Cmfcbasetabctrl:: gettabarea

Ruft die Größe und die Position des Registerkarten Bereichs des Registerkarten-Steuer Elements ab.

```
virtual void GetTabArea(
    CRect& rectTabAreaTop,
    CRect& rectTabAreaBottom) const = 0;
```

### <a name="parameters"></a>Parameter

*rectTabAreaTop*<br/>
in Ein Verweis auf ein `CRect` -Objekt. `GetTabArea`verwendet dieses-Objekt zum Speichern der Größe und Position des oberen Registerkarten Bereichs.

*rectTabAreaBottom*<br/>
in Ein Verweis auf ein `CRect` -Objekt. `GetTabArea`verwendet dieses-Objekt zum Speichern der Größe und Position des unteren Registerkarten Bereichs.

### <a name="remarks"></a>Hinweise

Nachdem `GetTabArea` zurückgegeben wurde `CRect` , enthalten die Parameter die Größe und Position des Registerkarten Bereichs in Client Koordinaten des Registerkarten-Steuer Elements. Wenn am oberen oder unteren Rand des Registerkarten-Steuer `rectTabAreaTop` Elements kein Registerkarten Bereich vorhanden ist oder `rectTabAreaBottom` leer ist.

`CMFCBaseTabCtrl Class`In ist diese Methode eine reine virtuelle Funktion und hat keine Implementierung. Wenn Sie eine Klasse von `CMFCBaseTabCtrl`ableiten, müssen Sie diese Funktion implementieren.

##  <a name="gettabbkcolor"></a>Cmfcbasetabctrl:: gettabbkcolor

Ruft die Hintergrundfarbe der angegebenen Registerkarte ab.

```
virtual COLORREF GetTabBkColor(int iTab) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der Registerkarte.

### <a name="return-value"></a>Rückgabewert

Ein [COLORREF](/windows/win32/gdi/colorref) -Wert, der die Hintergrundfarbe der angegebenen Registerkarte angibt. -1, wenn sich das *ITAB* außerhalb des gültigen Bereichs befindet.

##  <a name="gettabbordersize"></a>Cmfcbasetabctrl:: gettabbordersize

Ruft die Größe der Registerkarten Rahmen im Registerkarten-Steuerelement ab.

```
virtual int GetTabBorderSize() const;
```

### <a name="return-value"></a>Rückgabewert

Die Größe des Registerkarten Rahmens in Pixel.

### <a name="remarks"></a>Hinweise

Die Standardgröße für den Registerkarten Rahmen beträgt drei Pixel. Sie können diese Rahmengröße mit der [cmfcbasetabctrl:: settabbordersize](#settabbordersize)-Methode ändern.

##  <a name="gettabbyid"></a>Cmfcbasetabctrl:: gettabbyid

Ruft den Index einer Registerkarte auf der Grundlage einer Registerkarten-ID ab.

```
virtual int GetTabByID(int id) const;
```

### <a name="parameters"></a>Parameter

*ID*<br/>
in Eine Registerkarten-ID.

### <a name="return-value"></a>Rückgabewert

Der null basierte Index einer Registerkarte, wenn Sie gefunden wird. -1, wenn die Registerkarten-ID nicht gefunden wurde.

### <a name="remarks"></a>Hinweise

Die Registerkarten-IDs werden automatisch zugewiesen, wenn einem Registerkarten-Steuerelement Registerkarten hinzugefügt werden.

##  <a name="gettabclosebutton"></a>Cmfcbasetabctrl:: gettabclosebutton

```
CRect GetTabCloseButton() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="gettabfromhwnd"></a>Cmfcbasetabctrl:: gettabfromhwnd

Ruft den Index der Registerkarte ab, die das angegebene HWND-Objekt enthält.

```
virtual int GetTabFromHwnd(HWND hwnd) const;
```

### <a name="parameters"></a>Parameter

*HWND*<br/>
in Ein Handle für ein Fenster.

### <a name="return-value"></a>Rückgabewert

Der null basierte Index der Registerkarte, wenn erfolgreich. -1, wenn keine Registerkarte das *HWND*enthält.

##  <a name="gettabfrompoint"></a>Cmfcbasetabctrl:: gettabfrompoint

Ruft die Registerkarte ab, die einen angegebenen Punkt enthält.

```
virtual int GetTabFromPoint(CPoint& pt) const;
```

### <a name="parameters"></a>Parameter

*pt*<br/>
in Ein Punkt in den Client Koordinaten des Registerkarten-Steuer Elements.

### <a name="return-value"></a>Rückgabewert

Der Index der Registerkarte, die *PT*enthält. -1, wenn keine Registerkarte *PT*enthält.

##  <a name="gettabfullwidth"></a>Cmfcbasetabctrl:: gettabfullwidth

```
virtual int GetTabFullWidth(int iTab) const;
```

### <a name="parameters"></a>Parameter

[in] *iTab*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="gettabhicon"></a>Cmfcbasetabctrl:: gettabhicon

Gibt das HICON zurück, das der angegebenen Registerkarte zugeordnet ist.

```
virtual HICON GetTabHicon(int iTab) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index für die Registerkarte.

### <a name="return-value"></a>Rückgabewert

Das HICON, das einer Registerkarten Bezeichnung zugeordnet ist, wenn erfolgreich. NULL, wenn kein HICON vorhanden ist, oder, wenn die Methode fehlschlägt.

##  <a name="gettabicon"></a>Cmfcbasetabctrl:: gettabicon

Ruft das Symbol ab, das der angegebenen Registerkarte zugeordnet ist.

```
virtual UINT GetTabIcon(int iTab) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der Registerkarte.

### <a name="return-value"></a>Rückgabewert

Die Symbol-ID für die angegebene Registerkarte, wenn erfolgreich. -1, wenn der Index ungültig ist.

### <a name="remarks"></a>Hinweise

Das [cmfcbasetabctrl](../../mfc/reference/cmfcbasetabctrl-class.md) -Objekt speichert die Symbole im internen [CImageList](../../mfc/reference/cimagelist-class.md) -Objekt.

##  <a name="gettabid"></a>Cmfcbasetabctrl:: gettabid

Ruft die ID für eine Registerkarte ab, die durch den Registerkarten Index angegeben wird.

```
int GetTabID(int iTab) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der Registerkarte.

### <a name="return-value"></a>Rückgabewert

Eine ID der Registerkarte oder-1, wenn sich das *ITAB* außerhalb des gültigen Bereichs befindet.

##  <a name="gettablabel"></a>Cmfcbasetabctrl:: gettablabel

Ruft den Text einer Registerkarten Bezeichnung ab.

```
virtual BOOL GetTabLabel(
    int iTab,
    CString& strLabel) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der Registerkarte.

*strLabel*<br/>
vorgenommen Ein Verweis auf ein `CString` -Objekt. Diese Methode speichert die Bezeichnung der Registerkarte in diesem Parameter.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich; Andernfalls false.

### <a name="remarks"></a>Hinweise

Diese Methode schlägt fehl, wenn das *ITAB* -Index ungültig ist.

Wenn Sie die Registerkarte mit [cmfcbasetabctrl:: addTab](#addtab)erstellen, legen Sie die Bezeichnung für eine Registerkarte fest. Sie können die Bezeichnung auch nach der Erstellung mit der [cmfcbasetabctrl:: settablabel](#settablabel)-Methode ändern.

##  <a name="gettabrect"></a>Cmfcbasetabctrl:: GetTabRect

Ruft die Größe und Position der angegebenen Registerkarte ab.

```
virtual BOOL GetTabRect(
    int iTab,
    CRect& rect) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der Registerkarte.

*Rect*<br/>
vorgenommen Ein Verweis auf ein `CRect` -Objekt. Diese Methode speichert die Größe und Position der Registerkarte in diesem Parameter.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich; FALSE, wenn der Registerkarten Index ungültig ist.

##  <a name="gettabsheight"></a>Cmfcbasetabctrl:: gettabsheight

```
virtual int GetTabsHeight() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="gettabsnum"></a>Cmfcbasetabctrl:: gettabsnum

Ruft die Anzahl der Registerkarten im Registerkarten-Steuerelement ab.

```
virtual int GetTabsNum() const;
```

### <a name="return-value"></a>Rückgabewert

Die Anzahl der Registerkarten im Registerkarten-Steuerelement.

##  <a name="gettabsrect"></a>Cmfcbasetabctrl:: gettabsrect

```
virtual void GetTabsRect(CRect& rect) const;
```

### <a name="parameters"></a>Parameter

in *Rect*<br/>

### <a name="remarks"></a>Hinweise

##  <a name="gettabtextcolor"></a>Cmfcbasetabctrl:: gettabtextcolor

Ruft die Textfarbe für die angegebene Registerkarte ab.

```
virtual COLORREF GetTabTextColor(int iTab) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der Registerkarte.

### <a name="return-value"></a>Rückgabewert

Ein [COLORREF](/windows/win32/gdi/colorref) -Parameter, der die Textfarbe der angegebenen Registerkarte angibt. -1, wenn sich das *ITAB* außerhalb des gültigen Bereichs befindet.

##  <a name="gettabwnd"></a>Cmfcbasetabctrl:: gettabwnd

Gibt den Zeiger auf den Bereich zurück, der sich auf der angegebenen Registerkarte befindet.

```
virtual CWnd* GetTabWnd(int iTab) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index einer Registerkarte.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf das [CWnd](../../mfc/reference/cwnd-class.md) -Objekt, das sich auf der Registerkarte befindet, die von *ITAB* angegeben wird. NULL, wenn *ITAB* ungültig ist.

### <a name="remarks"></a>Hinweise

Das zurückgegebene Objekt ist das Objekt, das von der Anwendung hinzugefügt wurde, als [cmfcbasetabctrl:: addTab](#addtab) oder [cmfcbasetabctrl:: InsertTab](#inserttab)aufgerufen wurde.

Wenn das-Objekt auf einer Registerkarte über einen Wrapper verfügt, gibt diese Methode den Wrapper für das-Objekt zurück. Weitere Informationen zu Wrappern finden Sie unter [cmfcbasetabctrl:: deatewrapper](#createwrapper). Wenn Sie ohne den Wrapper auf einen Zeiger auf das direkte Objekt zugreifen möchten, verwenden Sie die [cmfcbasetabctrl:: gettabwndnowrapper](#gettabwndnowrapper)-Methode.

##  <a name="gettabwndnowrapper"></a>Cmfcbasetabctrl:: gettabwndnowrapper

Gibt einen Zeiger auf das Steuerelement zurück, das sich auf einer Registerkarte befindet, auch wenn das Steuerelement über einen Wrapper verfügt.

```
virtual CWnd* GetTabWndNoWrapper(int iTab) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index einer Registerkarte.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf das [CWnd](../../mfc/reference/cwnd-class.md) -Objekt, das sich auf der angegebenen Registerkarte befindet. NULL, wenn *ITAB* ungültig ist.

### <a name="remarks"></a>Hinweise

Diese Methode ruft einen direkten Zeiger auf das `CWnd` -Objekt ab, das Sie mit der-Methode [cmfcbasetabctrl:: addTab](#addtab) oder [cmfcbasetabctrl:: InsertTab](#inserttab)hinzugefügt haben. `GetTabWndNoWrapper`Ruft einen Zeiger auf den hinzugefügten `CWnd`ab, auch wenn das Framework einen Wrapper für das-Objekt hinzugefügt hat. Weitere Informationen zu Wrappern und der [cmfcbasetabctrl-Klasse](../../mfc/reference/cmfcbasetabctrl-class.md)finden Sie unter [cmfcbasetabctrl:: kreatewrapper](#createwrapper).

Verwenden Sie die-Methode [cmfcbasetabctrl:: gettabwnd](#gettabwnd) , wenn Sie die Wrapper Klasse nicht ignorieren möchten.

##  <a name="gettooltipctrl"></a>Cmfcbasetabctrl:: gettooltipctrl

Ruft einen Verweis auf die QuickInfo-Verbindungsliste ab.

```
CToolTipCtrl& GetToolTipCtrl() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Verweis auf das QuickInfo-Steuerelement.

##  <a name="getvisibletabsnum"></a>Cmfcbasetabctrl:: getvisibletabsnum

Ruft die Anzahl der aktuell sichtbaren Registerkarten ab.

```
virtual int GetVisibleTabsNum() const;
```

### <a name="return-value"></a>Rückgabewert

Die Anzahl der sichtbaren Registerkarten.

##  <a name="hasimage"></a>Cmfcbasetabctrl:: hasimage

```
virtual BOOL HasImage(int iTab) const;
```

### <a name="parameters"></a>Parameter

[in] *iTab*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="hidesingletab"></a>Cmfcbasetabctrl:: hidesintons ab

Legt die Option zum Ausblenden der Registerkarten für das Registerkarten-Steuerelement fest, wenn eine Registerkarte sichtbar ist.

```
virtual void HideSingleTab(BOOL bHide = TRUE);
```

### <a name="parameters"></a>Parameter

*bHide*<br/>
in Ein boolescher Wert, der angibt, ob das Ausblenden einzelner Registerkarten aktiviert werden soll.

### <a name="remarks"></a>Hinweise

Wenn die Anwendung für das Ausblenden einzelner Registerkarten konfiguriert ist, zeigt das Framework automatisch Registerkarten an, wenn dem Registerkarten-Steuerelement eine zweite Registerkarte hinzugefügt wird.

##  <a name="inserttab"></a>Cmfcbasetabctrl:: InsertTab

Fügt eine Registerkarte in das Register Steuerelement ein.

```
Virtual void InsertTab(
    CWnd* pNewWnd,
    LPCTSTR lpszTabLabel,
    int nInsertAt,
    UINT uiImageId = (UINT)-1,
    BOOL bDetachable = TRUE);

virtual void InsertTab(
    CWnd* pNewWnd,
    UINT uiResTabLabel,
    int nInsertAt,
    UINT uiImageId = (UINT)-1,
    BOOL bDetachable = TRUE);
```

### <a name="parameters"></a>Parameter

*pNewWnd*<br/>
in Ein Zeiger auf das Fenster, das von dieser Methode als neue Registerkarte hinzugefügt wird.

*lpszTabLabel*<br/>
in Eine Zeichenfolge, die die Bezeichnung für die neue Registerkarte enthält.

*nInsertAt*<br/>
in Der null basierte Index der neuen Registerkarte.

*uiImageId*<br/>
in Eine Image-ID aus der Bildliste. Das Registerkarten-Steuerelement verwendet dieses Bild als Symbol für die neue Registerkarte.

*bDetachable*<br/>
in Ein boolescher Parameter, der bestimmt, ob die neue Registerkarte getrennt werden kann.

*uiResTabLabel*<br/>
in Die Ressourcen-ID für die Bezeichnung.

### <a name="remarks"></a>Hinweise

Wenn das von *pnewwnd* angeforderte Objekt nicht von der [CDockablePane-Klasse](../../mfc/reference/cdockablepane-class.md) abgeleitet ist und der *bdetachable* -Parameter true ist, erstellt das Framework einen speziellen Wrapper für die neue Registerkarte. Standardmäßig ist der Wrapper eine Instanz der [cdockablepaneadapter-Klasse](../../mfc/reference/cdockablepaneadapter-class.md). Verwenden Sie die [cmfcbasetabctrl:: setdockingbarwrapperrtc](#setdockingbarwrapperrtc) -Methode, um eine andere Wrapper Klasse zu erstellen. Jede benutzerdefinierte Wrapper Klasse muss von `CDockablePaneAdapter`abgeleitet werden.

##  <a name="invalidatetab"></a>Cmfcbasetabctrl:: invalidatetab

```
void InvalidateTab(int iTab);
```

### <a name="parameters"></a>Parameter

[in] *iTab*<br/>

### <a name="remarks"></a>Hinweise

##  <a name="isactivetabclosebutton"></a>Cmfcbasetabctrl:: isactivetabclosebutton

```
virtual BOOL IsActiveTabCloseButton() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="isautocolor"></a>Cmfcbasetabctrl:: isautocolor

Bestimmt, ob das Registerkarten-Steuerelement im Autocolor-Modus ist.

```
BOOL IsAutoColor() const;
```

### <a name="return-value"></a>Rückgabewert

TRUE, wenn das Registerkarten-Steuerelement im Autocolor-Modus ist. Andernfalls false.

### <a name="remarks"></a>Hinweise

Sie können den Autocolor-Modus mithilfe der [cmfcbasetabctrl:: enableautocolor](#enableautocolor) -Methode aktivieren oder deaktivieren.

##  <a name="isautodestroywindow"></a>Cmfcbasetabctrl:: isautodestroywindow

```
BOOL IsAutoDestroyWindow() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="iscolored"></a>Cmfcbasetabctrl:: isfarbige

```
virtual BOOL IsColored() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="isdialogcontrol"></a>Cmfcbasetabctrl:: isdialogcontrol

```
BOOL IsDialogControl() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="isdrawnoprefix"></a>Cmfcbasetabctrl:: isdrawnoprefix

```
BOOL IsDrawNoPrefix() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="isflatframe"></a>Cmfcbasetabctrl:: isflatframe

Gibt an, ob der Rahmen des Registerkarten-Steuer Elements in einer flachen Formatvorlage oder in einem 3D-Stil gerendert wird.

```
virtual BOOL IsFlatFrame() const;
```

### <a name="return-value"></a>Rückgabewert

TRUE, wenn der Rahmen des Registerkarten-Steuer Elements in einem flachen Stil gerendert wird. FALSE, wenn der Frame in einem 3D-Stil gerendert wird.

### <a name="remarks"></a>Hinweise

Verwenden Sie [cmfctabctrl:: setflatframe](../../mfc/reference/cmfctabctrl-class.md#setflatframe) , um den Stil für den Rahmen des Registerkarten-Steuer Elements zu ändern.

Register Steuerelemente, die den Outlook-Stil verwenden, können nicht mit flachen Frames gerendert werden Dies umfasst die [cmfcoutlookbartabctrl-Klasse](../../mfc/reference/cmfcoutlookbartabctrl-class.md) und alle von dieser Klasse abgeleiteten Klassen.

##  <a name="isflattab"></a>Cmfcbasetabctrl:: isflattab

```
virtual BOOL IsFlatTab() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="ishidesingletab"></a>Cmfcbasetabctrl:: ishidesintons ab

Bestimmt, ob das Registerkarten-Steuerelement die Registerkarten Bezeichnung verbirgt, wenn nur eine Registerkarte vorhanden ist.

```
virtual BOOL IsHideSingleTab() const;
```

### <a name="return-value"></a>Rückgabewert

TRUE, wenn das Registerkarten-Steuerelement die Registerkarten Bezeichnung verbirgt, wenn es eine Registerkarte hat. andernfalls false.

### <a name="remarks"></a>Hinweise

Verwenden Sie die [cmfcbasetabctrl:: hidesintons ab](#hidesingletab) -Methode, um das Ausblenden der Registerkarten Bezeichnung zu aktivieren, wenn nur eine Registerkarte vorhanden ist.

##  <a name="isiconadded"></a>Cmfcbasetabctrl:: isisubadded

```
BOOL IsIconAdded(
    HICON hIcon,
    int& iIcon);
```

### <a name="parameters"></a>Parameter

[in] *hIcon*<br/>

[in] *iIcon*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="isinplaceedit"></a>Cmfcbasetabctrl:: isinplaceedit

Gibt an, ob das Registerkarten-Steuerelement so konfiguriert ist, dass der Benutzer die Registerkarten Bezeichnungen dynamisch ändern kann.

```
virtual BOOL IsInPlaceEdit() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich 0 (null), wenn die direkte Bearbeitung aktiviert ist. andernfalls 0.

### <a name="remarks"></a>Hinweise

Sie können die direkte Bearbeitung aktivieren oder deaktivieren, indem Sie die-Methode [cmfcbasetabctrl:: enableinplaceedit](#enableinplaceedit)aufrufen.

##  <a name="isleftrightrounded"></a>Cmfcbasetabctrl:: islefterghtrochte

```
virtual BOOL IsLeftRightRounded() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="ismditab"></a>Cmfcbasetabctrl:: ismditab

```
BOOL IsMDITab() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="isonenotestyle"></a>Cmfcbasetabctrl:: isonenotestyle

Bestimmt, ob Registerkarten im Stil von Microsoft OneNote angezeigt werden.

```
virtual BOOL IsOneNoteStyle() const;
```

### <a name="return-value"></a>Rückgabewert

TRUE, wenn Registerkarten im Stil von Microsoft OneNote angezeigt werden. andernfalls false.

### <a name="remarks"></a>Hinweise

Nennen Sie die [CMDIFrameWndEx:: enablemditabs](../../mfc/reference/cmdiframewndex-class.md#enablemditabs) -Methode, um den Microsoft OneNote-Stil zu aktivieren. Sie können diesen Stil auch aktivieren, wenn Sie die [cmfctabctrl-Klasse](../../mfc/reference/cmfctabctrl-class.md)instanziieren: übergeben Sie einfach den Stil STYLE_3D_ONENOTE an die-Methode [cmfctabctrl:: Create](../../mfc/reference/cmfctabctrl-class.md#create).

Standardmäßig wird der Microsoft OneNote-Stil in einer benutzerdefinierten Klasse, die von `CMFCBaseTabCtrl Class`abgeleitet ist, nicht unterstützt. Es wird jedoch in der `CMFCTabCtrl` -Klasse unterstützt.

##  <a name="isptintabarea"></a>Cmfcbasetabctrl:: isptintabarea

Bestimmt, ob sich ein Punkt innerhalb des Registerkarten Bereichs befindet.

```
virtual BOOL IsPtInTabArea(CPoint point) const = 0;
```

### <a name="parameters"></a>Parameter

*point*<br/>
in Der zu überprüfende Punkt.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn sich der Punkt im Registerkarten Bereich befindet. andernfalls 0.

### <a name="remarks"></a>Hinweise

`CMFCBaseTabCtrl Class`In ist diese Methode eine reine virtuelle Funktion und hat keine Implementierung. Wenn Sie eine Klasse von `CMFCBaseTabCtrl`ableiten, müssen Sie diese Funktion implementieren.

##  <a name="istabclosebuttonhighlighted"></a>Cmfcbasetabctrl:: istabclosebuttongehobene

```
BOOL IsTabCloseButtonHighlighted() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="istabclosebuttonpressed"></a>Cmfcbasetabctrl:: istabclosebuttonpressed

```
BOOL IsTabCloseButtonPressed() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="istabdetachable"></a>Cmfcbasetabctrl:: istabdetachable

Bestimmt, ob eine Registerkarte getrennt werden kann.

```
virtual BOOL IsTabDetachable(int iTab) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der zu Überprüfung enden Registerkarte.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die Registerkarte getrennt werden kann. Andernfalls false.

### <a name="remarks"></a>Hinweise

Verwenden Sie die [cmfcbasetabctrl:: enabletabdetach](#enabletabdetach)-Methode, um eine Registerkarte zu trennen.

##  <a name="istabicononly"></a>Cmfcbasetabctrl:: istabicononly

Bestimmt, ob eine Registerkarten Bezeichnung nur Symbole und keinen Text enthält.

```
virtual BOOL IsTabIconOnly(int iTab) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der Registerkarte.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn eine Registerkarten Bezeichnung nur über Symbole verfügt. Andernfalls false.

### <a name="remarks"></a>Hinweise

Um die Registerkarten in der Anwendung so festzulegen, dass nur Symbole angezeigt werden, müssen Sie die-Methode [cmfcbasetabctrl:: settabicononly](#settabicononly)aufrufen.

##  <a name="istabswapenabled"></a>Cmfcbasetabctrl:: istabswap-fähig

Bestimmt, ob das Registerkarten-Steuerelement dem Benutzer ermöglicht, Tabstopps mithilfe der Maus zu ändern.

```
BOOL IsTabSwapEnabled() const;
```

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn der Benutzer Registerkarten Positionen ändern kann. andernfalls 0.

### <a name="remarks"></a>Hinweise

Standardmäßig können Benutzer die Reihenfolge von Registerkarten in einem Registerkarten-Steuerelement nicht ändern. Verwenden Sie die [cmfcbasetabctrl:: enabletabswap](#enabletabswap) -Methode, um diese Funktionalität zu aktivieren.

##  <a name="istabvisible"></a>Cmfcbasetabctrl:: istabvisible

Gibt an, ob die angegebene Registerkarte sichtbar ist.

```
virtual BOOL IsTabVisible(int iTab) const;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der zu Überprüfung enden Registerkarte.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn die angegebene Registerkarte sichtbar ist. andernfalls 0.

##  <a name="isvs2005style"></a>Cmfcbasetabctrl:: IsVS2005Style

```
virtual BOOL IsVS2005Style() const;
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="m_bactivatetabonrightclick"></a>Cmfcbasetabctrl:: m_bActivateTabOnRightClick

`m_bActivateTabOnRightClick`bestimmt, ob Registerkarten im Fokus sind, wenn der Benutzer mit der rechten Maustaste auf eine Registerkarten Bezeichnung klickt.

```
BOOL m_bActivateTabOnRightClick;
```

### <a name="remarks"></a>Hinweise

Der Standardwert für dieses Datenmember ist false.

##  <a name="m_bautodestroywindow"></a>Cmfcbasetabctrl:: m_bAutoDestroyWindow

`m_bAutoDestroyWindow`bestimmt, ob das Framework die Objekte auf Registerkarten automatisch zerstört, wenn die Registerkarten entfernt werden.

```
BOOL m_bAutoDestroyWindow;
```

### <a name="remarks"></a>Hinweise

Standardmäßig ist dieser Member false.

##  <a name="movetab"></a>Cmfcbasetabctrl:: muvetab

```
virtual void MoveTab(
    int nSource,
    int nDest);
```

### <a name="parameters"></a>Parameter

in *nquelle*<br/>

in *ndest*<br/>

### <a name="remarks"></a>Hinweise

##  <a name="onchangetabs"></a>Cmfcbasetabctrl:: onchangetabs

Das Framework ruft diese Methode auf, wenn sich die Anzahl der Registerkarten eines Registerkarten-Steuer Elements ändert.

```
virtual void OnChangeTabs();
```

### <a name="remarks"></a>Hinweise

Standardmäßig führt diese Methode keine Aktion aus. Überschreiben Sie diese Methode, um benutzerdefinierten Code auszuführen, wenn sich die Anzahl der Registerkarten des Register Steuer Elements ändert.

##  <a name="ondrop"></a>Cmfcbasetabctrl:: OnDrop

```
virtual BOOL OnDrop(
    COleDataObject*,
    DROPEFFECT,
    CPoint);
```

### <a name="parameters"></a>Parameter

[in] _COleDataObject_\*<br/>

in *Dropffect*<br/>

in *CPoint*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="ondragover"></a>Cmfcbasetabctrl:: OnDragOver

```
virtual DROPEFFECT OnDragOver(
    COleDataObject*,
    DWORD,
    CPoint);
```

### <a name="parameters"></a>Parameter

[in] _COleDataObject_\*<br/>

in *DWORD*<br/>

in *CPoint*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="ondragleave"></a>Cmfcbasetabctrl:: OnDragLeave

```
virtual void OnDragLeave();
```

### <a name="remarks"></a>Hinweise

##  <a name="ondragenter"></a>Cmfcbasetabctrl:: OnDragEnter

```
virtual DROPEFFECT OnDragEnter(
    COleDataObject*,
    DWORD,
    CPoint);
```

### <a name="parameters"></a>Parameter

[in] _COleDataObject_\*<br/>

in *DWORD*<br/>

in *CPoint*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="onrenametab"></a>Cmfcbasetabctrl:: onrenametab

```
virtual BOOL OnRenameTab(int, CString&);
```

### <a name="parameters"></a>Parameter

[in] *int*<br/>

in *CString-&*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="pretranslatemessage"></a>Cmfcbasetabctrl::P retranslatemess Age

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>Parameter

[in] *pMsg*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="recalclayout"></a>Cmfcbasetabctrl:: Neuberechnung

Berechnet das interne Layout des Registerkarten-Steuer Elements neu.

```
virtual void RecalcLayout() = 0;
```

### <a name="remarks"></a>Hinweise

`CMFCBaseTabCtrl Class`In ist diese Methode eine reine virtuelle Funktion. Wenn Sie eine Klasse von `CMFCBaseTabCtrl`ableiten, müssen Sie diese Funktion implementieren.

##  <a name="removealltabs"></a>Cmfcbasetabctrl:: removealltabs

Entfernt alle Registerkarten aus dem Registerkarten-Steuerelement.

```
virtual void RemoveAllTabs();
```

### <a name="remarks"></a>Hinweise

Wenn [cmfcbasetabctrl:: m_bAutoDestroyWindow](#m_bautodestroywindow) den Wert true hat, löscht das Framework alle [CWnd](../../mfc/reference/cwnd-class.md) -Objekte, die an die entfernten Registerkarten angefügt sind.

##  <a name="removetab"></a>Cmfcbasetabctrl:: removetab

Entfernt eine Registerkarte aus dem Registerkarten-Steuerelement.

```
virtual BOOL RemoveTab(
    int iTab,
    BOOL bRecalcLayout = TRUE);
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index einer Registerkarte.

*bRecalcLayout*<br/>
in Ein boolescher Parameter, der angibt, ob das Layout der Registerkarte neu berechnet werden soll.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die-Methode die Registerkarte erfolgreich entfernt hat. andernfalls false.

### <a name="remarks"></a>Hinweise

Wenn [cmfcbasetabctrl:: m_bAutoDestroyWindow](#m_bautodestroywindow) den Wert true `RemoveTab` hat, zerstört das [CWnd](../../mfc/reference/cwnd-class.md) -Objekt, das der angegebenen Registerkarte zugeordnet ist.

##  <a name="renametab"></a>Cmfcbasetabctrl:: renametab

```
virtual BOOL RenameTab();
```

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="resetimagelist"></a>Cmfcbasetabctrl:: resetimagelist

Setzt die Bildliste für eine Instanz der [cmfcbasetabctrl-Klasse](../../mfc/reference/cmfcbasetabctrl-class.md)zurück.

```
void ResetImageList();
```

##  <a name="serialize"></a>Cmfcbasetabctrl:: Serialize

```
virtual void Serialize(CArchive& ar);
```

### <a name="parameters"></a>Parameter

[in] *ar*<br/>

### <a name="remarks"></a>Hinweise

##  <a name="setactivetab"></a>Cmfcbasetabctrl:: abtativetab

Aktiviert die angegebene Registerkarte.

```
virtual BOOL SetActiveTab(int iTab) = 0;
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index einer Registerkarte. `SetActiveTab` bewirkt, dass die Registerkarte mit diesem Index aktiv ist.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Hinweise

`CMFCBaseTabCtrl Class`In ist diese Methode eine reine virtuelle Funktion. Wenn Sie eine Klasse von `CMFCBaseTabCtrl`ableiten, müssen Sie diese Funktion implementieren.

##  <a name="setactivetabcolor"></a>Cmfcbasetabctrl:: Abbild

Legt die Hintergrundfarbe für die aktive Registerkarte fest.

```
virtual void SetActiveTabColor(COLORREF clr);
```

### <a name="parameters"></a>Parameter

*clr*<br/>
in Gibt die neue Hintergrundfarbe an.

### <a name="remarks"></a>Hinweise

Das Framework erhält die Standard Hintergrundfarbe für aktive Registerkarten aus der [GetSysColor](/windows/win32/api/winuser/nf-winuser-getsyscolor)-Methode.

##  <a name="setactivetabtextcolor"></a>Cmfcbasetabctrl:: abtativetabtextcolor

Legt die Textfarbe für aktive Registerkarten fest.

```
virtual void SetActiveTabTextColor(COLORREF clr);
```

### <a name="parameters"></a>Parameter

*clr*<br/>
in Ein [COLORREF](/windows/win32/gdi/colorref) -Parameter, der die neue Textfarbe angibt.

### <a name="remarks"></a>Hinweise

Standardmäßig erhält das Framework die Textfarbe von [GetSysColor](/windows/win32/api/winuser/nf-winuser-getsyscolor). Überschreiben Sie diese Standardfarbe mithilfe `SetActiveTabTextColor` der-Methode.

##  <a name="setautocolors"></a>Cmfcbasetabctrl:: abtautocolors

Legt die Farben des Registerkarten-Steuer Elements fest, das vom Framework im automatischen Farbmodus verwendet wird.

```
void SetAutoColors(const CArray<COLORREF,COLORREF>& arColors);
```

### <a name="parameters"></a>Parameter

*arColors*<br/>
in Ein Array von RGB-Farben.

### <a name="remarks"></a>Hinweise

Wenn Sie ein benutzerdefiniertes Array von Farben angeben, wird das Standard Array von Farben ignoriert. Wenn der Parameter *arcolors* leer ist, wird das Framework auf das Standard Array von Farben zurückgesetzt.

Um den Autocolor-Modus zu aktivieren, verwenden Sie die [cmfcbasetabctrl:: enableautocolor](#enableautocolor) -Methode.

##  <a name="setdockingbarwrapperrtc"></a>  CMFCBaseTabCtrl::SetDockingBarWrapperRTC

Legt die Wrapperklasse fest, die für nicht von der [CDockablePane Class](../../mfc/reference/cdockablepane-class.md)abgeleitete Objekte verwendet wird.

```
void SetDockingBarWrapperRTC(CRuntimeClass* pRTC);
```

### <a name="parameters"></a>Parameter

*pRTC*<br/>
in Die Lauf Zeit Klassen Informationen für die neue Wrapper Klasse.

### <a name="remarks"></a>Hinweise

Mithilfe der Methoden [cmfcbasetabctrl:: addTab](#addtab) und [cmfcbasetabctrl:: InsertTab](#inserttab)können Sie einem Registerkarten-Steuerelement Registerkarten hinzufügen. Wenn Sie eine Registerkarte hinzufügen, muss jedes Steuerelement auf dieser Registerkarte Andock fähig sein. Alle Objekte, die nicht von `CDockablePane` abgeleitet sind, müssen umschließt werden. `AddTab`und `InsertTab` erstellen Sie einen Wrapper für diese Objekte. Die Standard-Wrapper Klasse ist die [cdockablepaneadapter-Klasse](../../mfc/reference/cdockablepaneadapter-class.md). Die- `SetDockingBarWrapperRTC` Methode ermöglicht es Ihnen, die Klasse zu ändern, die als Wrapper Klasse verwendet wird. Die Wrapper Klasse, die Sie bereitstellen, muss `CDockablePaneAdapter`von abgeleitet werden.

##  <a name="setdrawnoprefix"></a>Cmfcbasetabctrl:: setdrawnoprefix

Aktiviert und deaktiviert die Verarbeitung von Präfix Zeichen in Registerkarten Bezeichnungen.

```
void SetDrawNoPrefix(
    BOOL bNoPrefix,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>Parameter

*bNoPrefix*<br/>
in TRUE, wenn Präfix Zeichen verarbeitet werden sollen. andernfalls false.

*bRedraw*<br/>
in TRUE, wenn Sie das Fenster im Registerkarten Format neu zeichnen möchten. andernfalls false.

### <a name="remarks"></a>Hinweise

Ein Präfix Zeichen ist ein mnetmonisches Zeichen, dem ein kaufmännisches und-Zeichen (&) vorangestellt ist.

##  <a name="setimagelist"></a>Cmfcbasetabctrl:: SetImageList

Legt die Symbolbild Liste für das Registerkarten-Steuerelement fest.

```
virtual BOOL SetImageList(
    UINT uiID,
    int cx = 15,
    COLORREF clrTransp = RGB(255, 0, 255));

virtual BOOL SetImageList(HIMAGELIST hImageList);
```

### <a name="parameters"></a>Parameter

*uiID*<br/>
in Eine Ressourcen-ID der Bitmap. `SetImageList`lädt die Bildliste aus dieser Ressource.

*verschoben*<br/>
in Die Breite jedes Bilds in Pixel.

*clrTransp*<br/>
in Ein [COLORREF](/windows/win32/gdi/colorref) -Parameter, der die transparente Farbe des Bilds angibt.

*hImageList*<br/>
in Ein Handle für eine vorab geladene Bildliste.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn die Methode erfolgreich war. andernfalls 0.

### <a name="remarks"></a>Hinweise

Die Bilder aus der Liste Symbolbild werden neben den Bezeichnungen für die Registerkarte angezeigt. Um ein Symbol anzuzeigen, müssen Sie den Index angeben, wenn Sie [cmfcbasetabctrl:: addTab](#addtab)aufrufen.

`SetImageList`schlägt fehl, wenn das Registerkarten-Steuerelement mit einem flachen Stil erstellt wurde. Es schlägt auch fehl, wenn das Framework das durch *uiid*gekennzeichnete Bild nicht laden kann.

Diese Methode berechnet die Höhe der Registerkarte entsprechend der Bild-und Text Größe neu.

##  <a name="setlocation"></a>Cmfcbasetabctrl:: setLocation

```
virtual void SetLocation(Location location);
```

### <a name="parameters"></a>Parameter

in *Speicherort*<br/>

### <a name="remarks"></a>Hinweise

##  <a name="settabbkcolor"></a>Cmfcbasetabctrl:: settabbkcolor

Legt die Hintergrundfarbe für die angegebene Registerkarte fest.

```
virtual BOOL SetTabBkColor(
    int iTab,
    COLORREF color = (COLORREF)-1);
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der Registerkarte.

*Farbe*<br/>
in Die festzulegende Farbe.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich; Andernfalls false.

##  <a name="settabbordersize"></a>Cmfcbasetabctrl:: settabbordersize

Legt eine neue Rahmengröße für das Registerkarten-Steuerelement fest.

```
virtual void SetTabBorderSize(
    int nTabBorderSize,
    BOOL bRepaint = TRUE);
```

### <a name="parameters"></a>Parameter

*nTabBorderSize*<br/>
in Die neue Rahmengröße in Pixel.

*bRepaint*<br/>
in Ein boolescher Parameter, der angibt, ob das Framework das Steuerelement neu zeichnet.

##  <a name="settabhicon"></a>Cmfcbasetabctrl:: settabhicon

Legt das Symbol für eine Registerkarten Bezeichnung fest.

```
virtual BOOL SetTabHicon(
    int iTab,
    HICON hIcon);
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index einer Registerkarte. Diese Methode ändert das Symbol für diese Registerkarte.

*hIcon*<br/>
in Ein Handle für ein Symbol.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

##  <a name="settabicon"></a>Cmfcbasetabctrl:: settabicon

Legt das Symbol für eine Registerkarte fest.

```
virtual BOOL SetTabIcon(
    int iTab,
    UINT uiIcon);
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der zu aktualisierenden Registerkarte.

*uiIcon*<br/>
in Die Symbol-ID für das neue Symbol. Diese ID verweist auf das interne [CImageList](../../mfc/reference/cimagelist-class.md) -Objekt.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

##  <a name="settabicononly"></a>Cmfcbasetabctrl:: settabicononly

Ermöglicht, dass auf einer bestimmten Registerkarte nur ein Symbol (und keine Text Bezeichnung) angezeigt wird.

```
virtual BOOL SetTabIconOnly(
    int iTab,
    BOOL bIconOnly = TRUE,
    BOOL bShowTooltipAlways = FALSE);
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der Registerkarte, die geändert werden soll.

*bIconOnly*<br/>
in Ein boolescher Parameter, der bestimmt, ob nur Symbole angezeigt werden sollen.

*bShowTooltipAlways*<br/>
in Ein boolescher Parameter, der bestimmt, ob das Framework Quick Infos für eine Registerkarten Bezeichnung anzeigt, die nur Symbole anzeigt.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Hinweise

Standardmäßig zeigt ein Registerkarten-Steuerelement das Symbol und die Text Bezeichnung für die einzelnen Registerkarten an.

##  <a name="settablabel"></a>Cmfcbasetabctrl:: settablabel

Legt den Text für eine Registerkarten Bezeichnung fest.

```
virtual BOOL SetTabLabel(
    int iTab,
    const CString& strLabel);
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der zu aktualisierenden Registerkarte.

*strLabel*<br/>
in Ein Verweis auf eine Zeichenfolge, die den neuen Text für die Registerkarten Bezeichnung enthält.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn erfolgreich; andernfalls 0.

##  <a name="settabsheight"></a>Cmfcbasetabctrl:: settabsheight

```
virtual void SetTabsHeight();
```

### <a name="remarks"></a>Hinweise

##  <a name="settabsorder"></a>Cmfcbasetabctrl:: settabsorder

Ordnet die Registerkarten in der angegebenen Reihenfolge an.

```
BOOL SetTabsOrder(const CArray<int,int>& arOrder);
```

### <a name="parameters"></a>Parameter

*arOrder*<br/>
in Ein Array von Null basierten Indizes, das die neue Aktivier Reihenfolge definiert.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich; Andernfalls fehlschlagen.

### <a name="remarks"></a>Hinweise

Die Größe des *arorder* -Arrays muss gleich der Anzahl der Registerkarten im Registerkarten-Steuerelement sein.

##  <a name="settabtextcolor"></a>Cmfcbasetabctrl:: settabtextcolor

Legt die Textfarbe für eine bestimmte Registerkarte fest.

```
virtual BOOL SetTabTextColor(
    int iTab,
    COLORREF color = (COLORREF)-1);
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der null basierte Index der Registerkarte.

*Farbe*<br/>
in Ein [COLORREF](/windows/win32/gdi/colorref) -Parameter, der die neue Textfarbe angibt.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn erfolgreich; andernfalls 0.

##  <a name="showtab"></a>Cmfcbasetabctrl:: showTab

Blendet die angegebene Registerkarte ein oder aus.

```
virtual BOOL ShowTab(
    int iTab,
    BOOL bShow = TRUE,
    BOOL bRecalcLayout = TRUE,
    BOOL bActivate = FALSE);
```

### <a name="parameters"></a>Parameter

*iTab*<br/>
in Der Index der Registerkarte, `ShowTab` die angezeigt oder ausgeblendet wird.

*bShow*<br/>
in Ein boolescher Parameter, der angibt, ob die Registerkarte angezeigt werden soll.

*bRecalcLayout*<br/>
in Ein boolescher Parameter, der angibt, ob das Fenster Layout sofort neu berechnet werden soll.

*bactivate*<br/>
in Ein boolescher Parameter, der angibt, ob die von *ITAB*angegebene Registerkarte ausgewählt werden soll.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Hinweise

Der Parameter *bactivate* gilt nur, wenn *bShow* den Wert true hat. Wenn *bactivate* den Wert true hat `ShowTab` und wenn erfolgreich `ShowTab` ist, sendet die Nachricht AFX_WM_CHANGE_ACTIVE_TAB an das übergeordnete Element des Registerkarten Fensters.

##  <a name="startrenametab"></a>Cmfcbasetabctrl:: startrenametab

```
virtual BOOL StartRenameTab(int iTab);
```

### <a name="parameters"></a>Parameter

[in] *iTab*<br/>

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

##  <a name="swaptabs"></a>Cmfcbasetabctrl:: Swap Tabs

```
virtual void SwapTabs(
    int nFisrtTabID,
    int nSecondTabID);
```

### <a name="parameters"></a>Parameter

[in] *nFisrtTabID*<br/>

in *nsecondtabid*<br/>

### <a name="remarks"></a>Hinweise

## <a name="see-also"></a>Siehe auch

[Hierarchiediagramm](../../mfc/hierarchy-chart.md)<br/>
[Klassen](../../mfc/reference/mfc-classes.md)<br/>
[CMFCTabCtrl-Klasse](../../mfc/reference/cmfctabctrl-class.md)<br/>
[CMFCOutlookBarTabCtrl-Klasse](../../mfc/reference/cmfcoutlookbartabctrl-class.md)
