---
title: CDC-Klasse | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: reference
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
dev_langs:
- C++
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 3e2f9edf2cdf6a0e462333224f3b8bd6d920fa2a
ms.sourcegitcommit: c6b095c5f3de7533fd535d679bfee0503e5a1d91
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/26/2018
ms.locfileid: "36954090"
---
# <a name="cdc-class"></a>CDC-Klasse
Definiert eine Klasse von Gerätekontextobjekten.  
  
## <a name="syntax"></a>Syntax  
  
```  
class CDC : public CObject  
```  
  
## <a name="members"></a>Member  
  
### <a name="public-constructors"></a>Öffentliche Konstruktoren  
  
|Name|Beschreibung|  
|----------|-----------------|  
|[CDC::CDC](#cdc)|Erstellt ein `CDC`-Objekt.|  
  
### <a name="public-methods"></a>Öffentliche Methoden  
  
|Name|Beschreibung|  
|----------|-----------------|  
|[CDC::AbortDoc](#abortdoc)|Beendet den aktuellen Druckauftrag, löschen Alles, was die Anwendung wurde seit dem letzten Aufruf von an das Gerät geschrieben die `StartDoc` Memberfunktion.|  
|[CDC::AbortPath](#abortpath)|Schließt und verwirft alle Pfade in den Gerätekontext.|  
|[CDC::AddMetaFileComment](#addmetafilecomment)|Kopiert den Kommentar aus einem Puffer in einem angegebenen EMF-Datei.|  
|[CDC::AlphaBlend](#alphablend)|Zeigt die Bitmaps, die transparent oder halbtransparenten Pixel haben.|  
|[CDC::AngleArc](#anglearc)|Liniensegment zeichnet einen Bogen, und die aktuelle Position in der Endpunkt des Bogens verschoben.|  
|[CDC::Arc](#arc)|Zeichnet einen elliptischen Bogen.|  
|[CDC::ArcTo](#arcto)|Zeichnet einen elliptischen Bogen. Diese Funktion ist vergleichbar mit `Arc`, außer dass die aktuelle Position aktualisiert wird.|  
|[CDC::Attach](#attach)|Fügt einen Windows-Gerätekontext dieser `CDC` Objekt.|  
|[CDC::BeginPath](#beginpath)|Öffnet eine Klammer Pfad in den Gerätekontext.|  
|[CDC::BitBlt](#bitblt)|Kopiert eine Bitmap aus einem angegebenen Gerätekontext.|  
|[CDC::Chord](#chord)|Zeichnet eine Sehne (eine geschlossene Form durch die Schnittmenge einer Ellipse und Liniensegment begrenzt).|  
|[CDC::CloseFigure](#closefigure)|Schließt eine offene Figur in einem Pfad.|  
|[CDC::CreateCompatibleDC](#createcompatibledc)|Erstellt einen Speicher-Gerätekontext, der mit einem anderen Gerätekontext kompatibel ist. Sie können zum Vorbereiten Images im Arbeitsspeicher.|  
|[CDC::CreateDC](#createdc)|Erstellt einen Gerätekontext für ein bestimmtes Gerät.|  
|[CDC::CreateIC](#createic)|Erstellt einen Informationskontext für ein bestimmtes Gerät. Dies bietet eine schnelle Möglichkeit, Informationen über das Gerät zu erhalten, ohne zu einen Gerätekontext erstellen.|  
|[CDC::DeleteDC](#deletedc)|Löscht das zugeordnete Windows-Gerätekontext `CDC` Objekt.|  
|[CDC::DeleteTempMap](#deletetempmap)|Wird aufgerufen, indem Sie die `CWinApp` -leerlaufzeithandler So löschen Sie temporäre `CDC` mit erstellte Objekt `FromHandle`. Auch trennt den Gerätekontext.|  
|[CDC::Detach](#detach)|Trennt den Windows-Gerätekontext aus diesem `CDC` Objekt.|  
|[CDC::DPtoHIMETRIC](#dptohimetric)|Konvertiert Geräteeinheiten in **HIMETRIC** Einheiten.|  
|[CDC::DPtoLP](#dptolp)|Geräteeinheiten konvertiert in logischen Einheiten.|  
|[CDC::Draw3dRect](#draw3drect)|Zeichnet eine dreidimensionale Rechteck.|  
|[CDC::DrawDragRect](#drawdragrect)|Löscht und zeichnet ein Rechteck, wie es gezogen wird.|  
|[CDC::DrawEdge](#drawedge)|Zeichnet die Ränder eines Rechtecks an.|  
|[CDC::DrawEscape](#drawescape)|Greift auf Zeichnen eine der Videoanzeige-Funktionen, die nicht direkt über die Graphics Device Interface (GDI) verfügbar sind.|  
|[CDC::DrawFocusRect](#drawfocusrect)|Zeichnet ein Rechteck im entsprechenden Stil verwendet, um den Fokus anzugeben.|  
|[CDC::DrawFrameControl](#drawframecontrol)|Zeichnen eines Bild-Steuerelements an.|  
|[CDC::DrawIcon](#drawicon)|Zeichnet ein Symbol an.|  
|[CDC::DrawState](#drawstate)|Zeigt ein Bild aus, und wendet ein visuellen Effekts um ein Zustand gekennzeichnet wird.|  
|[CDC::DrawText](#drawtext)|Zeichnet formatierten Text im angegebenen Rechteck.|  
|[CDC::DrawTextEx](#drawtextex)|Zeichnet formatierten Text im angegebenen Rechteck mit zusätzlichen Formaten.|  
|[CDC::Ellipse](#ellipse)|Zeichnet eine Ellipse.|  
|[CDC::EndDoc](#enddoc)|Beendet einen Druckauftrag gestartet, indem die `StartDoc` Memberfunktion.|  
|[CDC::EndPage](#endpage)|Informiert den Gerätetreiber, den eine Seite beendet wird.|  
|[CDC::EndPath](#endpath)|Schließt eine Klammer Pfad ein, und wählt den Pfad, der die schließende Klammer in den Gerätekontext definiert.|  
|[CDC::EnumObjects](#enumobjects)|Listet die Stifte und Pinsel verfügbar in einem Gerätekontext.|  
|[CDC::Escape](#escape)|Ermöglicht Anwendungen, Funktionen zuzugreifen, die nicht direkt von einem bestimmten Gerät über GDI verfügbar sind. Außerdem ermöglicht den Zugriff auf Windows-Escape-Funktionen. Escape-Aufrufe von einer Anwendung werden übersetzt und an den Gerätetreiber gesendet.|  
|[CDC::ExcludeClipRect](#excludecliprect)|Erstellt einen neuen Ausschneidebereich, der aus den vorhandenen Ausschneidebereich abzüglich des angegebenen Rechtecks besteht.|  
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Verhindert, dass ungültige Bereiche eines Fensters zeichnen, indem eine aktualisierte Region im Fenster von einem Ausschneidebereich ausgeschlossen.|  
|[CDC::ExtFloodFill](#extfloodfill)|Füllt einen Bereich mit der aktuellen Pinsel. Bietet mehr Flexibilität als die [CDC::FloodFill](#floodfill) Memberfunktion.|  
|[CDC::ExtTextOut](#exttextout)|Schreibt eine Zeichenfolge in einen rechteckigen Bereich mit der aktuell ausgewählten Schriftart an.|  
|[CDC::FillPath](#fillpath)|Schließt alle geöffneten Figuren im aktuellen Pfad und füllt den Pfad innere mithilfe des aktuellen Pinsel und Polygon füllenden Modus.|  
|[CDC::FillRect](#fillrect)|Füllt ein angegebenen Rechteck unter Verwendung eines bestimmten Pinsels.|  
|[CDC::FillRgn](#fillrgn)|Füllt eine bestimmte Region mit dem angegebenen Pinsel.|  
|[CDC::FillSolidRect](#fillsolidrect)|Füllt ein Rechteck mit einer Volltonfarbe aus.|  
|[CDC::FlattenPath](#flattenpath)|In den Pfad, in der aktuelle Gerätekontext ausgewählten Kurven transformiert und wandelt jede Kurve in einer Sequenz von Zeilen.|  
|[CDC::FloodFill](#floodfill)|Füllt einen Bereich mit der aktuellen Pinsel.|  
|[CDC::FrameRect](#framerect)|Zeichnet einen Rahmen um ein Rechteck.|  
|[CDC::FrameRgn](#framergn)|Zeichnet einen Rahmen um eine bestimmte Region Verwenden eines Pinsels.|  
|[CDC::FromHandle](#fromhandle)|Gibt einen Zeiger auf ein `CDC` Objekt, wenn ein Handle für einen Gerätekontext vorhanden. Wenn ein `CDC`-Objekt nicht an das Handle angefügt ist, wird ein temporäres `CDC`-Objekt erstellt und angefügt.|  
|[CDC::GetArcDirection](#getarcdirection)|Gibt die aktuelle Bogen Richtung für den Gerätekontext zurück.|  
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Ruft die Einstellung für den aktuellen Seitenverhältnis Filter ab.|  
|[CDC::GetBkColor](#getbkcolor)|Ruft die aktuelle Hintergrundfarbe ab.|  
|[CDC::GetBkMode](#getbkmode)|Ruft den Hintergrundmodus ab.|  
|[CDC::GetBoundsRect](#getboundsrect)|Gibt das aktuelle kumulierte umschließende Rechteck für den angegebenen Gerätekontext zurück.|  
|[CDC::GetBrushOrg](#getbrushorg)|Ruft den Ursprung des aktuellen Pinsels ab.|  
|[CDC::GetCharABCWidths](#getcharabcwidths)|Ruft die Breite in logischen Einheiten von aufeinander folgenden Zeichen in einem angegebenen Bereich aus der aktuellen Schriftart ab.|  
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Ruft die Breite in logischen Einheiten von aufeinander folgenden Glyphe Indizes in einem angegebenen Bereich aus der aktuellen TrueType-Schriftart ab.|  
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Ruft verschiedene Typen von Informationen zu einer Zeichenfolge ab.|  
|[CDC::GetCharWidth](#getcharwidth)|Ruft die Sekundenbruchteile Breite der aufeinander folgenden Zeichen in einem angegebenen Bereich aus der aktuellen Schriftart ab.|  
|[CDC::GetCharWidthI](#getcharwidthi)|Ruft die Breite in logischen Koordinaten von aufeinander folgenden Glyphe Indizes in einem angegebenen Bereich aus der aktuellen Schriftart ab.|  
|[CDC::GetClipBox](#getclipbox)|Ruft die Dimensionen des tightest umschließenden Rechtecks um den aktuellen Clipping Grenze ab.|  
|[CDC::GetColorAdjustment](#getcoloradjustment)|Ruft die Farbe Anpassungswerte für den Gerätekontext ab.|  
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Gibt einen Zeiger auf das derzeit ausgewählte `CBitmap` Objekt.|  
|[CDC::GetCurrentBrush](#getcurrentbrush)|Gibt einen Zeiger auf das derzeit ausgewählte `CBrush` Objekt.|  
|[CDC::GetCurrentFont](#getcurrentfont)|Gibt einen Zeiger auf das derzeit ausgewählte `CFont` Objekt.|  
|[CDC::GetCurrentPalette](#getcurrentpalette)|Gibt einen Zeiger auf das derzeit ausgewählte `CPalette` Objekt.|  
|[CDC::GetCurrentPen](#getcurrentpen)|Gibt einen Zeiger auf das derzeit ausgewählte `CPen` Objekt.|  
|[CDC::GetCurrentPosition](#getcurrentposition)|Ruft die aktuelle Position des Stifts (in logischen Koordinaten) ab.|  
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Ruft die aktuelle Pinselfarbe ab.|  
|[CDC::GetDCPenColor](#getdcpencolor)|Ruft die aktuelle Stiftfarbe ab.|  
|[CDC::GetDeviceCaps](#getdevicecaps)|Ruft eine angegebene Art von gerätespezifischen Informationen zu einem bestimmten Anzeigegerät Funktionen ab.|  
|[CDC::GetFontData](#getfontdata)|Ruft die Metrik Schriftartinformationen aus einer skalierbaren Schriftartdatei ab. Die abzurufenden Informationen wird durch Angeben eines Offsets in die Schriftartdatei und die Länge der zurückzugebenden Informationen identifiziert.|  
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Gibt Informationen zu den aktuell ausgewählten Schriftart für den angegebenen Anzeigekontext zurück.|  
|[CDC::GetGlyphOutline](#getglyphoutline)|Ruft die Gliederung Kurve oder eine Bitmap für eine Gliederung Zeichen in der aktuellen Schriftart ab.|  
|[CDC::GetGraphicsMode](#getgraphicsmode)|Ruft den aktuellen Graphics-Modus für den angegebenen Gerätekontext ab.|  
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Ruft einen Pinsel Rasterbild.|  
|[CDC::GetKerningPairs](#getkerningpairs)|Ruft das Zeichen kerning-Paare für die Schriftart, die den angegebenen Gerätekontext aktuell ausgewählt ist.|  
|[CDC::GetLayout](#getlayout)|Ruft das Layout für einen Gerätekontext (DC) ab. Das Layout kann werden entweder von links nach rechts (Standard) oder von rechts nach links (gespiegelten).|  
|[CDC::GetMapMode](#getmapmode)|Ruft den aktuellen Zuordnungsmodus ab.|  
|[CDC::GetMiterLimit](#getmiterlimit)|Gibt den Winkel Grenzwert für den Gerätekontext zurück.|  
|[CDC::GetNearestColor](#getnearestcolor)|Ruft die nächstgelegene logischen Farbe in der angegebenen logischen Farbe, die das angegebene Gerät darstellen kann.|  
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Ruft die Metrik Schriftartinformationen TrueType-Schriftarten.|  
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Ruft die Breite der einzelnen Zeichen in eine aufeinander folgende Gruppe von Zeichen aus der aktuellen Schriftart, die mit der Ausgabe-Gerätekontext ab.|  
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Berechnet die Breite und Höhe einer Zeichenfolge auf den Gerätekontext Ausgabe.|  
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Berechnet die Breite und Höhe einer Textzeile in der Ausgabe-Gerätekontext, der anhand der aktuellen Schriftart Dimensionen werden sollen.|  
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Ruft die Metriken für die aktuelle Schriftart aus der Ausgabe-Gerätekontext ab.|  
|[CDC::GetPath](#getpath)|Ruft die Koordinaten definieren die Endpunkte der Zeilen und die Steuerpunkte der Kurven im Pfad, der den Gerätekontext ausgewählt wurde gefunden.|  
|[CDC::GetPixel](#getpixel)|Ruft den RGB-Farbwert des Pixels an der angegebenen Position ab.|  
|[CDC::GetPolyFillMode](#getpolyfillmode)|Ruft den aktuellen Polygon Füllmodus ab.|  
|[CDC::GetROP2](#getrop2)|Ruft den aktuellen Zeichnungsmodus ab.|  
|[CDC::GetSafeHdc](#getsafehdc)|Gibt [CDC::m_hDC](#m_hdc), die Ausgabe-Gerätekontext.|  
|[CDC::GetStretchBltMode](#getstretchbltmode)|Ruft den aktuellen Modus Strecken einer Bitmap ab.|  
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Berechnet die Breite und Höhe einer Zeichenfolge auf den Gerätekontext Attribut.|  
|[CDC::GetTextAlign](#gettextalign)|Ruft die textausrichtung Flags ab.|  
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Ruft die aktuelle Einstellung für die Menge an Zeichenabstands ab.|  
|[CDC::GetTextColor](#gettextcolor)|Ruft die aktuelle Textfarbe ab.|  
|[CDC::GetTextExtent](#gettextextent)|Berechnet die Breite und Höhe einer Textzeile im Gerätekontext Attribut anhand der aktuellen Schriftart Dimensionen werden sollen.|  
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Ruft die Anzahl der Zeichen in einer angegebenen Zeichenfolge, die in einem angegebenen Raum zu passen, und füllt ein Array mit der Text-Block für jede dieser Zeichen ab.|  
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Ruft die Breite und Höhe des angegebenen Arrays von Glyphe Indizes.|  
|[CDC::GetTextFace](#gettextface)|Kopiert den Namen der aktuellen Schriftart in einen Puffer als Null-terminierte Zeichenfolge an.|  
|[CDC::GetTextMetrics](#gettextmetrics)|Ruft die Metriken für die aktuelle Schriftart aus den Gerätekontext Attribut ab.|  
|[CDC::GetViewportExt](#getviewportext)|Ruft die x und y-Blöcke des Viewports ab.|  
|[CDC::GetViewportOrg](#getviewportorg)|Ruft den x- und y-Koordinaten des Ursprungs Viewport ab.|  
|[CDC::GetWindow](#getwindow)|Gibt das Fenster den Anzeigekontext für das Gerät zugeordnet.|  
|[CDC::GetWindowExt](#getwindowext)|Ruft die x und y-Blöcke von das zugeordnete Fenster ab.|  
|[CDC::GetWindowOrg](#getwindoworg)|Ruft den x- und y-Koordinaten des Ursprungs der das zugeordnete Fenster ab.|  
|[CDC::GetWorldTransform](#getworldtransform)|Ruft den aktuellen World Speicherplatz Seite Speicherplatz Transformation ab.|  
|[CDC::GradientFill](#gradientfill)|Füllt Rechteck und Dreieck Strukturen mit einer gradating aus.|  
|[CDC::GrayString](#graystring)|Zeichnet abgeblendet (grau) Text an der angegebenen Position.|  
|[CDC::HIMETRICtoDP](#himetrictodp)|Konvertiert **HIMETRIC** Einheiten in Geräteeinheiten.|  
|[CDC::HIMETRICtoLP](#himetrictolp)|Konvertiert **HIMETRIC** Einheiten in logischen Einheiten.|  
|[CDC::IntersectClipRect](#intersectcliprect)|Erstellt einen neuen Ausschneidebereich durch, die die Schnittmenge der aktuellen Region und ein Rechteck bilden.|  
|[CDC::InvertRect](#invertrect)|Invertiert den Inhalt eines Rechtecks an.|  
|[CDC::InvertRgn](#invertrgn)|Invertiert die Farben in einer Region an.|  
|[CDC::IsPrinting](#isprinting)|Bestimmt, ob das Gerätekontext für das Drucken verwendet wird.|  
|[CDC::LineTo](#lineto)|Zeichnet eine Linie von der aktuellen Position bis zur, aber nicht einschließlich, einen Punkt an.|  
|[CDC::LPtoDP](#lptodp)|Logische Einheiten konvertiert in Geräteeinheiten.|  
|[CDC::LPtoHIMETRIC](#lptohimetric)|Konvertiert die logische Einheiten in **HIMETRIC** Einheiten.|  
|[CDC::MaskBlt](#maskblt)|Kombiniert die Farbdaten für die Quell- und Zielschemas Bitmaps, die unter Verwendung der angegebenen Maske und auszuführenden Vorgangs an.|  
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Ändert die globale Transformation für einen Gerätekontext, der mit dem angegebenen Zugriffsmodus.|  
|[CDC::MoveTo](#moveto)|Verschiebt die aktuelle Position.|  
|[CDC::OffsetClipRgn](#offsetcliprgn)|Verschiebt den Ausschneidebereich für das angegebene Gerät.|  
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Ändert den Ursprung des Ausschnitts relativ zu den Koordinaten des Ursprungs des aktuellen Viewport an.|  
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Ändert den Fensterursprung relativ zu den Koordinaten des Ursprungs des aktuellen Fensters.|  
|[CDC::PaintRgn](#paintrgn)|Füllt einen Bereich mit der ausgewählte Pinsel.|  
|[CDC::PatBlt](#patblt)|Erstellt ein Bitmuster an.|  
|[CDC::Pie](#pie)|Zeichnet einen kreisförmigen Keil an.|  
|[CDC::PlayMetaFile](#playmetafile)|Gibt den Inhalt der angegebenen Metadatei auf dem angegebenen Gerät an. Die erweiterte Version des `PlayMetaFile` zeigt das Bild in der angegebenen EMF-Datei gespeichert. Die Metadatei kann oft wiedergegeben werden.|  
|[CDC::PlgBlt](#plgblt)|Führt einen Bitblocktransfer der Farbdaten Bits auf das angegebene Rechteck, in dem Quellgerätekontext an der angegebenen Parallelogramm in den angegebenen Gerätekontext aus.|  
|[CDC::PolyBezier](#polybezier)|Zeichnet eine oder mehrere Bzier Splines an. Die aktuelle Position ist weder verwendet noch aktualisiert.|  
|[CDC::PolyBezierTo](#polybezierto)|Zeichnet eine oder mehrere Bzier Splines und verschiebt die aktuelle Position auf dem Endpunkt des letzten Bzier Splines.|  
|[CDC::PolyDraw](#polydraw)|Zeichnet eine Reihe von Liniensegmenten und Bzier Splines an. Diese Funktion aktualisiert die derzeitige Position.|  
|[CDC::Polygon](#polygon)|Zeichnet ein Vieleck, bestehend aus zwei oder mehr Punkten (Scheitelpunkte) durch Linien verbunden sind.|  
|[CDC::Polyline](#polyline)|Zeichnet eine Reihe von Liniensegmenten, die zwischen den angegebenen Punkten.|  
|[CDC::PolylineTo](#polylineto)|Zeichnet eine oder mehrere gerade Linien und die aktuelle Position bis zum Endpunkt der letzten Zeile bewegt.|  
|[CDC::PolyPolygon](#polypolygon)|Erstellt zwei oder mehr Polygone, die mit den aktuellen Polygon Füllmodus gefüllt werden. Die Polygone zusammenhanglosen werden, oder sie überlappen.|  
|[CDC::PolyPolyline](#polypolyline)|Zeichnet mehrere Reihen von verbundenen Liniensegmenten. Die aktuelle Position ist weder verwendet noch von dieser Funktion aktualisiert.|  
|[CDC::PtVisible](#ptvisible)|Gibt an, ob der angegebene Punkt innerhalb des Clippingbereichs liegt.|  
|[CDC::RealizePalette](#realizepalette)|Der Systempalette Paletteneinträge in der aktuellen logische Palette zugeordnet.|  
|[CDC::Rectangle](#rectangle)|Zeichnet ein Rechteck mit dem aktuellen Stift und füllt sie mit dem aktuellen Pinsel.|  
|[CDC::RectVisible](#rectvisible)|Bestimmt, ob eines beliebigen Teils des angegebenen Rechteck innerhalb des Clippingbereichs liegt.|  
|[CDC::ReleaseAttribDC](#releaseattribdc)|Versionen `m_hAttribDC`, den Gerätekontext Attribut.|  
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Versionen `m_hDC`, die Ausgabe-Gerätekontext.|  
|[CDC::ResetDC](#resetdc)|Updates der `m_hAttribDC` Gerätekontext.|  
|[CDC::RestoreDC](#restoredc)|Stellt den Gerätekontext in einen früheren Zustand gespeichert, die mit `SaveDC`.|  
|[CDC::RoundRect](#roundrect)|Zeichnet ein Rechteck mit abgerundeten Ecken der aktuellen Stift verwenden und mit dem aktuellen Pinsel gefüllt.|  
|[CDC::SaveDC](#savedc)|Speichert den aktuellen Zustand des Gerätekontexts.|  
|[CDC::ScaleViewportExt](#scaleviewportext)|Ändert das Ausmaß der Viewport relativ zum aktuellen Werte.|  
|[CDC::ScaleWindowExt](#scalewindowext)|Ändert die Blöcke Fenster relativ zum aktuellen Werte.|  
|[CDC::ScrollDC](#scrolldc)|Scrollt durch ein Rechteck von Bits, horizontal und vertikal.|  
|[CDC::SelectClipPath](#selectclippath)|Wählt den aktuellen Pfad als einen Ausschneidebereich für den Gerätekontext, kombinieren die neue Region mit einer beliebigen vorhandenen Clipping Region unter Verwendung des angegebenen Modus.|  
|[CDC::SelectClipRgn](#selectcliprgn)|Kombiniert die angegebene Region mit den aktuellen Ausschneidebereich unter Verwendung des angegebenen Modus.|  
|[CDC::SelectObject](#selectobject)|Markiert ein zeichnen GDI-Objekt, z. B. eines Stiftes an.|  
|[CDC::SelectPalette](#selectpalette)|Wählt die logische Palette an.|  
|[CDC::SelectStockObject](#selectstockobject)|Wählt einen der vordefinierten stock Stifte, Pinsel oder von Windows bereitgestellten Schriftarten.|  
|[CDC::SetAbortProc](#setabortproc)|Legt eine Programmierer bereitgestellte Rückruffunktion, die von Windows aufgerufen, wenn Sie ein Druckauftrag abgebrochen werden muss.|  
|[CDC::SetArcDirection](#setarcdirection)|Legt die Richtung die Zeichnung für Bogen und Rechteck Funktionen verwendet werden.|  
|[CDC::SetAttribDC](#setattribdc)|Legt `m_hAttribDC`, den Gerätekontext Attribut.|  
|[CDC::SetBkColor](#setbkcolor)|Legt die aktuelle Hintergrundfarbe fest.|  
|[CDC::SetBkMode](#setbkmode)|Legt den Hintergrundmodus.|  
|[CDC::SetBoundsRect](#setboundsrect)|Steuert die Kumulation umgebende Rechteck Informationen für den angegebenen Gerätekontext.|  
|[CDC::SetBrushOrg](#setbrushorg)|Gibt die Ursprungsdomäne für den nächsten Pinsel einen Gerätekontext ausgewählt.|  
|[CDC::SetColorAdjustment](#setcoloradjustment)|Legt die Farbe Anpassungswerte für den Gerätekontext, der mit den angegebenen Werten.|  
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Legt die aktuelle Pinselfarbe.|  
|[CDC::SetDCPenColor](#setdcpencolor)|Legt die aktuelle Stiftfarbe.|  
|[CDC::SetGraphicsMode](#setgraphicsmode)|Legt den aktuellen Graphics-Modus für den angegebenen Gerätekontext.|  
|[CDC::SetLayout](#setlayout)|Ändert das Layout für einen Gerätekontext (DC).|  
|[CDC::SetMapMode](#setmapmode)|Legt die aktuelle Zuordnungsmodus fest.|  
|[CDC::SetMapperFlags](#setmapperflags)|Ändert den Algorithmus, den die Schriftartenmapper verwendet, wenn es logische Schriftarten physischen Schriftarten zugeordnet.|  
|[CDC::SetMiterLimit](#setmiterlimit)|Legt das Limit für die Länge des gehrungsverbindungen für den Gerätekontext.|  
|[CDC::SetOutputDC](#setoutputdc)|Legt `m_hDC`, die Ausgabe-Gerätekontext.|  
|[CDC::SetPixel](#setpixel)|Legt das Pixel am angegebenen Punkt auf diesem am ehesten der angegebenen Farbe.|  
|[CDC::SetPixelV](#setpixelv)|Legt das Pixel an den angegebenen Koordinaten auf diesem am ehesten der angegebenen Farbe. `SetPixelV` ist schneller als `SetPixel` , da er nicht den Farbwert des Punkts tatsächlich gezeichnet zurückgeben muss.|  
|[CDC::SetPolyFillMode](#setpolyfillmode)|Legt den Modus Polygon füllen.|  
|[CDC::SetROP2](#setrop2)|Legt den aktuellen Zeichnungsmodus fest.|  
|[CDC::SetStretchBltMode](#setstretchbltmode)|Legt den Modus zum Strecken einer Bitmap.|  
|[CDC::SetTextAlign](#settextalign)|Legt die textausrichtung Flags.|  
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Legt den Zeitraum des Zeichenabstands fest.|  
|[CDC::SetTextColor](#settextcolor)|Legt die Textfarbe fest.|  
|[CDC::SetTextJustification](#settextjustification)|Speicherplatz und Zeilenumbruchzeichen unverändert in einer Zeichenfolge hinzugefügt.|  
|[CDC::SetViewportExt](#setviewportext)|Legt die x und y-Blöcke des Viewports an.|  
|[CDC::SetViewportOrg](#setviewportorg)|Legt den Ursprung des Viewports an.|  
|[CDC::SetWindowExt](#setwindowext)|Legt die x und y-Blöcke von das zugeordnete Fenster fest.|  
|[CDC::SetWindowOrg](#setwindoworg)|Legt den Fensterursprung des Gerätekontexts fest.|  
|[CDC::SetWorldTransform](#setworldtransform)|Legt den aktuellen World-Speicherplatz auf Seite Speicherplatz Transformation fest.|  
|[CDC::StartDoc](#startdoc)|Informiert den Gerätetreiber, den ein neuer Druckauftrag gestartet wird.|  
|[CDC::StartPage](#startpage)|Informiert den Gerätetreiber, den eine neue Seite gestartet wird.|  
|[CDC::StretchBlt](#stretchblt)|Verschiebt eine Bitmap aus einem Quellrechteck und das Gerät in ein Zielrechteck, Strecken oder komprimieren die Bitmap, soweit erforderlich, um die Maße des Zielrechtecks zu passen.|  
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Schließt alle geöffneten Figuren in einem Pfad, die Gliederung des Pfads mit dem aktuellen Stift eintritt und füllt mit der aktuellen Pinsel inneren.|  
|[CDC::StrokePath](#strokepath)|Rendert den angegebenen Pfad mit der aktuellen Stift.|  
|[CDC::TabbedTextOut](#tabbedtextout)|Schreibt eine Zeichenfolge an einer angegebenen Position, Registerkarten erweitern, um die Werte in einem Array von Tabstopp Positionen angegeben.|  
|[CDC::TextOut](#textout)|Schreibt eine Zeichenfolge an einer angegebenen Position, die mit der aktuell ausgewählten Schriftart an.|  
|[CDC::TransparentBlt](#transparentblt)|Übertragen einen Farbe Bit-Datenblock aus dem angegebenen Quellgerätekontext einen Gerätekontext Ziel, das eine angegebene Farbe in die Übertragung transparent zu rendern.|  
|[CDC::UpdateColors](#updatecolors)|Updates des Clientbereichs der Systempalette regelmäßig x Pixel mit den Clientbereich des Gerätekontexts durch Vergleich den aktuellen Farben.|  
|[CDC::WidenPath](#widenpath)|Definiert den aktuellen Pfad als der Bereich, der gezeichnet werden würde, wenn der Pfad mit dem aktuell ausgewählten den Gerätekontext Stift gezeichnet wurden.|  
  
### <a name="public-operators"></a>Öffentliche Operatoren  
  
|Name|Beschreibung|  
|----------|-----------------|  
|[CDC::Operator HDC](#operator_hdc)|Ruft das Handle für den Gerätekontext ab.|  
  
### <a name="public-data-members"></a>Öffentliche Datenmember  
  
|Name|Beschreibung|  
|----------|-----------------|  
|[CDC::m_hAttribDC](#m_hattribdc)|Die Attribut-Gerätekontext verwendete `CDC` Objekt.|  
|[CDC::m_hDC](#m_hdc)|Die Ausgabe-Gerätekontext verwendet, die von diesem `CDC` Objekt.|  
  
## <a name="remarks"></a>Hinweise  
 Die `CDC` Objekt bietet Memberfunktionen zum Arbeiten mit einem Gerätekontext, z. B. ein Bildschirm oder Drucker als auch Mitglieder für die Arbeit mit einen Anzeigekontext, das den Clientbereich eines Fensters zugeordnet.  
  
 Führen Sie über das Element alle Zeichnungen Funktionen von einer `CDC` Objekt. Die Klasse bietet Memberfunktionen für Gerätekontext Vorgänge, arbeiten mit Zeichentools, typsichere Graphics Device Interface (GDI)-Objektauswahl und Arbeiten mit Farben und Paletten. Sie bietet außerdem Memberfunktionen zum Abrufen und festlegen, die Attribute, Zuordnen von und Arbeiten mit den Viewport, arbeiten mit Fenster soweit, Konvertieren von Koordinaten, arbeiten mit Regionen, Clipping, Zeichnen von Linien und Zeichnen von Formen der einfachen, Ellipsen, zeichnen und Polygone. Memberfunktionen dienen außerdem zum Zeichnen von Text, arbeiten mit Schriftarten, Drucker Escapezeichen verwenden, Durchführen eines Bildlaufs und Wiedergeben von Metadateien.  
  
 Verwenden einer `CDC` Objekt, erstellen es und klicken Sie dann seine Memberfunktionen aufrufen, die Windows-Funktionen, mit denen Gerätekontexte für parallele.  
  
> [!NOTE]
>  Unter Windows 95-und Windows 98 sind alle Bildschirmkoordinaten auf 16 Bits beschränkt. Aus diesem Grund eine **Int** übergeben, um eine `CDC` Member-Funktion muss im Bereich zwischen-32768 und 32767 liegen.  
  
 Für einen bestimmten Verwendungszweck bietet die Microsoft Foundation Class-Bibliothek mehrere Klassen abgeleitet `CDC` . `CPaintDC` Aufrufe kapselt `BeginPaint` und `EndPaint`. `CClientDC` verwaltet einen Anzeigekontext Clientbereich eines Fensters zugeordnet. `CWindowDC` verwaltet einen Anzeigekontext eine gesamte Fenster, einschließlich der Frame und Steuerelemente zugeordnet. `CMetaFileDC` Ordnet eine Metadatei einen Gerätekontext.  
  
 `CDC` stellt zwei Memberfunktionen [GetLayout](#getlayout) und [SetLayout](#setlayout), für die Umkehrung des Layouts für einen Gerätekontext, der nicht das zugehörige Layout von einem Fenster erbt. Solche Ausrichtung von rechts nach links ist für Anwendungen, die geschrieben werden, wenn in Kulturen, z. B. Arabisch oder Hebräisch, wenn das Zeichen Layout keine Europäischen Standard ist erforderlich.  
  
 `CDC` enthält zwei Gerätekontexte [M_hDC](#m_hdc) und [M_hAttribDC](#m_hattribdc), das bei der Erstellung der ein `CDC` -Objekt, beziehen sich auf demselben Gerät. `CDC` leitet alle Ausgabe GDI-Aufrufe an `m_hDC` und die meisten Attribut GDI-Aufrufe von `m_hAttribDC`. (Ein Beispiel für ein Attributaufruf ist `GetTextColor`, während `SetTextColor` ist ein Output-Aufruf.)  
  
 Z. B. das Framework verwendet diese zwei Gerätekontexte zum Implementieren einer `CMetaFileDC` -Objekt, das Ausgabe an eine Metadatei, beim Lesen der Attribute eines physischen Geräts gesendet wird. Seitenansicht wird im Framework auf ähnliche Weise implementiert. Sie können auch in den anwendungsspezifischen Code die zwei Gerätekontexte auf ähnliche Weise verwenden.  
  
 Es gibt Situationen, wenn Sie möglicherweise Text Metrik Informationen sowohl benötigen, die `m_hDC` und `m_hAttribDC` Gerätekontexte. Die folgenden Paare von Funktionen bieten diese Funktion:  
  
|M_hAttribDC verwendet|M_hDC verwendet|  
|-----------------------|-----------------|  
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|  
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|  
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|  
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|  
  
 Weitere Informationen zu `CDC`, finden Sie unter [Gerätekontexte](../../mfc/device-contexts.md).  
  
## <a name="inheritance-hierarchy"></a>Vererbungshierarchie  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 `CDC`  
  
## <a name="requirements"></a>Anforderungen  
 **Header:** afxwin.h  
  
##  <a name="abortdoc"></a>  CDC::AbortDoc  
 Beendet den aktuellen Auftrag und löscht alle Elemente die Anwendung wurde seit dem letzten Aufruf von an das Gerät geschrieben der [StartDoc](#startdoc) Memberfunktion.  
  
```  
int AbortDoc();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Wert größer als oder gleich 0, wenn erfolgreich, oder einen negativen Wert, wenn ein Fehler aufgetreten ist. Die folgende Liste enthält häufig auftretende Fehlerwerte und ihre Bedeutung:  
  
- **SP_ERROR** allgemeiner Fehler.  
  
- **SP_OUTOFDISK** nicht genügend freier Speicherplatz steht zurzeit zum Spoolen und keinen Speicherplatz mehr zur Verfügung gestellt.  
  
- **SP_OUTOFMEMORY** ist nicht genügend Arbeitsspeicher zum Spoolen verfügbar.  
  
- **SP_USERABORT** wurde vom Benutzer beendet des Auftrags über den Druck-Manager.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion ersetzt die `ABORTDOC` Drucker Escapezeichen.  
  
 `AbortDoc` sollte verwendet werden, um Folgendes zu beenden:  
  
-   Drucken-Vorgänge, die eine Abort-Funktion verwendet keine angeben [SetAbortProc](#setabortproc).  
  
-   Drucken-Vorgänge, die ihre erste noch nicht erreicht hat **NEWFRAME** oder **NEXTBAND** Aufruf mit Escapezeichen versehen.  
  
 Wenn eine Anwendung einen drucken oder einen abgebrochenen Druckvorgang auftritt, muss er nicht versuchen, den Vorgang zu beenden, indem Sie entweder die [EndDoc](#enddoc) oder `AbortDoc` Memberfunktionen der Klasse `CDC`. GDI wird automatisch den Vorgang vor der Rückgabe des Fehlerwert beendet.  
  
 Wenn ein Dialogfeld, damit der Benutzer den Druckvorgang abbrechen kann von die Anwendung angezeigt wird, rufen sie `AbortDoc` vor dem Zerstören des Dialogfelds.  
  
 Wenn der Druck-Manager verwendet wurde, starten Sie den Druckauftrag, Aufrufen `AbortDoc` löscht den gesamten Spool-Auftrag – erhält der Drucker nichts. Wenn der Druck-Manager nicht verwendet wurde, um den Druckauftrag zu starten, die Daten möglicherweise gesendet wurden an den Drucker vor `AbortDoc` aufgerufen wurde. In diesem Fall der Druckertreiber würde den Drucker (wenn möglich) zurückgesetzt und den Druckauftrag geschlossen.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CDC::StartDoc](#startdoc).  
  
##  <a name="abortpath"></a>  CDC::AbortPath  
 Schließt und verwirft alle Pfade in den Gerätekontext.  
  
```  
BOOL AbortPath();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Wenn eine Klammer offenen Pfad in den Gerätekontext vorhanden ist, wird die Pfad-Klammer wird geschlossen, und der Pfad wird verworfen. Wenn in den Gerätekontext ein geschlossener Pfad vorhanden ist, wird der Pfad verworfen.  
  
##  <a name="addmetafilecomment"></a>  CDC::AddMetaFileComment  
 Kopiert den Kommentar aus einem Puffer in einem angegebenen EMF-Datei.  
  
```  
BOOL AddMetaFileComment(
    UINT nDataSize,  
    const BYTE* pCommentData);
```  
  
### <a name="parameters"></a>Parameter  
 *nDataSize*  
 Gibt die Länge des Puffers Kommentar in Bytes an.  
  
 *pCommentData*  
 Verweist auf den Puffer, der den Kommentar enthält.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Ein Kommentar kann private Informationen enthalten – z. B. die Quelle des Bilds und das Datum erstellt wurde. Ein Kommentar sollte mit einer Anwendungssignatur, gefolgt von den Daten beginnen. Kommentare dürfen keine Position-spezifische Daten enthalten. Position-spezifische Daten gibt den Speicherort eines Datensatzes, und sie darf nicht enthalten sein, da eine Metadatei in einem anderen Metadatei eingebettet werden kann. Diese Funktion kann nur mit Metadateien verwendet werden.  
  
##  <a name="alphablend"></a>  CDC::AlphaBlend  
 Rufen Sie diese Memberfunktion zum Anzeigen von Bitmaps, die transparent oder halbtransparenten Pixel haben.  
  
```  
BOOL AlphaBlend(
    int xDest,  
    int yDest,  
    int nDestWidth,  
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    BLENDFUNCTION blend);
```  
  
### <a name="parameters"></a>Parameter  
 *xDest*  
 Gibt die X-Koordinate, in logischen Einheiten, die von der linken oberen Ecke des Zielrechtecks an.  
  
 *yDest*  
 Gibt die y-Koordinate, in logischen Einheiten, die von der linken oberen Ecke des Zielrechtecks an.  
  
 *nDestWidth*  
 Gibt die Breite in logischen Einheiten des Zielrechtecks an.  
  
 *nDestHeight*  
 Gibt die Höhe in logischen Einheiten des Zielrechtecks an.  
  
 *pSrcDC*  
 Ein Zeiger auf dem Quellgerätekontext.  
  
 *xSrc*  
 Gibt die X-Koordinate, in logischen Einheiten, die von der linken oberen Ecke des Quellrechtecks an.  
  
 *ySrc*  
 Gibt die y-Koordinate, in logischen Einheiten, die von der linken oberen Ecke des Quellrechtecks an.  
  
 *nSrcWidth*  
 Gibt die Breite in logischen Einheiten des Quellrechtecks an.  
  
 *nSrcHeight*  
 Gibt die Höhe in logischen Einheiten des Quellrechtecks an.  
  
 *blend*  
 Gibt eine [BLENDFUNCTION](http://msdn.microsoft.com/library/windows/desktop/dd183393) Struktur.  
  
### <a name="return-value"></a>Rückgabewert  
 **"True"** Wenn erfolgreich; andernfalls **"false"**.  
  
### <a name="remarks"></a>Hinweise  
 Finden Sie unter [AlphaBlend](http://msdn.microsoft.com/library/windows/desktop/dd183351) in das Windows SDK für Weitere Informationen.  
  
##  <a name="anglearc"></a>  CDC::AngleArc  
 Zeichnet ein Liniensegment und einen Bogen.  
  
```  
BOOL AngleArc(
    int x,  
    int y,  
    int nRadius,  
    float fStartAngle,  
    float fSweepAngle);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate für den Mittelpunkt des Kreises.  
  
 *y*  
 Gibt die logische y-Koordinate für den Mittelpunkt des Kreises.  
  
 *nRadius*  
 Gibt den Radius des Kreises in logischen Einheiten. Dieser Wert muss positiv sein.  
  
 *fStartAngle*  
 Gibt den Anfangswinkel in Grad relativ zu der x-Achse an.  
  
 *fSweepAngle*  
 Der mittelpunktswinkel angibt in Grad relativ zu den Anfangswinkel.  
  
### <a name="return-value"></a>Rückgabewert  
 Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).  
  
### <a name="remarks"></a>Hinweise  
 Liniensegments wird von der aktuellen Position am Anfang des Bogens gezeichnet. Der Bogen gezeichnet wird entlang der Umkreis eines Kreises mit dem angegebenen Radius und Center. Die Länge des Bogens wird durch den angegebenen Start- und Sweep Winkeln definiert.  
  
 `AngleArc` Verschiebt die aktuelle Position auf dem Endpunkt des Bogens an. Der Bogen gezeichnet wird, die von dieser Funktion möglicherweise elliptischen, abhängig von der aktuellen Transformation und Zuordnung-Modus werden angezeigt. Vor dem Zeichnen des Bogens, zeichnet diese Funktion von der aktuellen Position Liniensegments auf den Anfang des Bogens an. Der Bogen gezeichnet wird durch das Erstellen eines imaginären Kreis mit den angegebenen Radius angegebenen Mittelpunkt. Der Anfangspunkt des Bogens wird durch das Messen der gegen den Uhrzeigersinn von der x-Achse des Kreises die Gradzahl in der Startwinkel bestimmt. Der Endpunkt wird der Speicherort auf ähnliche Weise am Anfangspunkt durch die Anzahl der in der mittelpunktswinkel Grad gegen den Uhrzeigersinn gedreht messen.  
  
 Wenn der mittelpunktswinkel von 360 Grad übersteigt ist der Bogen mehrmals überflüssig. Diese Funktion zeichnet Linien mit den aktuellen Stift. In der Abbildung ist nicht ausgefüllt.  
  
##  <a name="arc"></a>  CDC::ARC  
 Zeichnet einen elliptischen Bogen.  
  
```  
BOOL Arc(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Arc(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Parameter  
 *x1*  
 Gibt die X-Koordinate des der oberen linken Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *y1*  
 Gibt die y-Koordinate des der oberen linken Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *x2*  
 Gibt die X-Koordinate des der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *Y2*  
 Gibt die y-Koordinate des der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *x3*  
 Gibt an, dass die X-Koordinate des Punktes, der den Bogen definiert (in logischen Einheiten) Anfangspunkt des. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *Y3*  
 Gibt an, der die y-Koordinate des Punktes, der den Bogen definiert (in logischen Einheiten) Anfangspunkt des. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *X4*  
 Gibt die X-Koordinate des Punktes, der den Bogen-Endpunkt (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *Y4*  
 Gibt die y-Koordinate des Punktes, der den Bogen-Endpunkt (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *lpRect*  
 Gibt das umschließende Rechteck (in logischen Einheiten) an. Übergeben Sie entweder ein `LPRECT` oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.  
  
 *ptStart*  
 Gibt an, dass die x- und y-Koordinaten des Punkts, der den Bogen definiert (in logischen Einheiten) Anfangspunkt des. Dieser Punkt muss nicht genau auf den Bogen liegen. Übergeben Sie entweder eine [Punkt](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.  
  
 *ptEnd*  
 Gibt die x- und y-Koordinaten des Punkts, der den Bogen-Endpunkt (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau auf den Bogen liegen. Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der Bogen gezeichnet wird, mithilfe der Funktion ist ein Segment der Ellipse, die durch den angegebenen umschließendes Rechteck definiert ist.  
  
 Die tatsächliche Anfangspunkt des Bogens ist der Punkt, an dem ein Strahl von der Mitte des umschließenden Rechtecks über den angegebenen Anfangspunkt, an die Ellipse überschneidet. Die tatsächliche Endpunkt des Bogens ist der Punkt, an dem ein Strahl vom Mittelpunkt des umschließenden Rechtecks über den angegebenen Endpunkt Ellipse überschneidet. Der Bogen gezeichnet wird gegen den Uhrzeigersinn. Da ein Bogen keine geschlossene Form ist, wird er nicht ausgefüllt. Sowohl die Breite und Höhe des Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]  
  
##  <a name="arcto"></a>  CDC::ArcTo  
 Zeichnet einen elliptischen Bogen.  
  
```  
BOOL ArcTo(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL ArcTo(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Parameter  
 *x1*  
 Gibt die X-Koordinate des der oberen linken Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *y1*  
 Gibt die y-Koordinate des der oberen linken Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *x2*  
 Gibt die X-Koordinate des der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *Y2*  
 Gibt die y-Koordinate des der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *x3*  
 Gibt an, dass die X-Koordinate des Punktes, der den Bogen definiert (in logischen Einheiten) Anfangspunkt des. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *Y3*  
 Gibt an, der die y-Koordinate des Punktes, der den Bogen definiert (in logischen Einheiten) Anfangspunkt des. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *X4*  
 Gibt die X-Koordinate des Punktes, der den Bogen-Endpunkt (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *Y4*  
 Gibt die y-Koordinate des Punktes, der den Bogen-Endpunkt (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *lpRect*  
 Gibt das umschließende Rechteck (in logischen Einheiten) an. Sie können entweder einen Zeiger zu übergeben, eine [RECT](../../mfc/reference/rect-structure1.md) Datenstruktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.  
  
 *ptStart*  
 Gibt an, dass die x- und y-Koordinaten des Punkts, der den Bogen definiert (in logischen Einheiten) Anfangspunkt des. Dieser Punkt muss nicht genau auf den Bogen liegen. Übergeben Sie entweder eine [Punkt](../../mfc/reference/point-structure1.md) Datenstruktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.  
  
 *ptEnd*  
 Gibt die x- und y-Koordinaten des Punkts, der den Bogen-Endpunkt (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau auf den Bogen liegen. Übergeben Sie entweder eine **Punkt** Datenstruktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Diese Funktion ist vergleichbar mit `CDC::Arc`, außer dass die aktuelle Position aktualisiert wird. Die Punkte ( *X1*, *y1*) und ( *X2*, *y2*) des umschließenden Rechtecks angeben. Eine Ellipse, die durch das angegebene umschließende Rechteck gebildet definiert die Kurve des Bogens. Der Bogen erweitert gegen den Uhrzeigersinn gedreht (die Standardeinstellung Bogen Richtung) an dem Punkt, an dem sie die radiale Linie von der Mitte des umschließenden Rechtecks, schneidet ( *X3*, *y3*). Der Bogen endet, wo es die radiale Linie von der Mitte des umschließenden Rechtecks, überlappt ( *X4*, *y4*). Wenn Sie den Startpunkt und Endpunkt identisch sind, wird eine vollständige Ellipse gezeichnet.  
  
 Eine Linie wird von der aktuellen Position zum Anfangspunkt des Bogens gezeichnet. Wenn kein Fehler auftritt, wird die aktuelle Position bis zum Endpunkt des Bogens festgelegt. Der Bogen gezeichnet wird, mit dem aktuellen Stift; Es wird nicht ausgefüllt.  
  
##  <a name="attach"></a>  CDC::Attach  
 Verwenden Sie diese Memberfunktion für die Verbindung ein *hDC* auf die `CDC` Objekt.  
  
```  
BOOL Attach(HDC hDC);
```  
  
### <a name="parameters"></a>Parameter  
 *hDC*  
 Ein Windows-Gerätekontext.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Die *hDC* befindet sich in beiden `m_hDC`, den Gerätekontext Ausgabe, und klicken Sie in `m_hAttribDC`, den Gerätekontext Attribut.  
  
##  <a name="beginpath"></a>  CDC:: beginpath  
 Öffnet eine Klammer Pfad in den Gerätekontext.  
  
```  
BOOL BeginPath();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Nachdem eine Klammer Pfad geöffnet ist, kann eine Anwendung beginnen aufrufen GDI Zeichnen von Funktionen, um die Punkte, die sich im Pfad zu definieren. Eine Anwendung kann Klammer einer offenen Pfad durch Aufrufen der `EndPath` Memberfunktion. Wenn eine Anwendung ruft `BeginPath`, alle vorherigen Pfade werden verworfen.  
  
 Finden Sie unter [BeginPath](http://msdn.microsoft.com/library/windows/desktop/dd183363) in das Windows SDK für eine Liste der Zeichnen-Funktionen, die Punkte in einem Pfad zu definieren.  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]  
  
##  <a name="bitblt"></a>  CDC:: BitBlt  
 Kopiert eine Bitmap aus dem Quellgerätekontext für diese aktuelle Gerätekontext.  
  
```  
BOOL BitBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate der oberen linken Ecke des Zielrechtecks an.  
  
 *y*  
 Gibt die logische y-Koordinate der oberen linken Ecke des Zielrechtecks an.  
  
 *nWidth*  
 Gibt die Breite (in logischen Einheiten) der Zielbitmap Rechteck und Quelle.  
  
 *nHeight*  
 Gibt die Höhe (in logischen Einheiten) der Zielbitmap Rechteck und Quelle.  
  
 *pSrcDC*  
 Zeiger auf ein `CDC` Objekt, das den Gerätekontext identifiziert, von dem die Bitmap kopiert werden. Muss er **NULL** Wenn *DwRop* gibt einen auszuführenden Vorgangs, die nicht in eine Quelle enthalten ist.  
  
 *xSrc*  
 Gibt die logische X-Koordinate der oberen linken Ecke des Quellbitmaps an.  
  
 *ySrc*  
 Gibt die logische y-Koordinate der oberen linken Ecke des Quellbitmaps an.  
  
 *dwRop*  
 Gibt das Raster des auszuführenden Vorgangs an. Raster-Operationscodes definieren, wie GDI Farben in Ausgabevorgängen kombiniert, an denen ein aktueller Pinsel, eine mögliche Quellbitmap und eine Zielbitmap beteiligt sind. Finden Sie unter [BitBlt](http://msdn.microsoft.com/library/windows/desktop/dd183370) in das Windows SDK für eine Liste der rastervorgang Codes für *DwRop* und deren Beschreibungen  
  
 Eine vollständige Liste der rastervorgang Codes, finden Sie unter [zu Rastervorgangscode](http://msdn.microsoft.com/library/windows/desktop/dd162892) im Windows SDK.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Die Anwendung kann ausrichten, die Windows- oder Client-Bereichen auf Byte-Grenzen, um sicherzustellen, dass die `BitBlt` -Vorgänge für Rechtecke byteausgerichteten ausgeführt. (Legen Sie die **CS_BYTEALIGNWINDOW** oder **CS_BYTEALIGNCLIENT** kennzeichnet, wenn Sie die Fensterklassen registrieren.)  
  
 `BitBlt` Vorgänge für byteausgerichteten Rechtecke werden wesentlich schneller als `BitBlt` Vorgänge für Rechtecke, die nicht-Byte-ausgerichtet sind. Wenn Sie Klasse Formate wie Byte-Ausrichtung für Ihre eigenen Gerätekontext angeben möchten, müssen Sie eine Fensterklasse registriert anstelle der vertrauenden Seite für die Microsoft Foundation-Klassen, um diese Aufgabe für Sie. Verwenden Sie die globale Funktion [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).  
  
 GDI transformiert *nWidth* und *nHeight*einmal mithilfe der Zielgerätekontext und einmal mit dem Quellgerätekontext. Wenn die resultierende Blöcke nicht übereinstimmen, GDI verwendet die Windows `StretchBlt` Funktion zu komprimieren oder die Quellbitmap nach Bedarf zu Strecken.  
  
 Wenn das Ziel, die Quelle und die musterbitmaps nicht dasselbe Farbformat haben die `BitBlt` -Funktion konvertiert die Quelle und die musterbitmaps entsprechend das Ziel. Die Vordergrund- und Hintergrundfarben von die Zielbitmap werden bei der Konvertierung verwendet.  
  
 Wenn die `BitBlt` -Funktion konvertiert eine monochrome Bitmap in Farbe, legt Sie weiße Bits (1) auf die Hintergrundfarbe und schwarze Bits (0), der die Vordergrundfarbe. Die Vordergrund- und Hintergrundfarben des Zielgerätekontexts werden verwendet. Farbe in Monochrom, konvertieren `BitBlt` legt Sie Pixel, die die Farbe des Hintergrunds weiß entsprechen und legt alle anderen Pixel auf Schwarz fest. `BitBlt` verwendet die Vordergrund- und Hintergrundfarben des Gerätekontexts Farbe, um von Farbe in Monochrom zu konvertieren.  
  
 Beachten Sie, die nicht alle Gerätekontexte unterstützen `BitBlt`. Überprüft, ob es sich bei ein angegebenen Gerätekontext unterstützt `BitBlt`, verwenden die `GetDeviceCaps` Member Funktion, und geben Sie die **RASTERCAPS** Index.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CDC::CreateCompatibleDC](#createcompatibledc).  
  
##  <a name="cdc"></a>  CDC::CDC  
 Erstellt ein `CDC`-Objekt.  
  
```  
CDC();
```  
  
##  <a name="chord"></a>  CDC::Chord  
 Zeichnet eine Sehne (eine geschlossene Form durch die Schnittmenge einer Ellipse und Liniensegment begrenzt).  
  
```  
BOOL Chord(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Chord(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Parameter  
 *x1*  
 Gibt an, dass die X-Koordinate der oberen linken Ecke des Bandes umschließenden Rechtecks (in logischen Einheiten).  
  
 *y1*  
 Gibt an, der die y-Koordinate der oberen linken Ecke des Bandes umschließenden Rechtecks (in logischen Einheiten).  
  
 *x2*  
 Gibt an, dass die X-Koordinate der unteren rechten Ecke des Bandes umschließenden Rechtecks (in logischen Einheiten).  
  
 *Y2*  
 Gibt an, der die y-Koordinate der unteren rechten Ecke des Bandes umschließenden Rechtecks (in logischen Einheiten).  
  
 *x3*  
 Gibt an, dass die X-Koordinate des Punktes, der die Sehne definiert (in logischen Einheiten) Anfangspunkt des.  
  
 *Y3*  
 Gibt an, der die y-Koordinate des Punktes, der die Sehne definiert (in logischen Einheiten) Anfangspunkt des.  
  
 *X4*  
 Gibt die X-Koordinate des Punktes, der die Sehne-Endpunkt (in logischen Einheiten) definiert.  
  
 *Y4*  
 Gibt die y-Koordinate des Punktes, der die Sehne-Endpunkt (in logischen Einheiten) definiert.  
  
 *lpRect*  
 Gibt das umschließende Rechteck (in logischen Einheiten) an. Übergeben Sie entweder eine `LPRECT` oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.  
  
 *ptStart*  
 Gibt an, dass die x- und y-Koordinaten des Punkts, der die Sehne definiert (in logischen Einheiten) Anfangspunkt des. Dieser Punkt muss nicht genau auf die Sehne liegen. Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
 *ptEnd*  
 Gibt die x- und y-Koordinaten des Punkts, der die Sehne-Endpunkt (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau auf die Sehne liegen. Übergeben Sie entweder eine [Punkt](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der ( *X1*, *y1*) und ( *X2*, *y2*) Parameter geben die Ecken linken, oberen und unteren rechten bzw. eines Rechtecks Das umgebende Ellipse, der die Sehne gehört. Der ( *X3*, *y3*) und ( *X4*, *y4*) Parameter geben die Endpunkte einer Linie, die die Ellipse überschneidet. Die Sehne ist mit dem ausgewählten Stift gezeichnet und mit der ausgewählte Pinsel gefüllt.  
  
 Die Abbildung gezeichnet der `Chord` Funktion bis zu erweitert, aber nicht die Rechte und untere Koordinaten einschließt. Dies bedeutet, dass die Höhe der Abbildung *y2* - *y1* und die Breite der Abbildung ist *X2* - *X1*.  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]  
  
##  <a name="closefigure"></a>  CDC::CloseFigure  
 Schließt eine offene Figur in einem Pfad.  
  
```  
BOOL CloseFigure();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Die Funktion schließt in der Abbildung durch eine Linie von der aktuellen Position bis zum ersten Punkt des in der Abbildung (in der Regel, die durch den letzten Aufruf angegebenen Punkt der `MoveTo` Memberfunktion) und die Zeilen mithilfe der Linienverbindungsstil verbunden ist. Wenn eine Abbildung mit geschlossen ist die `LineTo` Memberfunktion anstelle der `CloseFigure`, Linienenden werden verwendet, um die Ecke anstelle eines Joins zu erstellen. `CloseFigure` sollte nur aufgerufen werden, wenn eine Klammer offenen Pfad in den Gerätekontext vorhanden ist.  
  
 Eine Abbildung in einem Pfad ist geöffnet, es sei denn, er durch diese Funktion explizit geschlossen wurde. (Abbildung kann geöffnet sein, auch wenn dem aktuellen Stand und den Ausgangspunkt der Abbildung identisch sind.) Alle Linien- oder der Pfad nach hinzugefügt `CloseFigure` startet eine neue Abbildung.  
  
##  <a name="createcompatibledc"></a>  CDC::CreateCompatibleDC  
 Erstellt einen Gerätekontext für Arbeitsspeicher, die kompatibel mit dem Gerät gemäß *pDC*.  
  
```  
BOOL CreateCompatibleDC(CDC* pDC);
```  
  
### <a name="parameters"></a>Parameter  
 *pDC*  
 Ein Zeiger zu einem Gerätekontext. Wenn *pDC* ist **NULL**, erstellt die Funktion einen Speicher-Gerätekontext, der mit dem System kompatibel ist.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Eine Speichergerätekontext ist ein Speicherblock, der eine Anzeigeoberfläche darstellt. Es dient zum Vorbereiten von Images im Arbeitsspeicher, bevor Sie sie auf die tatsächlichen Geräteoberfläche des Geräts kompatibel zu kopieren.  
  
 Wenn eine Speichergerätekontext erstellt wird, wählt GDI automatisch eine monochrome stock 1 x 1-Bitmap dafür an. GDI-Ausgabe-Funktionen können mit einer Speichergerätekontext verwendet werden, nur dann, wenn eine Bitmap erstellt und in diesem Kontext ausgewählt wurde.  
  
 Diese Funktion kann nur verwendet werden, um kompatibles Gerätekontexte für Geräte zu erstellen, die auszuführenden Vorgänge unterstützen. Finden Sie unter der [CDC:: BitBlt](#bitblt) Memberfunktion Informationen zu den Bit-Block übertragen zwischen Gerätekontexte. Um festzustellen, ob für ein Gerätekontext auszuführenden Vorgänge unterstützt, finden Sie unter der **RC_BITBLT** Raster-Funktion in der Memberfunktion `CDC::GetDeviceCaps`.  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]  
  
##  <a name="createdc"></a>  CDC::CreateDC  
 Erstellt einen Gerätekontext für das angegebene Gerät.  
  
```  
BOOL CreateDC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>Parameter  
 *lpszDriverName*  
 Zeigt auf eine auf Null endende Zeichenfolge, die den Dateinamen (ohne Erweiterung) des Gerätetreibers (z. B. "EPSON") angibt. Sie können auch übergeben ein `CString` Objekt für diesen Parameter.  
  
 *lpszDeviceName*  
 Zeigt auf eine auf Null endende Zeichenfolge, die den Namen des speziellen Geräts unterstützt werden müssen (z. B. "EPSON FX-80") angibt. Die *LpszDeviceName* Parameter wird verwendet, wenn das Modul über mehrere Geräte unterstützt. Sie können auch übergeben ein `CString` Objekt für diesen Parameter.  
  
 *lpszOutput*  
 Zeigt auf eine auf Null endende Zeichenfolge, die Datei oder neues Gerät Namen für das physische Ausgabemedium (oder im Ausgabefenster-Port) angibt. Sie können auch übergeben ein `CString` Objekt für diesen Parameter.  
  
 *lpInitData*  
 Verweist auf eine `DEVMODE` Struktur, die Geräte-spezifischer Initialisierungsdaten für den Gerätetreiber enthält. Die Windows `DocumentProperties` Funktion ruft diese Struktur ausgefüllt, die für ein bestimmtes Gerät ab. Die *LpInitData* Parameter muss **NULL** ist der Gerätetreiber verwendet die standardinitialisierung (sofern vorhanden), der vom Benutzer über die Systemsteuerung angegeben.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Drucken. H-Headerdatei ist erforderlich, wenn die [DEVMODE](http://msdn.microsoft.com/library/windows/desktop/dd183565) Struktur verwendet wird.  
  
 Gerätenamen diesen Konventionen: ein Enddatum Doppelpunkt (:) wird empfohlen, aber dies ist optional. Windows entfernt die abschließenden Doppelpunkt, damit Sie ein Gerätenamen mit einem Doppelpunkt endet mit dem gleichen Port als den gleichen Namen ohne Doppelpunkt zugeordnet ist. Die Treiber und Anschluss Namen müssen keine führende oder nachgestellte Leerzeichen enthalten. Funktionen von GDI-Ausgabe können nicht mit Informationen Kontexten verwendet werden.  
  
##  <a name="createic"></a>  CDC::CreateIC  
 Erstellt einen Informationskontext für das angegebene Gerät.  
  
```  
BOOL CreateIC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>Parameter  
 *lpszDriverName*  
 Zeigt auf eine auf Null endende Zeichenfolge, die den Dateinamen (ohne Erweiterung) des Gerätetreibers (z. B. "EPSON") angibt. Sie können übergeben, eine `CString` Objekt für diesen Parameter.  
  
 *lpszDeviceName*  
 Zeigt auf eine auf Null endende Zeichenfolge, die den Namen des speziellen Geräts unterstützt werden müssen (z. B. "EPSON FX-80") angibt. Die *LpszDeviceName* Parameter wird verwendet, wenn das Modul über mehrere Geräte unterstützt. Sie können übergeben, eine `CString` Objekt für diesen Parameter.  
  
 *lpszOutput*  
 Zeigt auf eine auf Null endende Zeichenfolge, die Datei oder neues Gerät Namen für das physische Ausgabemedium (Datei oder Port) angibt. Sie können übergeben, eine `CString` Objekt für diesen Parameter.  
  
 *lpInitData*  
 Verweist auf Geräte-spezifischer Initialisierungsdaten für den Gerätetreiber. Die *LpInitData* Parameter muss **NULL** ist der Gerätetreiber verwendet die standardinitialisierung (sofern vorhanden), der vom Benutzer über die Systemsteuerung angegeben. Finden Sie unter `CreateDC` für das Datenformat für die gerätespezifischen-Initialisierung.  
  
### <a name="return-value"></a>Rückgabewert  
 Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).  
  
### <a name="remarks"></a>Hinweise  
 Der Informationskontext bietet eine schnelle Möglichkeit, Informationen über das Gerät zu erhalten, ohne zu einen Gerätekontext erstellen.  
  
 Gerätenamen diesen Konventionen: ein Enddatum Doppelpunkt (:) wird empfohlen, aber dies ist optional. Windows entfernt die abschließenden Doppelpunkt, damit Sie ein Gerätenamen mit einem Doppelpunkt endet mit dem gleichen Port als den gleichen Namen ohne Doppelpunkt zugeordnet ist. Die Treiber und Anschluss Namen müssen keine führende oder nachgestellte Leerzeichen enthalten. Funktionen von GDI-Ausgabe können nicht mit Informationen Kontexten verwendet werden.  
  
##  <a name="deletedc"></a>  CDC::DeleteDC  
 Rufen Sie in der Regel nicht diese Funktion. der Destruktor wird dies für Sie übernimmt.  
  
```  
BOOL DeleteDC();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Wert ungleich NULL, wenn die Funktion erfolgreich ausgeführt wurde; andernfalls 0.  
  
### <a name="remarks"></a>Hinweise  
 Die `DeleteDC` Memberfunktion löscht die Windows-Gerätekontexte, die zugeordnet sind `m_hDC` in der aktuellen `CDC` Objekt. Wenn diese `CDC` Objekt ist die letzte aktive Gerätekontext für ein bestimmtes Gerät, das Gerät eine Benachrichtigung, und alle Speicher- und Ressourcen, die vom Gerät verwendet, werden freigegeben.  
  
 Eine Anwendung sollte nicht aufrufen `DeleteDC` Wenn Objekte in den Gerätekontext ausgewählt wurden. Objekte müssen zuerst im Gerätekontext ausgewählt werden, bevor sie gelöscht werden.  
  
 Löschen einer Anwendung muss keinen Gerätekontext, dessen Handle, durch den Aufruf abgerufen wurde [CWnd:: GetDC](../../mfc/reference/cwnd-class.md#getdc). Sie müssen stattdessen Aufrufen [CWnd:: ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) um den Gerätekontext freizugeben. Die [CClientDC](../../mfc/reference/cclientdc-class.md) und [CWindowDC](../../mfc/reference/cwindowdc-class.md) Klassen werden bereitgestellt, um diese Funktionalität zu umschließen.  
  
 Die `DeleteDC` Funktion wird im Allgemeinen zum Löschen mit erstellt Gerätekontexte [CreateDC](#createdc), [CreateIC](#createic), oder [CreateCompatibleDC](#createcompatibledc).  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).  
  
##  <a name="deletetempmap"></a>  CDC::DeleteTempMap  
 Wird aufgerufen, automatisch von der `CWinApp` -leerlaufzeithandler, `DeleteTempMap` löscht temporäre `CDC` von erstellten Objekte `FromHandle`, werden jedoch nicht die Gerät Kontexthandles zerstört wird ( `hDC`s) vorübergehend die zugeordnet`CDC` Objekte.  
  
```  
static void PASCAL DeleteTempMap();
```  
  
##  <a name="detach"></a>  CDC::Detach  
 Mit dieser Funktion wird beim Trennen des `m_hDC` (Gerätekontext Ausgabe) aus der `CDC` Objekt, und setzen Sie beide `m_hDC` und `m_hAttribDC` auf **NULL**.  
  
```  
HDC Detach();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Windows-Gerätekontext.  
  
##  <a name="dptohimetric"></a>  CDC::DPtoHIMETRIC  
 Verwenden Sie diese Funktion, wenn Sie erteilen **HIMETRIC** Größen an OLE, konvertieren Pixel, um die **HIMETRIC**.  
  
```  
void DPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpSize*  
 Verweist auf eine [Größe](http://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur oder [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Wenn der Zuordnungsmodus des Kontextobjekts Gerät ist `MM_LOENGLISH`, `MM_HIENGLISH`, `MM_LOMETRIC`, oder `MM_HIMETRIC`, und klicken Sie dann die Konvertierung auf die Anzahl der Pixel in der physischen Zoll basiert. Wenn der Zuordnungsmodus einen der anderen Modi nicht eingeschränkt ist (z. B. `MM_TEXT`), und klicken Sie dann die Konvertierung auf die Anzahl der Pixel in der logischem Zoll () basiert.  
  
##  <a name="dptolp"></a>  CDC::DPtoLP  
 Geräteeinheiten konvertiert in logischen Einheiten.  
  
```  
void DPtoLP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) Strukturen oder [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekte.  
  
 *nCount*  
 Die Anzahl von Punkten im Array.  
  
 *lpRect*  
 Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt. Dieser Parameter wird für den einfachen Fall mit einem Rechteck aus geräteverwaltungspunkte logischen Punkt verwendet.  
  
 *lpSize*  
 Verweist auf eine [Größe](http://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur oder [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Die Funktion ordnet die Koordinaten jedes Punkts oder mit einer Größe, aus das Koordinatensystem des Geräts in logischen Koordinatensystem GDI Dimension. Die Konvertierung hängt von der aktuellen Zuordnungsmodus und die Einstellungen der Ursprünge und Wertebereiche für Fenster und einen Viewport des Geräts ab.  
  
##  <a name="draw3drect"></a>  CDC::Draw3dRect  
 Rufen Sie diese Memberfunktion ein dreidimensionales Rechtecks zeichnen.  
  
```  
void Draw3dRect(
    LPCRECT lpRect,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);

 
void Draw3dRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Gibt das umschließende Rechteck (in logischen Einheiten) an. Sie können entweder einen Zeiger zu übergeben, eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.  
  
 *clrTopLeft*  
 Gibt die Farbe von der oberen und linken Rand des dreidimensionalen Rechtecks.  
  
 *clrBottomRight*  
 Gibt die Farbe des unteren und rechten Seite des dreidimensionalen Rechtecks an.  
  
 *w*  
 Gibt die logische X-Koordinate der oberen linken Ecke des Rechtecks dreidimensionalen an.  
  
 *y*  
 Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks dreidimensionalen an.  
  
 cx  
 Gibt die Breite des Rechtecks dreidimensionalen.  
  
 CY  
 Gibt die Höhe des Rechtecks dreidimensionalen.  
  
### <a name="remarks"></a>Hinweise  
 Das Rechteck gezeichnet werden mit den oberen und linken Rand in der Farbe gemäß *ClrTopLeft* und die unteren und rechten Seite in der Farbe gemäß *ClrBottomRight*.  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]  
  
##  <a name="drawdragrect"></a>  CDC::DrawDragRect  
 Rufen Sie diese Memberfunktion wiederholt ausführen, um einem Rechteck neu gezeichnet werden.  
  
```  
void DrawDragRect(
    LPCRECT lpRect,  
    SIZE size,  
    LPCRECT lpRectLast,  
    SIZE sizeLast,  
    CBrush* pBrush = NULL,  
    CBrush* pBrushLast = NULL);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt, das die logischen Koordinaten eines Rechtecks angibt – in diesem Fall wird die Endposition des Rechtecks neu gezeichnet wird.  
  
 *size*  
 Gibt die Verschiebung von der linken oberen Ecke des äußeren Rahmens der linken oberen Ecke des inneren Rahmens (d. h. die Stärke des Rahmens) eines Rechtecks an.  
  
 *lpRectLast*  
 Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt, das die logischen Koordinaten der Position eines Rechtecks angibt – in diesem Fall wird die ursprüngliche Position des Rechtecks neu gezeichnet wird.  
  
 *sizeLast*  
 Gibt die Verschiebung von der linken oberen Ecke des äußeren Rahmens in die linken oberen Ecke des inneren Rahmens (d. h. die Stärke des Rahmens) des ursprünglichen Rechtecks neu gezeichnet wird.  
  
 *pBrush*  
 Zeiger auf ein Pinselobjekt. Legen Sie auf **NULL** den standardmäßige Rasterbild Pinsel verwendet.  
  
 *pBrushLast*  
 Ein Zeiger auf das letzte Pinselobjekt verwendet. Legen Sie auf **NULL** den standardmäßige Rasterbild Pinsel verwendet.  
  
### <a name="remarks"></a>Hinweise  
 Rufen Sie es in einer Schleife, wie die Position des Mauszeigers, Beispiel, um visuelles Feedback anzuzeigen. Beim Aufruf `DrawDragRect`, das vorherige Rechteck wird gelöscht und eine neue gezeichnet wird. Als der Benutzer zieht Sie z. B. ein Rechteck über den Bildschirm `DrawDragRect` werden gelöscht, das ursprüngliche Rechteck und in seiner neuen Position einen neuen neu gezeichnet werden. Standardmäßig `DrawDragRect` zeichnet das Rechteck mit Rasterbild Pinsel, um Flackern zu beseitigen und die Darstellung eines Rechtecks, das problemlos verschieben zu erstellen.  
  
 Beim ersten Aufruf `DrawDragRect`, *LpRectLast* Parameter muss **NULL**.  
  
##  <a name="drawedge"></a>  CDC::DrawEdge  
 Rufen Sie diese Memberfunktion, um die Ränder eines Rechtecks mit dem angegebenen Typ und Stil zu zeichnen.  
  
```  
BOOL DrawEdge(
    LPRECT lpRect,  
    UINT nEdge,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Ein Zeiger auf eine **RECT** Struktur, die die logischen Koordinaten des Rechtecks enthält.  
  
 *nEdge*  
 Gibt den Typ des inneren und äußeren Rand gezeichnet werden soll. Dieser Parameter muss eine Kombination aus einem inneren Rahmen-Flag und einen äußeren Rahmens Flag sein. Finden Sie unter [DrawEdge](http://msdn.microsoft.com/library/windows/desktop/dd162477) in das Windows SDK für eine Tabelle mit den Parametertypen zulässig.  
  
 *nFlags*  
 Die Flags, die angeben, den Typ des Rahmens, gezeichnet werden soll. Finden Sie unter `DrawEdge` in das Windows SDK für eine Tabelle mit Werten des Parameters. Für die diagonalen Linien die **BF_RECT** Flags geben an, den Endpunkt des Vektors begrenzt, die für die Rechteckparameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).  
  
##  <a name="drawescape"></a>  CDC::DrawEscape  
 Greift auf Zeichnen eine der Videoanzeige-Funktionen, die nicht direkt über die Graphics Device Interface (GDI) verfügbar sind.  
  
```  
int DrawEscape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData);
```  
  
### <a name="parameters"></a>Parameter  
 *nEscape*  
 Gibt die Escape-Funktion ausgeführt werden.  
  
 *nInputSize*  
 Gibt die Anzahl der Datenbytes, die durch die *LpszInputData* Parameter.  
  
 *lpszInputData*  
 Zeigt auf der Eingabestruktur für das angegebene Escapezeichen erforderlich sind.  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt das Ergebnis der Funktion an. Größer als 0 (null), wenn erfolgreich, mit Ausnahme von der **QUERYESCSUPPORT** zeichnen Escape, der überprüft werden; nur Implementierung oder NULL, wenn das Escapezeichen ist nicht implementiert werden; oder kleiner als NULL, wenn ein Fehler aufgetreten ist.  
  
### <a name="remarks"></a>Hinweise  
 Wenn eine Anwendung ruft `DrawEscape`, die Daten durch identifiziert *nInputSize* und *LpszInputData* direkt an der angegebenen Bildschirmtreiber übergeben wird.  
  
##  <a name="drawfocusrect"></a>  CDC::DrawFocusRect  
 Zeichnet ein Rechteck im entsprechenden Stil verwendet, um anzugeben, dass das Rechteck, das Fokus besitzt.  
  
```  
void DrawFocusRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt, das die logischen Koordinaten des Rechtecks zu zeichnende angibt.  
  
### <a name="remarks"></a>Hinweise  
 Da dies eine booleschen XOR-Funktion ist, wird das Aufrufen dieser Funktion eines zweiten Mal mit dem gleichen Rechteck des Rechtecks aus der Anzeige entfernt. Das Rechteck gezeichnet, die von dieser Funktion kann nicht durch einen Bildlauf. Um einen Bereich mit einem Rechteck gezeichnet, die von dieser Funktion zu blättern, rufen Sie zuerst `DrawFocusRect` um das Rechteck aus der Anzeige zu entfernen, führen Sie den Bereich einen Bildlauf aus, und rufen Sie anschließend `DrawFocusRect` erneut aus, um das Rechteck in die neue Position zu zeichnen.  
  
> [!CAUTION]
> `DrawFocusRect` funktioniert nur in `MM_TEXT` Modus. In anderen Modi diese Funktion zeichnet keine Fokusrechtecks richtig, aber Fehlerwerte werden nicht zurückgegeben.  
  
##  <a name="drawframecontrol"></a>  CDC::DrawFrameControl  
 Rufen Sie diese Memberfunktion zum Zeichnen eines Steuerelements Frame mit dem angegebenen Typ und Stil.  
  
```  
BOOL DrawFrameControl(
    LPRECT lpRect,  
    UINT nType,  
    UINT nState);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Ein Zeiger auf eine **RECT** Struktur, die die logischen Koordinaten des Rechtecks enthält.  
  
 *%nbenachrichtigungen zu*  
 Gibt den Typ der Frame-Steuerelement gezeichnet werden soll. Finden Sie unter der *uType* im Parameters [DrawFrameControl](http://msdn.microsoft.com/library/windows/desktop/dd162480) in das Windows SDK für eine Liste der möglichen Werte des Parameters.  
  
 *nState*  
 Gibt an den Ausgangszustand des Steuerelements Frame. Kann eine oder mehrere der Werte beschrieben, für die *uState* im Parameters `DrawFrameControl` im Windows SDK. Verwenden der *nState* Wert **DFCS_ADJUSTRECT** Anpassen des umschließenden Rechtecks um den umgebenden Rand die Schaltfläche auszuschließen.  
  
### <a name="return-value"></a>Rückgabewert  
 Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).  
  
### <a name="remarks"></a>Hinweise  
 In vielen Fällen *nState* richtet sich nach der *%nbenachrichtigungen zu* Parameter. Die folgende Liste zeigt die Beziehung zwischen den vier *%nbenachrichtigungen zu* Werte und *nState*:  
  
- **DFC_BUTTON**  
  
    - **DFCS_BUTTON3STATE** drei-Status-Schaltfläche  
  
    - **DFCS_BUTTONCHECK** Kontrollkästchen  
  
    - **DFCS_BUTTONPUSH** Schaltflächen  
  
    - **DFCS_BUTTONRADIO** Optionsfeld  
  
    - **DFCS_BUTTONRADIOIMAGE** Bild für Optionsfeld (nicht quadratischen benötigt Image)  
  
    - **DFCS_BUTTONRADIOMASK** Maske für Optionsfeld (nicht quadratischen benötigt Maske)  
  
- **DFC_CAPTION**  
  
    - **DFCS_CAPTIONCLOSE** Schaltfläche "Schließen"  
  
    - **DFCS_CAPTIONHELP** Schaltfläche "Hilfe"  
  
    - **DFCS_CAPTIONMAX** Schaltfläche "Maximieren"  
  
    - **DFCS_CAPTIONMIN** Schaltfläche "Minimieren"  
  
    - **DFCS_CAPTIONRESTORE** "Wiederherstellen"  
  
- **DFC_MENU**  
  
    - **DFCS_MENUARROW** Untermenüpfeil  
  
    - **DFCS_MENUBULLET** Aufzählungszeichen  
  
    - **DFCS_MENUCHECK** Häkchen  
  
- **DFC_SCROLL**  
  
    - **DFCS_SCROLLCOMBOBOX** Kombinationsfeld Feld Bildlaufleiste  
  
    - **DFCS_SCROLLDOWN** nach-unten-Pfeil der Bildlaufleiste.  
  
    - **DFCS_SCROLLLEFT** -Bildlaufleiste links-Taste  
  
    - **DFCS_SCROLLRIGHT** Bildlaufleiste nach-rechts  
  
    - **DFCS_SCROLLSIZEGRIP** Größenziehpunkts in der unteren rechten Ecke des Fensters  
  
    - **DFCS_SCROLLUP** -oben-Taste Bildlaufleiste  
  
### <a name="example"></a>Beispiel  
 Dieser Code zeichnet ziehelements Größe in der unteren rechten Ecke des Fensters. Es eignet sich für die `OnPaint` Ereignishandler von einem Dialogfeld verfügt über keine Formatvorlagen und normalerweise keine andere Steuerelemente (z. B. eine Statusleiste), mit denen sie eine Größe ziehelements erhalten können.  
  
 [!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]  
  
##  <a name="drawicon"></a>  CDC::DrawIcon  
 Zeichnet ein Symbol auf dem Gerät, das vom aktuellen `CDC` Objekt.  
  
```  
BOOL DrawIcon(
    int x,  
    int y,  
    HICON hIcon);

 
BOOL DrawIcon(
    POINT point,  
    HICON hIcon);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate der oberen linken Ecke des Symbols an.  
  
 *y*  
 Gibt die logische y-Koordinate der oberen linken Ecke des Symbols an.  
  
 *hIcon*  
 Gibt das Handle des Symbols, gezeichnet werden soll.  
  
 *Punkt*  
 Gibt die logische x- und y-Koordinaten der oberen linken Ecke des Symbols an. Sie können übergeben eine [Punkt](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Wert ungleich NULL, wenn die Funktion erfolgreich ausgeführt wurde; andernfalls 0.  
  
### <a name="remarks"></a>Hinweise  
 Die Funktion setzt die linke obere Ecke das Symbol "an der vom angegebenen Position *x* und *y*. Der Speicherort ist gemäß der aktuellen Zuordnungsmodus des Gerätekontexts.  
  
 Die Symbolressource muss zuvor geladen mit den Funktionen `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`, oder `CWinApp::LoadOEMIcon`. Die `MM_TEXT` Zuordnungsmodus muss ausgewählt sein, bevor Sie diese Funktion verwenden.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).  
  
##  <a name="drawstate"></a>  CDC::DrawState  
 Rufen Sie diese Memberfunktion zum Anzeigen eines Bilds und Anwenden eines visuellen Effekts um einen Status, z. B. einen deaktivierten oder Standardstatus anzugeben.  
  
> [!NOTE]
>  Für alle *nFlag* Zustände mit Ausnahme von **DSS_NORMAL**, das Bild wird in Monochrom konvertiert, bevor die visuellen Effekts angewendet wird.  
  
```  
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HBITMAP hBitmap,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    CBitmap* pBitmap,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    CBrush* pBrush = NULL);
```  
  
### <a name="parameters"></a>Parameter  
 *pt*  
 Gibt den Speicherort des Bilds.  
  
 *size*  
 Gibt die Größe des Bilds.  
  
 *hBitmap*  
 Ein Handle für eine Bitmap.  
  
 *nFlags*  
 Flags, die den Bildtyp und Zustand angeben. Finden Sie unter [DrawState](http://msdn.microsoft.com/library/windows/desktop/dd162496) in das Windows SDK für die möglichen *nFlags* Typen und Status.  
  
 *hBrush*  
 Ein Handle für einen Pinsel.  
  
 *pBitmap*  
 Ein Zeiger auf ein CBitmap-Objekt.  
  
 *pBrush*  
 Ein Zeiger auf ein CBrush-Objekt.  
  
 *hIcon*  
 Ein Handle für ein Symbol.  
  
 *lpszText*  
 Ein Zeiger auf Text.  
  
 *bPrefixText*  
 Text, der möglicherweise eine Zugriffstaste mnemonische Zeichen enthalten. Die *lData* Parameter gibt die Adresse der Zeichenfolge ist, und die *nTextLen* Parameter gibt die Länge. Wenn *nTextLen* gleich 0 ist, wird angenommen, dass die Zeichenfolge Null-terminiert sein.  
  
 *nTextLen*  
 Länge der Zeichenfolge verweist *LpszText*. Wenn *nTextLen* gleich 0 ist, wird angenommen, dass die Zeichenfolge Null-terminiert sein.  
  
 *lpDrawProc*  
 Ein Zeiger auf eine Rückruffunktion verwendet, um ein Bild zu rendern. Dieser Parameter ist erforderlich, wenn der Bildtyp in *nFlags* ist **DST_COMPLEX**. Es ist optional und kann **NULL** ist der Bildtyp **DST_TEXT**. Für alle anderen Bildtypen wird dieser Parameter ignoriert. Weitere Informationen über die Rückruffunktion finden Sie unter der [DrawStateProc](http://msdn.microsoft.com/library/windows/desktop/dd162497) Funktion im Windows SDK.  
  
 *lData*  
 Gibt Informationen zu dem Bild. Die Bedeutung dieses Parameters hängt von der Bildtyp ab.  
  
### <a name="return-value"></a>Rückgabewert  
 Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).  
  
##  <a name="drawtext"></a>  CDC:: DrawText  
 Rufen Sie diese Memberfunktion zum Formatieren von Text in einem angegebenen Rechteck. Verwenden Sie zum Angeben zusätzlicher Formatierungsoptionen [CDC::DrawTextEx](#drawtextex).  
  
```  
virtual int DrawText(
    LPCTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat);

 
int DrawText(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat);
```  
  
### <a name="parameters"></a>Parameter  
 *lpszString*  
 Verweist auf das zu zeichnende Zeichenfolge. Wenn *nCount* ist-1 und die Zeichenfolge muss Null-terminiert sein.  
  
 *nCount*  
 Gibt die Anzahl der Zeichen in der Zeichenfolge an. Wenn *nCount* ist-1, dann *LpszString* wird davon ausgegangen, dass ein long-Zeiger auf eine Null-terminierte Zeichenfolge und `DrawText` die Zeichenanzahl automatisch berechnet.  
  
 *lpRect*  
 Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das das Rechteck (in logischen Koordinaten) enthält, in dem der Text formatiert werden.  
  
 *str*  
 Ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt, das die angegebenen Zeichen, gezeichnet werden soll.  
  
 *nFormat*  
 Gibt die Methode Formatieren des Texts an. Es kann eine beliebige Kombination der Werte beschrieben, für die *uFormat* im Parameters [DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) im Windows SDK. (kombinieren Sie, mit dem bitweisen OR-Operator):  
  
> [!NOTE]
>  Einige *uFormat* Flagkombinationen können dazu führen, dass die übergebene Zeichenfolge, die geändert werden. Mit **DT_MODIFYSTRING** entweder mit **DT_END_ELLIPSIS** oder **DT_PATH_ELLIPSIS** kann dazu führen, dass die Zeichenfolge, die geändert werden, verursacht eine Assertion in der `CString` außer Kraft setzen. Die Werte `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, und `DT_NOPREFIX` kann nicht verwendet werden, mit der `DT_TABSTOP` Wert.  
  
### <a name="return-value"></a>Rückgabewert  
 Die Höhe des Texts, wenn die Funktion erfolgreich ausgeführt wird.  
  
### <a name="remarks"></a>Hinweise  
 Formatiert Text von Registerkarten in die entsprechende Leerzeichen, Ausrichten von Text links, rechts oder zentriert des angegebenen Rechtecks erweitert, und Zerlegen von Text in Zeilen, die in einem angegebenen Rechteck zu passen. Die Art der Formatierung wird durch angegeben *nFormat*.  
  
 Diese Memberfunktion verwendet des Gerätekontexts ausgewählten Schriftart, Textfarbe und Hintergrundfarbe zum Zeichnen des Texts an. Wenn die `DT_NOCLIP` Format verwendet wird, `DrawText` schneidet den Text, damit der Text nicht außerhalb des angegebenen Rechtecks angezeigt wird. Die gesamte Formatierung wird davon ausgegangen, dass mehrere Zeilen aufweisen, es sei denn, die `DT_SINGLELINE` Format erhält.  
  
 Wenn die ausgewählte Schriftart zu groß für das angegebene Rechteck, ist die `DrawText` Memberfunktion nicht versucht, mit eine kleinere Schriftart zu ersetzen.  
  
 Wenn die `DT_CALCRECT` Flag angegeben ist, wird durch das Rechteck angegebenen *LpRect* wird aktualisiert, um die Breite und Höhe, die zum Zeichnen des Texts erforderlich wiederzugeben.  
  
 Wenn die **TA_UPDATECP** textausrichtung Flag festgelegt wurde (siehe [CDC::SetTextAlign](#settextalign)), `DrawText` zeigt Text an der aktuellen Position, anstatt auf der linken Seite des angegebenen Rechtecks ab. `DrawText` Text wird nicht umbrochen bei der **TA_UPDATECP** Flag festgelegt wurde (d. h. die `DT_WORDBREAK` Flag hat keine Auswirkung).  
  
 Die Textfarbe kann festgelegt werden, indem [CDC::SetTextColor](#settextcolor).  
  
##  <a name="drawtextex"></a>  CDC::DrawTextEx  
 Formatiert den Text im angegebenen Rechteck.  
  
```  
virtual int DrawTextEx(
    LPTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

 
int DrawTextEx(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```  
  
### <a name="parameters"></a>Parameter  
 *lpszString*  
 Verweist auf das zu zeichnende Zeichenfolge. Wenn *nCount* ist-1 und die Zeichenfolge muss Null-terminiert sein.  
  
 *nCount*  
 Gibt die Anzahl der Zeichen in der Zeichenfolge an. Wenn *nCount* ist-1, dann *LpszString* wird davon ausgegangen, dass ein long-Zeiger auf eine Null-terminierte Zeichenfolge und `DrawText` die Zeichenanzahl automatisch berechnet.  
  
 *lpRect*  
 Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das das Rechteck (in logischen Koordinaten) enthält, in dem der Text formatiert werden.  
  
 *str*  
 Ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt, das die angegebenen Zeichen, gezeichnet werden soll.  
  
 *nFormat*  
 Gibt die Methode Formatieren des Texts an. Es kann eine beliebige Kombination der Werte beschrieben, für die *uFormat* im Parameters [DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) im Windows SDK. (Kombinieren, mit dem bitweisen `OR` Operator):  
  
> [!NOTE]
>  Einige *uFormat* Flagkombinationen können dazu führen, dass die übergebene Zeichenfolge, die geändert werden. Mit **DT_MODIFYSTRING** entweder mit **DT_END_ELLIPSIS** oder **DT_PATH_ELLIPSIS** kann dazu führen, dass die Zeichenfolge, die geändert werden, verursacht eine Assertion in der `CString` außer Kraft setzen. Die Werte **DT_CALCRECT**, **DT_EXTERNALLEADING**, **DT_INTERNAL**, **DT_NOCLIP**, und **DT_NOPREFIX**kann nicht verwendet werden, mit der **DT_TABSTOP** Wert.  
  
 *lpDTParams*  
 Zeiger auf eine [DRAWTEXTPARAMS](http://msdn.microsoft.com/library/windows/desktop/dd162500) ' Optionen '-Struktur, zusätzliche Formatierungsinformationen angibt. Dieser Parameter kann **NULL**.  
  
### <a name="remarks"></a>Hinweise  
 Formatiert Text von Registerkarten in die entsprechende Leerzeichen, Ausrichten von Text links, rechts oder zentriert des angegebenen Rechtecks erweitert, und Zerlegen von Text in Zeilen, die in einem angegebenen Rechteck zu passen. Die Art der Formatierung wird durch angegeben *nFormat* und *LpDTParams*. Weitere Informationen finden Sie unter [CDC:: DrawText](#drawtext) und [DrawTextEx](http://msdn.microsoft.com/library/windows/desktop/dd162499) im Windows SDK.  
  
 Die Textfarbe kann festgelegt werden, indem [CDC::SetTextColor](#settextcolor).  
  
##  <a name="ellipse"></a>  CDC::Ellipse  
 Zeichnet eine Ellipse.  
  
```  
BOOL Ellipse(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Ellipse(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Parameter  
 *x1*  
 Gibt die logische X-Koordinate der oberen linken Ecke des umschließenden Rechtecks für die Ellipse.  
  
 *y1*  
 Gibt die logische y-Koordinate der oberen linken Ecke des umschließenden Rechtecks für die Ellipse.  
  
 *x2*  
 Gibt die logische X-Koordinate der unteren rechten Ecke des umschließenden Rechtecks für die Ellipse.  
  
 *Y2*  
 Gibt die logische y-Koordinate der unteren rechten Ecke des umschließenden Rechtecks für die Ellipse.  
  
 *lpRect*  
 Gibt an, das die Ellipse umschließenden Rechtecks. Sie können auch übergeben einer [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der Mittelpunkt der Ellipse steht im Mittelpunkt des umschließenden Rechtecks gemäß *X1*, *y1*, *X2*, und *y2*, oder  *LpRect*. Die Ellipse mit dem aktuellen Stift gezeichnet wird, und inneren mit dem aktuellen Pinsel gefüllt wird.  
  
 Die Abbildung gezeichnet, die von dieser Funktion bis zu erweitert, aber nicht einschließt, die Rechte und untere Koordinaten. Dies bedeutet, dass die Höhe der Abbildung *y2* - *y1* und die Breite der Abbildung ist *X2* - *X1*.  
  
 Wenn die Breite oder der Höhe des umschließenden Rechtecks 0 ist, wird keine Ellipse gezeichnet.  
  
##  <a name="enddoc"></a>  CDC::EndDoc  
 Beendet einen Druckauftrag gestartet, die durch einen Aufruf der [StartDoc](#startdoc) Memberfunktion.  
  
```  
int EndDoc();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Größer als oder gleich 0, wenn die Funktion erfolgreich ist oder einen negativen Wert, wenn ein Fehler aufgetreten.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion ersetzt die **ENDDOC** Drucker Escapezeichen und unmittelbar nach Abschluss eines erfolgreichen Druckauftrags aufgerufen werden.  
  
 Wenn eine Anwendung einen drucken oder einen abgebrochenen Druckvorgang auftritt, muss er nicht versuchen, den Vorgang zu beenden, indem Sie entweder `EndDoc` oder [AbortDoc](#abortdoc). GDI wird automatisch den Vorgang vor der Rückgabe des Fehlerwert beendet.  
  
 Diese Funktion sollte nicht innerhalb von Metadateien verwendet werden.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CDC::StartDoc](#startdoc).  
  
##  <a name="endpage"></a>  CDC::EndPage  
 Informiert dem Gerät, dass die Anwendung das Schreiben in eine Seite abgeschlossen ist.  
  
```  
int EndPage();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Größer als oder gleich 0, wenn die Funktion erfolgreich ist oder einen negativen Wert, wenn ein Fehler aufgetreten.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion wird normalerweise verwendet, leiten den Gerätetreiber zu einer neuen Seite zu gelangen.  
  
 Diese Memberfunktion ersetzt die **NEWFRAME** Drucker Escapezeichen. Im Gegensatz zu **NEWFRAME**, diese Funktion wird immer aufgerufen, nachdem eine Seite zu drucken.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CDC::StartDoc](#startdoc).  
  
##  <a name="endpath"></a>  CDC::EndPath  
 Schließt eine Klammer Pfad ein, und wählt den Pfad, der die schließende Klammer in den Gerätekontext definiert.  
  
```  
BOOL EndPath();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CDC:: beginpath](#beginpath).  
  
##  <a name="enumobjects"></a>  CDC:: EnumObjects  
 Listet die Stifte und Pinsel verfügbar in einem Gerätekontext.  
  
```  
int EnumObjects(
    int nObjectType,  
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),  
    LPARAM lpData);
```  
  
### <a name="parameters"></a>Parameter  
 *nObjectType*  
 Gibt den Objekttyp an. Sie können die Werte haben **OBJ_BRUSH** oder **OBJ_PEN**.  
  
 *lpfn*  
 Ist die verfahrensinstanz Adresse der Anwendung bereitgestellten Rückruffunktion. Siehe Abschnitt "Hinweise".  
  
 *lpData*  
 Verweist auf die von der Anwendung bereitgestellten Daten. Die Daten werden an die Rückruffunktion zusammen mit der Objektinformationen übergeben.  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt den letzten Wert zurückgegeben, durch die [Rückruffunktion](callback-functions-used-by-mfc.md#enum_objects). Die Bedeutung ist benutzerdefiniert.  
  
### <a name="remarks"></a>Hinweise  
 Die Rückruffunktion, die Sie übergeben wird für jedes Objekt eines angegebenen Typs mit den Informationen für dieses Objekt aufgerufen. Das System Ruft die Rückruffunktion auf, bis keine weitere Objekte vorhanden sind oder die Callback-Funktion gibt 0 zurück.  
  
 Beachten Sie, dass die neue Funktionen von Microsoft Visual C++ können Sie eine gewöhnliche Funktion zu verwenden, wie die Funktion, die an `EnumObjects`. Das an die Adresse `EnumObjects` ist ein Zeiger auf eine Funktion mit exportierten **EXPORTIEREN** und mit der Pascal-Aufrufkonvention. Im geschützten Modus Anwendungen müssen Sie nicht diese Funktion zu erstellen, mit der Windows-MakeProcInstance-Funktion, oder geben die Funktion nach der Verwendung mit der FreeProcInstance Windows-Funktion.  
  
 Sie auch keine so exportieren Sie den Namen der Funktion in einer **EXPORTE** -Anweisung in Ihrer Anwendung Moduldefinitionsdatei. Stattdessen können Sie die **EXPORTIEREN** Modifizierer, wie in-Funktion  
  
 **EXPORTIEREN der RÜCKRUF Int** AFunction **(LPSTR**, **LPSTR);**  
  
 den Compiler den ordnungsgemäßen Export-Datensatz für den Export nach Namen ohne Aliasing auszugebende verursachen. Dies funktioniert für die meisten Anforderungen. Für einige Sonderfälle, z. B. eine Funktion nach Ordnungszahl oder Aliasing des Exports exportieren Sie dennoch verwenden müssen eine **EXPORTE** -Anweisung in einer Moduldefinitionsdatei.  
  
 Zum Kompilieren von Microsoft Foundation-Programme, werden Sie normalerweise die/GA und Compileroptionen /GEs verwenden. Die/GW (Compileroption) wird nicht mit der Microsoft Foundation Classes verwendet. (Wenn Sie die Windows-Funktion verwenden **MakeProcInstance**, müssen Sie explizit aus den zurückgegebenen Funktionszeiger umgewandelt **FARPROC** in den Typ in dieser API erforderlich.) Registrierung von Rückrufschnittstellen sind jetzt als typsicherer (Sie müssen in einen Funktionszeiger, der auf die richtige Art von Funktion für den bestimmten Rückruf zeigt übergeben).  
  
 Beachten Sie außerdem, dass alle Rückruffunktionen vor der Rückgabe an Windows, da Ausnahmen hinweg Rückruf ausgelöst werden, können nicht Microsoft Foundation-Ausnahmen abfangen müssen. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]  
  
##  <a name="escape"></a>  CDC::Escape  
 Diese Memberfunktion ist praktisch für die Win32-Programmierung veraltet.  
  
```  
virtual int Escape(
    int nEscape,  
    int nCount,  
    LPCSTR lpszInData,  
    LPVOID lpOutData);

 
int Escape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData,  
    int nOutputSize,  
    LPSTR lpszOutputData);
```  
  
### <a name="parameters"></a>Parameter  
 *nEscape*  
 Gibt die Escape-Funktion ausgeführt werden.  
  
 Eine vollständige Liste der Escape-Funktionen, finden Sie unter [Escape](http://msdn.microsoft.com/library/windows/desktop/dd162701) im Windows SDK.  
  
 *nCount*  
 Gibt die Anzahl der Datenbytes, die durch *LpszInData*.  
  
 *lpszInData*  
 Verweist auf die eingabedatenstruktur für diese Escapezeichen erforderlich sind.  
  
 *lpOutData*  
 Verweist auf die Struktur, die zum Empfangen der Ausgabe aus dieser Escapezeichen. Die *LpOutData* Parameter ist **NULL** , wenn keine Daten zurückgegeben werden.  
  
 *nInputSize*  
 Gibt die Anzahl der Datenbytes, die durch die *LpszInputData* Parameter.  
  
 *lpszInputData*  
 Zeigt auf der Eingabestruktur für das angegebene Escapezeichen erforderlich sind.  
  
 *nOutputSize*  
 Gibt die Anzahl der Datenbytes, die durch die *LpszOutputData* Parameter.  
  
 *lpszOutputData*  
 Verweist auf die Struktur, die Ausgabe aus dieser Escape empfängt. Dieser Parameter muss **NULL** , wenn keine Daten zurückgegeben werden.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein positiver Wert wird zurückgegeben, wenn die Funktion erfolgreich ist, mit Ausnahme von wird der **QUERYESCSUPPORT** Escapesequenzen, die nur für die Implementierung überprüft. 0 (null) wird zurückgegeben, wenn das Escapezeichen nicht implementiert wird. Ein negativer Wert wird zurückgegeben, wenn ein Fehler aufgetreten. Es folgen allgemeine Fehlerwerte:  
  
- **SP_ERROR** allgemeiner Fehler.  
  
- **SP_OUTOFDISK** nicht genügend freier Speicherplatz steht zurzeit zum Spoolen und keinen Speicherplatz mehr zur Verfügung gestellt.  
  
- **SP_OUTOFMEMORY** ist nicht genügend Arbeitsspeicher zum Spoolen verfügbar.  
  
- **SP_USERABORT** Benutzer beendet den Auftrag über den Druck-Manager.  
  
### <a name="remarks"></a>Hinweise  
 Von der ursprünglichen Drucker umgeht, nur **QUERYESCSUPPORT** für Win32-Anwendungen unterstützt wird. Alle anderen Drucker-Escapezeichen wurden als veraltet eingestuft und werden nur für Kompatibilität mit 16-Bit-Anwendungen unterstützt.  
  
 Für die Win32-Programmierung `CDC` bietet jetzt sechs Memberfunktionen, die ihre entsprechenden Drucker Escapezeichen abgelöst:  
  
- [CDC::AbortDoc](#abortdoc)  
  
- [CDC::EndDoc](#enddoc)  
  
- [CDC::EndPage](#endpage)  
  
- [CDC::SetAbortProc](#setabortproc)  
  
- [CDC::StartDoc](#startdoc)  
  
- [CDC::StartPage](#startpage)  
  
 Darüber hinaus [GetDeviceCaps](#getdevicecaps) Win32-Indizes, die andere Drucker Escapezeichen ablösen unterstützt. Finden Sie unter [GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877) in das Windows SDK für Weitere Informationen.  
  
 Diese Memberfunktion ermöglicht Anwendungen die Funktionen eines bestimmten Geräts zugreifen, die nicht direkt über GDI verfügbar sind.  
  
 Verwenden Sie die erste Version aus, wenn Ihre Anwendung vordefinierte Escape-Werte verwendet. Verwenden Sie die zweite Version aus, wenn Ihre Anwendung privat Escape-Werte definiert. Finden Sie unter [ExtEscape](http://msdn.microsoft.com/library/windows/desktop/dd162708) in das Windows SDK für Weitere Informationen über die zweite Version.  
  
##  <a name="excludecliprect"></a>  CDC::ExcludeClipRect  
 Erstellt einen neuen Ausschneidebereich, der aus den vorhandenen Ausschneidebereich abzüglich des angegebenen Rechtecks besteht.  
  
```  
int ExcludeClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int ExcludeClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Parameter  
 *x1*  
 Gibt die logische X-Koordinate der oberen linken Ecke des Rechtecks an.  
  
 *y1*  
 Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks an.  
  
 *x2*  
 Gibt die logische X-Koordinate der unteren rechten Ecke des Rechtecks an.  
  
 *Y2*  
 Gibt die logische y-Koordinate der unteren rechten Ecke des Rechtecks an.  
  
 *lpRect*  
 Gibt das Rechteck. Kann auch ein `CRect` Objekt.  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt den neuen Ausschneidebereich-Typ. Die folgenden Werte sind möglich:  
  
- **COMPLEXREGION** der Region wurde überlappende Rahmen.  
  
- **Fehler** wurde keine Region erstellt.  
  
- **NULLREGION** die Region ist leer.  
  
- **SIMPLEREGION** die Region besitzt keine überlappenden Rahmen.  
  
### <a name="remarks"></a>Hinweise  
 Die Breite des Rechtecks, durch den absoluten Wert des angegebenen *X2* - *X1*, darf maximal 32.767 Einheiten. Dieser Grenzwert gilt für die Höhe des Rechtecks ebenfalls.  
  
##  <a name="excludeupdatergn"></a>  CDC::ExcludeUpdateRgn  
 Verhindert, dass ungültige Bereiche eines Fensters zeichnen eine aktualisierte Region im Fenster des Clippingbereichs zugeordneten ausgeschlossen der `CDC` Objekt.  
  
```  
int ExcludeUpdateRgn(CWnd* pWnd);
```  
  
### <a name="parameters"></a>Parameter  
 *pWnd*  
 Verweist auf das Window-Objekt, dessen Fenster aktualisiert wird.  
  
### <a name="return-value"></a>Rückgabewert  
 Der Typ des ausgeschlossenen Region. Eine der folgenden Werte sind möglich:  
  
- **COMPLEXREGION** der Region wurde überlappende Rahmen.  
  
- **Fehler** wurde keine Region erstellt.  
  
- **NULLREGION** die Region ist leer.  
  
- **SIMPLEREGION** die Region besitzt keine überlappenden Rahmen.  
  
##  <a name="extfloodfill"></a>  CDC::ExtFloodFill  
 Füllt einen Bereich von der Anzeigeoberfläche mit dem aktuellen Pinsel.  
  
```  
BOOL ExtFloodFill(
    int x,  
    int y,  
    COLORREF crColor,  
    UINT nFillType);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate des Punkts, an dem Füllen beginnt.  
  
 *y*  
 Gibt die logische y-Koordinate des Punkts, an dem Füllen beginnt.  
  
 *crColor*  
 Gibt die Farbe der Grenze oder des Bereichs gefüllt werden soll. Die Interpretation der *CrColor* hängt vom Wert der *nFillType*.  
  
 *nFillType*  
 Gibt den Typ des auszuführenden füllen. Es muss eine der folgenden Werte sein:  
  
- **FLOODFILLBORDER** Füllbereichs wird begrenzt durch die Farbe gemäß *CrColor*. Dieser Stil ist identisch mit dem Füllen von ausgeführten `FloodFill`.  
  
- **FLOODFILLSURFACE** Füllbereichs wird definiert, durch die Farbe gemäß *CrColor*. Füllen wird nach außen in allen Richtungen fortgesetzt, solange die Farbe gefunden wird. Dieses Format eignet sich zum Füllen von Bereichen mit mehrfarbige Grenzen.  
  
### <a name="return-value"></a>Rückgabewert  
 Wert ungleich NULL, wenn die Funktion erfolgreich ist; andernfalls 0, wenn die füllen nicht abgeschlossen werden konnte der angegebene Punkt hat die Grenze, angegeben durch Farbe *CrColor* (Wenn **FLOODFILLBORDER** wurde angefordert), wenn der angegebene Punkt keinen angegebene Farbe durch *CrColor* (Wenn **FLOODFILLSURFACE** wurde angefordert), oder wenn der Punkt außerhalb des Clippingbereichs ist.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion bietet mehr Flexibilität als `FloodFill` , da Sie in einem Fülltyp angeben können *nFillType*.  
  
 Wenn *nFillType* festgelegt ist, um **FLOODFILLBORDER**, wird angenommen, dass der Bereich vollständig durch die Farbe gemäß umschlossen werden *CrColor*. Startet die Funktion, die zum Zeitpunkt der gemäß *x* und *y* und in allen Richtungen auf die Begrenzung des Farbe gefüllt.  
  
 Wenn *nFillType* festgelegt ist, um **FLOODFILLSURFACE**, startet die Funktion, die zum Zeitpunkt der gemäß *x* und *y* und in allen wird fortgesetzt Richtungen weisenden Pfeilen, füllen alle angrenzende Bereichen, die mit der Farbe, die gemäß *CrColor*.  
  
 Nur Arbeitsspeicher-Gerätekontexte und Geräte, die Unterstützung für Raster-Technologie unterstützen `ExtFloodFill`. Weitere Informationen finden Sie unter der [GetDeviceCaps](#getdevicecaps) Memberfunktion.  
  
##  <a name="exttextout"></a>  CDC::ExtTextOut  
 Rufen Sie diese Memberfunktion zum Schreiben einer Zeichenfolge in einen rechteckigen Bereich mit der aktuell ausgewählten Schriftart.  
  
```  
virtual BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    LPCTSTR lpszString,  
    UINT nCount,  
    LPINT lpDxWidths);

 
BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    const CString& str,  
    LPINT lpDxWidths);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate der Zeichenzelle für das erste Zeichen in der angegebenen Zeichenfolge an.  
  
 *y*  
 Gibt die logische y-Koordinate des oberen Rands der Zeichenzelle für das erste Zeichen in der angegebenen Zeichenfolge an.  
  
 *nOptions*  
 Gibt den Typ des Rechtecks. Dieser Parameter kann einen, beide oder keines der folgenden Werte sein:  
  
- **ETO_CLIPPED** gibt an, dass Text in das Rechteck abgeschnitten wird.  
  
- **ETO_OPAQUE** gibt an, dass die aktuelle Farbe des Hintergrunds für das Rechteck ausgefüllt. (Festlegen und Abfragen mit die aktuellen Hintergrundfarbe der [SetBkColor](#setbkcolor) und [GetBkColor](#getbkcolor) Memberfunktionen.)  
  
 *lpRect*  
 Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur, die die Abmessungen des Rechtecks bestimmt. Dieser Parameter kann **NULL**. Sie können auch übergeben einer [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.  
  
 *lpszString*  
 Verweist auf die angegebene Zeichenfolge, gezeichnet werden soll. Sie können auch übergeben einer [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.  
  
 *nCount*  
 Gibt die Anzahl von Zeichen in der Zeichenfolge an.  
  
 *lpDxWidths*  
 Verweist auf ein Array von Werten, die den Abstand zwischen den Ursprüngen von angrenzenden Zeichenzellen angeben. Z. B. *LpDxWidths*[ *ich*] logische Einheiten werden Sie die Ursprünge an der Zeichenzelle getrennt *ich* und Zeichenzelle *ich* + 1. Wenn *LpDxWidths* ist **NULL**, `ExtTextOut` den Standardabstand zwischen Zeichen verwendet.  
  
 *str*  
 Ein `CString` -Objekt, das die angegebenen Zeichen, gezeichnet werden soll.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der rechteckige Bereich kann nicht transparent (mit der aktuellen Hintergrundfarbe ausgefüllt), und einen Ausschneidebereich sind möglich.  
  
 Wenn *nOptions* ist 0 und *LpRect* ist **NULL**, die Funktion schreibt Text in den Gerätekontext, ohne einen rechteckigen Bereich. Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert. Wenn eine Anwendung muss die aktuelle Position aktualisieren, beim Aufrufen von `ExtTextOut`, die Anwendung aufrufen kann die `CDC` Memberfunktion [SetTextAlign](#settextalign) mit *nFlags* festgelegt**TA_UPDATECP**. Wenn dieses Flag festgelegt ist, ignoriert Windows *x* und *y* bei nachfolgenden Aufrufen `ExtTextOut` und verwendet Sie stattdessen die aktuelle Position. Wenn eine Anwendung mithilfe **TA_UPDATECP** zum Aktualisieren der aktuellen Position `ExtTextOut` setzt die aktuelle Position am Ende der vorherigen Zeile des Texts oder an der Position, die durch das letzte Element des Arrays verweist angegeben*LpDxWidths*, welcher Wert größer ist.  
  
##  <a name="fillpath"></a>  CDC::FillPath  
 Schließt alle geöffneten Figuren im aktuellen Pfad und füllt den Pfad innere mithilfe des aktuellen Pinsel und Polygon füllenden Modus.  
  
```  
BOOL FillPath();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Nach dem inneren ausgefüllt wird, wird der Pfad aus dem Gerätekontext verworfen.  
  
##  <a name="fillrect"></a>  CDC::fillRect  
 Rufen Sie diese Memberfunktion zum Ausfüllen von eines angegebenen Rechtecks mit dem angegebenen Pinsel.  
  
```  
void FillRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) -Struktur, die die logischen Koordinaten des Rechtecks gefüllt werden soll. Sie können auch übergeben einer [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.  
  
 *pBrush*  
 Identifiziert den Pinsel, der zum Füllen des Rechtecks.  
  
### <a name="remarks"></a>Hinweise  
 Die Funktion füllt das umfassende Rechteck, einschließlich der linken und oberen Rahmens, aber die rechten und unteren Ränder wird nicht aufgefüllt werden.  
  
 Der Pinsel muss entweder mit erstellt werden, die [CBrush](../../mfc/reference/cbrush-class.md) Memberfunktionen [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush), und [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), oder abgerufen, indem die `GetStockObject` Windows-Funktion.  
  
 Wenn das angegebene Rechteck ausgefüllt `FillRect` enthält keine Rechte und untere-Seiten des Rechtecks. GDI bis zu füllt ein Rechteck, aber nicht einschließt, die rechte Spalte und der unteren Zeile, unabhängig von der aktuellen Zuordnungsmodus. `FillRect` Vergleicht die Werte der **oben**, **unteren**, **linken**, und **rechten** Member des angegebenen Rechtecks. Wenn **unteren** ist kleiner als oder gleich **oben**, oder wenn **rechten** ist kleiner als oder gleich **linken**, nicht das Rechteck gezeichnet wird.  
  
 `FillRect` ähnelt dem [CDC::FillSolidRect](#fillsolidrect)jedoch `FillRect` akzeptiert einen Pinsel und kann daher verwendet werden, um ein Rechteck mit einer Volltonfarbe, eine Farbe, schraffierten Pinsel oder ein Muster zu füllen. `FillSolidRect` verwendet nur Volltonfarben (angegeben durch eine **COLORREF** Parameter). `FillRect` in der Regel ist langsamer als `FillSolidRect`.  
  
##  <a name="fillrgn"></a>  CDC::FillRgn  
 Füllt den Bereich von angegebenen *PRNG* mit dem Pinsel gemäß *pBrush*.  
  
```  
BOOL FillRgn(
    CRgn* pRgn,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Parameter  
 *PRNG*  
 Ein Zeiger auf die Region gefüllt werden soll. Die Koordinaten für den angegebenen Bereich sind in logischen Einheiten angegeben.  
  
 *pBrush*  
 Identifiziert den Pinsel, der zum Ausfüllen der Region verwendet werden.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der Pinsel muss entweder mit erstellt werden die `CBrush` Memberfunktionen `CreateHatchBrush`, `CreatePatternBrush`, `CreateSolidBrush`, oder abgerufen werden, indem `GetStockObject`.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).  
  
##  <a name="fillsolidrect"></a>  CDC::FillSolidRect  
 Rufen Sie diese Memberfunktion zum angegebene Rechteck mit den angegebenen Volltonfarbe zu füllen.  
  
```  
void FillSolidRect(
    LPCRECT lpRect,  
    COLORREF clr);

 
void FillSolidRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clr);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Gibt das umschließende Rechteck (in logischen Einheiten) an. Sie können entweder einen Zeiger zu übergeben, eine [RECT](../../mfc/reference/rect-structure1.md) Datenstruktur oder ein `CRect` Objekt für diesen Parameter.  
  
 *CLR* gibt die Farbe an, die zum Ausfüllen des Rechtecks verwendet werden.  
  
 *w*  
 Gibt die logische X-Koordinate der oberen linken Ecke des Rechtecks an.  
  
 *y*  
 Gibt die logische y-Koordinate der oberen linken Ecke des Zielrechtecks an.  
  
 *CX*  
 Gibt die Breite des Rechtecks.  
  
 *CY*  
 Gibt die Höhe des Rechtecks.  
  
### <a name="remarks"></a>Hinweise  
 `FillSolidRect` ist sehr ähnlich [CDC::FillRect](#fillrect)jedoch `FillSolidRect` verwendet nur Volltonfarben (erkennbar die **COLORREF** Parameter), während `FillRect` akzeptiert einen Pinsel und kann daher verwendet werden, um das Füllen einer Rechteck mit einer Volltonfarbe, eine Farbe, schraffierten Pinsel oder ein Muster. `FillSolidRect` in der Regel ist schneller als `FillRect`.  
  
> [!NOTE]
>  Beim Aufruf `FillSolidRect`, die Hintergrundfarbe, die zuvor mit dem festgelegt wurde [SetBkColor](#setbkcolor), festgelegt ist, die durch Farbe *Clr*.  
  
##  <a name="flattenpath"></a>  CDC::FlattenPath  
 In den Pfad, in der aktuelle Gerätekontext ausgewählten Kurven transformiert und wandelt jede Kurve in einer Sequenz von Zeilen.  
  
```  
BOOL FlattenPath();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
##  <a name="floodfill"></a>  CDC::FloodFill  
 Füllt einen Bereich von der Anzeigeoberfläche mit dem aktuellen Pinsel.  
  
```  
BOOL FloodFill(
    int x,  
    int y,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate des Punkts, an dem Füllen beginnt.  
  
 *y*  
 Gibt die logische y-Koordinate des Punkts, an dem Füllen beginnt.  
  
 *crColor*  
 Gibt die Farbe der Grenze.  
  
### <a name="return-value"></a>Rückgabewert  
 Wert ungleich NULL, wenn die Funktion erfolgreich ist; andernfalls 0 wird zurückgegeben, wenn die füllen nicht abgeschlossen werden konnte, hat der angegebene Punkt von angegebene Grenze Farbe *CrColor*, oder der Punkt außerhalb des Clippingbereichs.  
  
### <a name="remarks"></a>Hinweise  
 Der Bereich wird davon ausgegangen, die als umschlossen werden gemäß *CrColor*. Die `FloodFill` Funktion beginnt, an dem Punkt, die vom angegebenen *x* und *y* und in allen Richtungen auf die Begrenzung des Farbe wird fortgesetzt.  
  
 Nur Arbeitsspeicher-Gerätekontexte und Geräte, die Unterstützung für Raster-Technologie unterstützen die `FloodFill` Memberfunktion. Informationen zu **RC_BITBLT** Funktion finden Sie unter der `GetDeviceCaps` Memberfunktion.  
  
 Die `ExtFloodFill` Funktion bietet ähnliche Funktionalität jedoch größere Flexibilität.  
  
##  <a name="framerect"></a>  CDC:: FrameRect  
 Zeichnet einen Rahmen um das Rechteck, angegeben durch *LpRect*.  
  
```  
void FrameRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt, das die logischen Koordinaten der oberen linken und rechten unteren Ecken des Rechtecks enthält. Sie können auch übergeben ein `CRect` Objekt für diesen Parameter.  
  
 *pBrush*  
 Identifiziert den Pinsel für die Darstellung des Rechtecks verwendet werden soll.  
  
### <a name="remarks"></a>Hinweise  
 Die Funktion verwendet den angegebenen Pinsel zum Zeichnen des Rahmens an. Die Breite und Höhe des Rahmens ist immer 1 logische Einheit.  
  
 Wenn des Rechtecks **unteren** Koordinate ist kleiner als oder gleich **oben**, oder wenn **rechten** ist kleiner als oder gleich **linken**, das Rechteck ist nicht gezeichnet wird.  
  
 Den Rahmen gezeichnet `FrameRect` befindet sich in derselben Position wie ein Rahmen gezeichnet, die durch die **Rechteck** Memberfunktion, die mit den Koordinaten (Wenn **Rechteck** verwendet einen Stift, der logischen Einheit wide 1 ist). Das Innere eines Rechtecks wird nicht ausgefüllt, indem `FrameRect`.  
  
##  <a name="framergn"></a>  CDC::FrameRgn  
 Zeichnet einen Rahmen um den Bereich von angegebenen *PRNG* mit dem Pinsel gemäß *pBrush*.  
  
```  
BOOL FrameRgn(
    CRgn* pRgn,  
    CBrush* pBrush,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Parameter  
 *PRNG*  
 Verweist auf die `CRgn` Objekt, das den Bereich innerhalb eines Rahmens eingeschlossen werden identifiziert. Die Koordinaten für den angegebenen Bereich sind in logischen Einheiten angegeben.  
  
 *pBrush*  
 Verweist auf die `CBrush` Objekt, das den Pinsel zum Zeichnen des Rahmens zu verwendende identifiziert.  
  
 *nWidth*  
 Gibt die Breite des Rahmens in einem vertikalen Pinselstrich in Geräteeinheiten an.  
  
 *nHeight*  
 Gibt die Höhe des Rahmens in einem horizontalen Pinselstrich in Geräteeinheiten an.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).  
  
##  <a name="fromhandle"></a>  CDC::FromHandle  
 Gibt einen Zeiger auf ein `CDC` Objekt, wenn ein Handle für einen Gerätekontext vorhanden.  
  
```  
static CDC* PASCAL FromHandle(HDC hDC);
```  
  
### <a name="parameters"></a>Parameter  
 *hDC*  
 Enthält ein Handle für einen Gerätekontext für Windows.  
  
### <a name="return-value"></a>Rückgabewert  
 Der Zeiger kann temporär sein und sollte nicht hinter sofort gespeichert werden.  
  
### <a name="remarks"></a>Hinweise  
 Wenn ein `CDC`-Objekt nicht an das Handle angefügt ist, wird ein temporäres `CDC`-Objekt erstellt und angefügt.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).  
  
##  <a name="getarcdirection"></a>  CDC::GetArcDirection  
 Gibt die aktuelle Bogen Richtung für den Gerätekontext zurück.  
  
```  
int GetArcDirection() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt die aktuelle Bogen Richtung an, ob erfolgreich ausgeführt. Es folgen die gültige Rückgabewerte:  
  
- **AD_COUNTERCLOCKWISE** Bögen und Rechtecke, die gegen den Uhrzeigersinn gezeichnet.  
  
- **AD_CLOCKWISE** Bögen und Rechtecke im Uhrzeigersinn gezeichnet.  
  
 Wenn ein Fehler auftritt, ist der Rückgabewert 0 (null).  
  
### <a name="remarks"></a>Hinweise  
 ARC und Rechteck-Funktionen verwenden die Richtung des Bogens.  
  
##  <a name="getaspectratiofilter"></a>  CDC::GetAspectRatioFilter  
 Ruft die Einstellung für den aktuellen Seitenverhältnis Filter ab.  
  
```  
CSize GetAspectRatioFilter() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein `CSize` Objekt, das das Seitenverhältnis, die von der aktuellen Seitenverhältnis Filter verwendeten darstellt.  
  
### <a name="remarks"></a>Hinweise  
 Das Seitenverhältnis ist das Verhältnis gebildet, indem Sie ein Gerät Pixelbreite und Höhe. Informationen zu einem Gerät Seitenverhältnis wird in die Erstellung, die Auswahl und die Anzeige von Schriftarten verwendet. Windows bietet einen speziellen Filter, der Filter Seitenverhältnis Schriftarten für eine bestimmte Seitenverhältnis aller verfügbaren Schriftarten auswählen. Der Filter verwendet das Seitenverhältnis gemäß der `SetMapperFlags` Memberfunktion.  
  
##  <a name="getbkcolor"></a>  CDC::GetBkColor  
 Gibt die aktuelle Hintergrundfarbe zurück.  
  
```  
COLORREF GetBkColor() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Wert für den RGB-Farbe.  
  
### <a name="remarks"></a>Hinweise  
 Wenn der Hintergrundmodus ist **nicht TRANSPARENTEN**, das System verwendet die Farbe des Hintergrunds zum Füllen der Lücken in formatierte Zeilen, die Lücken zwischen schraffierten Linien, Pinsel und Hintergrund in Zeichenzellen. Das System verwendet auch die Farbe des Hintergrunds beim Konvertieren von Bitmaps zwischen Farbe und monochrome Gerätekontexte.  
  
##  <a name="getbkmode"></a>  CDC::GetBkMode  
 Gibt den Hintergrundmodus.  
  
```  
int GetBkMode() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Die aktuelle Hintergrundmodus kann u. **nicht TRANSPARENTEN** oder **TRANSPARENT**.  
  
### <a name="remarks"></a>Hinweise  
 Die Hintergrundmodus definiert, ob das System vorhandene Hintergrundfarben auf die Zeichenoberfläche entfernt vor dem Zeichnen von Text, schraffierten Pinsel oder jede Stift-Formatvorlage, die keine durchgehende Linie ist.  
  
##  <a name="getboundsrect"></a>  CDC::GetBoundsRect  
 Gibt das aktuelle kumulierte umschließende Rechteck für den angegebenen Gerätekontext zurück.  
  
```  
UINT GetBoundsRect(
    LPRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRectBounds*  
 Zeigt auf einen Puffer, der aktuellen umschließenden Rechtecks erhält. Das Rechteck wird in logischen Koordinaten zurückgegeben.  
  
 *flags*  
 Gibt an, ob das umschließende Rechteck gelöscht werden, nachdem sie zurückgegeben werden. Dieser Parameter sollte 0 (null) sein oder auf den folgenden Wert festgelegt:  
  
- **DCB_RESET** erzwingt das umschließende Rechteck gelöscht werden, nachdem sie zurückgegeben wird.  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt den aktuellen Status des umschließenden Rechtecks, wenn die Funktion erfolgreich ausgeführt wird. Eine Kombination der folgenden Werte sind möglich:  
  
- **DCB_ACCUMULATE** umgebende Rechteck Accumulation / auftritt.  
  
- **DCB_RESET** umgebende Rechteck ist leer.  
  
- **DCB_SET** umgebende Rechteck ist nicht leer.  
  
- **DCB_ENABLE** Accumulation / umgebende befindet sich auf.  
  
- **DCB_DISABLE** Accumulation / umgebende ist deaktiviert.  
  
##  <a name="getbrushorg"></a>  CDC::GetBrushOrg  
 Ruft den Ursprung (in Geräteeinheiten) der aktuell für den Gerätekontext ausgewählten Pinsel ab.  
  
```  
CPoint GetBrushOrg() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Der aktuelle Ursprung des Pinsels (in Geräteeinheiten) als eine [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Der Ursprung der anfänglichen Pinsel ist (0,0) des Clientbereichs. Der Rückgabewert gibt diesen Punkt im Geräteeinheiten relativ zum Ursprung des Fensters auf dem desktop an.  
  
##  <a name="getcharacterplacement"></a>  CDC::GetCharacterPlacement  
 Ruft verschiedene Typen von Informationen zu einer Zeichenfolge ab.  
  
```  
DWORD GetCharacterPlacement(
    LPCTSTR lpString,  
    int nCount,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
  
DWORD GetCharacterPlacement(
    CString& str,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpString*  
 Ein Zeiger auf die zu verarbeitende Zeichenfolge.  
  
 *nCount*  
 Gibt die Länge der Zeichenfolge an. Bei der ANSI-Version ist es eine Byteanzahl und bei der Unicode-Funktion ist es eine Wortanzahl. Weitere Informationen finden Sie unter [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx).  
  
 *nMaxExtent*  
 Gibt der maximale Wertbereich (in logischen Einheiten) an, zu dem die Zeichenfolge verarbeitet wird. Zeichen, die diesen Wertbereich bei Verarbeitung überschreiten würden, werden ignoriert. Berechnungen für alle erforderlichen Reihenfolge- oder Glyphenarrays gelten nur für die enthaltenen Zeichen. Dieser Parameter wird verwendet, nur, wenn der GCP_MAXEXTENT-Wert, in angegeben ist der *DwFlags* Parameter. Da die Funktion die Eingabezeichenfolge verarbeitet, wird jedes Zeichen und sein Wertebereich nur dann der Ausgabe, dem Wertebereich und anderen Arrays hinzugefügt, wenn der gesamte Wertebereich das Maximum noch nicht überschritten hat. Bei Erreichen des Limits wird die Verarbeitung beendet.  
  
 lpResults  
 Zeiger auf eine [GCP_Results](http://msdn.microsoft.com/library/windows/desktop/dd144842\(v=vs.85\).aspx) -Struktur, die die Ergebnisse der Funktion empfängt.  
  
 *dwFlags*  
 Gibt das Verarbeiten der Zeichenfolge in die erforderlichen Arrays an. Dieser Parameter kann eine oder mehrere der Werte in der *DwFlags* Teil der [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx) Thema.  
  
 *str*  
 Ein Zeiger auf eine [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt zu verarbeiten.  
  
### <a name="return-value"></a>Rückgabewert  
 Wenn die Funktion erfolgreich ist, handelt es sich bei dem Rückgabewert um die Breite und Höhe der Zeichenfolge in logischen Einheiten.  
  
 Wenn die Funktion fehlerhaft ist, ist der Rückgabewert null.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion emuliert die Funktionen der Funktion [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx)gemäß der Beschreibung im Windows SDK.  
  
##  <a name="getcharabcwidths"></a>  CDC::GetCharABCWidths  
 Ruft die Breite der aufeinander folgenden Zeichen in einem angegebenen Bereich aus der aktuellen TrueType-Schriftart ab.  
  
```  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABC lpabc) const;  
  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABCFLOAT lpABCF) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *nFirstChar*  
 Gibt das erste Zeichen im Bereich von Zeichen aus der aktuellen Schriftart für die breiten Zeichen zurückgegeben werden.  
  
 *nLastChar*  
 Gibt das letzte Zeichen im Bereich von Zeichen aus der aktuellen Schriftart für die breiten Zeichen zurückgegeben werden.  
  
 *lpabc*  
 Verweist auf ein Array von [ABC](../../mfc/reference/abc-structure.md) Strukturen, die Breite Zeichen zu erhalten, wenn die Funktion zurückgibt. Dieses Array muss mindestens so viele **ABC** Strukturen als Zeichen vorhanden, in dem vom angegebenen Bereich sind der *nFirstChar* und *nLastChar* Parameter.  
  
 *lpABCF*  
 Verweist auf eine von der Anwendung bereitgestellten Puffer mit einem Array von [ABCFLOAT](../../mfc/reference/abcfloat-structure.md) Strukturen zu Breite Zeichen zu erhalten, wenn die Funktion zurückgibt. Die Breite, die von dieser Funktion zurückgegebenen befinden sich in der IEEE-Gleitkomma-Format.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Die Breite werden in logischen Einheiten zurückgegeben. Diese Funktion erfolgreich ausgeführt wird, nur mit TrueType-Schriftarten.  
  
 Die TrueType-Rasterisierungsfunktion enthält Zeichenabstand "ABC", nach eine bestimmten Zeitpunkt-Größe ausgewählt wurde. "A" Zwischenraum entspricht dem Abstand, der das der aktuellen Position hinzugefügt wird, bevor Sie das Symbol platzieren. Abstand von "B" ist die Breite des schwarzen Teils des Symbols. "C" Abstand, wird die aktuelle Position für den Leerraum auf der rechten Seite des Symbols für das Konto hinzugefügt. Die Summe erweiterte Breite, angegeben durch ein + B + C.  
  
 Wenn die `GetCharABCWidths` Memberfunktion ruft negative "A" oder "C" Breite für ein Zeichen, die dieses Zeichen umfasst, Underhangs oder Überhängen.  
  
 Zum Konvertieren der breiten ABC in Schriftentwurfseinheiten sollten erstellen Sie eine Anwendung eine Schriftart, dessen Höhe (nach den Angaben in der **LfHeight** Mitglied der [LOGFONT](http://msdn.microsoft.com/library/windows/desktop/dd145037) Struktur) gleich dem Wert in der gespeichertist**NtmSizeEM** Mitglied der [NEWTEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162741) Struktur. (Der Wert von der **NtmSizeEM** Element abgerufen werden kann, durch Aufrufen der [EnumFontFamilies](http://msdn.microsoft.com/library/windows/desktop/dd162619) -Funktion von Windows.)  
  
 Breite des Standardzeichensatzes ABC werden für Zeichen verwendet, die außerhalb des Bereichs der derzeit ausgewählten Schriftart sind.  
  
 Um die Breite der Zeichen in nicht-TrueType abzurufen, sollten Anwendungen verwenden die [GetCharWidth](http://msdn.microsoft.com/library/windows/desktop/dd144861) Windows-Funktion.  
  
##  <a name="getcharabcwidthsi"></a>  CDC::GetCharABCWidthsI  
 Ruft die Breite in logischen Einheiten von aufeinander folgenden Glyphe Indizes in einem angegebenen Bereich aus der aktuellen TrueType-Schriftart ab.  
  
```  
BOOL GetCharABCWidthsI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPABC lpabc) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *giFirst*  
 Gibt die ersten Glyphe Index in der Gruppe von aufeinander folgenden Glyphe Indizes aus der aktuellen Schriftart an. Dieser Parameter wird nur verwendet, wenn die *Pgi* Parameter ist **NULL**.  
  
 *CGI*  
 Gibt die Anzahl der Symbolindizes an.  
  
 *PGI*  
 Ein Zeiger auf ein Array mit Glyphe Indizes. Wenn der Wert **NULL**, *GiFirst* Parameter wird stattdessen verwendet. Die *Cgi* Parameter gibt die Anzahl der Symbolindizes in diesem Array.  
  
 *lpabc*  
 Zeiger auf ein Array von [ABC](http://msdn.microsoft.com/library/windows/desktop/dd162454) Strukturen, die die breiten Zeichen empfangen. Dieses Array muss mindestens so viele **ABC** Strukturen als Glyphe Indizes sind die *Cgi* Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion emuliert die Funktionen der Funktion [GetCharABCWidthsI](http://msdn.microsoft.com/library/windows/desktop/dd144859)gemäß der Beschreibung im Windows SDK.  
  
##  <a name="getcharwidth"></a>  CDC::GetCharWidth  
 Ruft die Breite der einzelnen Zeichen in eine aufeinander folgende Gruppe von Zeichen aus der aktuellen Schriftart ab mit `m_hAttribDC`, Eingabegerät, das Kontext.  
  
```  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    float* lpFloatBuffer) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *nFirstChar*  
 Gibt das erste Zeichen in eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart an.  
  
 *nLastChar*  
 Gibt das letzte Zeichen in eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart an.  
  
 *lpBuffer*  
 Zeigt auf einen Puffer, der die Breitenwerte für eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart erhält.  
  
 *lpFloatBuffer*  
 Zeigt auf einen Puffer zur Aufnahme der breiten Zeichen. Die zurückgegebene breiten befinden sich in der 32-Bit-IEEE-Gleitkomma-Format. (Die Breiten werden entlang der Grundlinie der Zeichen gemessen.)  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Z. B. wenn *nFirstChar* identifiziert den Buchstaben "a" und *nLastChar* identifiziert dem Buchstaben "Z", die Funktion ruft die Breite der alle Kleinbuchstaben.  
  
 Die Funktion speichert die Werte in den Puffer verweist *LpBuffer*. Dieser Puffer muss groß genug für alle der breiten. D. h. muss es mindestens 26 Einträge im Beispiel angegeben.  
  
 Wenn ein Zeichen in dem aufeinander folgende Gruppe von Zeichen in einer bestimmten Schriftart nicht vorhanden ist, wird der Breitenwert des Standardzeichensatzes zugewiesen werden.  
  
##  <a name="getcharwidthi"></a>  CDC::GetCharWidthI  
 Ruft die Breite in logischen Koordinaten von aufeinander folgenden Glyphe Indizes in einem angegebenen Bereich aus der aktuellen Schriftart ab.  
  
```  
BOOL GetCharWidthI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *giFirst*  
 Gibt die ersten Glyphe Index in der Gruppe von aufeinander folgenden Glyphe Indizes aus der aktuellen Schriftart an. Dieser Parameter wird nur verwendet, wenn die *Pgi* Parameter ist **NULL**.  
  
 *CGI*  
 Gibt die Anzahl der Symbolindizes an.  
  
 *PGI*  
 Ein Zeiger auf ein Array mit Glyphe Indizes. Wenn der Wert **NULL**, *GiFirst* Parameter wird stattdessen verwendet. Die *Cgi* Parameter gibt die Anzahl der Symbolindizes in diesem Array.  
  
 *lpBuffer*  
 Ein Zeiger auf einen Puffer, der die Breite empfängt.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion emuliert die Funktionen der Funktion [GetCharWidthI](http://msdn.microsoft.com/library/windows/desktop/dd144864)gemäß der Beschreibung im Windows SDK.  
  
##  <a name="getclipbox"></a>  CDC::GetClipBox  
 Ruft die Dimensionen des tightest umschließenden Rechtecks um den aktuellen Clipping Grenze ab.  
  
```  
virtual int GetClipBox(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Verweist auf die [RECT](../../mfc/reference/rect-structure1.md) Struktur oder [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das die Abmessungen des Rechtecks empfangen.  
  
### <a name="return-value"></a>Rückgabewert  
 Der Typ des Clippingbereichs. Die folgenden Werte sind möglich:  
  
- **COMPLEXREGION** Ausschneidebereich weist überlappende Rahmen.  
  
- **Fehler** Gerätekontext ist ungültig.  
  
- **NULLREGION** Ausschneidebereich ist leer.  
  
- **SIMPLEREGION** Ausschneidebereich besitzt keine überlappenden Rahmen.  
  
### <a name="remarks"></a>Hinweise  
 Die Dimensionen sind in den Puffer verweist kopiert *LpRect*.  
  
##  <a name="getcoloradjustment"></a>  CDC::GetColorAdjustment  
 Ruft die Farbe Anpassungswerte für den Gerätekontext ab.  
  
```  
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpColorAdjust*  
 Verweist auf eine [COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md) Datenstruktur, um die Werte der Farbe Anpassung zu empfangen.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
##  <a name="getcurrentbitmap"></a>  CDC::GetCurrentBitmap  
 Gibt einen Zeiger auf das derzeit ausgewählte `CBitmap` Objekt.  
  
```  
CBitmap* GetCurrentBitmap() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Zeiger auf eine `CBitmap` -Objekt, wenn erfolgreich; andernfalls **NULL**.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion kann temporäre Objekte zurückgeben.  
  
##  <a name="getcurrentbrush"></a>  CDC::GetCurrentBrush  
 Gibt einen Zeiger auf das derzeit ausgewählte `CBrush` Objekt.  
  
```  
CBrush* GetCurrentBrush() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Zeiger auf eine `CBrush` -Objekt, wenn erfolgreich; andernfalls **NULL**.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion kann temporäre Objekte zurückgeben.  
  
##  <a name="getcurrentfont"></a>  CDC::GetCurrentFont  
 Gibt einen Zeiger auf das derzeit ausgewählte `CFont` Objekt.  
  
```  
CFont* GetCurrentFont() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Zeiger auf eine `CFont` -Objekt, wenn erfolgreich; andernfalls **NULL**.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion kann temporäre Objekte zurückgeben.  
  
##  <a name="getcurrentpalette"></a>  CDC::GetCurrentPalette  
 Gibt einen Zeiger auf das derzeit ausgewählte `CPalette` Objekt.  
  
```  
CPalette* GetCurrentPalette() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Zeiger auf eine `CPalette` -Objekt, wenn erfolgreich; andernfalls **NULL**.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion kann temporäre Objekte zurückgeben.  
  
##  <a name="getcurrentpen"></a>  CDC::GetCurrentPen  
 Gibt einen Zeiger auf das derzeit ausgewählte `CPen` Objekt.  
  
```  
CPen* GetCurrentPen() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Zeiger auf eine `CPen` -Objekt, wenn erfolgreich; andernfalls **NULL**.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion kann temporäre Objekte zurückgeben.  
  
##  <a name="getcurrentposition"></a>  CDC::GetCurrentPosition  
 Ruft die aktuelle Position (in logischen Koordinaten) ab.  
  
```  
CPoint GetCurrentPosition() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Der aktuellen Position als ein `CPoint` Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Die aktuelle Position festgelegt werden kann, mit der `MoveTo` Memberfunktion.  
  
##  <a name="getdcbrushcolor"></a>  CDC::GetDCBrushColor  
 Ruft die aktuelle Pinselfarbe ab.  
  
```  
COLORREF GetDCBrushColor() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Wenn die Funktion erfolgreich ausgeführt wird, ist der Rückgabewert der [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) Wert für die aktuelle Pinselfarbe.  
  
 Wenn die Funktion fehlschlägt, ist der Rückgabewert **CLR_INVALID**.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion emuliert die Funktionen der Funktion [GetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd144872)gemäß der Beschreibung im Windows SDK.  
  
##  <a name="getdcpencolor"></a>  CDC::GetDCPenColor  
 Ruft die aktuelle Stiftfarbe ab.  
  
```  
COLORREF GetDCPenColor() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Wenn die Funktion erfolgreich ausgeführt wird, ist der Rückgabewert der [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) Wert für die aktuelle Stiftfarbe.  
  
 Wenn die Funktion fehlschlägt, ist der Rückgabewert **CLR_INVALID**.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion verwendet die Win32-Funktion [GetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd144875)gemäß der Beschreibung im Windows SDK.  
  
##  <a name="getdevicecaps"></a>  GetDeviceCaps  
 Ruft eine Vielzahl von Geräte-spezifischer Informationen zu dem Anzeigegerät ab.  
  
```  
int GetDeviceCaps(int nIndex) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *nIndex*  
 Gibt den Typ der zurückzugebenden Informationen. Finden Sie unter [GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877) in das Windows SDK für eine Liste von Werten.  
  
### <a name="return-value"></a>Rückgabewert  
 Der Wert für die angeforderte Funktion, wenn die Funktion erfolgreich ausgeführt wird.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).  
  
##  <a name="getfontdata"></a>  CDC::GetFontData  
 Ruft die Schriftart-Metrik Informationen aus einer skalierbaren Schriftartdatei ab.  
  
```  
DWORD GetFontData(
    DWORD dwTable,  
    DWORD dwOffset,  
    LPVOID lpData,  
    DWORD cbData) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *dwTable*  
 Gibt den Namen der Metrik Tabelle zurückgegeben werden. Dieser Parameter kann eine der Metriken Tabellen dokumentiert in der TrueType-Schriftartdateien-Spezifikation, die von der Microsoft Corporation veröffentlicht sein. Wenn dieser Parameter 0 ist, wird die Informationen abgerufen am Anfang der Schriftartdatei ab.  
  
 *dwOffset*  
 Gibt den Offset vom Anfang der Tabelle auf dem Informationen abgerufen werden soll. Wenn dieser Parameter 0 ist, die Informationen abgerufen beginnend am Anfang der Tabelle, die gemäß der *DwTable* Parameter. Wenn dieser Wert größer als oder gleich der Größe der Tabelle, `GetFontData` gibt 0 zurück.  
  
 *lpData*  
 Zeigt auf einen Puffer, der die Schriftartinformationen erhält. Wenn dieser Wert ist **NULL**, die Funktion gibt die Größe des Puffers für die im angegebenen Schriftartdaten erforderlichen der *DwTable* Parameter.  
  
 *cbData*  
 Gibt die Länge in Bytes, der Informationen abgerufen werden sollen. Wenn dieser Parameter 0 ist, `GetFontData` gibt die Größe der Daten in der *DwTable* Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt die Anzahl der Bytes im Puffer verweist zurückgegeben *LpData* ist die Funktion erfolgreich, andernfalls -1.  
  
### <a name="remarks"></a>Hinweise  
 Die abzurufenden Informationen wird durch Angeben eines Offsets in die Schriftartdatei und die Länge der zurückzugebenden Informationen identifiziert.  
  
 Eine Anwendung kann in einigen Fällen verwenden die `GetFontData` Member-Funktion, um eine TrueType-Schriftart mit einem Dokument zu speichern. Zu diesem Zweck wird die Anwendung bestimmt, ob die Schriftart eingebettet werden kann, und ruft dann die gesamte Schriftartdatei Angabe von 0 für die *DwTable*, *DwOffset*, und *CbData* Parameter.  
  
 Anwendungen können bestimmen, ob eine Schriftart kann, indem Sie überprüfen eingebettet werden die **OtmfsType** Mitglied der [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) Struktur. Wenn 1 bit **OtmfsType** festgelegt ist, Einbetten von ist für die Schriftart nicht zulässig. Wenn 1-Bit deaktiviert ist, kann die Schriftart eingebettet. Wenn das Bit 2 festgelegt ist, ist das Einbetten schreibgeschützt.  
  
 Wenn eine Anwendung versucht, diese Funktion zu verwenden, um das Abrufen von Informationen für eine nicht-TrueType-Schriftart die `GetFontData` Memberfunktion gibt-1 zurück.  
  
##  <a name="getfontlanguageinfo"></a>  CDC::GetFontLanguageInfo  
 Gibt Informationen zu den aktuell ausgewählten Schriftart für den angegebenen Anzeigekontext zurück.  
  
```  
DWORD GetFontLanguageInfo() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Der Rückgabewert gibt Merkmale der derzeit ausgewählten Schriftart. Eine vollständige Liste der möglichen Werte finden Sie unter [GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886).  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion emuliert die Funktionen der Funktion [GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886)gemäß der Beschreibung im Windows SDK.  
  
##  <a name="getglyphoutline"></a>  CDC::GetGlyphOutline  
 Ruft die Gliederung Kurve oder eine Bitmap für eine Gliederung Zeichen in der aktuellen Schriftart ab.  
  
```  
DWORD GetGlyphOutline(
    UINT nChar,  
    UINT nFormat,  
    LPGLYPHMETRICS lpgm,  
    DWORD cbBuffer,  
    LPVOID lpBuffer,  
    const MAT2* lpmat2) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *nChar*  
 Gibt das Zeichen für das Informationen zurückgegeben werden.  
  
 *nFormat*  
 Gibt das Format, in dem die Funktion zum Zurückgeben von Informationen ist. Einer der folgenden Werte oder 0 sind möglich:  
  
|Wert|Bedeutung|  
|-----------|-------------|  
|**GGO_BITMAP**|Gibt die Symbolbitmap zurück. Wenn die Funktion zurückgibt, den Puffer verweist *LpBuffer* enthält eine 1 Bit pro Pixel-Bitmap, deren Zeilen auf Doppelwort Grenzen zu starten.|  
|**GGO_NATIVE**|Gibt die Kurve Datenpunkte die Rasterisierungsfunktion systemeigene Datenformate Geräteeinheiten mit zurück. Wenn dieser Wert angegeben ist, wird jede Transformation in angegebenen *lpmat2* wird ignoriert.|  
  
 Wenn der Wert der *nFormat* gleich 0 ist, füllt die Funktion eine [GLYPHMETRICS](http://msdn.microsoft.com/library/windows/desktop/dd144955) -Struktur, aber keine Glyphe Gliederung Daten zurückgibt.  
  
 *lpgm*  
 Verweist auf eine **GLYPHMETRICS** Struktur, die die Platzierung des Symbols im Zeichenzelle beschreibt.  
  
 *cbBuffer*  
 Gibt die Größe des Puffers, in dem die Funktion Informationen über die Gliederung Zeichen kopiert. Wenn dieser Wert 0 ist und die *nFormat* Parameter ist entweder der **GGO_BITMAP** oder **GGO_NATIVE** Werte, die Funktion gibt die erforderliche Größe des Puffers zurück.  
  
 *lpBuffer*  
 Zeigt auf einen Puffer, in dem die Funktion Informationen über die Gliederung Zeichen kopiert. Wenn *nFormat* gibt an, die **GGO_NATIVE** Wert, der Informationen wird in Form von kopiert **TTPOLYGONHEADER** und **TTPOLYCURVE** Strukturen. Wenn dieser Wert ist **NULL** und *nFormat* handelt es sich um die **GGO_BITMAP** oder **GGO_NATIVE** Wert, die Funktion gibt die erforderliche Größe von der Puffer.  
  
 *lpmat2*  
 Verweist auf eine [MAT2](http://msdn.microsoft.com/library/windows/desktop/dd145048) -Struktur, die eine Transformationsmatrix für das Zeichen enthält. Dieser Parameter darf nicht sein **NULL**, selbst wenn die **GGO_NATIVE** Wert wird angegeben, für die *nFormat*.  
  
### <a name="return-value"></a>Rückgabewert  
 Die Größe in Bytes, des Puffers für die abgerufenen Informationen erforderlich, wenn *CbBuffer* 0 oder *LpBuffer* ist **NULL**. Ist, andernfalls ein positiver Wert, wenn die Funktion erfolgreich ist oder -1, wenn ein Fehler vorliegt.  
  
### <a name="remarks"></a>Hinweise  
 Eine Anwendung kann im Bitmapformat durch Angabe einer Transformationsmatrix 2 x 2-in der Struktur verweist abgerufene Zeichen drehen *lpmat2*.  
  
 Eine Glyphe Gliederung wird als eine Reihe von Konturen zurückgegeben. Jede Kontur wird definiert, indem eine [TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158) Struktur so viele gefolgt **TTPOLYCURVE** Strukturen als erforderlich sind, um es zu beschreiben. Alle Punkte werden zurückgegeben, als [POINTFX](http://msdn.microsoft.com/library/windows/desktop/dd162806) -Strukturen und absolute Positionen, keinen relativen wechselt darstellen. Den Ausgangspunkt angegeben durch die **PfxStart** Mitglied der [TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158) Struktur ist der Punkt, an dem die Kontur einer Kontur beginnt. Die [TTPOLYCURVE](http://msdn.microsoft.com/library/windows/desktop/dd145157) Strukturen, die folgen kann entweder Polylinie oder Spline-Datensätze. Polylinie Datensätze sind eine Reihe von Punkten. zwischen den Punkten gezeichnete Linien beschreiben die Gliederung des Zeichens an. Spline Datensätze darstellen, die quadratischen Kurven von TrueType (d. h. quadratische b-Splines) verwendet wird.  
  
##  <a name="getgraphicsmode"></a>  CDC::GetGraphicsMode  
 Ruft den aktuellen Graphics-Modus für den angegebenen Gerätekontext ab.  
  
```  
int GetGraphicsMode() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Bei Erfolg wird den aktuelle Graphics-Modus zurückgegeben. Eine Liste der Werte, die diese Methode zurückgeben können, finden Sie unter [GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892).  
  
 Gibt 0 bei einem Fehler zurück.  
  
 Um erweiterte Fehlerinformationen abzurufen, rufen [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode dient als Wrapper für die Windows-GDI-Funktion [GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892).  
  
##  <a name="gethalftonebrush"></a>  CDC::GetHalftoneBrush  
 Rufen Sie diese Memberfunktion, um einen Pinsel Rasterbild abzurufen.  
  
```  
static CBrush* PASCAL GetHalftoneBrush();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Zeiger auf eine `CBrush` -Objekt, wenn erfolgreich; andernfalls **NULL**.  
  
### <a name="remarks"></a>Hinweise  
 Ein Rasterbild Pinsel zeigt Pixel, die klicken Sie alternativ die Vordergrund- und Hintergrundfarben ein gedithertes Muster zu erstellen sind. Im folgenden ist ein Beispiel für ein gedithertes Muster erstellt, indem ein Rasterbild Pinsel.  
  
 ![Detail eines geditherten Stiftstrichs](../../mfc/reference/media/vc318s1.gif "vc318s1")  
  
##  <a name="getkerningpairs"></a>  CDC::GetKerningPairs  
 Ruft das Zeichen kerning-Paare für die Schriftart, die den angegebenen Gerätekontext aktuell ausgewählt ist.  
  
```  
int GetKerningPairs(
    int nPairs,  
    LPKERNINGPAIR lpkrnpair) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *nPairs*  
 Gibt die Anzahl der [KERNINGPAIR](http://msdn.microsoft.com/library/windows/desktop/dd145024) Strukturen verweist *Lpkrnpair*. Die Funktion kopiert nicht mehr kerning Paare als *nPairs*.  
  
 *lpkrnpair*  
 Verweist auf ein Array von **KERNINGPAIR** Strukturen, die das kerning empfangen-Paaren bei Rückgabe der Funktion. Dieses Array muss mindestens so viele Strukturen Angaben enthalten *nPairs*. Wenn dieser Parameter ist **NULL**, die Funktion gibt die Gesamtanzahl der kerning-Paare für die Schriftart zurück.  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt die Anzahl der kerning Paare abgerufen oder die Gesamtanzahl der kerning-Paare in der Schriftart an, wenn die Funktion erfolgreich ausgeführt wird. 0 (null) wird zurückgegeben, wenn die Funktion fehlerhaft ist, oder es keine kerning-Paare für die Schriftart sind.  
  
##  <a name="getlayout"></a>  CDC::GetLayout  
 Rufen Sie diese Memberfunktion, um das Layout von Text und Grafiken für einen Gerätekontext, z. B. einen Drucker oder eine Metadatei zu bestimmen.  
  
```  
DWORD GetLayout() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Im Erfolgsfall kennzeichnet das Layout für den aktuellen Gerätekontext. Andernfalls **GDI_ERROR**. Rufen Sie für erweiterte Fehlerinformationen [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360). Eine Liste der Flags, die Layout, finden Sie unter [CDC::SetLayout](#setlayout).  
  
### <a name="remarks"></a>Hinweise  
 Das Standardlayout ist links nach rechts.  
  
##  <a name="getmapmode"></a>  CDC::GetMapMode  
 Ruft den aktuellen Zuordnungsmodus ab.  
  
```  
int GetMapMode() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Den Zuordnungsmodus.  
  
### <a name="remarks"></a>Hinweise  
 Eine Beschreibung der Zuordnungsmodi finden Sie in der `SetMapMode` Memberfunktion.  
  
> [!NOTE]
>  Beim Aufrufen [SetLayout](#setlayout) so ändern Sie den Domänencontroller auf rechts-nach-links-Layout `SetLayout` ändert automatisch den Zuordnungsmodus zu `MM_ISOTROPIC`. Folglich jeder nachfolgende Aufruf von `GetMapMode` zurück `MM_ISOTROPIC`.  
  
##  <a name="getmiterlimit"></a>  CDC::GetMiterLimit  
 Gibt den Winkel Grenzwert für den Gerätekontext zurück.  
  
```  
float GetMiterLimit() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der Grenzwert für den Winkel wird beim Zeichnen geometrische Zeilen mit Joins Linienverbindungsstile verwendet.  
  
##  <a name="getnearestcolor"></a>  CDC::GetNearestColor  
 Gibt die Volltonfarbe, die eine bestimmten logischen Farbe am besten entspricht.  
  
```  
COLORREF GetNearestColor(COLORREF crColor) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *crColor*  
 Gibt die Farbe, die abgeglichen werden.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein RGB (Rot, Grün, Blau)-Farbe-Wert, der die Durchgezogen definiert Farbe am nächsten gelegenen der *CrColor* -Wert, der das Gerät darstellen kann.  
  
### <a name="remarks"></a>Hinweise  
 Das angegebene Gerät muss diese Farbe darstellen können.  
  
##  <a name="getoutlinetextmetrics"></a>  CDC::GetOutlineTextMetrics  
 Ruft die Metrik Informationen TrueType-Schriftarten ab.  
  
```  
UINT GetOutlineTextMetrics(
    UINT cbData,  
    LPOUTLINETEXTMETRIC lpotm) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpotm*  
 Verweist auf ein Array von [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) Strukturen. Wenn dieser Parameter ist **NULL**, die Funktion gibt die Größe des Puffers für die abgerufenen metrischen Daten erforderlich sind.  
  
 *cbData*  
 Gibt die Größe in Byte des Puffers an, zu dem Informationen zurückgegeben werden.  
  
 *lpotm*  
 Verweist auf ein **OUTLINETEXTMETRIC** Struktur. Wenn dieser Parameter ist **NULL**, die Funktion gibt die Größe des Puffers für die Metrik abgerufenen Informationen erforderlich sind.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Die [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) Struktur enthält die meisten bereitgestellt, mit dem Format TrueType-Schriftart Metrik Informationen einschließlich einer [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) Struktur. Die letzten vier Member, der die **OUTLINETEXTMETRIC** Struktur sind Zeiger auf Zeichenfolgen. Anwendungen sollten diese Zeichenfolgen zusätzlich zu den erforderlichen Speicherplatz für die anderen Member Speicherplatz zuweisen. Da unbegrenzt System auferlegt die Größe der Zeichenfolgen vorhanden ist, ist die einfachste Methode zum Belegen von Speicher durch Angabe die erforderliche Größe abzurufenden **NULL** für *Lpotm* im ersten Aufruf der `GetOutlineTextMetrics` Funktion.  
  
##  <a name="getoutputcharwidth"></a>  CDC::GetOutputCharWidth  
 Verwendet den Gerätekontext Ausgabe `m_hDC`, und ruft die Breite der einzelnen Zeichen in eine aufeinander folgende Gruppe von Zeichen aus der aktuellen Schriftart ab.  
  
```  
BOOL GetOutputCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *nFirstChar*  
 Gibt das erste Zeichen in eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart an.  
  
 *nLastChar*  
 Gibt das letzte Zeichen in eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart an.  
  
 *lpBuffer*  
 Zeigt auf einen Puffer, der die Breitenwerte für eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart erhält.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Z. B. wenn *nFirstChar* identifiziert den Buchstaben "a" und *nLastChar* identifiziert dem Buchstaben "Z", die Funktion ruft die Breite der alle Kleinbuchstaben.  
  
 Die Funktion speichert die Werte in den Puffer verweist *LpBuffer*. Dieser Puffer muss groß genug für alle der breiten sein. d. h. muss es mindestens 26 Einträge im Beispiel angegeben.  
  
 Wenn ein Zeichen in dem aufeinander folgende Gruppe von Zeichen in einer bestimmten Schriftart nicht vorhanden ist, wird der Breitenwert des Standardzeichensatzes zugewiesen werden.  
  
##  <a name="getoutputtabbedtextextent"></a>  CDC::GetOutputTabbedTextExtent  
 Rufen Sie diese Memberfunktion, um die Breite und Höhe einer Zeichenfolge mit Zeichen berechnen [M_hDC](#m_hdc), die Ausgabe-Gerätekontext.  
  
```  
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetOutputTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpszString*  
 Verweist auf eine Zeichenfolge, die gemessen werden. Sie können auch übergeben einer [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.  
  
 *nCount*  
 Gibt die Anzahl von Zeichen in der Zeichenfolge an. Wenn *nCount* ist-1, wird die Länge berechnet.  
  
 *nTabPositions*  
 Gibt die Anzahl der Tabstopp Positionen im Array verweist *LpnTabStopPositions*.  
  
 *lpnTabStopPositions*  
 Verweist auf ein Array von Ganzzahlen, das die Tabstopp Positionen in logischen Einheiten enthält. Die Tabstopps müssen in aufsteigender Reihenfolge sortiert werden; der kleinste X-Wert muss das erste Element im Array. Back-Registerkarten sind nicht zulässig.  
  
 *str*  
 Ein `CString` -Objekt, das die angegebenen Zeichen gemessen werden.  
  
### <a name="return-value"></a>Rückgabewert  
 Die Dimensionen der Zeichenfolge (in logischen Einheiten) in einem [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Wenn die Zeichenfolge eine oder mehrere Tabulatorzeichen enthält, basiert die Breite der Zeichenfolge auf die Tabstopps gemäß *LpnTabStopPositions*. Die Funktion verwendet die aktuell ausgewählte Schriftart, um die Dimensionen der Zeichenfolge berechnen.  
  
 Die Breite und Höhe zurückgegebenes des aktuellen Ausschneidebereichs kein versetzen der `GetOutputTabbedTextExtent` Funktion.  
  
 Da einige Geräte kein Zeichen in normale Zelle Arrays setzen (d. h. sie Unterschneiden Zeichen), die Summe der Blöcke der Zeichen in einer Zeichenfolge darf nicht das Ausmaß der Zeichenfolge gleich sein.  
  
 Wenn *nTabPositions* ist 0 und *LpnTabStopPositions* ist **NULL**, Registerkarten auf acht durchschnittliche Zeichen breiten erweitert werden. Wenn *nTabPositions* beträgt 1, der Tabstopps getrennt werden von der durch den ersten Wert in das Array, das dem angegebenen Abstand *LpnTabStopPositions* Punkte. Wenn *LpnTabStopPositions* verweist auf mehr als einen einzelnen Wert, ein Tabstopp wird festgelegt, für jeden Wert im Array, bis zur Anzahl von angegebenen *nTabPositions*.  
  
##  <a name="getoutputtextextent"></a>  CDC::GetOutputTextExtent  
 Rufen Sie diese Memberfunktion um den Gerätekontext Ausgabe verwenden [M_hDC](#m_hdc), und die Breite und Höhe einer Textzeile, mit der aktuellen Schriftart zu berechnen.  
  
```  
CSize GetOutputTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetOutputTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpszString*  
 Zeigt auf eine Zeichenfolge von Zeichen. Sie können auch übergeben einer [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.  
  
 *nCount*  
 Gibt die Anzahl von Zeichen in der Zeichenfolge an. Wenn *nCount* ist-1, wird die Länge berechnet.  
  
 *str*  
 Ein `CString` -Objekt, das die angegebenen Zeichen gemessen werden.  
  
### <a name="return-value"></a>Rückgabewert  
 Die Dimensionen der Zeichenfolge (in logischen Einheiten) zurückgegeben, die einem [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Der aktuelle Ausschneidebereich hat keinen Einfluss auf die Breite und Höhe zurückgegebenes `GetOutputTextExtent`.  
  
 Da einige Geräte kein Zeichen in normale Zelle Arrays setzen (d. h. sie durchzuführen, kerning), die Summe der Blöcke der Zeichen in einer Zeichenfolge darf nicht das Ausmaß der Zeichenfolge gleich sein.  
  
##  <a name="getoutputtextmetrics"></a>  CDC::GetOutputTextMetrics  
 Ruft die Metriken für die aktuelle Schriftart mit `m_hDC`, die Ausgabe-Gerätekontext.  
  
```  
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpMetrics*  
 Verweist auf die [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) Struktur, die Metriken empfängt.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
##  <a name="getpath"></a>  CDC::getPath  
 Ruft die Koordinaten definieren die Endpunkte der Zeilen und die Steuerpunkte der Kurven im Pfad, der den Gerätekontext ausgewählt wurde gefunden.  
  
```  
int GetPath(
    LPPOINT lpPoints,  
    LPBYTE lpTypes,  
    int nCount) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) Datenstrukturen oder `CPoint` Objekte, in denen die Endpunkte und die Kurve Steuerpunkte, platziert werden.  
  
 *lpTypes*  
 Verweist auf ein Array von Bytes, wo die Vertextypen platziert werden. Folgende Werte sind eine der folgenden:  
  
- **PT_MOVETO** gibt an, die an den entsprechenden *LpPoints* zusammenhanglose Abbildung beginnt.  
  
- **PT_LINETO** gibt an, die im vorherigen Punkt und dem entsprechenden zeigen *LpPoints* sind die Endpunkte einer Zeile.  
  
- **PT_BEZIERTO** gibt an, die an den entsprechenden *LpPoints* ist ein Kontrollpunkt oder den Endpunkt für eine Kurve Bzier.  
  
 **PT_BEZIERTO** Typen werden immer in Sätze von drei erfolgen. Der Punkt im Pfad unmittelbar vorausgehenden definiert den Anfangspunkt der Kurve Bzier. Die ersten beiden **PT_BEZIERTO** Punkte sind die Steuerpunkte und der dritte **PT_BEZIERTO** Punkt ist der Endpunkt (wenn hartcodierte).  
  
     Ein **PT_LINETO** oder **PT_BEZIERTO** Typ kann mit der folgenden Flags kombiniert werden (mit dem bitweisen Operator **OR**), um anzugeben, dass die entsprechenden Punkt der letzte Punkt ist in Abbildung enthalten und sollten in der Abbildung geschlossen werden:  
  
- **PT_CLOSEFIGURE** gibt an, die in der Abbildung wird automatisch nach der entsprechenden Zeile geschlossen oder die Kurve gezeichnet wird. In der Abbildung wird geschlossen, indem eine Linie vom Endpunkt oder Kurve zu dem Zeitpunkt, zu dem letzten entspricht **PT_MOVETO**.  
  
 *nCount*  
 Gibt die Gesamtanzahl der [Punkt](../../mfc/reference/point-structure1.md) -Datenstrukturen, die in platziert werden, können die *LpPoints* Array. Dieser Wert muss identisch mit der Anzahl der Bytes, die in platziert werden kann die *LpTypes* Array.  
  
### <a name="return-value"></a>Rückgabewert  
 Wenn die *nCount* Parameter ungleich NULL ist, ist die Anzahl der Punkte aufgelistet. Wenn *nCount* ist 0, die Gesamtzahl der Punkte im Pfad (und `GetPath` nichts in den Puffer geschrieben). Wenn *nCount* ist ungleich NULL und kleiner als die Anzahl der Punkte im Pfad, der Rückgabewert-1 ist.  
  
### <a name="remarks"></a>Hinweise  
 Der Gerätekontext muss einen geschlossenen Pfad enthalten. In logischen Koordinaten sind die Punkte des Pfads zurückgegeben. Punkte werden in den Pfad im Gerätekoordinaten gespeichert, daher `GetPath` ändert sich die Punkte von Gerätekoordinaten in logische Koordinaten durch die Umkehrung der aktuellen Transformation verwenden. Die `FlattenPath` Memberfunktion aufgerufen werden kann, bevor `GetPath`, um alle Kurven im Pfad in Liniensegmente konvertieren.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CDC:: beginpath](#beginpath).  
  
##  <a name="getpixel"></a>  CDC::getPixel  
 Ruft ab den RGB-Farbwert des Pixels an dem Punkt gemäß *x* und *y*.  
  
```  
COLORREF GetPixel(
    int x,  
    int y) const;  
  
COLORREF GetPixel(POINT point) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate des Punkts, der untersucht werden.  
  
 *y*  
 Gibt die logische y-Koordinate des Punkts, der untersucht werden.  
  
 *Punkt*  
 Gibt die logische X - und y-Koordinaten des Punkts, der untersucht werden.  
  
### <a name="return-value"></a>Rückgabewert  
 Für eine der Versionen der Funktion, eine RGB-Wert für die Farbe des angegebenen Punkt. Ist -1, wenn die Koordinaten einen Punkt in der Ausschneidebereich keine angeben.  
  
### <a name="remarks"></a>Hinweise  
 Der Punkt muss sich im des Clippingbereichs. Wenn der Verwaltungspunkt nicht in den Ausschneidebereich ist, wird die Funktion wirkt sich nicht und gibt-1 zurück.  
  
 Nicht alle Geräte unterstützen die **GetPixel** Funktion. Weitere Informationen finden Sie unter der **RC_BITBLT** Raster-Funktion unter den [GetDeviceCaps](#getdevicecaps) Memberfunktion.  
  
 Die **GetPixel** Memberfunktion erscheint in zwei Formen. Der erste erfordert zwei Koordinatenwerte; die zweite akzeptiert entweder eine [Punkt](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt.  
  
##  <a name="getpolyfillmode"></a>  CDC::GetPolyFillMode  
 Ruft den aktuellen Polygon Füllmodus ab.  
  
```  
int GetPolyFillMode() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Der aktuelle Polygon ausgefüllte Modus **ALTERNATIVEN** oder **WINDING**, wenn die Funktion erfolgreich ausgeführt wird.  
  
### <a name="remarks"></a>Hinweise  
 Finden Sie unter der `SetPolyFillMode` Memberfunktion für eine Beschreibung der Modi Polygon füllen.  
  
##  <a name="getrop2"></a>  CDC::GetROP2  
 Ruft den aktuellen Zeichnungsmodus ab.  
  
```  
int GetROP2() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Zeichnungsmodus. Eine Liste der Zeichnung Moduswerte, finden Sie unter der `SetROP2` Memberfunktion.  
  
### <a name="remarks"></a>Hinweise  
 Zeichnungsmodus des gibt an, wie die Farben des Stifts und das Innere eines gefüllten Objekte mit der Farbe bereits auf der Anzeigeoberfläche kombiniert werden.  
  
##  <a name="getsafehdc"></a>  CDC::GetSafeHdc  
 Rufen Sie diese Memberfunktion abzurufenden [M_hDC](#m_hdc), die Ausgabe-Gerätekontext.  
  
```  
HDC GetSafeHdc() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Handle für einen Gerätekontext.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion funktioniert auch mit null-Zeiger.  
  
##  <a name="getstretchbltmode"></a>  CDC::GetStretchBltMode  
 Ruft den aktuellen Modus Strecken einer Bitmap ab.  
  
```  
int GetStretchBltMode() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Der Rückgabewert gibt an, den aktuellen Strecken einer Bitmap-Modus – **STRETCH_ANDSCANS**, **STRETCH_DELETESCANS**, oder **STRETCH_ORSCANS** – Wenn die Funktion erfolgreich ausgeführt wird.  
  
### <a name="remarks"></a>Hinweise  
 Strecken einer Bitmap-Modus definiert, wie Informationen über Bitmaps entfernt wird, die gestreckt oder komprimiert die `StretchBlt` Memberfunktion.  
  
 Die **STRETCH_ANDSCANS** und **STRETCH_ORSCANS** Modi werden in der Regel verwendet, um Vordergrund-Pixel monochrome Bitmaps beizubehalten. Die **STRETCH_DELETESCANS** Modus ist in der Regel verwendet, um Farbe in Farbe Bitmaps beizubehalten.  
  
##  <a name="gettabbedtextextent"></a>  CDC::GetTabbedTextExtent  
 Rufen Sie diese Memberfunktion, um die Breite und Höhe einer Zeichenfolge mit Zeichen berechnen [M_hAttribDC](#m_hattribdc), den Gerätekontext Attribut.  
  
```  
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpszString*  
 Verweist auf eine Zeichenfolge. Sie können auch übergeben einer [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.  
  
 *nCount*  
 Gibt die Anzahl von Zeichen in der Zeichenfolge an. Wenn *nCount* ist-1, wird die Länge berechnet.  
  
 *nTabPositions*  
 Gibt die Anzahl der Tabstopp Positionen im Array verweist *LpnTabStopPositions*.  
  
 *lpnTabStopPositions*  
 Verweist auf ein Array von Ganzzahlen, das die Tabstopp Positionen in logischen Einheiten enthält. Die Tabstopps müssen in aufsteigender Reihenfolge sortiert werden; der kleinste X-Wert muss das erste Element im Array. Back-Registerkarten sind nicht zulässig.  
  
 *str*  
 Ein `CString` -Objekt, das die angegebenen Zeichen, gezeichnet werden soll.  
  
### <a name="return-value"></a>Rückgabewert  
 Die Dimensionen der Zeichenfolge (in logischen Einheiten) in einem [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Wenn die Zeichenfolge eine oder mehrere Tabulatorzeichen enthält, basiert die Breite der Zeichenfolge auf die Tabstopps gemäß *LpnTabStopPositions*. Die Funktion verwendet die aktuell ausgewählte Schriftart, um die Dimensionen der Zeichenfolge berechnen.  
  
 Die Breite und Höhe zurückgegebenes des aktuellen Ausschneidebereichs kein versetzen der `GetTabbedTextExtent` Funktion.  
  
 Da einige Geräte kein Zeichen in normale Zelle Arrays setzen (d. h. sie Unterschneiden Zeichen), die Summe der Blöcke der Zeichen in einer Zeichenfolge darf nicht das Ausmaß der Zeichenfolge gleich sein.  
  
 Wenn *nTabPositions* ist 0 und *LpnTabStopPositions* ist **NULL**, Registerkarten auf acht Mal durchschnittliche Zeichenbreite erweitert werden. Wenn *nTabPositions* beträgt 1, der Tabstopps getrennt werden von der durch den ersten Wert in das Array, das dem angegebenen Abstand *LpnTabStopPositions* Punkte. Wenn *LpnTabStopPositions* verweist auf mehr als einen einzelnen Wert, ein Tabstopp wird festgelegt, für jeden Wert im Array, bis zur Anzahl von angegebenen *nTabPositions*.  
  
##  <a name="gettextalign"></a>  CDC::GetTextAlign  
 Ruft den Status der textausrichtung Flags für den Gerätekontext ab.  
  
```  
UINT GetTextAlign() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Der Status der textausrichtung Flags. Der Rückgabewert ist eine oder mehrere der folgenden Werte:  
  
- **TA_BASELINE** gibt die Ausrichtung der x-Achse und der Basislinie der ausgewählten Schriftart innerhalb des umschließenden Rechtecks an.  
  
- **TA_BOTTOM** gibt die Ausrichtung der x-Achse und dem unteren Rand des umschließenden Rechtecks.  
  
- **TA_CENTER** gibt die Ausrichtung der y-Achse und dem Mittelpunkt des umschließenden Rechtecks an.  
  
- **TA_LEFT** gibt die Ausrichtung der y-Achse und der linken Seite des umschließenden Rechtecks.  
  
- **TA_NOUPDATECP** gibt an, dass die aktuelle Position nicht aktualisiert wird.  
  
- **TA_RIGHT** gibt die Ausrichtung der y-Achse und der rechten Seite des umschließenden Rechtecks an.  
  
- **TA_TOP** gibt die Ausrichtung der x-Achse und dem oberen Rand des umschließenden Rechtecks.  
  
- **TA_UPDATECP** gibt an, dass die aktuelle Position aktualisiert wird.  
  
### <a name="remarks"></a>Hinweise  
 Die textausrichtung Flags legen fest, wie die `TextOut` und `ExtTextOut` Memberfunktionen ausrichten eine Textzeichenfolge in Bezug auf die Zeichenfolge Ausgangspunkt. Die textausrichtung Flags sind nicht unbedingt ein Einzelbit-Flags und möglicherweise gleich 0 sein. Um zu testen, ob ein Flag festgelegt ist, sollte eine Anwendung die folgenden Schritte ausführen:  
  
1.  Das Flag und den zugehörigen Flags, wie folgt gruppiert gelten Sie die bitweisen OR-Operator:  
  
    - **TA_LEFT**, **TA_CENTER**, und **TA_RIGHT**  
  
    - **TA_BASELINE**, **TA_BOTTOM**, und **TA_TOP**  
  
    - **TA_NOUPDATECP** und **TA_UPDATECP**  
  
2.  Übernehmen Sie den bitweisen- und Operator, um das Ergebnis und der Rückgabewert der `GetTextAlign`.  
  
3.  Die Gleichheit dieses Ergebnis und das Flag testen.  
  
##  <a name="gettextcharacterextra"></a>  CDC::GetTextCharacterExtra  
 Ruft die aktuelle Einstellung für die Menge an Zeichenabstands ab.  
  
```  
int GetTextCharacterExtra() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Der Anteil der Zeichenabstands.  
  
### <a name="remarks"></a>Hinweise  
 GDI hinzugefügt jedes Zeichen, einschließlich Zeilenumbruchzeichen unverändert, wenn sie eine Textzeile für den Gerätekontext schreibt diesen Abstand.  
  
 Der Standardwert für die Menge an Zeichenabstands ist 0.  
  
##  <a name="gettextcolor"></a>  CDC::GetTextColor  
 Ruft die aktuelle Textfarbe ab.  
  
```  
COLORREF GetTextColor() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Die aktuelle Textfarbe als eine RGB-Wert.  
  
### <a name="remarks"></a>Hinweise  
 Die Textfarbe wird die Vordergrundfarbe von Zeichen, die mit der Ausgabe von Text Memberfunktionen GDI gezeichnet [TextOut](#textout), [ExtTextOut](#exttextout), und [TabbedTextOut](#tabbedtextout).  
  
##  <a name="gettextextent"></a>  CDC::getTextExtent  
 Rufen Sie diese Memberfunktion, um die Breite und Höhe einer Textzeile, verwenden die aktuelle Schriftart zur Ermittlung der Dimensionen zu berechnen.  
  
```  
CSize GetTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpszString*  
 Zeigt auf eine Zeichenfolge von Zeichen. Sie können auch übergeben einer [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.  
  
 *nCount*  
 Gibt die Anzahl von Zeichen in der Zeichenfolge an.  
  
 *str*  
 Ein `CString` Objekt, das die angegebenen Zeichen enthält.  
  
### <a name="return-value"></a>Rückgabewert  
 Die Dimensionen der Zeichenfolge (in logischen Einheiten) in einem [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Die Informationen aus abgerufen [M_hAttribDC](#m_hattribdc), den Gerätekontext Attribut.  
  
 Standardmäßig `GetTextExtent` geht davon aus, der Text für die ruft es ab, die Dimension entlang einer horizontalen Linie festgelegt ist (d. h. die Vorschub ist 0). Bei der Erstellung einer Schriftart eine Vorschub ungleich NULL angeben, müssen Sie den Winkel des Texts explizit abzurufenden die Dimensionen der Zeichenfolge konvertieren.  
  
 Der aktuelle Ausschneidebereich hat keinen Einfluss auf die Breite und Höhe zurückgegebenes `GetTextExtent`.  
  
 Da einige Geräte kein Zeichen in normale Zelle Arrays setzen (d. h. sie durchzuführen, kerning), die Summe der Blöcke der Zeichen in einer Zeichenfolge darf nicht das Ausmaß der Zeichenfolge gleich sein.  
  
##  <a name="gettextextentexpointi"></a>  CDC::GetTextExtentExPointI  
 Ruft die Anzahl der Zeichen in einer angegebenen Zeichenfolge, die in einem angegebenen Raum zu passen, und füllt ein Array mit der Text-Block für jede dieser Zeichen ab.  
  
```  
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,  
    int cgi,  
    int nMaxExtent,  
    LPINT lpnFit,  
    LPINT alpDx,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *pgiIn*  
 Ein Zeiger auf ein Array von Glyphe Indizes für die Blöcke sind, abgerufen werden sollen.  
  
 *CGI*  
 Gibt die Anzahl der Symbole im Array verweist *PgiIn*.  
  
 *nMaxExtent*  
 Gibt die maximale zulässige Breite in logischen Einheiten der formatierten Zeichenfolge an.  
  
 *lpnFit*  
 Ein Zeiger auf eine ganze Zahl, die Anzahl der die maximale Anzahl von Zeichen empfängt, die in dem Bereich gemäß passen *nMaxExtent*. Wenn *LpnFit* ist **NULL**, *nMaxExtent* wird ignoriert.  
  
 *alpDx*  
 Ein Zeiger auf ein Array von Ganzzahlen, die teilweise Glyphe Blöcke empfängt. Jedes Element im Array enthält die Entfernung in logischen Einheiten, zwischen dem Anfang der Glyphe Indexarray und eines der Symbole, die in den vom angegebenen Platz passt *nMaxExtent*. Obwohl dieses Array Glyphe Indizes mindestens so viele Elemente verfügen soll *Cgi*, die Funktion füllt das Array mit den Wertebereichen nur für so viele Glyphe Indizes wie vom angegebenen *LpnFit*. Wenn *LpnDx* ist **NULL**, berechnet die Funktion nicht Teil der Zeichenfolge Breite.  
  
 *lpSize*  
 Zeiger auf eine [Größe](http://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur, die Dimensionen des Arrays Indizes Glyphe in logischen Einheiten empfängt. Dieser Wert darf nicht **NULL**.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion emuliert die Funktionen der Funktion [GetTextExtentExPointI](http://msdn.microsoft.com/library/windows/desktop/dd144936)gemäß der Beschreibung im Windows SDK.  
  
##  <a name="gettextextentpointi"></a>  CDC::GetTextExtentPointI  
 Ruft die Breite und Höhe des angegebenen Arrays von Glyphe Indizes.  
  
```  
BOOL GetTextExtentPointI(
    LPWORD pgiIn,  
    int cgi,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *pgiIn*  
 Ein Zeiger auf ein Array von Glyphe Indizes für die Blöcke sind, abgerufen werden sollen.  
  
 *CGI*  
 Gibt die Anzahl der Symbole im Array verweist *PgiIn*.  
  
 *lpSize*  
 Zeiger auf eine [Größe](http://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur, die Dimensionen des Arrays Indizes Glyphe in logischen Einheiten empfängt. Dieser Wert darf nicht **NULL**.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion emuliert die Funktionen der Funktion [GetTextExtentPointI](http://msdn.microsoft.com/library/windows/desktop/dd144939)gemäß der Beschreibung im Windows SDK.  
  
##  <a name="gettextface"></a>  CDC::GetTextFace  
 Rufen Sie diese Memberfunktion um den Namen der aktuellen Schriftart in einen Puffer zu kopieren.  
  
```  
int GetTextFace(
    int nCount,  
    LPTSTR lpszFacename) const;  
  
int GetTextFace(CString& rString) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *nCount*  
 Gibt die Größe des Puffers (in Bytes). Wenn der Schriftartname länger als die Anzahl der Bytes, die mit diesem Parameter angegebenen ist, wird der Name abgeschnitten.  
  
 *lpszFacename*  
 Verweist auf den Puffer für den Schriftartnamen.  
  
 *rString*  
 Ein Verweis auf eine [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt.  
  
### <a name="return-value"></a>Rückgabewert  
 Die Anzahl der Bytes, die in den Puffer, nicht einschließlich des abschließenden Null-Zeichens kopiert. Es ist 0, wenn ein Fehler auftritt.  
  
### <a name="remarks"></a>Hinweise  
 Der Schriftartname wird als Null-terminierte Zeichenfolge kopiert.  
  
##  <a name="gettextmetrics"></a>  CDC::GetTextMetrics  
 Ruft die Metriken für die aktuelle Schriftart, die mit den Gerätekontext Attribut ab.  
  
```  
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpMetrics*  
 Verweist auf die [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) Struktur, die Metriken empfängt.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
##  <a name="getviewportext"></a>  CDC::GetViewportExt  
 Ruft die x und y-Blöcke des Viewports für den Gerätekontext ab.  
  
```  
CSize GetViewportExt() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Die X - und y-Blöcke (in Geräteeinheiten) als ein `CSize` Objekt.  
  
##  <a name="getviewportorg"></a>  CDC::GetViewportOrg  
 Ruft die x- und y-Koordinaten des Ursprungs des Viewports zugeordneten den Gerätekontext ab.  
  
```  
CPoint GetViewportOrg() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Der Ursprung des Viewports (in logische Koordinaten) als ein `CPoint` Objekt.  
  
##  <a name="getwindow"></a>  CDC::GetWindow  
 Gibt das Fenster den Anzeigekontext für das Gerät zugeordnet.  
  
```  
CWnd* GetWindow() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Zeiger auf eine `CWnd` -Objekt, wenn erfolgreich; andernfalls **NULL**.  
  
### <a name="remarks"></a>Hinweise  
 Dies ist eine erweiterte Funktion. Beispielsweise kann diese Memberfunktion das Ansichtsfenster nicht beim Drucken oder in der Seitenansicht zurückgeben. Es gibt immer das Fenster Ausgabe zugeordnet ist. In diesem Fenster ausgabefunktionen, die den angegebenen Domänencontroller verwenden gezeichnet werden soll.  
  
##  <a name="getwindowext"></a>  CDC::GetWindowExt  
 Ruft die x und y-Blöcke des Fensters den Gerätekontext zugeordnet.  
  
```  
CSize GetWindowExt() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Die X - und y-Blöcke (in logischen Einheiten) als ein `CSize` Objekt.  
  
##  <a name="getwindoworg"></a>  CDC::GetWindowOrg  
 Ruft den x- und y-Koordinaten des Ursprungs des Fensters den Gerätekontext zugeordnet.  
  
```  
CPoint GetWindowOrg() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Der Ursprung des Fensters (in logischen Koordinaten) als ein `CPoint` Objekt.  
  
##  <a name="getworldtransform"></a>  CDC::GetWorldTransform  
 Ruft den aktuellen World Speicherplatz Seite Speicherplatz Transformation ab.  
  
```  
BOOL GetWorldTransform(XFORM& rXform) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *rXform*  
 Ein Verweis auf ein [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) -Struktur, die der aktuellen World Leerraum Seite Speicherplatz Transformation empfängt.  
  
### <a name="return-value"></a>Rückgabewert  
 Bei Erfolg wird einen Wert ungleich NULL zurückgegeben.  
  
 Gibt 0 bei einem Fehler zurück.  
  
 Um erweiterte Fehlerinformationen abzurufen, rufen [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode dient als Wrapper für die Windows-GDI-Funktion [GetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd144953).  
  
##  <a name="gradientfill"></a>  CDC::GradientFill  
 Rufen Sie diese Memberfunktion zum Rechteck und Dreieck Strukturen mit Farbe gefüllt, die gleichmäßig auf einer Seite in den anderen ausgeblendet wird.  
  
```  
BOOL GradientFill(
    TRIVERTEX* pVertices,  
    ULONG nVertices,  
    void* pMesh,  
    ULONG nMeshElements,  
    DWORD dwMode);
```  
  
### <a name="parameters"></a>Parameter  
 *pVertices*  
 Zeiger auf ein Array von [TRIVERTEX](http://msdn.microsoft.com/library/windows/desktop/dd145142) Strukturen, die jeweils einen Dreieck Vertex definieren.  
  
 *nVertices*  
 Die Anzahl der Scheitelpunkte.  
  
 *pMesh*  
 Array von [GRADIENT_TRIANGLE](http://msdn.microsoft.com/library/windows/desktop/dd144959) im Modus Dreieck oder ein Array von Strukturen [GRADIENT_RECT](http://msdn.microsoft.com/library/windows/desktop/dd144958) Strukturen im Rechteck-Modus.  
  
 *nMeshElements*  
 Die Anzahl von Elementen (Dreiecke oder Rechtecke) in *pMesh*.  
  
 *dwMode*  
 Gibt graduelle Füllung-Modus. Eine Liste der möglichen Werte finden Sie unter [GradientFill](http://msdn.microsoft.com/library/windows/desktop/dd144957) im Windows SDK.  
  
### <a name="return-value"></a>Rückgabewert  
 **"True"** Wenn erfolgreich; andernfalls **"false"**.  
  
### <a name="remarks"></a>Hinweise  
 Weitere Informationen finden Sie unter `GradientFill` im Windows SDK.  
  
##  <a name="graystring"></a>  CDC:: graystring  
 Zeichnet abgeblendet (grau) Text an der angegebenen Position durch Schreiben von Text in eine Bitmap Arbeitsspeicher Abblenden Bitmap und anschließend kopieren die Bitmap der Anzeige.  
  
```  
virtual BOOL GrayString(
    CBrush* pBrush,  
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),  
    LPARAM lpData,  
    int nCount,  
    int x,  
    int y,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Parameter  
 *pBrush*  
 Identifiziert den Pinsel für die (das Abblenden abblendet) verwendet werden soll.  
  
 *lpfnOutput*  
 Gibt die verfahrensinstanz Adresse der Anwendung bereitgestellten Rückruffunktion, die die Zeichenfolge gezeichnet wird. Weitere Informationen finden Sie in der Beschreibung des Windows- **OutputFunc** [Rückruffunktion](callback-functions-used-by-mfc.md#graystring). Wenn dieser Parameter ist **NULL**, das System verwendet den Windows `TextOut` Funktion zum Zeichnen der Zeichenfolge und *LpData* wird davon ausgegangen, dass ein long-Zeiger auf die Zeichenfolge in ausgegeben werden.  
  
 *lpData*  
 Gibt einen ferner Zeiger auf Daten, die an die Ausgabe-Funktion übergeben werden. Wenn *LpfnOutput* ist **NULL**, *LpData* muss ein long-Zeiger auf die Zeichenfolge, die ausgegeben werden.  
  
 *nCount*  
 Gibt die Anzahl von Zeichen in ausgegeben werden. Wenn dieser Parameter 0 ist, `GrayString` berechnet die Länge der Zeichenfolge (vorausgesetzt, dass *LpData* ist ein Zeiger auf die Zeichenfolge). Wenn *nCount* ist-1 und die Funktion verweist, zu *LpfnOutput* 0 zurückgibt, das Bild ist angezeigt, jedoch nicht abgeblendet.  
  
 *w*  
 Gibt die logische X-Koordinate der Startposition des Rechtecks, das die Zeichenfolge enthält.  
  
 *y*  
 Gibt die logische y-Koordinate der Startposition des Rechtecks, das die Zeichenfolge enthält.  
  
 *nWidth*  
 Gibt die Breite (in logischen Einheiten) des Rechtecks, das die Zeichenfolge enthält. Wenn *nWidth* ist 0, `GrayString` berechnet die Breite des Bereichs, vorausgesetzt, *LpData* ist ein Zeiger auf die Zeichenfolge.  
  
 *nHeight*  
 Gibt die Höhe (in logischen Einheiten) des Rechtecks, das die Zeichenfolge enthält. Wenn *nHeight* ist 0, `GrayString` berechnet die Höhe des Bereichs, vorausgesetzt, *LpData* ist ein Zeiger auf die Zeichenfolge.  
  
### <a name="return-value"></a>Rückgabewert  
 Ungleich NULL, wenn die Zeichenfolge gezeichnet wird, oder 0, wenn entweder die `TextOut` Funktion oder die Ausgabe von der Anwendung bereitgestellten Funktion zurückgegebene 0 ist, oder es war nicht genügend Arbeitsspeicher zum Erstellen einer Bitmap Arbeitsspeicher für Abblenden.  
  
### <a name="remarks"></a>Hinweise  
 Die Funktion wird den Text unabhängig von den ausgewählten Pinsel und den Hintergrund abgeblendet. Die `GrayString` Memberfunktion verwendet die aktuell ausgewählte Schriftart. Die `MM_TEXT` Zuordnungsmodus muss ausgewählt sein, bevor Sie diese Funktion verwenden.  
  
 Eine Anwendung kann deaktiviert (abgeblendet) Zeichenfolgen auf Geräten, die eine graue Volltonfarbe ohne Aufruf unterstützen zeichnen die `GrayString` Memberfunktion. Die Systemfarbe **COLOR_GRAYTEXT** Durchgezogen grau Systemfarbe, der zum Zeichnen von deaktivierten Texts verwendet wird. Rufen Sie die Anwendung kann die **GetSysColor** Windows-Funktion zum Abrufen des Werts der Farbe des **COLOR_GRAYTEXT**. Die Anwendung kann aufrufen, ist die Farbe ungleich 0 (Schwarz), die `SetTextColor` Memberfunktion, die die Textfarbe auf den Farbwert festgelegt, und zeichnen Sie dann direkt auf die Zeichenfolge. Wenn die abgerufenen Farbe Schwarz ist, muss die Anwendung aufrufen `GrayString` , abgeblendet (grau) den Text.  
  
 Wenn `lpfnOutput` ist **NULL**, GDI verwendet die Windows [TextOut](http://msdn.microsoft.com/library/windows/desktop/dd145133) -Funktion und *LpData* wird davon ausgegangen, dass ein ferner Zeiger auf das Zeichen in ausgegeben werden. Wenn die Zeichen, die Ausgabe von behandelt werden können die `TextOut` Member-Funktion (z. B. die Zeichenfolge als Bitmap gespeichert ist), die Anwendung muss eine eigene Funktion Ausgabe angeben.  
  
 Beachten Sie außerdem, dass alle Rückruffunktionen vor der Rückgabe an Windows, da Ausnahmen hinweg Rückruf ausgelöst werden, können nicht Microsoft Foundation-Ausnahmen abfangen müssen. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).  
  
 Die Rückruffunktion übergeben wird, um `GrayString` verwenden, müssen die `__stdcall` -Aufrufkonvention verwendet und muss mit exportiert werden `__declspec`.  
  
 Wenn das Framework ist im Vorschaumodus, einen Aufruf der `GrayString` Memberfunktion übersetzt eine `TextOut` Aufruf und die Rückruffunktion wird nicht aufgerufen.  
  
##  <a name="himetrictodp"></a>  CDC::HIMETRICtoDP  
 Verwenden Sie diese Funktion beim Konvertieren von **HIMETRIC** Größen von OLE in Pixel.  
  
```  
void HIMETRICtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpSize*  
 Verweist auf eine [Größe](http://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur oder [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Wenn der Zuordnungsmodus des Kontextobjekts Gerät ist `MM_LOENGLISH`, `MM_HIENGLISH`, `MM_LOMETRIC` oder `MM_HIMETRIC`, und klicken Sie dann die Konvertierung auf die Anzahl der Pixel in der physischen Zoll basiert. Wenn der Zuordnungsmodus einen der anderen Modi nicht eingeschränkt ist (z. B. `MM_TEXT`), und klicken Sie dann die Konvertierung auf die Anzahl der Pixel in der logischem Zoll () basiert.  
  
##  <a name="himetrictolp"></a>  CDC::HIMETRICtoLP  
 Mit dieser Funktion wird zum Konvertieren von **HIMETRIC** Einheiten in logischen Einheiten.  
  
```  
void HIMETRICtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpSize*  
 Verweist auf eine [Größe](http://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur oder [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Verwenden Sie diese Funktion, wenn Sie abrufen **HIMETRIC** Größen von OLE und möchten sie in Ihrer Anwendung natürliche Zuordnungsmodus zu konvertieren.  
  
 Die Konvertierung erfolgt durch die erste Konvertierung den **HIMETRIC** Einheiten in Pixel und klicken Sie dann diese Einheiten in logischen Einheiten, die mit den Gerätekontext aktuelle Zuordnung Einheiten konvertieren. Beachten Sie, dass die Blöcke von Fenster und Viewport des Geräts das Ergebnis ausgewirkt hat.  
  
##  <a name="intersectcliprect"></a>  CDC::IntersectClipRect  
 Erstellt einen neuen Ausschneidebereich durch, die die Schnittmenge der aktuellen Region und die durch angegebene Rechteck bilden *X1*, *y1*, *X2*, und *y2*.  
  
```  
int IntersectClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int IntersectClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Parameter  
 *x1*  
 Gibt die logische X-Koordinate der oberen linken Ecke des Rechtecks an.  
  
 *y1*  
 Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks an.  
  
 *x2*  
 Gibt die logische X-Koordinate der unteren rechten Ecke des Rechtecks an.  
  
 *Y2*  
 Gibt die logische y-Koordinate der unteren rechten Ecke des Rechtecks an.  
  
 *lpRect*  
 Gibt das Rechteck. Übergeben Sie entweder eine `CRect` Objekt oder ein Zeiger auf eine `RECT` Struktur für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Der neue Ausschneidebereich-Typ. Eine der folgenden Werte sind möglich:  
  
- **COMPLEXREGION** neue Ausschneidebereich weist überlappende Rahmen.  
  
- **Fehler** Gerätekontext ist ungültig.  
  
- **NULLREGION** neue Ausschneidebereich ist leer.  
  
- **SIMPLEREGION** neue Ausschneidebereich besitzt keine überlappenden Rahmen.  
  
### <a name="remarks"></a>Hinweise  
 GDI Schneidet alle nachfolgenden Ausgabe an die neue Grenze angepasst. Die Breite und Höhe darf maximal 32.767.  
  
##  <a name="invertrect"></a>  CDC::InvertRect  
 Hierdurch wird der Inhalt des angegebenen Rechtecks.  
  
```  
void InvertRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Verweist auf eine `RECT` , invertiert die logischen Koordinaten des Rechtecks enthält. Sie können auch übergeben ein `CRect` Objekt für diesen Parameter.  
  
### <a name="remarks"></a>Hinweise  
 Die Umkehrung ist ein logisches nicht Vorgang und spiegelt die Bits pro Pixel. In Monochrom angezeigt das, verwendet werden kann die Funktion weißen Pixeln Schwarz und schwarzen weiß. Die Umkehrung hängt in Farbe anzeigen wie Farben für die Anzeige generiert werden. Aufrufen von `InvertRect` zweimal dasselbe Rechteck setzt die Anzeige zu seiner vorherigen Farben.  
  
 Wenn das Rechteck leer ist, wird nichts gezeichnet.  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]  
  
##  <a name="invertrgn"></a>  CDC::InvertRgn  
 Invertiert die Farben in der Region gemäß *PRNG*.  
  
```  
BOOL InvertRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>Parameter  
 *PRNG*  
 Identifiziert die Region, in die umgekehrt werden. Die Koordinaten für die Region sind in logischen Einheiten angegeben.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 In Monochrom angezeigt das, verwendet werden kann die Funktion weißen Pixeln Schwarz und schwarzen weiß. Die Umkehrung hängt in Farbe anzeigen wie die Farben für die Anzeige generiert werden.  
  
##  <a name="isprinting"></a>  CDC::IsPrinting  
 Bestimmt, ob das Gerätekontext für das Drucken verwendet wird.  
  
```  
BOOL IsPrinting() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Einen Wert ungleich null der `CDC` Objekt ist ein Domänencontroller, andernfalls 0.  
  
##  <a name="lineto"></a>  CDC::LineTo  
 Zeichnet eine Linie von der aktuellen Position bis zur, aber nicht einschließlich, die vom angegebenen Punkt *x* und *y* (oder *zeigen*).  
  
```  
BOOL LineTo(
    int x,  
    int y);  
  
BOOL LineTo(POINT point);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate des Endpunkts für die Zeile an.  
  
 *y*  
 Gibt die logische y-Koordinate des Endpunkts für die Zeile an.  
  
 *Punkt*  
 Gibt den Endpunkt für die Zeile. Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Wert ungleich NULL, wenn die Linie gezeichnet wird; andernfalls 0.  
  
### <a name="remarks"></a>Hinweise  
 Die Linie wird mit dem ausgewählten Stift gezeichnet. Die aktuelle Position festgelegt ist, um *x*, *y* oder *zeigen*.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).  
  
##  <a name="lptodp"></a>  CDC::LPtoDP  
 Logische Einheiten konvertiert in Geräteeinheiten.  
  
```  
void LPtoDP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von Punkten. Jeder Punkt in dem Array ist ein [zeigen](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt.  
  
 *nCount*  
 Die Anzahl von Punkten im Array.  
  
 *lpRect*  
 Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt. Dieser Parameter wird für den meisten Fällen der Zuordnung ein Rechteck vom logischen Gerät Einheiten verwendet.  
  
 *lpSize*  
 Verweist auf eine [Größe](http://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur oder ein [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Die Funktion ordnet die Koordinaten jedes Punkts oder Dimensionen mit einer Größe, aus GDIs logischen Koordinatensystem in einem gerätekoordinatensystem. Die Konvertierung hängt von der aktuellen Zuordnungsmodus und die Einstellungen der Herkunft und Erweiterungen des Fensters und Viewport des Geräts ab.  
  
 Die x- und y-Koordinaten der Punkte sind 2-Byte, die im Bereich von -32.768 bis 32.767 Ganzzahlen mit Vorzeichen. In Fällen, in denen Werte, die diese Größe überschreitet den Zuordnungsmodus führen würde, setzt das System die Werte zum -32.768 bis 32.767.  
  
##  <a name="lptohimetric"></a>  CDC::LPtoHIMETRIC  
 Mit dieser Funktion wird für das Konvertieren von logischer Einheiten in **HIMETRIC** Einheiten.  
  
```  
void LPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpSize*  
 Verweist auf eine **Größe** Struktur oder ein `CSize` Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Verwenden Sie diese Funktion, wenn Sie erteilen **HIMETRIC** Größen an OLE, die von Ihrer Anwendung natürliche Zuordnungsmodus konvertieren. Beachten Sie, dass die Blöcke von Fenster und Viewport des Geräts das Ergebnis ausgewirkt hat.  
  
 Die Konvertierung erfolgt durch die erste konvertieren die logischen Einheiten in Pixel, verwenden den Gerätekontext aktuelle Zuordnung Einheiten und anschließende konvertieren diese Einheiten in **HIMETRIC** Einheiten.  
  
##  <a name="m_hattribdc"></a>  CDC::m_hAttribDC  
 Die Attribut-Gerätekontext für diesen `CDC` Objekt.  
  
```  
HDC m_hAttribDC;  
```  
  
### <a name="remarks"></a>Hinweise  
 Standardmäßig ist dieser Gerätekontext gleich `m_hDC`. Im allgemeinen `CDC` GDI-Aufrufe, die Informationen aus dem Gerätekontext anfordern, werden an weitergeleitet `m_hAttribDC`. Finden Sie unter der [CDC](../../mfc/reference/cdc-class.md) Beschreibung für Weitere Informationen über die Verwendung von diesen beiden Gerätekontexte Klasse.  
  
##  <a name="m_hdc"></a>  CDC::m_hDC  
 Die Ausgabe-Gerätekontext für diesen `CDC` Objekt.  
  
```  
HDC m_hDC;  
```  
  
### <a name="remarks"></a>Hinweise  
 Standardmäßig `m_hDC` gleich `m_hAttribDC`, die andere umschlossen Gerätekontext `CDC`. Im allgemeinen `CDC` GDI-Aufrufe, die Ausgabe zu erstellen, wechseln Sie zu der `m_hDC` Gerätekontext. Sie können initialisieren `m_hDC` und `m_hAttribDC` auf verschiedenen Geräten. Finden Sie unter der [CDC](../../mfc/reference/cdc-class.md) Beschreibung für Weitere Informationen über die Verwendung von diesen beiden Gerätekontexte Klasse.  
  
##  <a name="maskblt"></a>  CDC::MaskBlt  
 Kombiniert die Farbdaten für die Quell- und Zielschemas Bitmaps, die unter Verwendung der angegebenen Maske und auszuführenden Vorgangs an.  
  
```  
BOOL MaskBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate der oberen linken Ecke des Zielrechtecks an.  
  
 *y*  
 Gibt die logische y-Koordinate der oberen linken Ecke des Zielrechtecks an.  
  
 *nWidth*  
 Gibt die Breite in logische Arbeitseinheiten Zielbitmap Rechteck und die Quelle an.  
  
 *nHeight*  
 Gibt die Höhe in logische Arbeitseinheiten Zielbitmap Rechteck und die Quelle an.  
  
 *pSrcDC*  
 Identifiziert den Gerätekontext, von dem die Bitmap ist, kopiert werden soll. Es muss NULL, wenn die *DwRop* Parameter gibt einen auszuführenden Vorgangs, die nicht in eine Quelle enthalten ist.  
  
 *xSrc*  
 Gibt die logische X-Koordinate der oberen linken Ecke des Quellbitmaps an.  
  
 *ySrc*  
 Gibt die logische y-Koordinate der oberen linken Ecke des Quellbitmaps an.  
  
 *maskBitmap*  
 Identifiziert die monochrome Maskenbitmap, die zusammen mit der Farbbitmap in dem Quellgerätekontext an.  
  
 *xMask*  
 Gibt den horizontalen Pixel-Offset für die Maskenbitmap gemäß der *MaskBitmap* Parameter.  
  
 *yMask*  
 Gibt den Offset der vertikalen Pixel für die Maskenbitmap gemäß der *MaskBitmap* Parameter.  
  
 *dwRop*  
 Gibt die Vordergrund- und Hintergrundfarben ternäre rastervorgangscode, der die Funktion verwendet, um die Kombination von Quell-und Zieldaten zu steuern. Der Hintergrund Raster Vorgangscode wird in das hohe Word dieses Werts das höherwertige Byte gespeichert. im Vordergrund auszuführenden Vorgangscode wird in das hohe Word dieses Werts das niedrige Byte gespeichert. das niedrige Word dieses Werts wird ignoriert, und sollte 0 (null) sein. Das Makro **MAKEROP4** erstellt solche Kombination aus Vordergrund- und rastervorgangscode. Finden Sie im Abschnitt "Hinweise" eine Erläuterung der Vorder- und Hintergrundfarbe im Kontext dieser Funktion. Finden Sie unter der `BitBlt` Memberfunktion, die eine Liste der allgemeinen rastervorgangscode.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der Wert 1 in der Maske gemäß *MaskBitmap* gibt an, dass durch den Vordergrund Raster Vorgangscode angegeben *DwRop* an dieser Stelle angewendet werden soll. Der Wert 0 in der Maske gibt an, dass der Hintergrund Raster Vorgangscode durch angegeben *DwRop* an dieser Stelle angewendet werden soll. Wenn die auszuführenden Vorgänge eine Datenquelle benötigen, muss die Maske Rechteck Quellrechtecks abdecken. Wenn dies nicht der Fall ist, schlägt die Funktion fehl. Wenn die auszuführenden Vorgänge nicht mit eine Datenquelle benötigen, muss die Maske Rechteck Zielrechtecks abdecken. Wenn dies nicht der Fall ist, schlägt die Funktion fehl.  
  
 Wenn eine Transformation Drehung oder Scherung für dem Quellgerätekontext beim aktiviert diese Funktion aufgerufen wird ist, tritt ein Fehler auf. Andere Arten von Transformationen sind jedoch zulässig.  
  
 Wenn die Farbe Formate von der Quelle, Muster und Zielbitmaps unterschiedlich sind, konvertiert diese Funktion das Muster Quellformat oder beides, um das Zielformat entsprechen. Wenn die Maskenbitmap nicht um eine monochrome Bitmap ist, tritt ein Fehler auf. Wenn eine erweiterte Metadatei aufgezeichnet werden wird, ein Fehler auftritt (und die Funktion gibt 0 zurück.) Wenn dem Quellgerätekontext eine EMF-Gerätekontext identifiziert. Nicht alle Geräte unterstützen `MaskBlt`. Eine Anwendung sollte Aufrufen `GetDeviceCaps` zu bestimmen, ob ein Gerät diese Funktion unterstützt. Wenn keine Maskenbitmap bereitgestellt wird, diese Funktion verhält sich genau so wie `BitBlt`, mit dem Vordergrund auszuführenden Vorgangscode. Das Pixel, die in dem Quellgerätekontext mithilfe einer Bitmap in der Maske Bitmap-Zuordnung zu dem Punkt (0,0) versetzt werden. Dies ist nützlich für Fälle, in denen eine Maskenbitmap einen Satz von Masken enthält. eine Anwendung kann einfach eine von ihnen auf Anwenden eine Maske Blitting Aufgabe durch die Pixel-Offsets anpassen und Größen Rechteck an `MaskBlt`.  
  
##  <a name="modifyworldtransform"></a>  CDC::ModifyWorldTransform  
 Ändert die globale Transformation für einen Gerätekontext, der mit dem angegebenen Zugriffsmodus.  
  
```  
BOOL ModifyWorldTransform(
    const XFORM& rXform,  
    DWORD iMode);
```  
  
### <a name="parameters"></a>Parameter  
 *rXform*  
 Ein Verweis auf ein [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) Struktur verwendet, um die globale Transformation für den angegebenen Gerätekontext ändern.  
  
 *iMode*  
 Gibt an, wie die Transformationsdaten die aktuellen globalen Transformation ändert. Eine Liste der Werte, die für diesen Parameter, finden Sie unter [ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060).  
  
### <a name="return-value"></a>Rückgabewert  
 Bei Erfolg wird einen Wert ungleich NULL zurückgegeben.  
  
 Gibt 0 bei einem Fehler zurück.  
  
 Um erweiterte Fehlerinformationen abzurufen, rufen [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode dient als Wrapper für die Windows-GDI-Funktion [ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060).  
  
##  <a name="moveto"></a>  CDC::MoveTo  
 Verschiebt die aktuelle Position, die vom angegebenen Punkt *x* und *y* (oder durch *zeigen*).  
  
```  
CPoint MoveTo(
    int x,  
    int y);  
  
CPoint MoveTo(POINT point);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate der neuen Position.  
  
 *y*  
 Gibt die logische y-Koordinate der neuen Position.  
  
 *Punkt*  
 Gibt die neue Position. Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Die x- und y-Koordinaten der vorherigen Position als ein `CPoint` Objekt.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).  
  
##  <a name="offsetcliprgn"></a>  CDC::OffsetClipRgn  
 Verschiebt den Ausschneidebereich den Gerätekontext durch den angegebenen Offsets.  
  
```  
int OffsetClipRgn(
    int x,  
    int y);  
  
int OffsetClipRgn(SIZE size);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die Anzahl der logischen Einheiten, die zum Verschieben von links oder rechts.  
  
 *y*  
 Gibt die Anzahl der logischen Einheiten nach oben oder unten zu verschieben.  
  
 *size*  
 Gibt den Betrag für den offset an.  
  
### <a name="return-value"></a>Rückgabewert  
 Die neue Region-Typs. Eine der folgenden Werte sind möglich:  
  
- **COMPLEXREGION** Ausschneidebereich weist überlappende Rahmen.  
  
- **Fehler** Gerätekontext ist ungültig.  
  
- **NULLREGION** Ausschneidebereich ist leer.  
  
- **SIMPLEREGION** Ausschneidebereich besitzt keine überlappenden Rahmen.  
  
### <a name="remarks"></a>Hinweise  
 Die-Funktion verschiebt die Region *x* Einheiten entlang der x-Achse und *y* Einheiten entlang der y-Achse.  
  
##  <a name="offsetviewportorg"></a>  CDC::OffsetViewportOrg  
 Ändert die Koordinaten des Ursprungs Viewport relativ zu den Koordinaten des Ursprungs des aktuellen Viewport an.  
  
```  
virtual CPoint OffsetViewportOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Parameter  
 *nWidth*  
 Gibt die Anzahl der Geräteeinheiten, um die X-Koordinate für den aktuellen Ursprung hinzufügen.  
  
 *nHeight*  
 Gibt die Anzahl der Geräteeinheiten, hinzufügen zu den aktuellen Ursprung y-Koordinate.  
  
### <a name="return-value"></a>Rückgabewert  
 Der vorherige Viewport Ursprung (Device-Koordinaten) als ein `CPoint` Objekt.  
  
##  <a name="offsetwindoworg"></a>  CDC::OffsetWindowOrg  
 Ändert die Koordinaten des Ursprungs Fenster relativ zu den Koordinaten des Ursprungs des aktuellen Fensters.  
  
```  
CPoint OffsetWindowOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Parameter  
 *nWidth*  
 Gibt die Anzahl der logischen Einheiten hinzufügen zu den aktuellen Ursprung X-Koordinate.  
  
 *nHeight*  
 Gibt die Anzahl der logischen Einheiten hinzufügen zu den aktuellen Ursprung y-Koordinate.  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherigen Fensterursprung (in logischen Koordinaten) als ein `CPoint` Objekt.  
  
##  <a name="operator_hdc"></a>  CDC::Operator HDC  
 Verwenden Sie diesen Operator ein Handle für den Gerätekontext des abzurufenden der `CDC` Objekt.  
  
```  
operator HDC() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Bei Erfolg das Handle des Gerätekontextobjekt; andernfalls **NULL**.  
  
### <a name="remarks"></a>Hinweise  
 Sie können das Handle verwenden, Windows-APIs direkt aufrufen.  
  
##  <a name="paintrgn"></a>  CDC::PaintRgn  
 Füllt den Bereich von angegebenen *PRNG* mit dem aktuellen Pinsel.  
  
```  
BOOL PaintRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>Parameter  
 *PRNG*  
 Identifiziert die Region gefüllt werden soll. Die Koordinaten für den angegebenen Bereich sind in logischen Einheiten angegeben.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
##  <a name="patblt"></a>  CDC::PatBlt  
 Erstellt ein Bitmuster auf dem Gerät.  
  
```  
BOOL PatBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate der oberen linken Ecke des Rechtecks, das das Muster zu erhalten.  
  
 *y*  
 Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks, das das Muster zu erhalten.  
  
 *nWidth*  
 Gibt die Breite (in logischen Einheiten) des Rechtecks, das das Muster zu erhalten.  
  
 *nHeight*  
 Gibt die Höhe (in logischen Einheiten) des Rechtecks, das das Muster zu erhalten.  
  
 *dwRop*  
 Gibt den auszuführenden Vorgang Code. Raster-Operationscodes (-RPC-Vorgänge) definieren, wie GDI Farben in Ausgabevorgängen kombiniert, an denen ein aktueller Pinsel, eine mögliche Quellbitmap und eine Zielbitmap beteiligt sind. Dieser Parameter kann einen der folgenden Werte sein:  
  
- **PATCOPY** Muster Zielbitmap kopiert.  
  
- **PATINVERT** Zielbitmap mithilfe des booleschen XOR-Operators mit Muster kombiniert.  
  
- **DSTINVERT** Hierdurch wird die Zielbitmap.  
  
- **BLACKNESS** Ausgabe Schwarz.  
  
- **WHITENESS** Ausgabe weiß.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Das Muster ist eine Kombination der ausgewählte Pinsel und das Muster bereits auf dem Gerät. Das Raster Vorgangscode gemäß *DwRop* definiert, wie die Muster sind, kombiniert werden sollen. Die auszuführenden Vorgänge aufgeführt, die für diese Funktion sind eine beschränkte Teilmenge des vollständigen 256 ternäre rastervorgang-Codes. Insbesondere kann ein rastervorgang Code, der mit einer Datenquelle verweist verwendet werden.  
  
 Nicht alle Gerätekontexte unterstützen die `PatBlt` Funktion. Zu bestimmen, ob für ein Gerätekontext unterstützt `PatBlt`, rufen Sie die `GetDeviceCaps` Memberfunktion mit der **RASTERCAPS** index, und überprüfen Sie den Rückgabewert für die **RC_BITBLT** Flag.  
  
##  <a name="pie"></a>  CDC::PIE  
 Zeichnet einen kreisförmigen Keil durch Zeichnen eines elliptischen Bogens, dessen Mitte und zwei Endpunkte durch Linien verbunden sind.  
  
```  
BOOL Pie(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Parameter  
 *x1*  
 Gibt die X-Koordinate des der oberen linken Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *y1*  
 Gibt die y-Koordinate des der oberen linken Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *x2*  
 Gibt die X-Koordinate des der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *Y2*  
 Gibt die y-Koordinate des der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.  
  
 *x3*  
 Gibt die X-Koordinate des Anfangspunkts des Bogens, (in logischen Einheiten) an. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *Y3*  
 Gibt die y-Koordinate des Anfangspunkts des Bogens, (in logischen Einheiten) an. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *X4*  
 Gibt die X-Koordinate des Endpunkts des Bogens, (in logischen Einheiten) an. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *Y4*  
 Gibt die y-Koordinate des Endpunkts des Bogens, (in logischen Einheiten) an. Dieser Punkt muss nicht genau auf den Bogen liegen.  
  
 *lpRect*  
 Gibt das umschließende Rechteck. Übergeben Sie entweder eine `CRect` Objekt oder ein Zeiger auf eine `RECT` Struktur für diesen Parameter.  
  
 *ptStart*  
 Gibt den Anfangspunkt des Bogens an. Dieser Punkt muss nicht genau auf den Bogen liegen. Übergeben Sie entweder eine [Punkt](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.  
  
 *ptEnd*  
 Gibt den Endpunkt des Bogens. Dieser Punkt muss nicht genau auf den Bogen liegen. Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Das Zentrum des Bogens steht im Mittelpunkt des umschließenden Rechtecks gemäß *X1*, *y1*, *X2*, und *y2* (oder durch *LpRect* ). Die Start- und Endpunkt des Bogens werden angegeben, indem *X3*, *y3*, *X4*, und *y4* (oder durch *PtStart*und *PtEnd*).  
  
 Der Bogen gezeichnet wird mit dem ausgewählten Stift, gegen den Uhrzeigersinn verschieben. Zwei zusätzliche Linien werden von jedem Endpunkt des Bogens Center gezeichnet. Der Bereich kreisförmigen ist mit dem aktuellen Pinsel gefüllt. Wenn *X3* gleich *X4* und *y3* gleich *y4*, das Ergebnis ist eine Ellipse, die mit einer einzelnen Zeile aus der Mitte der Ellipse, die auf den Punkt ( *X3*, *y3*) oder ( *X4*, *y4*).  
  
 Die Abbildung gezeichnet, die von dieser Funktion bis zu erweitert, aber schließt nicht die Rechte und untere Koordinaten. Dies bedeutet, dass die Höhe der Abbildung *y2* - *y1* und die Breite der Abbildung ist *X2* - *X1*. Die Breite und die Höhe des umschließenden Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]  
  
##  <a name="playmetafile"></a>  CDC::PlayMetaFile  
 Der Inhalt der angegebenen Metadatei wiedergegeben auf den Gerätekontext.  
  
```  
BOOL PlayMetaFile(HMETAFILE hMF);

 
BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,  
    LPCRECT lpBounds);
```  
  
### <a name="parameters"></a>Parameter  
 *hMF*  
 Identifiziert die Metadatei wiedergegeben werden soll.  
  
 *hEnhMetaFile*  
 Identifiziert die erweiterte Metadatei an.  
  
 *lpBounds*  
 Verweist auf eine `RECT` Struktur oder ein `CRect` Objekt mit den Koordinaten des umschließenden Rechtecks verwendet, um das Bild anzuzeigen. Die Koordinaten werden in logischen Einheiten angegeben.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Die Metadatei kann oft wiedergegeben werden.  
  
 Die zweite Version der `PlayMetaFile` zeigt das Bild in der angegebenen EMF-Datei gespeichert. Wenn eine Anwendung ruft die zweite Version der `PlayMetaFile`, Windows verwendet die Bilderrahmen im EMF-Header, ordnen Sie das Bild in das Rechteck, verweist der *LpBounds* Parameter. (Dieses Bild möglicherweise verbogen oder gedreht werden, indem Sie die globale Transformation in das Ausgabegerät vor dem Aufruf festlegen `PlayMetaFile`.) In der Abbildung sind Punkte an den Rändern des Rechtecks enthalten. Ein EMF-Bild kann durch die Definition des Clippingbereichs in das Ausgabegerät vor der Wiedergabe von EMF zugeschnitten werden.  
  
 EMF eine optionale Palette enthält, kann eine Anwendung konsistente Farben erzielen, indem Sie das Einrichten einer Farbpalette auf dem Ausgabegerät vor dem Aufrufen der zweiten Version `PlayMetaFile`. Verwenden Sie zum Abrufen der optionalen Palette der **GetEnhMetaFilePaletteEntries** Windows-Funktion. Erweiterte Metadatei in eine neu erstellte erweiterte Metadatei eingebettet werden kann, durch Aufrufen der zweiten Version `PlayMetaFile` und Wiedergabe von der Quelle, die erweiterte Metadatei in den Gerätekontext für das neue, erweiterte Metadatei.  
  
 Von dieser Funktion werden die Zustände des Gerätekontexts Ausgabe beibehalten. Ein Objekt erstellt, aber nicht in der erweiterten Metadatei gelöscht wird von dieser Funktion gelöscht. Um diese Funktion zu beenden, kann eine Anwendung Aufrufen der **CancelDC** Windows-Funktion von einem anderen Thread, um den Vorgang zu beenden. In diesem Fall gibt die Funktion 0 (null) zurück.  
  
##  <a name="plgblt"></a>  CDC::PlgBlt  
 Führt einen Bitblocktransfer der Farbdaten Bits auf das angegebene Rechteck, in dem Quellgerätekontext an der angegebenen Parallelogramm in den angegebenen Gerätekontext aus.  
  
```  
BOOL PlgBlt(
    LPPOINT lpPoint,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nWidth,  
    int nHeight,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask);
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoint*  
 Verweist auf ein Array von drei Punkten in logischer Speicherplatz, der drei Ecken des Parallelogramms ergibt Ziel identifiziert. Der erste Punkt in diesem Array, der oberen rechten Ecke auf den zweiten Punkt in diesem Array und der unteren linken Ecke auf den dritten Punkt wird der linken oberen Ecke des Quellrechtecks zugeordnet. Der unteren rechten Ecke des Quellrechtecks wird bis zum vierten implizite Punkt in der Parallelogramm zugeordnet.  
  
 *pSrcDC*  
 Gibt den Quellgerätekontext an.  
  
 *xSrc*  
 Gibt die X-Koordinate, in logischen Einheiten, die von der linken oberen Ecke des Quellrechtecks an.  
  
 *ySrc*  
 Gibt die y-Koordinate, in logischen Einheiten, die von der linken oberen Ecke des Quellrechtecks an.  
  
 *nWidth*  
 Gibt die Breite in logischen Einheiten des Quellrechtecks an.  
  
 *nHeight*  
 Gibt die Höhe in logischen Einheiten des Quellrechtecks an.  
  
 *maskBitmap*  
 Gibt eine optionale monochrome Bitmap, die verwendet wird, um die Farben des Quellrechtecks zu maskieren.  
  
 *xMask*  
 Gibt die X-Koordinate der oberen linken Ecke der monochrome Bitmap an.  
  
 *yMask*  
 Gibt die y-Koordinate der oberen linken Ecke der monochrome Bitmap an.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Wenn das Handle der angegebenen Bitmaske gültige monochrome Bitmap identifiziert wird, verwendet die Funktion diese Bitmap zum Maskieren der Bits der Farbdaten vom Quellrechtecks an.  
  
 Des vierten Vertex eines Parallelogramms ergibt (D) wird definiert, indem Sie die ersten drei behandeln Punkte (A, B und C) als Vektoren und computing D = B + C – A.  
  
 Wenn die Bitmaske vorhanden ist, gibt einen Wert 1 in der Maske an, dass die Pixelfarbe Quelle zum Ziel kopiert werden sollen. Der Wert in der Maske 0 gibt an, dass die Pixelfarbe Ziel nicht geändert werden.  
  
 Ist das Rechteck Maske kleiner als die Quelle und Ziel Rechtecke, repliziert die Funktion der Maskenmuster.  
  
 In dem Quellgerätekontext Skalierung, Verschiebung und Reflektion-Transformationen zulässig. Allerdings sind die Drehung und Scherung Transformationen nicht. Wenn die Maskenbitmap nicht um eine monochrome Bitmap ist, tritt ein Fehler auf. Der streckmodus für Zielgerätekontext wird verwendet, um zu bestimmen wie gestreckt oder komprimiert die Pixel, falls dies erforderlich ist. Wenn eine erweiterte Metadatei aufgezeichnet wird, tritt ein Fehler auf, wenn dem Quellgerätekontext eine EMF-Gerätekontext identifiziert.  
  
 Die Zielkoordinaten werden gemäß dem Zielgerätekontext umgewandelt. Die Quellkoordinaten werden gemäß dem Quellgerätekontext umgewandelt. Wenn die Umwandlung einer Drehung oder Scherung verfügt, wird ein Fehler zurückgegeben. Wenn die Ziel- und Rechtecke nicht dasselbe Farbformat haben `PlgBlt` Quellrechtecks Zielrechtecks entsprechend konvertiert. Nicht alle Geräte unterstützen `PlgBlt`. Weitere Informationen finden Sie unter der Beschreibung der **RC_BITBLT** Raster-Funktion in der `CDC::GetDeviceCaps` Memberfunktion.  
  
 Wenn die Quell- und Zielschemas Gerätekontexte inkompatible Geräte darstellen `PlgBlt` gibt einen Fehler zurück.  
  
##  <a name="polybezier"></a>  CDC::PolyBezier  
 Zeichnet eine oder mehrere Bzier Splines an.  
  
```  
BOOL PolyBezier(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) -Datenstrukturen, die die Endpunkte enthalten und Steuern der Spline(s) Punkte.  
  
 *nCount*  
 Gibt die Anzahl der Punkte in der *LpPoints* Array. Dieser Wert muss eine mehr als drei Mal die Anzahl der zu zeichnende Splines, jeden Bzier Spline zwei Steuerpunkte und einen Endpunkt und den anfänglichen Spline erfordert Quellformat, sodass einen zusätzlichen Ausgangspunkt.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Diese Funktion zeichnet kubische Bzier Splines mithilfe der Endpunkte und Steuerpunkte, die gemäß der *LpPoints* Parameter. Der erste Spline wird vom ersten Punkt bis zum vierten Punkt mithilfe der zweite und dritte Punkt als Steuerpunkte gezeichnet. Jede nachfolgende Spline in der Sequenz benötigt genau drei weitere Punkte: den Endpunkt der vorherigen Spline dient als Ausgangspunkt, die nächsten beiden Punkte in der Sequenz sind Steuerpunkte und der dritte ist der Endpunkt.  
  
 Die aktuelle Position ist weder verwendet noch aktualisiert, indem die `PolyBezier` Funktion. In der Abbildung ist nicht ausgefüllt. Diese Funktion zeichnet Linien mit den aktuellen Stift.  
  
##  <a name="polybezierto"></a>  CDC::PolyBezierTo  
 Zeichnet eine oder mehrere Bzier Splines an.  
  
```  
BOOL PolyBezierTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) verweist-Datenstrukturen, die die Endpunkte und das Steuerelement enthält.  
  
 *nCount*  
 Gibt die Anzahl der Punkte in der *LpPoints* Array. Dieser Wert muss die dreimal so groß wie die Anzahl der Splines gezeichnet werden, da jede Bzier Spline zwei Steuerpunkte und einen Endpunkt erforderlich ist.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Diese Funktion zeichnet kubische Bzier Splines mithilfe der Steuerpunkte, die gemäß der *LpPoints* Parameter. Der erste Spline wird von der aktuellen Position auf dem dritten Punkt mit den ersten beiden Punkte als Steuerpunkte gezeichnet. Für jeden nachfolgenden Spline die Funktion genau drei weitere Punkte benötigt, und verwendet den Endpunkt der vorherigen Spline als Ausgangspunkt für die nächsten. `PolyBezierTo` Verschiebt die aktuelle Position an den Endpunkt des letzten Bzier Splines an. In der Abbildung ist nicht ausgefüllt. Diese Funktion zeichnet Linien mit den aktuellen Stift.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CDC:: beginpath](#beginpath).  
  
##  <a name="polydraw"></a>  CDC::PolyDraw  
 Zeichnet eine Reihe von Liniensegmenten und Bzier Splines an.  
  
```  
BOOL PolyDraw(
    const POINT* lpPoints,  
    const BYTE* lpTypes,  
    int nCount);
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) -Datenstrukturen, die Endpunkte enthält, die für jede Zeile Segment und die Endpunkte und Kontrollpunkte für jeden Bzier Spline.  
  
 *lpTypes*  
 Zeigt auf ein Array, der angibt, wie jede zeigen Sie der *LpPoints* Array verwendet wird. Die folgenden Werte sind möglich:  
  
- **PT_MOVETO** gibt an, dass bisher eine nicht zusammenhängende Abbildung beginnt. Dieser Punkt wird die neue Position.  
  
- **PT_LINETO** gibt an, dass eine Linie von der aktuellen Position bis zu diesem Punkt gezeichnet werden soll, klicken Sie dann die neue Position wird.  
  
- **PT_BEZIERTO** gibt an, dass diesem Punkt ein Utility Control Point oder ein Endpunkt für einen Bzier Spline ist.  
  
 **PT_BEZIERTO** Typen werden immer in Sätze von drei erfolgen. Die aktuelle Position definiert den Ausgangspunkt für die Splinekurve Bzier. Die ersten beiden **PT_BEZIERTO** Punkte sind die Steuerpunkte und der dritte **PT_BEZIERTO** Punkt ist der Endpunkt. Der Endpunkt wird die neue Position. Wenn es sich nicht drei aufeinanderfolgende **PT_BEZIERTO** Punkte, eine Fehlermeldung ausgegeben.  
  
     Ein **PT_LINETO** oder **PT_BEZIERTO** Typ mit der folgenden Konstanten kombiniert werden kann, mit dem bitweisen Operator "oder", um anzugeben, dass die entsprechenden Punkt der letzte Punkt in der Abbildung und in der Abbildung ist geschlossen :  
  
- **PT_CLOSEFIGURE** gibt an, die in der Abbildung automatisch, nachdem geschlossen wird die **PT_LINETO** oder **PT_BEZIERTO** Geben Sie für diesen Punkt erfolgt. Wird eine Linie an diesem Punkt der aktuellen **PT_MOVETO** oder `MoveTo` zeigen.  
  
     Dieses Flag wird mit kombiniert die **PT_LINETO** Typ für eine Linie oder mit der **PT_BEZIERTO** Typ des Endpunkts für einen Spline Bzier mit dem bitweisen **OR** Operator. Die aktuelle Position ist auf den Endpunkt, der die abschließende Zeile festgelegt.  
  
 *nCount*  
 Gibt die Gesamtzahl der Punkte in der *LpPoints* identisch mit der Anzahl der Bytes im array der *LpTypes* Array.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Diese Funktion kann verwendet werden, zum Zeichnen von nicht zusammenhängenden Zahlen anstelle von aufeinander folgende Aufrufe von `CDC::MoveTo`, `CDC::LineTo`, und `CDC::PolyBezierTo` Memberfunktionen. Die Zeilen und Splines werden mit dem aktuellen Stift gezeichnet und Abbildungen werden nicht aufgefüllt. Es ist ein aktiver Pfad durch den Aufruf gestartet der `CDC::BeginPath` Memberfunktion `PolyDraw` zum Pfad hinzugefügt. Punkte der *LpPoints* Array und im *LpTypes* gibt an, ob es sich bei jedem Punkt Teil ist eine `CDC::MoveTo`, eine `CDC::LineTo`, oder ein **CDC::BezierTo** der Vorgang. Es ist auch möglich, Formen zu schließen. Diese Funktion aktualisiert die derzeitige Position.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CDC:: beginpath](#beginpath).  
  
##  <a name="polygon"></a>  CDC::Polygon  
 Zeichnet ein Vieleck, bestehend aus zwei oder mehr Punkten (Scheitelpunkte) von Zeilen, die mit dem aktuellen Stift verbunden sind.  
  
```  
BOOL Polygon(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von Punkten, die die Eckpunkte des Vielecks angibt. Jeder Punkt in dem Array ist ein **zeigen** Struktur oder ein `CPoint` Objekt.  
  
 *nCount*  
 Gibt die Anzahl der Scheitelpunkte im Array an.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Das System das Polygon wird automatisch geschlossen, ggf. durch eine Linie zwischen dem letzten Scheitelpunkt mit dem ersten.  
  
 Der aktuelle Polygon füllenden-Modus kann abgerufen oder festgelegt werden, mithilfe der `GetPolyFillMode` und `SetPolyFillMode` Memberfunktionen.  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]  
  
##  <a name="polyline"></a>  CDC::Polyline  
 Zeichnet eine Reihe von Liniensegmenten, die zwischen den angegebenen von Punkten *LpPoints*.  
  
```  
BOOL Polyline(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von **Punkt** Strukturen oder `CPoint` Objekten verbunden werden.  
  
 *nCount*  
 Gibt die Anzahl von Punkten im Array an. Dieser Wert muss mindestens 2 sein.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Die Zeilen werden aus den ersten Punkt über die nachfolgenden Punkte, die mit dem aktuellen Stift gezeichnet. Im Gegensatz zu den `LineTo` Memberfunktion, die `Polyline` Funktion weder verwendet noch aktualisiert die derzeitige Position.  
  
 Weitere Informationen finden Sie unter [Polylinie](http://msdn.microsoft.com/library/windows/desktop/dd162815) im Windows SDK.  
  
##  <a name="polylineto"></a>  CDC::PolylineTo  
 Zeichnet eine oder mehrere gerade Linien an.  
  
```  
BOOL PolylineTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) -Datenstrukturen, die die Eckpunkte des der Zeile enthält.  
  
 *nCount*  
 Gibt die Anzahl von Punkten im Array an.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Wird eine Linie von der aktuellen Position mit dem ersten Punkt gemäß der *LpPoints* Parameter mit den aktuellen Stift. Für jede zusätzliche Zeile zeichnet die Funktion aus den Endpunkt der vorherigen Zeile auf der nächsten durch angegebene Punkt *LpPoints*. `PolylineTo` Verschiebt die aktuelle Position zum Endpunkt der letzten Zeile an. Wenn der Liniensegmente gezeichnet, die von dieser Funktion eine geschlossene Form bilden, wird in der Abbildung nicht ausgefüllt.  
  
##  <a name="polypolygon"></a>  CDC::PolyPolygon  
 Erstellt zwei oder mehr Polygone, die mit den aktuellen Polygon Füllmodus gefüllt werden.  
  
```  
BOOL PolyPolygon(
    LPPOINT lpPoints,  
    LPINT lpPolyCounts,  
    int nCount);
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von **Punkt** Strukturen oder `CPoint` Objekten, die die Eckpunkte des der Polygone definieren.  
  
 *lpPolyCounts*  
 Zeigt auf ein Array von Ganzzahlen, von denen jede gibt an, die Anzahl der Punkte in einem der Polygone in der *LpPoints* Array.  
  
 *nCount*  
 Die Anzahl der Einträge in der *LpPolyCounts* Array. Diese Zahl gibt die Anzahl von Polygonen, gezeichnet werden soll. Dieser Wert muss mindestens 2 sein.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Die Polygone können zusammenhanglos oder überlappende sein.  
  
 Jedes Polygon angegeben, die in einem Aufruf der `PolyPolygon` Funktion muss geschlossen werden. Im Gegensatz zu Polygone erstellt, indem die `Polygon` Memberfunktion, die Polygone erstellt, indem `PolyPolygon` werden nicht automatisch geschlossen.  
  
 Die Funktion erstellt zwei oder mehreren Polygonen. Um ein einzelnes Polygon zu erstellen, eine Anwendung verwenden, sollten die `Polygon` Memberfunktion.  
  
 Der aktuelle Polygon füllenden-Modus kann abgerufen oder festgelegt werden, mithilfe der `GetPolyFillMode` und `SetPolyFillMode` Memberfunktionen.  
  
##  <a name="polypolyline"></a>  CDC::PolyPolyline  
 Zeichnet mehrere Reihen von verbundenen Liniensegmenten.  
  
```  
BOOL PolyPolyline(
    const POINT* lpPoints,  
    const DWORD* lpPolyPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Parameter  
 *lpPoints*  
 Verweist auf ein Array von Strukturen, die die Eckpunkte des der Polylinien enthält. Die Polylinien werden fortlaufend angegeben.  
  
 *lpPolyPoints*  
 Verweist auf ein Array von Variablen zur Angabe der Anzahl der Punkte in der *LpPoints* Array für das entsprechende Polygon. Jeder Eintrag muss größer als oder gleich 2 sein.  
  
 *nCount*  
 Gibt die Gesamtanzahl der Zahlen in der *LpPolyPoints* Array.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der Liniensegmente werden mit den aktuellen Stift gezeichnet. Die Abbildungen gebildet, indem die Segmente werden nicht aufgefüllt. Die aktuelle Position ist weder verwendet noch von dieser Funktion aktualisiert.  
  
##  <a name="ptvisible"></a>  CDC::PtVisible  
 Bestimmt, ob der angegebene Punkt innerhalb des Clippingbereichs des Gerätekontexts.  
  
```  
virtual BOOL PtVisible(
    int x,  
    int y) const;  
  
BOOL PtVisible(POINT point) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate des Punkts an.  
  
 *y*  
 Gibt die logische y-Koordinate des Punkts an.  
  
 *Punkt*  
 Gibt an, um in logische Koordinaten zu überprüfen. Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Wert ungleich NULL, wenn der angegebene Punkt innerhalb des Clippingbereichs ist; andernfalls 0.  
  
##  <a name="queryabort"></a>  CDC::QueryAbort  
 Ruft die Abort-Funktion installiert, indem Sie die [SetAbortProc](#setabortproc) Memberfunktion für eine Anwendung zum Drucken und Abfragen, ob das Drucken beendet werden sollen.  
  
```  
BOOL QueryAbort() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Der zurückgegebene Wert ist ungleich NULL, wenn Drucken fortgesetzt werden soll, oder wenn keine Prozedur Abbruch vorhanden ist. Es ist 0, wenn der Druckauftrag beendet werden sollen. Der Rückgabewert wird von der Abort-Funktion bereitgestellt.  
  
##  <a name="realizepalette"></a>  CDC::RealizePalette  
 Ordnet die Einträge aus der aktuellen logischen Palette der Systempalette.  
  
```  
UINT RealizePalette();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt an, wie viele Einträge in der logischen Palette, die verschiedene Einträge in der Systempalette zugeordnet waren. Diese Zahl entspricht der Anzahl von Einträgen, die diese Funktion neu zugeordnet, um Änderungen in der Systempalette aufzunehmen, seit der letzten logische Palette realisiert wurde.  
  
### <a name="remarks"></a>Hinweise  
 Eine logische Farbpalette fungiert als Puffer zwischen Farbe-Intensive Anwendungen und vom System ermöglicht es einer Anwendung verwenden, wie viele Farben Bedarf ohne Konflikte mit einem eigenen Farben angezeigt oder mit Farben, die von anderen Fenstern angezeigt.  
  
 Wenn ein Fenster hat, den Eingabefokus und ruft `RealizePalette`, Windows wird sichergestellt, dass das Fenster die angeforderte Farben, bis die maximale Anzahl gleichzeitig zur Verfügung stehen, auf dem Bildschirm angezeigt werden. Windows wird außerdem die Farben, die in das Fenster Palette nicht gefunden werden, durch Abgleich mit der verfügbaren Farben angezeigt.  
  
 Darüber hinaus entspricht Windows die Farben von inaktiven Fenstern, die die Funktion so getreu wie möglich auf die verfügbaren Farben aufrufen angefordert. Dies verringert erheblich unerwünschte Änderungen in den Farben in inaktiven Fenstern angezeigt.  
  
##  <a name="rectangle"></a>  CDC::Rectangle  
 Zeichnet ein Rechteck mit dem aktuellen Stift.  
  
```  
BOOL Rectangle(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Rectangle(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Parameter  
 *x1*  
 Gibt die X-Koordinate des der oberen linken Ecke des Rechtecks (in logischen Einheiten) an.  
  
 *y1*  
 Gibt die y-Koordinate des der oberen linken Ecke des Rechtecks (in logischen Einheiten) an.  
  
 *x2*  
 Gibt die X-Koordinate des der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.  
  
 *Y2*  
 Gibt die y-Koordinate des der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.  
  
 *lpRect*  
 Gibt das Rechteck in logischen Einheiten. Übergeben Sie entweder eine `CRect` Objekt oder ein Zeiger auf eine `RECT` Struktur für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Das Innere eines Rechtecks wird mit dem aktuellen Pinsel gefüllt.  
  
 Das Rechteck bis zu erweitert, aber nicht einschließt, die Rechte und untere Koordinaten. Dies bedeutet, dass die Höhe des Rechtecks *y2* - *y1* und die Breite des Rechtecks ist *X2* - *X1*. Die Breite und die Höhe eines Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]  
  
##  <a name="rectvisible"></a>  CDC::RectVisible  
 Bestimmt, ob der Ausschneidebereich den Anzeigekontext eines beliebigen Teils des angegebenen Rechtecks liegt.  
  
```  
virtual BOOL RectVisible(LPCRECT lpRect) const;  
```  
  
### <a name="parameters"></a>Parameter  
 *lpRect*  
 Verweist auf eine `RECT` Struktur oder ein `CRect` Objekt, das die logischen Koordinaten des angegebenen Rechtecks enthält.  
  
### <a name="return-value"></a>Rückgabewert  
 Ungleich NULL, wenn alle Teil des angegebenen Rechtecks liegt innerhalb des Clippingbereichs; andernfalls 0.  
  
##  <a name="releaseattribdc"></a>  CDC::ReleaseAttribDC  
 Rufen Sie diese Memberfunktion festzulegende `m_hAttribDC` auf **NULL**.  
  
```  
virtual void ReleaseAttribDC();
```  
  
### <a name="remarks"></a>Hinweise  
 Dies führt nicht dazu, dass eine **trennen** auftreten. Nur die Ausgabe-Gerätekontext angefügt ist die `CDC` -Objekt, und es können getrennt werden.  
  
##  <a name="releaseoutputdc"></a>  CDC::ReleaseOutputDC  
 Rufen Sie diese Memberfunktion zum Festlegen der `m_hDC` Element **NULL**.  
  
```  
virtual void ReleaseOutputDC();
```  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion kann nicht aufgerufen werden, wenn die Ausgabe-Gerätekontext angefügt ist die `CDC` Objekt. Verwenden der `Detach` Memberfunktion um den Gerätekontext Ausgabe zu trennen.  
  
##  <a name="resetdc"></a>  CDC::ResetDC  
 Rufen Sie diese Memberfunktion um den Gerätekontext umschlossen Aktualisieren der `CDC` Objekt.  
  
```  
BOOL ResetDC(const DEVMODE* lpDevMode);
```  
  
### <a name="parameters"></a>Parameter  
 *lpDevMode*  
 Ein Zeiger auf ein Windows `DEVMODE` Struktur.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der Gerätekontext wird aus den Informationen in den Fenstern aktualisiert `DEVMODE` Struktur. Diese Memberfunktion setzt nur den Gerätekontext Attribut zurück.  
  
 Eine Anwendung wird in der Regel verwenden Sie die `ResetDC` Memberfunktion, wenn ein Fenster verarbeitet eine `WM_DEVMODECHANGE` Nachricht. Diese Memberfunktion können auch die papierausrichtung oder Papier Klassen beim Drucken eines Dokuments ändern.  
  
 Sie können diese Memberfunktion der Treibername, den Gerätenamen ändern oder-ausgabeports. Wenn der Benutzer die Verbindung mit Port oder die Gerätenamen ändert, müssen Sie löschen den ursprünglichen Gerätekontext und einen neuen Gerätekontext mit den neuen Informationen erstellen.  
  
 Bevor Sie diese Memberfunktion aufrufen, müssen Sie sicherstellen, dass alle Objekte (mit Ausnahme des vordefinierten Objekten), die in den Gerätekontext ausgewählt wurden, ausgewählt wurden.  
  
##  <a name="restoredc"></a>  CDC::RestoreDC  
 Stellt den Gerätekontext in den vorherigen Zustand identifizierten *nSavedDC*.  
  
```  
virtual BOOL RestoreDC(int nSavedDC);
```  
  
### <a name="parameters"></a>Parameter  
 *nSavedDC*  
 Gibt den Gerätekontext wiederhergestellt werden. Es kann ein Wert, der von einem vorherigen zurückgegebene sein `SaveDC` Funktionsaufruf. Wenn *nSavedDC* ist-1, die zuletzt gespeicherte Gerätekontext wird wiederhergestellt.  
  
### <a name="return-value"></a>Rückgabewert  
 Wert ungleich NULL, wenn der angegebene Kontext wiederhergestellt wurde; andernfalls 0.  
  
### <a name="remarks"></a>Hinweise  
 `RestoreDC` Stellt den Gerätekontext von Zustandsinformationen, die einen Stapel von früheren aufrufen, erstellt das herunternehmen die `SaveDC` Memberfunktion.  
  
 Der Stapel kann die Statusinformationen für mehrere Gerätekontexte enthält. Wenn der Kontext, wird angegeben *nSavedDC* ist nicht am oberen Ende des Stapels `RestoreDC` löscht alle Zustandsinformationen zwischen den Gerätekontext, der gemäß *nSavedDC* und dem oberen Ende des Stapels. Die gelöschte Informationen geht verloren.  
  
##  <a name="roundrect"></a>  CDC::RoundRect  
 Zeichnet ein Rechteck mit abgerundeten Ecken, die mit dem aktuellen Stift.  
  
```  
BOOL RoundRect(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3);

 
BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```  
  
### <a name="parameters"></a>Parameter  
 *x1*  
 Gibt die X-Koordinate des der oberen linken Ecke des Rechtecks (in logischen Einheiten) an.  
  
 *y1*  
 Gibt die y-Koordinate des der oberen linken Ecke des Rechtecks (in logischen Einheiten) an.  
  
 *x2*  
 Gibt die X-Koordinate des der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.  
  
 *Y2*  
 Gibt die y-Koordinate des der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.  
  
 *x3*  
 Gibt die Breite der Ellipse, die zum Zeichnen der abgerundeten Ecken (in logischen Einheiten) verwendet.  
  
 *Y3*  
 Gibt die Höhe der Ellipse, die zum Zeichnen der abgerundeten Ecken (in logischen Einheiten) verwendet.  
  
 *lpRect*  
 Gibt das umschließende Rechteck in logischen Einheiten. Übergeben Sie entweder eine `CRect` Objekt oder ein Zeiger auf eine `RECT` Struktur für diesen Parameter.  
  
 *Punkt*  
 Die X-Koordinate der *zeigen* gibt die Breite der Ellipse, die zum Zeichnen der abgerundeten Ecken (in logischen Einheiten). Die y-Koordinate der *zeigen* gibt die Höhe der Ellipse, die zum Zeichnen der abgerundeten Ecken (in logischen Einheiten). Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Das Innere eines Rechtecks wird mit dem aktuellen Pinsel gefüllt.  
  
 In der Abbildung, die diese Funktion zeichnet bis zu erweitert, aber nicht die Rechte und untere Koordinaten einschließt. Dies bedeutet, dass die Höhe der Abbildung *y2* - *y1* und die Breite der Abbildung ist *X2* - *X1*. Die Höhe und die Breite des umschließenden Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.  
  
### <a name="example"></a>Beispiel  
 [!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]  
  
##  <a name="savedc"></a>  CDC::SaveDC  
 Speichert den aktuellen Status des Gerätekontexts durch Kopieren von Statusinformationen (z. B. Ausschneidebereich, ausgewählte Objekte und Zuordnungsmodus) eine Kontext-Stapel von Windows verwaltet wird.  
  
```  
virtual int SaveDC();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Eine ganze Zahl, die den gespeicherten Gerätekontext identifizieren. Es ist 0, wenn ein Fehler auftritt. Dieser Wert kann verwendet werden, um durch Aufrufen der Gerätekontext wiederherstellen Rückgabetyp `RestoreDC`.  
  
### <a name="remarks"></a>Hinweise  
 Die gespeicherten Gerätekontext später wiederhergestellt werden, indem mithilfe `RestoreDC`.  
  
 `SaveDC` kann beliebig häufig verwendet, um eine beliebige Anzahl von Gerätekontext Status speichern.  
  
##  <a name="scaleviewportext"></a>  CDC::ScaleViewportExt  
 Ändert die Viewport-Blöcke relativ zum aktuellen Werte.  
  
```  
virtual CSize ScaleViewportExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>Parameter  
 *xNum*  
 Gibt die Menge, mit der die aktuelle X-Block multipliziert.  
  
 *xDenom*  
 Gibt den Umfang an, durch die dividiert des Ergebnis der Multiplikation von der aktuellen X-Block durch den Wert der *xNum* Parameter.  
  
 *yNum*  
 Gibt die Menge, mit der der aktuelle y-Block multipliziert.  
  
 *yDenom*  
 Gibt den Umfang an, durch die dividiert des Ergebnis der Multiplikation von der aktuellen y-Block durch den Wert der *yNum* Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherigen Viewport Blöcke (in Geräteeinheiten) als ein `CSize` Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Die Formeln werden wie folgt geschrieben:  
  
 `xNewVE = ( xOldVE * xNum ) / xDenom`  
  
 `yNewVE = ( yOldVE * yNum ) / yDenom`  
  
 Die neue Viewport-Blöcke werden berechnet, indem die aktuellen Blöcke mit der angegebenen Zähler multipliziert und durch Teilen durch den angegebenen Nenner.  
  
##  <a name="scalewindowext"></a>  CDC::ScaleWindowExt  
 Ändert die Blöcke Fenster relativ zum aktuellen Werte.  
  
```  
virtual CSize ScaleWindowExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>Parameter  
 *xNum*  
 Gibt die Menge, mit der die aktuelle X-Block multipliziert.  
  
 *xDenom*  
 Gibt den Umfang an, durch die dividiert des Ergebnis der Multiplikation von der aktuellen X-Block durch den Wert der *xNum* Parameter.  
  
 *yNum*  
 Gibt die Menge, mit der der aktuelle y-Block multipliziert.  
  
 *yDenom*  
 Gibt den Umfang an, durch die dividiert des Ergebnis der Multiplikation von der aktuellen y-Block durch den Wert der *yNum* Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherigen Fenster Blöcke (in logischen Einheiten) als ein `CSize` Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Die Formeln werden wie folgt geschrieben:  
  
 `xNewWE = ( xOldWE * xNum ) / xDenom`  
  
 `yNewWE = ( yOldWE * yNum ) / yDenom`  
  
 Das neue Fenster Wertebereiche werden berechnet, indem die aktuellen Blöcke mit der angegebenen Zähler multipliziert und durch Teilen durch den angegebenen Nenner.  
  
##  <a name="scrolldc"></a>  CDC::ScrollDC  
 Scrollt durch ein Rechteck von Bits, horizontal und vertikal.  
  
```  
BOOL ScrollDC(
    int dx,  
    int dy,  
    LPCRECT lpRectScroll,  
    LPCRECT lpRectClip,  
    CRgn* pRgnUpdate,  
    LPRECT lpRectUpdate);
```  
  
### <a name="parameters"></a>Parameter  
 *DX*  
 Gibt die Anzahl der Einheiten der horizontalen Bildlaufleiste.  
  
 *dy*  
 Gibt die Anzahl der Einheiten der vertikalen Bildlaufleiste.  
  
 *lpRectScroll*  
 Verweist auf die `RECT` Struktur oder `CRect` Objekt, das die Koordinaten des fortlaufenden Rechtecks enthält.  
  
 *lpRectClip*  
 Verweist auf die `RECT` Struktur oder `CRect` Objekt, das die Koordinaten der das Clippingrechteck enthält. Wenn dieses Rechteck ist kleiner als die ursprüngliche eine verweist *LpRectScroll*, Durchführen eines Bildlaufs tritt nur in kleinere Rechteck.  
  
 *pRgnUpdate*  
 Identifiziert die Region, die durch den fortlaufenden Prozess aufgedeckt. Die `ScrollDC` Funktion dieser Bereich definiert; es ist nicht unbedingt ein Rechteck.  
  
 *lpRectUpdate*  
 Verweist auf die `RECT` Struktur oder `CRect` Objekt, das die Koordinaten des Rechtecks empfängt, das Durchführen eines Bildlaufs Aktualisierungsbereich umschließt. Dies ist die größte rechteckigen Bereichs, die Neuzeichnen erfordert. Die Werte in der Struktur oder das Objekt bei Rückgabe der Funktion sind in Clientkoordinaten, unabhängig von den Zuordnungsmodus für den angegebenen Gerätekontext.  
  
### <a name="return-value"></a>Rückgabewert  
 Wert ungleich NULL, wenn ein Bildlauf ausgeführt wird; andernfalls 0.  
  
### <a name="remarks"></a>Hinweise  
 Wenn *LpRectUpdate* ist **NULL**, berechnet Windows nicht das Update Rechteck. Wenn beide *pRgnUpdate* und *LpRectUpdate* sind **NULL**, berechnet Windows nicht dem Aktualisierungsbereich. Wenn *pRgnUpdate* nicht **NULL**, Windows wird davon ausgegangen, dass sie einen gültigen Zeiger auf die Region, die durch den fortlaufenden Prozess aufgedeckt enthält (definiert durch die `ScrollDC` Memberfunktion). Der Aktualisierungsbereich im zurückgegebenen *LpRectUpdate* übergeben werden kann, um `CWnd::InvalidateRgn` bei Bedarf.  
  
 Eine Anwendung verwenden, sollten die `ScrollWindow` Memberfunktion der Klasse `CWnd` Wenn es ist notwendig, den gesamten Clientbereich eines Fensters einen Bildlauf. Andernfalls sollten sie verwenden `ScrollDC`.  
  
##  <a name="selectclippath"></a>  CDC::SelectClipPath  
 Wählt den aktuellen Pfad als einen Ausschneidebereich für den Gerätekontext, kombinieren die neue Region mit einer beliebigen vorhandenen Clipping Region unter Verwendung des angegebenen Modus.  
  
```  
BOOL SelectClipPath(int nMode);
```  
  
### <a name="parameters"></a>Parameter  
 *nMode*  
 Gibt an, wie der Pfad verwendet wird. Die folgenden Werte sind zulässig:  
  
- **RGN_AND** der neuen Ausschneidebereich umfasst die Schnittmenge (überlappende Bereiche) des aktuellen Ausschneidebereichs und der aktuelle Pfad.  
  
- **RGN_COPY** der neue Ausschneidebereich ist der aktuelle Pfad.  
  
- **RGN_DIFF** der neuen Ausschneidebereich enthält die Bereiche des aktuellen Ausschneidebereichs und die von den aktuellen Pfad ausgeschlossen werden.  
  
- **RGN_OR** der neuen Ausschneidebereich umfasst die Kombination (kombinierten Bereiche) des aktuellen Ausschneidebereichs und den aktuellen Pfad.  
  
- **RGN_XOR** der neuen Ausschneidebereich enthält die Gesamtmenge des aktuellen Ausschneidebereichs und der aktuelle Pfad, jedoch ohne die überlappenden Bereiche.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Gekennzeichnete Gerätekontext muss einen geschlossenen Pfad enthalten.  
  
##  <a name="selectcliprgn"></a>  CDC::SelectClipRgn  
 Wählt eine bestimmten Region als des aktuellen Ausschneidebereichs für den Gerätekontext.  
  
```  
int SelectClipRgn(CRgn* pRgn);

 
int SelectClipRgn(
    CRgn* pRgn,  
    int nMode);
```  
  
### <a name="parameters"></a>Parameter  
 *PRNG*  
 Identifiziert die Region ausgewählt werden.  
  
-   Für die erste Version dieser Funktion, wenn dieser Wert ist **NULL**, der gesamten Clientbereich ausgewählt ist und Ausgabe immer noch die Fenster zugeschnitten wird.  
  
-   Die zweite Version dieser Funktion dieses Handle kann **NULL** nur, wenn die **RGN_COPY** -Modus ist angegeben.  
  
 *nMode*  
 Gibt den Vorgang ausgeführt werden. Es muss eine der folgenden Werte sein:  
  
- **RGN_AND** der neuen Ausschneidebereich kombiniert die überlappenden Bereiche des aktuellen Ausschneidebereichs und der Region identifizierten *PRNG*.  
  
- **RGN_COPY** der neue Ausschneidebereich ist eine Kopie des identifizierten Region *PRNG*. Dies ist die Funktionalität ist identisch mit der ersten Version von `SelectClipRgn`. Wenn der Bereich von identifiziert *PRNG* ist **NULL**, der neuen Ausschneidebereich wird des Clippingbereichs Standardwert (null "Region").  
  
- **RGN_DIFF** der neuen Ausschneidebereich kombiniert die Bereiche des aktuellen Ausschneidebereichs mit diesen Bereichen, die aus der Region identifizierte ausgeschlossen *PRNG*.  
  
- **RGN_OR** der neuen Ausschneidebereich kombiniert des aktuellen Ausschneidebereichs und der Region identifizierten *PRNG*.  
  
- **RGN_XOR** der neuen Ausschneidebereich kombiniert des aktuellen Ausschneidebereichs und der Region identifizierten *PRNG* jedoch überlappenden Bereiche ausschließt.  
  
### <a name="return-value"></a>Rückgabewert  
 Die Region-Typs. Die folgenden Werte sind möglich:  
  
- **COMPLEXREGION** neue Ausschneidebereich weist überlappende Rahmen.  
  
- **Fehler** Gerätekontext oder die Region ist ungültig.  
  
- **NULLREGION** neue Ausschneidebereich ist leer.  
  
- **SIMPLEREGION** neue Ausschneidebereich besitzt keine überlappenden Rahmen.  
  
### <a name="remarks"></a>Hinweise  
 Es wird nur eine Kopie der ausgewählten Region verwendet. Die Region selbst kann eine beliebige Anzahl von anderen Gerätekontexte ausgewählt werden, oder er kann gelöscht werden.  
  
 Die Funktion wird davon ausgegangen, dass die Koordinaten für den angegebenen Bereich in Geräteeinheiten angegeben werden. Einige Druckergeräte unterstützt die Ausgabe von Text mit einer höheren Auflösung als Grafikausgabe, um die Genauigkeit erforderlich, um Text Metriken express beizubehalten. Diese Geräte melden Geräteeinheiten in der höhere Auflösung, d. h. in Texteinheiten. Diese Geräte skalieren dann Koordinaten für Grafiken, sodass mehrere Geräte Einheiten Zuordnung nur 1 Grafik Einheit gemeldet. Sie sollten immer aufrufen, die `SelectClipRgn` -Funktion mit Texteinheiten.  
  
 Anwendungen, die die Skalierung von Grafikobjekten in GDI ausführen müssen, können die **GETSCALINGFACTOR** Drucker ESC, um den Faktor für die Skalierung zu bestimmen. Diese Skalierungsfaktor wirkt sich auf ihn abzuschneiden. Wenn eine Region, auszuschneiden von Grafiken verwendet wird, teilt GDI die Koordinaten um den Skalierungsfaktor. Wenn die Region, schneiden Sie Text verwendet wird, macht GDI keine Skalierung Anpassung an. Ein Skalierungsfaktor von 1 bewirkt, dass die Koordinaten durch 2 geteilt wird. ein Skalierungsfaktor von 2 führt dazu, dass die Koordinaten durch 4 geteilt werden; Und so weiter.  
  
##  <a name="selectobject"></a>  CDC:: SelectObject  
 Wählt ein Objekt in den Gerätekontext aus.  
  
```  
CPen* SelectObject(CPen* pPen);  
CBrush* SelectObject(CBrush* pBrush);  
virtual CFont* SelectObject(CFont* pFont);  
CBitmap* SelectObject(CBitmap* pBitmap);  
int SelectObject(CRgn* pRgn);  
CGdiObject* SelectObject(CGdiObject* pObject);
```  
  
### <a name="parameters"></a>Parameter  
 *pPen*  
 Ein Zeiger auf eine [CPen](../../mfc/reference/cpen-class.md) Objekt ausgewählt werden.  
  
 *pBrush*  
 Ein Zeiger auf eine [CBrush](../../mfc/reference/cbrush-class.md) Objekt ausgewählt werden.  
  
 *pFont*  
 Ein Zeiger auf eine [CFont](../../mfc/reference/cfont-class.md) Objekt ausgewählt werden.  
  
 *pBitmap*  
 Ein Zeiger auf eine [CBitmap](../../mfc/reference/cbitmap-class.md) Objekt ausgewählt werden.  
  
 *PRNG*  
 Ein Zeiger auf eine [CRgn](../../mfc/reference/crgn-class.md) Objekt ausgewählt werden.  
  
 *pObject*  
 Ein Zeiger auf eine [CGdiObject](../../mfc/reference/cgdiobject-class.md) Objekt ausgewählt werden.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Zeiger auf das Objekt, das ersetzt wird. Dies ist ein Zeiger auf ein Objekt eines der von abgeleiteten Klassen `CGdiObject`, wie z. B. `CPen`, je nachdem, welche Version der Funktion verwendet wird. Der Rückgabewert ist **NULL** , wenn ein Fehler vorliegt. Diese Funktion kann einen Zeiger auf ein temporäres Objekt zurückgeben. Dieses temporäre Objekt ist nur gültig, während der Verarbeitung einer Windows-Meldung. Weitere Informationen finden Sie unter `CGdiObject::FromHandle`.  
  
 Die Version der Memberfunktion, die einen Bereichsparameter annimmt, führt die gleiche Aufgabe wie die `SelectClipRgn` Memberfunktion. Der Rückgabewert kann eine der folgenden:  
  
- **COMPLEXREGION** neue Ausschneidebereich weist überlappende Rahmen.  
  
- **Fehler** Gerätekontext oder die Region ist ungültig.  
  
- **NULLREGION** neue Ausschneidebereich ist leer.  
  
- **SIMPLEREGION** neue Ausschneidebereich besitzt keine überlappenden Rahmen.  
  
### <a name="remarks"></a>Hinweise  
 Klasse `CDC` enthält fünf Versionen für bestimmte Arten von GDI-Objekte, z. B. Stifte, Pinsel, Schriftarten, Bitmaps und Regionen spezialisiert. Das neu ausgewählte Objekt ersetzt das vorherige Objekt des gleichen Typs. Z. B. wenn *pObject* der allgemeinen Version `SelectObject` verweist auf eine [CPen](../../mfc/reference/cpen-class.md) -Objekt, die Funktion ersetzt den aktuellen Stift durch den Stift gemäß *pObject* .  
  
 Eine Anwendung kann eine Bitmap in Gerätekontexten Arbeitsspeicher nur und nur einen Speicher-Gerätekontext auswählen zu einem Zeitpunkt. Das Format der Bitmap muss Monochrom oder mit den Gerätekontext kompatibel sein; ist dies nicht der Fall, `SelectObject` gibt einen Fehler zurück.  
  
 Für Windows 3.1 und höher die `SelectObject` Funktion der gleiche Wert zurückgegeben, ob es in einer Metadatei oder nicht verwendet wird. Unter früheren Versionen von Windows `SelectObject` einen Wert ungleich NULL für Erfolg und 0 für Fehler zurückgegeben, wenn er in einer Metadatei verwendet wurde.  
  
##  <a name="selectpalette"></a>  CDC::SelectPalette  
 Wählt die logische Palette, die von angegeben wird *pPalette* wie das Palettenobjekt der ausgewählten des Gerätekontexts.  
  
```  
CPalette* SelectPalette(
    CPalette* pPalette,  
    BOOL bForceBackground);
```  
  
### <a name="parameters"></a>Parameter  
 *pPalette*  
 Gibt die logische Palette ausgewählt werden. Diese Palette muss bereits erstellt worden mit der `CPalette` Memberfunktion [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).  
  
 *bForceBackground*  
 Gibt an, ob die logische Palette erzwungen wird, werden einer Hintergrundpalette im. Wenn *bForceBackground* ist ungleich NULL ist, die ausgewählten Palette ist immer eine Hintergrundpalette, unabhängig davon, ob das Fenster den Eingabefokus besitzt. Wenn *bForceBackground* ist 0 und der Gerätekontext für ein Fenster angefügt ist, die logische Palette ist eine Vordergrund Palette aus, wenn das Fenster den Eingabefokus besitzt.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Zeiger auf eine `CPalette` Objekt, das die logische Palette Fassung der Palette, die vom angegebenen bezeichnet *pPalette*. Es ist **NULL** , wenn ein Fehler vorliegt.  
  
### <a name="remarks"></a>Hinweise  
 Die neue Palette wird die Palettenobjekt, das von GDI verwendet, um steuerelementfarben, die in den Gerätekontext angezeigt und ersetzt die vorherige Palette.  
  
 Eine Anwendung kann eine logische Palette mehrere Gerätekontext auswählen. Änderungen an einer logischen Palette wirkt alle Gerätekontexte sich jedoch für die es aktiviert ist. Wenn eine Anwendung eine Palette mehrere Gerätekontext auswählt, müssen die Gerätekontexte alle auf demselben physischen Gerät gehören.  
  
##  <a name="selectstockobject"></a>  CDC::SelectStockObject  
 Wählt eine [CGdiObject](../../mfc/reference/cgdiobject-class.md) Objekt, das eine der vordefinierten stock Stifte, Pinsel oder Schriftarten entspricht.  
  
```  
virtual CGdiObject* SelectStockObject(int nIndex);
```  
  
### <a name="parameters"></a>Parameter  
 *nIndex*  
 Gibt die Art des gewünschten stock-Objekts. Die folgenden Werte sind möglich:  
  
- **BLACK_BRUSH** Schwarz Pinsel.  
  
- **DKGRAY_BRUSH** dunkel grauen Pinsel.  
  
- **GRAY_BRUSH** grau Pinsel.  
  
- **HOLLOW_BRUSH** leeres Pinsel.  
  
- **LTGRAY_BRUSH** hell grauen Pinsel.  
  
- **NULL_BRUSH** Null Pinsel.  
  
- **WHITE_BRUSH** weiß Pinsel.  
  
- **BLACK_PEN** schwarzen Stift.  
  
- **NULL_PEN** Null Stift.  
  
- **WHITE_PEN** Weißer Stift.  
  
- **ANSI_FIXED_FONT** festen Systemschriftart ANSI.  
  
- **ANSI_VAR_FONT** Variable Systemschriftart ANSI.  
  
- **DEVICE_DEFAULT_FONT** geräteabhängige Schriftart.  
  
- **OEM_FIXED_FONT** OEM-abhängige Schriftart behoben.  
  
- **SYSTEM_FONT** Systemschriftart. Standardmäßig verwendet Windows die Systemschriftart Menüs, Dialogfeld-Steuerelemente und anderer Text gezeichnet werden soll. Es wird jedoch empfohlen, abhängig von SYSTEM_FONT zum Abrufen der Schriftart für Dialogfelder und Fenster nicht. Verwenden Sie stattdessen die `SystemParametersInfo` Funktion mit dem Parameter SPI_GETNONCLIENTMETRICS ab, um die aktuelle Schriftart abzurufen. `SystemParametersInfo` berücksichtigt die aktuelle Design und bietet Informationen zur Schriftart für Beschriftungen, Menüs und Dialogfelder der Nachricht.  
  
- **SYSTEM_FIXED_FONT** fester Breite Systemschriftart in Windows verwendet werden, vor der Version 3.0. Dieses Objekt ist für die Kompatibilität mit früheren Versionen von Windows verfügbar.  
  
- **DEFAULT_PALETTE** Standardfarbpalette. Diese Palette besteht aus 20 statische Farben in der Systempalette.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Zeiger auf die `CGdiObject` -Objekt, das ersetzt wurde, wenn die Funktion erfolgreich ausgeführt wird. Ist das eigentliche Objekt verweist auf eine [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), oder [CFont](../../mfc/reference/cfont-class.md) Objekt. Wenn der Aufruf nicht erfolgreich ist, ist der Rückgabewert **NULL**.  
  
##  <a name="setabortproc"></a>  CDC:: setabortproc  
 Installiert die Abort-Prozedur für den Druckauftrag an.  
  
```  
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```  
  
### <a name="parameters"></a>Parameter  
 *lpfn*  
 Ein Zeiger auf die Abort-Funktion, die als Abbruchvorgangs installieren. Weitere Informationen über die Rückruffunktion finden Sie unter [Rückruffunktion für CDC:: setabortproc](callback-functions-used-by-mfc.md#setabortproc).  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt das Ergebnis der `SetAbortProc` Funktion. Einige der folgenden Werte sind wahrscheinlicher als andere, aber alle sind möglich.  
  
- **SP_ERROR** allgemeiner Fehler.  
  
- **SP_OUTOFDISK** nicht genügend freier Speicherplatz steht zurzeit zum Spoolen und keinen Speicherplatz mehr zur Verfügung gestellt.  
  
- **SP_OUTOFMEMORY** ist nicht genügend Arbeitsspeicher zum Spoolen verfügbar.  
  
- **SP_USERABORT** Benutzer beendet den Auftrag über den Druck-Manager.  
  
### <a name="remarks"></a>Hinweise  
 Wenn eine Anwendung den Druckauftrag, während für Aufträge abgebrochen werden können, müssen sie die Abort-Funktion festlegen, vor dem Start des Druckauftrags mit dem [StartDoc](#startdoc) Memberfunktion. Der Druck-Manager ruft die Abort-Funktion, während für Aufträge, damit die Anwendung den Druckauftrag abbrechen oder Out of Disk Space Bedingungen verarbeiten kann. Wenn keine Abort-Funktion festgelegt ist, schlägt der Druckauftrag fehl, wenn es nicht genügend Speicherplatz zum Spoolen ist.  
  
 Beachten Sie, dass die Funktionen von Microsoft Visual C++ die vereinfachte Erstellung die Rückruffunktion übergeben `SetAbortProc`. Die Adresse übergeben, um die `EnumObjects` Memberfunktion ist ein Zeiger auf eine Funktion mit exportierten **__declspec(dllexport)** und mit der `__stdcall` Aufrufkonvention.  
  
 Sie auch keine so exportieren Sie den Namen der Funktion in einer **EXPORTE** -Anweisung in Ihrer Anwendung Moduldefinitionsdatei. Stattdessen können Sie die **EXPORTIEREN** Modifizierer, wie in-Funktion  
  
 **BOOL RÜCKRUF EXPORT** AFunction ( **HDC**, `int` **);**  
  
 den Compiler den ordnungsgemäßen Export-Datensatz für den Export nach Namen ohne Aliasing auszugebende verursachen. Dies funktioniert für die meisten Anforderungen. Für einige Sonderfälle, z. B. eine Funktion nach Ordnungszahl oder Aliasing des Exports exportieren Sie dennoch verwenden müssen eine **EXPORTE** -Anweisung in einer Moduldefinitionsdatei.  
  
 Registrierung von Rückrufschnittstellen sind jetzt als typsicherer (Sie müssen in einen Funktionszeiger, der auf die richtige Art von Funktion für den bestimmten Rückruf zeigt übergeben).  
  
 Beachten Sie außerdem, dass alle Rückruffunktionen vor der Rückgabe an Windows, da Ausnahmen hinweg Rückruf ausgelöst werden, können nicht Microsoft Foundation-Ausnahmen abfangen müssen. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).  
  
##  <a name="setarcdirection"></a>  CDC::SetArcDirection  
 Legt die Richtung die Zeichnung für Bogen und Rechteck Funktionen verwendet werden.  
  
```  
int SetArcDirection(int nArcDirection);
```  
  
### <a name="parameters"></a>Parameter  
 *nArcDirection*  
 Gibt die neue Richtung der Bogen an. Dieser Parameter kann einen der folgenden Werte sein:  
  
- **AD_COUNTERCLOCKWISE** Formen gezeichnet gegen den Uhrzeigersinn gedreht.  
  
- **AD_CLOCKWISE** Zahlen im Uhrzeigersinn gezeichnet.  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt die alte Bogen Richtung an, wenn erfolgreich. andernfalls 0.  
  
### <a name="remarks"></a>Hinweise  
 Die Standardeinstellung ist gegen den Uhrzeigersinn. Die `SetArcDirection` -Funktion gibt die Richtung, in dem Sie die folgenden Zeichnen-Befehl Funktionen, an:  
  
|Bogen|Segment|  
|---------|---------|  
|**ArcTo**|**Rechteck**|  
|**Die Sehne**|**RoundRect**|  
|**Ellipse**||  
  
##  <a name="setattribdc"></a>  CDC::SetAttribDC  
 Mit dieser Funktion können Sie den Gerätekontext Attribut festgelegt `m_hAttribDC`.  
  
```  
virtual void SetAttribDC(HDC hDC);
```  
  
### <a name="parameters"></a>Parameter  
 *hDC*  
 Ein Windows-Gerätekontext.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion wird nicht auf den Gerätekontext angefügt der `CDC` Objekt. Nur die Ausgabe-Gerätekontext angefügt ist ein `CDC` Objekt.  
  
##  <a name="setbkcolor"></a>  CDC::SetBkColor  
 Legt die aktuelle Hintergrundfarbe der angegebenen Farbe fest.  
  
```  
virtual COLORREF SetBkColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Parameter  
 *crColor*  
 Die neue Hintergrundfarbe angibt.  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherigen Hintergrundfarbe als eine RGB-Wert. Wenn ein Fehler auftritt, ist der Rückgabewert 0 x 80000000.  
  
### <a name="remarks"></a>Hinweise  
 Wenn der Hintergrundmodus ist **nicht TRANSPARENTEN**, das System verwendet die Farbe des Hintergrunds zum Füllen der Lücken in formatierte Zeilen, die Lücken zwischen schraffierten Linien, Pinsel und Hintergrund in Zeichenzellen. Das System verwendet auch die Farbe des Hintergrunds beim Konvertieren von Bitmaps zwischen Farbe und monochrome Gerätekontexte.  
  
 Wenn das Gerät kann nicht die angegebene Farbe angezeigt wird, setzt das System die Farbe des Hintergrunds auf die nächste physische Farbe.  
  
##  <a name="setbkmode"></a>  CDC::SetBkMode  
 Legt den Hintergrundmodus.  
  
```  
int SetBkMode(int nBkMode);
```  
  
### <a name="parameters"></a>Parameter  
 *nBkMode*  
 Gibt den Modus festgelegt werden. Dieser Parameter kann einen der folgenden Werte sein:  
  
- **Nicht TRANSPARENTE** Hintergrund wird mit der aktuellen Hintergrundfarbe vor dem Text, schraffierten Pinsel gefüllt oder Stift gezeichnet wird. Dies ist der Standardmodus für den Hintergrund.  
  
- **TRANSPARENTE** Hintergrund wird vor dem Zeichnen nicht geändert.  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherigen Hintergrundmodus.  
  
### <a name="remarks"></a>Hinweise  
 Die Hintergrundmodus definiert, ob das System vorhandene Hintergrundfarben auf die Zeichenoberfläche entfernt vor dem Zeichnen von Text, schraffierten Pinsel oder jede Stift-Formatvorlage, die keine durchgehende Linie ist.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).  
  
##  <a name="setboundsrect"></a>  CDC::SetBoundsRect  
 Steuert die Kumulation umgebende Rechteck Informationen für den angegebenen Gerätekontext.  
  
```  
UINT SetBoundsRect(
    LPCRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>Parameter  
 *lpRectBounds*  
 Verweist auf eine `RECT` Struktur oder `CRect` -Objekt, das zum Festlegen des umschließenden Rechtecks verwendet wird. Rechteck-Dimensionen sind in logischen Koordinaten angegeben. Dieser Parameter kann **NULL**.  
  
 *flags*  
 Gibt an, wie das neue Rechteck mit den akkumulierten Rechteck kombiniert werden. Dieser Parameter kann eine Kombination der folgenden Werte sein:  
  
- **DCB_ACCUMULATE** das Rechteck gemäß *LpRectBounds* auf das umschließende Rechteck (mithilfe eines Rechtecks-Union-Vorgangs).  
  
- **DCB_DISABLE** Grenzen Accumulation / deaktivieren.  
  
- **DCB_ENABLE** Grenzen Accumulation / einschalten. (Die Standardeinstellung für Grenzen Ansammlung ist deaktiviert.)  
  
### <a name="return-value"></a>Rückgabewert  
 Der aktuelle Status des umschließenden Rechtecks, wenn die Funktion erfolgreich ausgeführt wird. Wie *Flags*, der Rückgabewert kann eine Kombination von **DCB_** Werte:  
  
- **DCB_ACCUMULATE** das umschließende Rechteck ist nicht leer. Dieser Wert wird immer festgelegt werden.  
  
- **DCB_DISABLE** Grenzen Ansammlung ist deaktiviert.  
  
- **DCB_ENABLE** Grenzen Accumulation / befindet sich auf.  
  
### <a name="remarks"></a>Hinweise  
 Windows kann ein umschließendes Rechteck für alle Zeichenvorgänge aufrechterhalten werden. Dieses Rechteck kann abgefragt und zurücksetzen, indem Sie die Anwendung. Die Zeichnung Grenzen eignen sich für die Bitmap-Caches wird ungültig gemacht.  
  
##  <a name="setbrushorg"></a>  CDC::SetBrushOrg  
 Gibt die Ursprungsdomäne, die GDI auf den nächsten Pinsel zuweist, die die Anwendung in den Gerätekontext auswählt.  
  
```  
CPoint SetBrushOrg(
    int x,  
    int y);  
  
CPoint SetBrushOrg(POINT point);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die X-Koordinate (in Geräteeinheiten) des neuen Ursprungs. Dieser Wert muss im Bereich von 0-7.  
  
 *y*  
 Gibt die y-Koordinate (in Geräteeinheiten) des neuen Ursprungs. Dieser Wert muss im Bereich von 0-7.  
  
 *Punkt*  
 Gibt die x- und y-Koordinaten des Ursprungs neue an. Jeder Wert muss im Bereich von 0-7. Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Der vorherige Ursprung des Pinsels in Geräteeinheiten.  
  
### <a name="remarks"></a>Hinweise  
 Die Standardeinstellung für die Ursprungsdomäne Pinsel koordiniert werden (0, 0). Aufrufen, um den Ursprung eines Pinsels zu ändern, die `UnrealizeObject` -Funktion für die `CBrush` -Objekt, rufen Sie `SetBrushOrg`, und rufen Sie dann die `SelectObject` Memberfunktion den Pinsel, der den Gerätekontext auswählen.  
  
 Verwenden Sie keine `SetBrushOrg` mit Stock `CBrush` Objekte.  
  
##  <a name="setcoloradjustment"></a>  CDC::SetColorAdjustment  
 Legt die Farbe Anpassungswerte für den Gerätekontext, der mit den angegebenen Werten.  
  
```  
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```  
  
### <a name="parameters"></a>Parameter  
 *lpColorAdjust*  
 Verweist auf eine [COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md) Datenstruktur, die die Werte der Farbe Anpassung.  
  
### <a name="return-value"></a>Rückgabewert  
 Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).  
  
### <a name="remarks"></a>Hinweise  
 Die Werte der Farbe Anpassung werden verwendet, um die Eingabe Farbe des Quellbitmaps für Aufrufe von Anpassen der `CDC::StretchBlt` Memberfunktion beim **RASTERBILD** -Modus festgelegt ist.  
  
##  <a name="setdcbrushcolor"></a>  CDC::SetDCBrushColor  
 Legt die aktuelle Pinselfarbe der Geräts Gerätekontext (DC) auf den Wert der angegebenen Farbe.  
  
```  
COLORREF SetDCBrushColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Parameter  
 *crColor*  
 Gibt die neue Pinselfarbe.  
  
### <a name="return-value"></a>Rückgabewert  
 Wenn die Funktion erfolgreich ausgeführt wird, wird der Rückgabewert gibt die vorherige DC Pinselfarbe als eine `COLORREF` Wert.  
  
 Wenn die Funktion fehlschlägt, ist der Rückgabewert `CLR_INVALID`.  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode emuliert die Funktionen der Funktion [SetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd162969)gemäß der Beschreibung im Windows SDK.  
  
##  <a name="setdcpencolor"></a>  CDC::SetDCPenColor  
 Legt die aktuelle Stiftfarbe der Geräts Gerätekontext (DC) auf den Wert der angegebenen Farbe.  
  
```  
COLORREF SetDCPenColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Parameter  
 *crColor*  
 Gibt die neue Stiftfarbe.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion verwendet die Win32-Funktion [SetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd162970)gemäß der Beschreibung im Windows SDK.  
  
##  <a name="setgraphicsmode"></a>  CDC::SetGraphicsMode  
 Legt den Grafikmodus für den angegebenen Gerätekontext.  
  
```  
int SetGraphicsMode(int iMode);
```  
  
### <a name="parameters"></a>Parameter  
 *iMode*  
 Gibt den Grafikmodus. Eine Liste der Werte, die für diesen Parameter, finden Sie unter [SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977).  
  
### <a name="return-value"></a>Rückgabewert  
 Bei Erfolg wird den alte Grafikmodus zurückgegeben.  
  
 Gibt 0 bei einem Fehler zurück. Um erweiterte Fehlerinformationen abzurufen, rufen [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode dient als Wrapper für die Windows-GDI-Funktion [SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977).  
  
##  <a name="setlayout"></a>  CDC::SetLayout  
 Rufen Sie diese Memberfunktion, um das Layout von Text und Grafiken für einen Gerätekontext in rechts nach links, das Standardlayout für Kulturen wie Arabisch und Hebräisch zu ändern.  
  
```  
DWORD SetLayout(DWORD dwLayout);
```  
  
### <a name="parameters"></a>Parameter  
 *dwLayout*  
 Gerät Kontext und Bitmap Flags zu bestimmen. Eine Kombination der folgenden Werte sind möglich.  
  
|Wert|Bedeutung|  
|-----------|-------------|  
|LAYOUT_BITMAPORIENTATIONPRESERVED|Deaktiviert alle Reflektion für Aufrufe von [CDC:: BitBlt](#bitblt) und [CDC::StretchBlt](#stretchblt).|  
|LAYOUT_RTL|Legt die horizontale Standardlayout werden von rechts nach links fest.|  
|LAYOUT_LTR|Legt das Standardlayout, links nach rechts ausgerichtet werden.|  
  
### <a name="return-value"></a>Rückgabewert  
 Bei erfolgreicher Ausführung der vorherigen Layout des Gerätekontexts.  
  
 Wenn dies nicht gelingt, **GDI_ERROR**. Um erweiterte Fehlerinformationen abzurufen, rufen [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Hinweise  
 Normalerweise würden Sie nicht aufrufen **SetLayout** für ein Fenster. Stattdessen steuern das Layout rechts-nach-links in einem Fenster durch Festlegen der [erweiterten Fensterstile](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) wie z. B. **WS_EX_RTLREADING**. Dieses Layout ein Gerätekontext, z. B. einen Drucker oder eine Metadatei nicht geerbt. Die einzige Möglichkeit, den Gerätekontext für festgelegte ein Layout von rechts nach links durch Aufrufen von **SetLayout**.  
  
 Beim Aufrufen **SetLayout (LAYOUT_RTL** ), **SetLayout** ändert automatisch den Zuordnungsmodus zu `MM_ISOTROPIC`. Als Ergebnis ein nachfolgender Aufruf von [GetMapMode](#getmapmode) zurück **MM_ISOTROPIC** anstelle von `MM_TEXT`.  
  
 In einigen Fällen können z. B. mit vielen Bitmaps Sie das Layout von links nach rechts beibehalten möchten. In diesen Fällen das Bild zu rendern durch Aufrufen von `BitBlt` oder `StretchBlt`, legen Sie dann auf die Bitmap für protokollierungssteuerungs-Flag für *DwLayout* auf **LAYOUT_BITMAPORIENTATIONPRESERVED**.  
  
 Nachdem Sie das Layout mit ändern die **LAYOUT_RTL** kennzeichnen, die Flags, die normalerweise angeben rechts oder Links werden rückgängig gemacht. Um Verwirrung zu vermeiden, empfiehlt es sich um alternativen Namen für die standard-Flags zu definieren. Eine Liste der vorgeschlagenen alternativen Flag Namen, finden Sie unter [SetLayout](http://msdn.microsoft.com/library/windows/desktop/dd162979) im Windows SDK.  
  
##  <a name="setmapmode"></a>  CDC::SetMapMode  
 Legt den Zuordnungsmodus.  
  
```  
virtual int SetMapMode(int nMapMode);
```  
  
### <a name="parameters"></a>Parameter  
 *nMapMode*  
 Gibt den neuen Zuordnungsmodus. Eine der folgenden Werte sind möglich:  
  
- `MM_ANISOTROPIC` Logische Einheiten werden in beliebigen Einheiten mit nach dem Zufallsprinzip skalierte Achsen konvertiert. Festlegen der Zuordnungsmodus auf `MM_ANISOTROPIC` ändert sich nicht auf das aktuelle Fenster oder der Viewport-Einstellungen. Ausrichtung und Skalierung, rufen Sie zum Ändern der Einheiten der [SetWindowExt](#setwindowext) und [SetViewportExt](#setviewportext) Memberfunktionen.  
  
- `MM_HIENGLISH` Jeder logischen Einheit wird in 0,001 Zoll konvertiert. Positive x ist auf der rechten Seite. positive y ist aktiv.  
  
- `MM_HIMETRIC` Jeder logischen Einheit wird in 0,01 Millimeter konvertiert. Positive x ist auf der rechten Seite. positive y ist aktiv.  
  
- `MM_ISOTROPIC` Logische Einheiten werden in beliebigen Einheiten mit gleichermaßen skalierte Achsen konvertiert. d. h. gleich 1 Einheit der x-Achse 1 Einheit entlang der y-Achse. Verwenden der `SetWindowExt` und `SetViewportExt` Memberfunktionen können Sie die gewünschte Einheiten und die Ausrichtung der Achsen angeben. GDI kann Anpassungen nach Bedarf um sicherzustellen, dass die x- und y-Einheiten bleiben die gleiche Größe.  
  
- `MM_LOENGLISH` Jeder logischen Einheit wird in 0,01 Zoll konvertiert. Positive x ist auf der rechten Seite. positive y ist aktiv.  
  
- `MM_LOMETRIC` Jeder logischen Einheit wird in 0,1 Millimeter konvertiert. Positive x ist auf der rechten Seite. positive y ist aktiv.  
  
- `MM_TEXT` Jeder logischen Einheit wird auf 1 Gerät Pixel konvertiert. Positive x ist auf der rechten Seite. positive y ist ausgefallen.  
  
- `MM_TWIPS` Jeder logischen Einheit wird auf 1/20 eines Punkts konvertiert. (Da es ein Punkt 1/72 Zoll handelt, ist ein Twip 1/1440 Zoll.) Positive x ist auf der rechten Seite. positive y ist aktiv.  
  
### <a name="return-value"></a>Rückgabewert  
 Vom vorherigen Zuordnungsmodus.  
  
### <a name="remarks"></a>Hinweise  
 Vom Zuordnungsmodus definiert die Maßeinheit, die zum Konvertieren von logischer Einheiten in Geräteeinheiten verwendet. Außerdem wird die Ausrichtung des Geräts in dessen x- und y-Achse zu definiert. GDI verwendet den Zuordnungsmodus logische Koordinaten in den entsprechenden Gerätegruppen Koordinaten konvertieren. Die `MM_TEXT` Modus ermöglicht es Anwendungen funktionieren in Pixeln, wobei 1 Einheit gleich 1 Pixel. Die physische Größe eines Pixels hängt vom Gerät ab.  
  
 Die `MM_HIENGLISH`, `MM_HIMETRIC`, `MM_LOENGLISH`, `MM_LOMETRIC`, und `MM_TWIPS` Modi eignen sich für Anwendungen, die in physisch sinnvoller Einheiten (z. B. Zoll oder Millimeter) zeichnen müssen. Die `MM_ISOTROPIC` Modus wird sichergestellt, dass eine 1:1-Seitenverhältnis, das ist nützlich, wenn es wichtig ist, die genaue Form eines Bilds beibehalten. Die `MM_ANISOTROPIC` Modus ermöglicht die x- und y-Koordinaten unabhängig angepasst werden.  
  
> [!NOTE]
>  Beim Aufrufen [SetLayout](#setlayout) so ändern Sie den Domänencontroller (Gerätekontext) rechts-nach-links-Layout `SetLayout` ändert automatisch den Zuordnungsmodus zu `MM_ISOTROPIC`.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setmapperflags"></a>  CDC::SetMapperFlags  
 Ändert die Methode, die von der Schriftartenmapper verwendet werden, wenn eine logische Schriftart in einer physischen Schriftart konvertiert werden.  
  
```  
DWORD SetMapperFlags(DWORD dwFlag);
```  
  
### <a name="parameters"></a>Parameter  
 *dwFlag*  
 Gibt an, ob die Schriftartenmapper versucht, eine Schriftart Aspekt Höhe und Breite auf dem Gerät übereinstimmen. Wenn dieser Wert ist **ASPECT_FILTERING**, der Mapper wählt nur Schriftarten, dessen X-Aspekt und y-Aspekt ist genau übereinstimmen, die von dem angegebenen Gerät.  
  
### <a name="return-value"></a>Rückgabewert  
 Der vorherige Wert des Flags Schriftarten-Mapper.  
  
### <a name="remarks"></a>Hinweise  
 Eine Anwendung kann mithilfe `SetMapperFlags` , dazu führen, dass den Schriftartenmapper versucht, die nur eine physische Schriftart auswählen, die genau das Seitenverhältnis des angegebenen Geräts übereinstimmt.  
  
 Eine Anwendung, die nur die Rasterschriftarten verwendet werden können die `SetMapperFlags` Funktion, um sicherzustellen, dass die vom Schriftartenmapper ausgewählte Schriftart ansprechend und lesbar, auf das angegebene Gerät ist. Anwendungen, die skalierbare (TrueType) Schriftarten, in der Regel verwenden verwenden Sie keine `SetMapperFlags`.  
  
 Wenn keine physischen Schriftart ein Seitenverhältnis besitzt, die die logische Schriftart-Spezifikation übereinstimmt, wird GDI wählt einen neuen Seitenverhältnis und wählt eine Schriftart, die diese neuen Seitenverhältnis entspricht.  
  
##  <a name="setmiterlimit"></a>  CDC::SetMiterLimit  
 Legt das Limit für die Länge des gehrungsverbindungen für den Gerätekontext.  
  
```  
BOOL SetMiterLimit(float fMiterLimit);
```  
  
### <a name="parameters"></a>Parameter  
 *fMiterLimit*  
 Gibt den neuen Spitz Grenzwert für den Gerätekontext.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Die Länge Spitz ist definiert als die Entfernung aus der Schnittmenge der Zeile Wände auf das Innere des Joins auf die Schnittmenge der Zeile Wände an der Außenseite des Joins. Der Grenzwert für den Winkel ist die maximale zulässige Verhältnis von der Spitz lang ist, um die Linienstärke. Das Standardlimit für die Gehrung ist 10,0.  
  
##  <a name="setoutputdc"></a>  CDC::SetOutputDC  
 Rufen Sie diese Memberfunktion um den Gerätekontext Ausgabe festzulegen `m_hDC`.  
  
```  
virtual void SetOutputDC(HDC hDC);
```  
  
### <a name="parameters"></a>Parameter  
 *hDC*  
 Ein Windows-Gerätekontext.  
  
### <a name="remarks"></a>Hinweise  
 Diese Memberfunktion kann nur aufgerufen werden, wenn Sie ein Gerätekontext nicht zugeordnet wurde die `CDC` Objekt. Diese Memberfunktion legt `m_hDC` jedoch nicht den Gerätekontext behandelt wird die `CDC` Objekt.  
  
##  <a name="setpixel"></a>  CDC::SetPixel  
 Legt die Pixel angegeben, um diesem am ehesten der Farbe von angegebenen Zeitpunkt *CrColor*.  
  
```  
COLORREF SetPixel(
    int x,  
    int y,  
    COLORREF crColor);

 
COLORREF SetPixel(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate des Punkts, der festgelegt werden.  
  
 *y*  
 Gibt die logische y-Koordinate des Punkts, der festgelegt werden.  
  
 *crColor*  
 Ein **COLORREF** RGB-Wert, der angibt, die Farbe, die zum Zeichnen des Punkts verwendet wird. Finden Sie unter [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) in das Windows SDK für eine Beschreibung dieses Werts.  
  
 *Punkt*  
 Gibt die logische X - und y-Koordinaten des Punkts, der festgelegt werden. Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein RGB-Wert für die Farbe, der Punkt tatsächlich gezeichnet wird. Mögliche Werte sind identisch, die vom angegebenen *CrColor* Wenn ein Näherungswert der jeweiligen Farbe verwendet wird. Wenn die Funktion fehlerhaft ist (wenn der Punkt außerhalb des Clippingbereichs ist), ist der Rückgabewert-1 zurück.  
  
### <a name="remarks"></a>Hinweise  
 Der Punkt muss sich im des Clippingbereichs. Wenn der Verwaltungspunkt nicht in den Ausschneidebereich ist, bleibt die Funktion untätig.  
  
 Nicht alle Geräte unterstützen die `SetPixel`-Funktion. Um zu bestimmen, ob ein Gerät unterstützt `SetPixel`, Aufrufen der `GetDeviceCaps` Memberfunktion mit der **RASTERCAPS** index, und überprüfen Sie den Rückgabewert für die **RC_BITBLT** Flag.  
  
##  <a name="setpixelv"></a>  CDC::SetPixelV  
 Legt das Pixel an den angegebenen Koordinaten auf diesem am ehesten der angegebenen Farbe.  
  
```  
BOOL SetPixelV(
    int x,  
    int y,  
    COLORREF crColor);

 
BOOL SetPixelV(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die X-Koordinate, in logischen Einheiten des Punkts, der festgelegt werden.  
  
 *y*  
 Gibt die y-Koordinate, in logischen Einheiten des Punkts, der festgelegt werden.  
  
 *crColor*  
 Gibt die Farbe an, die verwendet werden, um den Punkt zu zeichnen.  
  
 *Punkt*  
 Gibt die logische X - und y-Koordinaten des Punkts, der festgelegt werden. Übergeben Sie entweder eine [Punkt](../../mfc/reference/point-structure1.md) Datenstruktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der Punkt muss sich im Ausschneidebereichs und der sichtbare Teil der Geräteoberfläche. Nicht alle Geräte unterstützen die Member-Funktion. Weitere Informationen finden Sie unter der **RC_BITBLT** -Funktion die `CDC::GetDeviceCaps` Memberfunktion. `SetPixelV` ist schneller als `SetPixel` , da er nicht den Farbwert des Punkts tatsächlich gezeichnet zurückgeben muss.  
  
##  <a name="setpolyfillmode"></a>  CDC::SetPolyFillMode  
 Legt den Modus Polygon füllen.  
  
```  
int SetPolyFillMode(int nPolyFillMode);
```  
  
### <a name="parameters"></a>Parameter  
 *nPolyFillMode*  
 Gibt den neuen Füllmodus. Dieser Wert möglicherweise entweder **ALTERNATIVEN** oder **WINDING**. Der Standardmodus in Windows festgelegt ist **ALTERNATIVEN**.  
  
### <a name="return-value"></a>Rückgabewert  
 Den vorherigen Füllmodus, wenn erfolgreich; andernfalls 0.  
  
### <a name="remarks"></a>Hinweise  
 Wenn der Polygon füllenden Modus ist **ALTERNATIVEN**, das System füllt den Bereich zwischen ungerader und gerader Polygonseiten für jede Scanzeile. Das System füllt, also den Bereich zwischen der ersten und zweiten Seite, zwischen dem dritten und vierten Seite und So weiter. Dieser Modus ist die Standardeinstellung.  
  
 Wenn der Polygon füllenden Modus ist **WINDING**, verwendet das System die Richtung, in der Abbildung gezeichnet wurde, um zu ermitteln, ob eine Fläche auszufüllen. Jedes Liniensegment in einem Polygon wird im Uhrzeigersinn oder gegen den Uhrzeigersinn gezeichnet. Wenn gegen den Uhrzeigersinn Liniensegment eine imaginäre Linie gezeichnet aus einem eingeschlossenen Bereich außerhalb der Abbildung durchläuft, wird eine Anzahl erhöht. Wenn die Zeile gegen den Uhrzeigersinn Liniensegment durchläuft, wird die Anzahl verringert. Der Bereich wird ausgefüllt, wenn der Wert ungleich NULL ist, wenn die Zeile außerhalb der in der Abbildung erreicht.  
  
##  <a name="setrop2"></a>  CDC::SetROP2  
 Legt den aktuellen Zeichnungsmodus fest.  
  
```  
int SetROP2(int nDrawMode);
```  
  
### <a name="parameters"></a>Parameter  
 *nDrawMode*  
 Gibt den neuen Zeichnungsmodus an. Die folgenden Werte sind möglich:  
  
- **R2_BLACK** Pixel ist immer Schwarz.  
  
- **R2_WHITE** Pixel ist immer weiß.  
  
- **R2_NOP** Pixel bleibt unverändert.  
  
- **R2_NOT** Pixel ist die Umkehrung der Bildschirmfarbe.  
  
- **R2_COPYPEN** Pixel ist die Stiftfarbe.  
  
- **R2_NOTCOPYPEN** Pixel ist das Gegenteil der Stiftfarbe.  
  
- **R2_MERGEPENNOT** Pixel ist eine Kombination der Stiftfarbe und die Umkehrung der Bildschirmfarbe (letzte Pixel = (nicht in Bildschirmpixel) oder Stift).  
  
- **R2_MASKPENNOT** Pixel ist eine Kombination der Farben auf den Stift und die Umkehrung des Bildschirms (letzte Pixel = (nicht in Bildschirmpixel) und Stift).  
  
- **R2_MERGENOTPEN** Pixel ist eine Kombination der Bildschirmfarbe und die Umkehrung der Stiftfarbe (letzte Pixel (nicht Stift) = ' oder ' Bildschirm Pixel).  
  
- **R2_MASKNOTPEN** Pixel ist eine Kombination der Farben auf dem Bildschirm und die Umkehrung des Stifts (letzte Pixel (nicht Stift) = ' und ' Bildschirm Pixel).  
  
- **R2_MERGEPEN** Pixel ist eine Kombination der Stiftfarbe und der Bildschirmfarbe (letzte Pixel = Stift OR Bildschirmpixel).  
  
- **R2_NOTMERGEPEN** Pixel ist die Umkehrung der **R2_MERGEPEN** Farbe (endgültigen Pixel = nicht (Stift oder Bildschirmpixel)).  
  
- **R2_MASKPEN** Pixel ist eine Kombination der Farben der Stift und der Bildschirm (letzte Pixel = Stift und Bildschirmpixel).  
  
- **R2_NOTMASKPEN** Pixel ist die Umkehrung der **R2_MASKPEN** Farbe (endgültigen Pixel = nicht (Stift und Bildschirmpixel)).  
  
- **R2_XORPEN** Pixel ist eine Kombination der Farben, die in den Stift oder auf dem Bildschirm, aber nicht in beiden sind (letzte Pixel = Stift XOR Bildschirmpixel).  
  
- **R2_NOTXORPEN** Pixel ist die Umkehrung der **R2_XORPEN** Farbe (letzte Pixel = nicht (Stift XOR Bildschirmpixel)).  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherigen Zeichnungsmodus des.  
  
 Es kann einer der Werte im Windows SDK angegeben sein.  
  
### <a name="remarks"></a>Hinweise  
 Zeichnungsmodus des gibt an, wie die Farben des Stifts und das Innere eines gefüllten Objekte mit der Farbe bereits auf der Anzeigeoberfläche kombiniert werden.  
  
 Zeichnungsmodus des ist nur für Rastergeräte. Es gilt nicht für Geräte Vektor. Zeichnung Modi handelt es sich um binäre rastervorgang Codes, die alle mögliche booleschen Kombinationen von zwei Variablen, die mit binären Operatoren AND, OR und XOR (exklusives OR) und der unären Operation "NOT" darstellt.  
  
##  <a name="setstretchbltmode"></a>  CDC::SetStretchBltMode  
 Legt den Modus Strecken einer Bitmap für die `StretchBlt` Memberfunktion.  
  
```  
int SetStretchBltMode(int nStretchMode);
```  
  
### <a name="parameters"></a>Parameter  
 *nStretchMode*  
 Gibt den streckmodus an. Die folgenden Werte sind möglich:  
  
|Wert|Beschreibung|  
|-----------|-----------------|  
|**BLACKONWHITE**|Führt eine boolesche AND-Operation, die mithilfe der Farbwerte für die Pixel eliminiert und vorhandene. Wenn die Bitmap eine monochrome Bitmap ist, behält in diesem Modus schwarze Pixel auf Kosten der weißen Pixel.|  
|**COLORONCOLOR**|Löscht die Pixel. Dieser Modus löscht alle gelöschte Zeilen der Pixel, ohne zu versuchen, ihre Informationen beibehalten.|  
|**RASTERBILD**|Ordnet Pixel vom Quellrechtecks in Blöcke von Pixel Zielrechtecks an. Die durchschnittliche Farbe über den Zielblock eines Pixel entspricht in etwa die Farbe der Pixel der Quelle.|  
||Nach dem Festlegen der **RASTERBILD** Strecken Modus muss eine Anwendung die Win32-Funktion aufrufen [SetBrushOrgEx](http://msdn.microsoft.com/library/windows/desktop/dd162967) Pinsel Ursprung festlegen. Wenn sie nicht dazu, tritt auf, so Pinsel.|  
|**STRETCH_ANDSCANS**|**Windows 95-und Windows 98**: identisch mit **BLACKONWHITE**|  
|**STRETCH_DELETESCANS**|**Windows 95-und Windows 98**: identisch mit **COLORONCOLOR**|  
|**STRETCH_HALFTONE**|**Windows 95-und Windows 98**: identisch mit **RASTERBILD**.|  
|**STRETCH_ORSCANS**|**Windows 95-und Windows 98**: identisch mit **WHITEONBLACK**|  
|**WHITEONBLACK**|Führt eine boolesche OR-Operation, die die Farbwerte für die Pixel eliminiert und vorhandene verwenden. Wenn die Bitmap eine monochrome Bitmap ist, behält in diesem Modus weißen Pixel auf Schwarz Pixel Kosten an.|  
  
### <a name="return-value"></a>Rückgabewert  
 Der vorherige ausdehnen Modus. Es kann sein **STRETCH_ANDSCANS**, **STRETCH_DELETESCANS**, oder **STRETCH_ORSCANS**.  
  
### <a name="remarks"></a>Hinweise  
 Der Modus zum Strecken einer Bitmap definiert, wie Informationen über Bitmaps entfernt wird, die komprimiert werden, mithilfe der Funktion.  
  
 Die **BLACKONWHITE** ( **STRETCH_ANDSCANS**) und **WHITEONBLACK** ( **STRETCH_ORSCANS**) Modi werden in der Regel verwendet, um beibehalten Vordergrund Pixel monochrome Bitmaps. Die **COLORONCOLOR** ( **STRETCH_DELETESCANS**) Modus ist in der Regel verwendet, um Farbe in Farbe Bitmaps beizubehalten.  
  
 Die **RASTERBILD** Modus erfordert mehr Verarbeitungszeit des Quellbilds als die anderen drei Modi; ist langsamer als die anderen, aber höhere Bildqualität erzeugt. Beachten Sie, dass **SetBrushOrgEx** muss aufgerufen werden, nach dem Festlegen der **RASTERBILD** Modus Pinsel so vermieden.  
  
 Weitere ausdehnen Modi können abhängig von den Funktionen des Gerätetreibers verfügbar sein.  
  
##  <a name="settextalign"></a>  CDC::SetTextAlign  
 Legt die textausrichtung Flags.  
  
```  
UINT SetTextAlign(UINT nFlags);
```  
  
### <a name="parameters"></a>Parameter  
 *nFlags*  
 Gibt die textausrichtung Flags. Die Flags geben die Beziehung zwischen einem Punkt und ein Rechteck, das den Text umschließt. Der Punkt kann der aktuellen Position oder durch eine Ausgabe von Text-Funktion angegebenen Koordinaten. Das Rechteck, das den Text umschließende wird durch die angrenzenden Zeichenzellen in der Textzeichenfolge definiert. Die *nFlags* Parameter kann eine oder mehrere Flags aus den folgenden drei Kategorien umfassen. Wählen Sie nur einen Flag aus jeder Kategorie ein. Die erste Kategorie wirkt sich auf die Ausrichtung des Texts in der X-Richtung:  
  
- **TA_CENTER** richtet den Punkt mit der horizontalen Mitte des umschließenden Rechtecks.  
  
- **TA_LEFT** richtet den Punkt mit der linken Seite des umschließenden Rechtecks. Dies ist die Standardeinstellung.  
  
- **TA_RIGHT** richtet den Punkt mit der rechten Seite des umschließenden Rechtecks.  
  
 Die zweite Kategorie wirkt sich auf die Ausrichtung des Texts in der y-Richtung:  
  
- **TA_BASELINE** richtet den Punkt mit der Grundlinie der ausgewählten Schriftart.  
  
- **TA_BOTTOM** richtet den Punkt am unteren Rand des umschließenden Rechtecks.  
  
- **TA_TOP** richtet den Punkt am oberen Rand des umschließenden Rechtecks. Dies ist die Standardeinstellung.  
  
 Die dritte Kategorie bestimmt, ob die aktuelle Position aktualisiert wird, wenn Text geschrieben wird:  
  
- **TA_NOUPDATECP** die aktuelle Position nach jedem Aufruf an eine Ausgabe von Text-Funktion wird nicht aktualisiert. Dies ist die Standardeinstellung.  
  
- **TA_UPDATECP** aktualisiert die aktuelle X-Position nach jedem Aufruf an eine Ausgabe von Text-Funktion. Die neue Position wird auf der rechten Seite des umschließenden Rechtecks für den Text. Wenn dieses Flag festgelegt ist, die in Aufrufen an angegebenen Koordinaten das `TextOut` Memberfunktion werden ignoriert.  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherige textausrichtung-Einstellung, wenn erfolgreich. Das niedrige Byte enthält das horizontale und das höherwertige Byte enthält das vertikale; andernfalls 0.  
  
### <a name="remarks"></a>Hinweise  
 Die `TextOut` und `ExtTextOut` Memberfunktionen eine Zeichenfolge auf ein Gerät oder die Anzeige zu positionieren, diese Flags verwenden. Die Flags geben die Beziehung zwischen einem bestimmten Zeitpunkt und ein Rechteck, das den Text umschließt. Die Koordinaten der bisher übergeben werden, als Parameter für die `TextOut` Memberfunktion. Das Rechteck, das den Text umschließt, wird durch die angrenzenden Zeichenzellen in der Textzeichenfolge gebildet.  
  
##  <a name="settextcharacterextra"></a>  CDC::SetTextCharacterExtra  
 Legt den Zeitraum des Zeichenabstands fest.  
  
```  
int SetTextCharacterExtra(int nCharExtra);
```  
  
### <a name="parameters"></a>Parameter  
 *nCharExtra*  
 Gibt Sie den zusätzlichen Abstand (in logischen Einheiten) an, dass jedes Zeichen hinzugefügt werden. Wenn nicht vom aktuellen Zuordnungsmodus ist `MM_TEXT`, *nCharExtra* transformiert und auf das nächste Pixel gerundet.  
  
### <a name="return-value"></a>Rückgabewert  
 Der Anteil der vorherigen Zeichenabstands.  
  
### <a name="remarks"></a>Hinweise  
 GDI hinzugefügt jedes Zeichen, einschließlich Zeilenumbruchzeichen unverändert, wenn sie eine Textzeile für den Gerätekontext schreibt diesen Abstand. Der Standardwert für die Menge an Zeichenabstands ist 0.  
  
##  <a name="settextcolor"></a>  CDC::SetTextColor  
 Legt die Textfarbe der angegebenen Farbe fest.  
  
```  
virtual COLORREF SetTextColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Parameter  
 *crColor*  
 Gibt die Farbe des Texts als eine RGB-Wert an.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein für die vorherigen Textfarbe RGB-Wert.  
  
### <a name="remarks"></a>Hinweise  
 Das System verwendet dieses Textfarbe, beim Schreiben von Text in dieser Gerätekontext und auch beim Konvertieren von Bitmaps zwischen-Farbe aus, und monochrome Gerätekontexte.  
  
 Wenn das Gerät die angegebene Farbe nicht darstellen kann, setzt das System die Textfarbe auf die nächste physische Farbe. Die Farbe des Hintergrunds für ein Zeichen gemäß der `SetBkColor` und `SetBkMode` Memberfunktionen.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).  
  
##  <a name="settextjustification"></a>  CDC::SetTextJustification  
 Speicherplatz und Zeilenumbruchzeichen unverändert in einer Zeichenfolge hinzugefügt.  
  
```  
int SetTextJustification(
    int nBreakExtra,  
    int nBreakCount);
```  
  
### <a name="parameters"></a>Parameter  
 *nBreakExtra*  
 Gibt an, der zusätzliche Gesamtspeicherplatz die Textzeile (in logischen Einheiten) hinzugefügt werden. Wenn nicht vom aktuellen Zuordnungsmodus ist `MM_TEXT`, der von diesem Parameter angegebene Wert wird in der aktuellen Zuordnungsmodus konvertiert und auf die nächste Geräteeinheit gerundet.  
  
 *nBreakCount*  
 Gibt die Anzahl der Zeilenumbruchzeichen unverändert in der Zeile an.  
  
### <a name="return-value"></a>Rückgabewert  
 Eins, wenn die Funktion erfolgreich ist; andernfalls 0.  
  
### <a name="remarks"></a>Hinweise  
 Eine Anwendung kann mithilfe der `GetTextMetrics` Memberfunktionen zum Abrufen einer Schriftart unterbrechen Zeichen.  
  
 Nach der `SetTextJustification` Memberfunktion aufgerufen wird, wird einen Aufruf an eine Ausgabe von Text-Funktion (z. B. `TextOut`) verteilt den angegebenen zusätzlichen Speicherplatz gleichmäßig auf die angegebene Anzahl von Zeilenumbruchzeichen unverändert. Das Umbruchzeichen wird in der Regel das Leerzeichen (ASCII 32), aber möglicherweise von einer Schriftart als ein anderes Zeichen definiert.  
  
 Die Memberfunktion `GetTextExtent` wird normalerweise verwendet, mit `SetTextJustification`. `GetTextExtent` berechnet die Breite einer bestimmten Zeile vor der Ausrichtung an. Eine Anwendung kann bestimmen, wie viel Speicherplatz an, in der *nBreakExtra* Parameter durch Subtrahieren der Rückgabewert von `GetTextExtent` von der Breite der Zeichenfolge nach Ausrichtung.  
  
 Die `SetTextJustification` Funktion kann verwendet werden, um eine Linie auszurichten, die mehrere Läufe in unterschiedliche Schriftarten enthält. In diesem Fall muss die Zeile schrittweise durch das Ausrichten und schreiben zu jedem Durchlauf separat erstellt werden.  
  
 Da Rundungsfehler während Ausrichtung auftreten kann, bleiben im System ausgeführten Fehler Ausdruck, der den aktuellen Fehler definiert. Wenn eine Zeile ausrichten, die mehrere ausgeführt wird, enthält `GetTextExtent` automatisch verwendet, wenn das Ausmaß der nächsten Ausführung berechnet, Fehler Begriff. Dadurch wird die Ausgabe von Text-Funktion, die den Fehler in der neuen ausführenden blend.  
  
 Nachdem jede Zeile ausgerichtet wurden, muss dieser Begriff Fehler deaktiviert werden, um zu verhindern, dass es in die nächste Zeile des Nachrichtenflusses integriert wird. Der Begriff kann gelöscht werden, durch den Aufruf `SetTextJustification` mit *nBreakExtra* auf 0 festgelegt.  
  
##  <a name="setviewportext"></a>  CDC::SetViewportExt  
 Legt die x und y-Blöcke des Viewports des Gerätekontexts fest.  
  
```  
virtual CSize SetViewportExt(
    int cx,  
    int cy);  
  
CSize SetViewportExt(SIZE size);
```  
  
### <a name="parameters"></a>Parameter  
 *CX*  
 Gibt den X-Umfang des Viewports (in Geräteeinheiten).  
  
 *CY*  
 Gibt den y-Umfang des Viewports (in Geräteeinheiten).  
  
 *size*  
 Gibt die x und y-Blöcke des Viewports (in Geräteeinheiten) an.  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherigen Blöcke des Viewports als eine [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt. Wenn ein Fehler auftritt, werden die x- und y-Koordinaten der zurückgegebenen `CSize` Objekt werden auf 0 festgelegt.  
  
### <a name="remarks"></a>Hinweise  
 Viewport, zusammen mit den Gerätekontext Fenster definiert, wie GDI Punkte in der logischen Koordinatensystem Punkt im Koordinatensystem des tatsächlichen Geräts zugeordnet. Das heißt, werden definiert, wie GDI logische Koordinaten in logische Koordinaten konvertiert.  
  
 Wenn die folgenden Zuordnungsmodi festgelegt sind, Aufrufe von `SetWindowExt` und `SetViewportExt` werden ignoriert:  
  
|MM_HIENGLISH|MM_LOMETRIC|  
|-------------------|------------------|  
|`MM_HIMETRIC`|`MM_TEXT`|  
|`MM_LOENGLISH`|`MM_TWIPS`|  
  
 Wenn `MM_ISOTROPIC` -Modus festgelegt ist, muss eine Anwendung aufrufen, die `SetWindowExt` Memberfunktion vor `SetViewportExt`.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setviewportorg"></a>  CDC::SetViewportOrg  
 Legt den Ursprung des Ausschnitts des Gerätekontexts fest.  
  
```  
virtual CPoint SetViewportOrg(
    int x,  
    int y);  
  
CPoint SetViewportOrg(POINT point);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die X-Koordinate (in Geräteeinheiten) des Ursprungs des Viewports an. Der Wert muss innerhalb des Bereichs des Koordinatensystems Gerät sein.  
  
 *y*  
 Gibt die y-Koordinate (in Geräteeinheiten) des Ursprungs des Viewports an. Der Wert muss innerhalb des Bereichs des Koordinatensystems Gerät sein.  
  
 *Punkt*  
 Gibt den Ursprung des Viewports an. Die Werte müssen innerhalb des Bereichs des Koordinatensystems Gerät sein. Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherigen Ursprung des Viewports (in logische Koordinaten) als ein `CPoint` Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Viewport, zusammen mit den Gerätekontext Fenster definiert, wie GDI Punkte in der logischen Koordinatensystem Punkt im Koordinatensystem des tatsächlichen Geräts zugeordnet. Das heißt, werden definiert, wie GDI logische Koordinaten in logische Koordinaten konvertiert.  
  
 Der Ursprung des Ausschnitts kennzeichnet den Punkt im gerätekoordinatensystem, dem zugeordnet GDI Fensterursprung, einem Punkt im logischen Koordinatensystem gemäß, der **SetWindowOrg** Memberfunktion. GDI ordnet alle anderen Punkten durch Befolgung desselben Prozesses erforderlich, um den Fensterursprung, Viewports Ursprung zuzuordnen. Beispielsweise werden alle Punkte in einem Kreis, um den Punkt am ursprünglichen Speicherort Fenster in einem Kreis, um den Punkt am ursprünglichen Speicherort Viewport. Auf ähnliche Weise werden alle Punkte in einer Zeile, die den Fensterursprung werden in einer Zeile, die der Ursprung des Ausschnitts durchlaufen.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setwindowext"></a>  CDC::SetWindowExt  
 Legt die x und y-Blöcke des Fensters den Gerätekontext zugeordnet.  
  
```  
virtual CSize SetWindowExt(
    int cx,  
    int cy);  
  
CSize SetWindowExt(SIZE size);
```  
  
### <a name="parameters"></a>Parameter  
 *CX*  
 Gibt den X-Umfang (in logischen Einheiten) des Fensters.  
  
 *CY*  
 Gibt den y-Umfang (in logischen Einheiten) des Fensters.  
  
 *size*  
 Gibt die X - und y-Blöcke (in logischen Einheiten) des Fensters.  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherigen Blöcke des Fensters (in logischen Einheiten) als ein `CSize` Objekt. Wenn ein Fehler auftritt, die x- und y-Koordinaten der zurückgegebenen `CSize` Objekt werden auf 0 festgelegt.  
  
### <a name="remarks"></a>Hinweise  
 Im Fenster zusammen mit den Viewport Gerätekontext definiert, wie GDI Punkte in der logischen Koordinatensystem Punkt im gerätekoordinatensystem zugeordnet.  
  
 Wenn die folgenden Zuordnungsmodi festgelegt sind, Aufrufe von `SetWindowExt` und `SetViewportExt` Funktionen werden ignoriert:  
  
- `MM_HIENGLISH`  
  
- `MM_HIMETRIC`  
  
- `MM_LOENGLISH`  
  
- `MM_LOMETRIC`  
  
- `MM_TEXT`  
  
- `MM_TWIPS`  
  
 Wenn `MM_ISOTROPIC` -Modus festgelegt ist, muss eine Anwendung aufrufen, die `SetWindowExt` Memberfunktion vor dem Aufruf `SetViewportExt`.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setwindoworg"></a>  CDC::SetWindowOrg  
 Legt den Fensterursprung des Gerätekontexts fest.  
  
```  
CPoint SetWindowOrg(
    int x,  
    int y);  
  
CPoint SetWindowOrg(POINT point);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate des neuen Ursprung des Fensters.  
  
 *y*  
 Gibt die logische y-Koordinate des neuen Ursprung des Fensters.  
  
 *Punkt*  
 Gibt den logischen Koordinaten des neuen Ursprung des Fensters. Übergeben Sie entweder eine **Punkt** Struktur oder ein `CPoint` Objekt für diesen Parameter.  
  
### <a name="return-value"></a>Rückgabewert  
 Die vorherigen Ursprung des Fensters als ein `CPoint` Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Im Fenster zusammen mit den Viewport Gerätekontext definiert, wie GDI Punkte in der logischen Koordinatensystem Punkt im gerätekoordinatensystem zugeordnet.  
  
 Der Fensterursprung kennzeichnet den Punkt in der logischen Koordinatensystem aus dem GDI der Ursprung des Ausschnitts, einem Punkt im Koordinatensystem Geräts angegeben werden ordnet, indem Sie die **SetWindowOrg** Funktion. GDI ordnet alle anderen Punkten durch Befolgung desselben Prozesses erforderlich, um den Fensterursprung, Viewports Ursprung zuzuordnen. Beispielsweise werden alle Punkte in einem Kreis, um den Punkt am ursprünglichen Speicherort Fenster in einem Kreis, um den Punkt am ursprünglichen Speicherort Viewport. Auf ähnliche Weise werden alle Punkte in einer Zeile, die den Fensterursprung werden in einer Zeile, die der Ursprung des Ausschnitts durchlaufen.  
  
##  <a name="setworldtransform"></a>  CDC::SetWorldTransform  
 Legt eine lineare 2D-Transformation zwischen World und Seite freien Speicherplatzes für den angegebenen Gerätekontext. Diese Transformation kann verwendet werden, zu skalieren, drehen, Scheren oder Grafikausgabe übersetzen.  
  
```  
BOOL SetWorldTransform(const XFORM& rXform);
```  
  
### <a name="parameters"></a>Parameter  
 *rXform*  
 Ein Verweis auf ein [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) Struktur, die die Transformationsdaten enthält.  
  
### <a name="return-value"></a>Rückgabewert  
 Bei Erfolg wird einen Wert ungleich NULL zurückgegeben.  
  
 Gibt 0 bei einem Fehler zurück.  
  
 Um erweiterte Fehlerinformationen abzurufen, rufen [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode dient als Wrapper für die Windows-GDI-Funktion [SetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145104).  
  
##  <a name="startdoc"></a>  CDC::StartDoc  
 Informiert den Gerätetreiber, die ein neuer Druckauftrag gestartet wird und dass alle nachfolgenden `StartPage` und `EndPage` Aufrufe gespoolt werden sollten, unter dem gleichen Auftrag erst ein `EndDoc` Aufruf erfolgt.  
  
```  
int StartDoc(LPDOCINFO lpDocInfo);  
int StartDoc(LPCTSTR lpszDocName);
```  
  
### <a name="parameters"></a>Parameter  
 *lpDocInfo*  
 Verweist auf eine [DOCINFO](http://msdn.microsoft.com/library/windows/desktop/dd183574) Struktur, die den Namen des Dokuments und der Name der Ausgabedatei enthält.  
  
 *lpszDocName*  
 Ein Zeiger auf eine Zeichenfolge, die mit dem Namen des Dokuments.  
  
### <a name="return-value"></a>Rückgabewert  
 Wenn die Funktion erfolgreich ausgeführt wird, ist der Rückgabewert größer als 0 (null). Dieser Wert wird der Druckauftrag Bezeichner für das Dokument.  
  
 Wenn die Funktion fehlschlägt, ist der Rückgabewert kleiner oder gleich 0 (null).  
  
### <a name="remarks"></a>Hinweise  
 Dadurch wird sichergestellt, dass Dokumente, die mehr als eine Seite nicht mit anderen Aufträgen vermischt werden werden.  
  
 Für Windows-Versionen 3.1 und höher, diese Funktion ersetzt die **STARTDOC** Drucker Escapezeichen. Mit dieser Funktion wird sichergestellt, dass alle Dokumente, die mehr als eine Seite mit anderen Druckaufträge nicht kombiniert werden.  
  
 `StartDoc` sollte nicht innerhalb von Metadateien verwendet werden.  
  
### <a name="example"></a>Beispiel  
 Dieses Codefragment ruft den Standarddrucker, öffnet einen Druckauftrag und spoolt eine Seite mit "Hello, World!" darauf. Da der Text, der durch diesen Code gedruckt auf den Drucker logische Einheiten skaliert wird nicht, kann der Ausgabetext solche kleinen Buchstaben sein, dass das Ergebnis nicht gelesen werden. Der CDC-Funktionen, wie z. B. Skalierung `SetMapMode`, `SetViewportOrg`, und `SetWindowExt`, können verwendet werden, um die Skalierung zu beheben.  
  
 [!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]  
  
##  <a name="startpage"></a>  CDC::StartPage  
 Rufen Sie diese Memberfunktion um den Druckertreiber zum Empfangen von Daten vorzubereiten.  
  
```  
int StartPage();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Größer als oder gleich 0, wenn die Funktion erfolgreich ist oder einen negativen Wert, wenn ein Fehler aufgetreten.  
  
### <a name="remarks"></a>Hinweise  
 `StartPage` hat Vorrang vor den **NEWFRAME** und **BANDINFO** schützt.  
  
 Eine Übersicht über die Aufrufsequenz drucken, finden Sie unter der [StartDoc](#startdoc) Memberfunktion.  
  
 Deaktiviert das System die `ResetDC` Memberfunktion zwischen den Aufrufen `StartPage` und `EndPage`.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CDC::StartDoc](#startdoc).  
  
##  <a name="stretchblt"></a>  CDC::StretchBlt  
 Kopiert eine Bitmap aus einem Quellrechteck in ein Zielrechteck, wobei das Bitmap gestreckt oder komprimiert wird, falls dies notwendig ist, um zu den Maßen des Zielrechtecks zu passen.  
  
```  
BOOL StretchBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Zielrechtecks an.  
  
 *y*  
 Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Zielrechtecks an.  
  
 *nWidth*  
 Gibt die Breite (in logischen Einheiten) des Zielrechtecks an.  
  
 *nHeight*  
 Gibt die Höhe (in logischen Einheiten) des Zielrechtecks an.  
  
 *pSrcDC*  
 Gibt den Quellgerätekontext an.  
  
 *xSrc*  
 Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quellrechtecks an.  
  
 *ySrc*  
 Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quellrechtecks an.  
  
 *nSrcWidth*  
 Gibt die Breite (in logischen Einheiten) des Quellrechtecks an.  
  
 *nSrcHeight*  
 Gibt die Höhe (in logischen Einheiten) des Quellrechtecks an.  
  
 *dwRop*  
 Gibt das Raster des auszuführenden Vorgangs an. Rastervorgangscode definiert, wie GDI Farben in Ausgabevorgängen kombiniert, an denen ein aktueller Pinsel, eine mögliche Quellbitmap und eine Zielbitmap beteiligt sind. Dieser Parameter kann möglicherweise einen der folgenden Werte aufweisen:  
  
- **BLACKNESS** Ausgabe Schwarz.  
  
- **DSTINVERT** Hierdurch wird die Zielbitmap.  
  
- **MERGECOPY** das Muster und die Quellbitmap mithilfe des booleschen AND-Operators kombiniert.  
  
- **MERGEPAINT** die umgekehrte Quellbitmap mit der Zielbitmap mithilfe des booleschen OR-Operators kombiniert.  
  
- **NOTSRCCOPY** die umgekehrte Quellbitmap in das Ziel kopiert.  
  
- **NOTSRCERASE** kehrt das Ergebnis einer Kombination aus dem Ziel- und Quellbitmaps mithilfe des booleschen OR-Operators.  
  
- **PATCOPY** das Muster in das Zielbitmap kopiert.  
  
- **PATINVERT** das Zielbitmap mithilfe des booleschen XOR-Operators mit dem Muster kombiniert.  
  
- **PATPAINT** die umgekehrte Quellbitmap mithilfe des booleschen OR-Operators mit dem Muster kombiniert. Hierdurch wird das Ziel dieses Vorgangs mithilfe des booleschen OR-Operators mit dem Zielbitmap kombiniert.  
  
- **SRCAND** Pixel der Ziel- und Quellbitmaps mithilfe des booleschen AND-Operators kombiniert.  
  
- **SRCCOPY** die Quellbitmap in das Zielbitmap kopiert.  
  
- **SRCERASE** Hierdurch wird die Zielbitmap und das Ergebnis mit dem Quellbitmap mithilfe des booleschen AND-Operators kombiniert.  
  
- **SRCINVERT** Pixel der Ziel- und Quellbitmaps mithilfe des booleschen XOR-Operators kombiniert.  
  
- **SRCPAINT** Pixel der Ziel- und Quellbitmaps mithilfe des booleschen OR-Operators kombiniert.  
  
- **WHITENESS** Ausgabe weiß.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Bitmap gezeichnet wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Die Funktion verwendet den Streckmodus des Zielgerätkontexts (durch `SetStretchBltMode` festgelegt), um zu bestimmen, wie die Bitmap gestreckt oder komprimiert werden soll.  
  
 Die `StretchBlt` -Funktion verschiebt die Bitmap vom Quellgerät, indem *pSrcDC* zum Zielgerät, dargestellt durch das Gerätekontext Objekt, dessen Memberfunktion aufgerufen wird. Die *xSrc*, *ySrc*, *nSrcWidth*, und *nSrcHeight* Parameter definieren, die linke obere Ecke und die Maße des Quellrechtecks . Die *x*, *y*, *nWidth*, und *nHeight* Parameter geben die linke obere Ecke und die Dimensionen des Zielrechtecks. Durch angegebene rastervorgang *DwRop* definiert, wie die Quellbitmap und die Bits bereits auf dem Zielgerät kombiniert werden.  
  
 Die `StretchBlt` -Funktion erstellt ein Spiegelbild der Bitmap auf, wenn die Anzeichen für die *nSrcWidth* und *nWidth* oder *nSrcHeight* und *nHeight* Parameter unterscheiden sich. Wenn *nSrcWidth* und *nWidth* unterschiedliche Vorzeichen haben, erstellt die Funktion ein Spiegelbild der Bitmap entlang der x-Achse. Wenn *nSrcHeight* und *nHeight* unterschiedliche Vorzeichen haben, erstellt die Funktion ein Spiegelbild der Bitmap entlang der y-Achse.  
  
 Die Funktion `StretchBlt` streckt oder komprimiert die Quellbitmap im Speicher und kopiert dann das Ergebnis in das Ziel. Wenn ein Muster mit dem Ergebnis zusammengeführt werden soll, wird es erst zusammengeführt, wenn die gestreckte Quellbitmap in das Ziel kopiert wurde. Wenn ein Pinsel verwendet wird, ist es der ausgewählte Pinsel im Zielgerätekontext. Die Zielkoordinaten werden gemäß dem Zielgerätekontext transformiert. Die Quellkoordinaten werden gemäß dem Quellgerätekontext transformiert.  
  
 Wenn das Ziel, die Quelle und die Musterbitmaps nicht dasselbe Farbformat haben, konvertiert `StretchBlt` die Quelle und die Musterbitmaps so, dass sie mit den Zielbitmaps übereinstimmen. Die Vordergrund- und Hintergrundfarben des Zielgerätekontexts werden bei der Konvertierung verwendet.  
  
 Wenn `StretchBlt` eine monochrome Bitmap in eine farbige konvertiere muss, legt sie weiße Bits (1) für die Hintergrundfarbe und schwarze Bits (0) für die Vordergrundfarbe fest. Um Farbe in monochrom zu verwandeln, legt sie Pixel, die mit der Hintergrundfarbe übereinstimmen, auf weiß (1) fest und legt alle anderen Pixel auf schwarz (0) fest. Die Vordergrund- und Hintergrundfarben des Gerätekontexts mit Farbe werden verwendet.  
  
 Nicht alle Geräte unterstützen die `StretchBlt`-Funktion. Um zu bestimmen, ob ein Gerät unterstützt `StretchBlt`, Aufrufen der `GetDeviceCaps` Memberfunktion mit der **RASTERCAPS** index, und überprüfen Sie den Rückgabewert für die **RC_STRETCHBLT** Flag.  
  
##  <a name="strokeandfillpath"></a>  CDC::StrokeAndFillPath  
 Schließt alle geöffneten Figuren in einem Pfad, die Gliederung des Pfads mit dem aktuellen Stift Striche und füllt mit der aktuellen Pinsel inneren.  
  
```  
BOOL StrokeAndFillPath();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der Gerätekontext muss einen geschlossenen Pfad enthalten. Die `StrokeAndFillPath` Memberfunktion hat dieselbe Wirkung wie das schließen alle geöffneten Abbildungen in den Pfad und Kontur zuweisen, und füllen den Pfad getrennt, mit dem Unterschied, dass ausgefüllten Bereichs nicht die gestrichelt Region, selbst wenn überschneiden, wird der Stift breit ist.  
  
##  <a name="strokepath"></a>  CDC::StrokePath  
 Rendert den angegebenen Pfad mit der aktuellen Stift.  
  
```  
BOOL StrokePath();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Der Gerätekontext muss einen geschlossenen Pfad enthalten.  
  
##  <a name="tabbedtextout"></a>  CDC::TabbedTextOut  
 Rufen Sie diese Memberfunktion zum Schreiben einer Zeichenfolge Zeichen an der angegebenen Position, erweitern Registerkarten, auf die Werte im Array der Tabstopp Positionen angegeben.  
  
```  
virtual CSize TabbedTextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);

 
CSize TabbedTextOut(
    int x,  
    int y,  
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische X-Koordinate des Anfangspunkts der Zeichenfolge an.  
  
 *y*  
 Gibt die logische y-Koordinate des Anfangspunkts der Zeichenfolge an.  
  
 *lpszString*  
 Verweist auf die Zeichenfolge gezeichnet werden soll. Sie können entweder einen Zeiger übergeben, um ein Array von Zeichen oder ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.  
  
 *nCount*  
 Gibt die Anzahl von Zeichen in der Zeichenfolge an. Wenn *nCount* ist-1, wird die Länge berechnet.  
  
 *nTabPositions*  
 Gibt die Anzahl der Werte im Array der Tabstopp Positionen an.  
  
 *lpnTabStopPositions*  
 Verweist auf ein Array mit der Tabulatortaste Positionen (in logischen Einheiten). Die Tabstopps müssen in aufsteigender Reihenfolge sortiert werden; der kleinste X-Wert muss das erste Element im Array.  
  
 *nTabOrigin*  
 Gibt die X-Koordinate der Startposition aus der Registerkarten (in logischen Einheiten) erweitert werden.  
  
 *str*  
 Ein `CString` Objekt, das die angegebenen Zeichen enthält.  
  
### <a name="return-value"></a>Rückgabewert  
 Die Dimensionen der Zeichenfolge (in logischen Einheiten) als ein `CSize` Objekt.  
  
### <a name="remarks"></a>Hinweise  
 Text wird in der aktuell ausgewählten Schriftart geschrieben. Wenn *nTabPositions* ist 0 und *LpnTabStopPositions* ist **NULL**, Registerkarten auf acht Mal durchschnittliche Zeichenbreite erweitert werden.  
  
 Wenn *nTabPositions* beträgt 1, der beendet von den durch den ersten Wert im angegebenen Abstand getrennt werden Registerkarte die *LpnTabStopPositions* Array. Wenn die *LpnTabStopPositions* Array enthält mehr als einen Wert, ein Tabstopp wird festgelegt, für jeden Wert im Array, bis zur Anzahl von angegebenen *nTabPositions*. Die *nTabOrigin* Parameter kann eine Anwendung zum Aufrufen der `TabbedTextOut` Funktion mehrmals für eine einzelne Zeile. Wenn die Anwendung die Funktion mit mehr als einmal aufgerufen der *nTabOrigin* jedes Mal auf den gleichen Wert festgelegt, die Funktion wird erweitert, alle Registerkarten relativ zur Position gemäß *nTabOrigin*.  
  
 Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert. Wenn eine Anwendung muss die aktuelle Position aktualisieren, wenn sie die Funktion aufruft, kann die Anwendung Aufrufen der [SetTextAlign](#settextalign) Memberfunktion mit *nFlags* festgelegt **TA_UPDATECP**. Wenn dieses Flag festgelegt ist, ignoriert Windows die *x* und *y* -Parameter bei nachfolgenden Aufrufen auf `TabbedTextOut`, verwenden Sie stattdessen die aktuelle Position.  
  
##  <a name="textout"></a>  TextOut  
 Schreibt mithilfe der aktuell ausgewählten Schriftart eine Zeichenfolge an dem angegebenen Speicherort.  
  
```  
virtual BOOL TextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount);

 
BOOL TextOut(
    int x,
    int y,
    const CString& str);
```  
  
### <a name="parameters"></a>Parameter  
 *w*  
 Gibt die logische x-Koordinate des Anfangspunkts des Texts an.  
  
 *y*  
 Gibt die logische y-Koordinate des Anfangspunkts des Texts an.  
  
 *lpszString*  
 Zeigt auf die zu zeichnende Zeichenfolge.  
  
 *nCount*  
 Gibt die Anzahl von Zeichen in der Zeichenfolge an.  
  
 *str*  
 Ein `CString`-Objekt, das die zu zeichnenden Zeichen enthält.  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Zeichenursprünge befindet sich in der oberen linken Ecke der Zeichenzelle. Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert.  
  
 Wenn eine Anwendung muss die aktuelle Position aktualisieren, beim Aufrufen von `TextOut`, kann die Anwendung Aufrufen der `SetTextAlign` Memberfunktion mit *nFlags* festgelegt **TA_UPDATECP**. Wenn dieses Flag festgelegt ist, ignoriert Windows die *x* und *y* -Parameter bei nachfolgenden Aufrufen auf `TextOut`, verwenden Sie stattdessen die aktuelle Position.  
  
### <a name="example"></a>Beispiel  
  Siehe das Beispiel für [CDC:: beginpath](#beginpath).  
  
##  <a name="transparentblt"></a>  CDC::TransparentBlt  
 Rufen Sie diese Memberfunktion zur Übertragung von eines Bit-Datenblocks die Farbe, die einem Rechteck aus Pixeln aus dem angegebenen Quellgerätekontext einen Gerätekontext Ziel entspricht.  
  
```  
BOOL TransparentBlt(
    int xDest,  
    int yDest,
    int nDestWidth,
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    UINT clrTransparent);
```  
  
### <a name="parameters"></a>Parameter  
 *xDest*  
 Gibt die X-Koordinate, in logischen Einheiten, die von der linken oberen Ecke des Zielrechtecks an.  
  
 *yDest*  
 Gibt die y-Koordinate, in logischen Einheiten, die von der linken oberen Ecke des Zielrechtecks an.  
  
 *nDestWidth*  
 Gibt die Breite in logischen Einheiten des Zielrechtecks an.  
  
 *nDestHeight*  
 Gibt die Höhe in logischen Einheiten des Zielrechtecks an.  
  
 *pSrcDC*  
 Ein Zeiger auf dem Quellgerätekontext.  
  
 *xSrc*  
 Gibt die X-Koordinate, in logischen Einheiten des Quellrechtecks an.  
  
 *ySrc*  
 Gibt die y-Koordinate, in logischen Einheiten des Quellrechtecks an.  
  
 *nSrcWidth*  
 Gibt die Breite in logischen Einheiten des Quellrechtecks an.  
  
 *nSrcHeight*  
 Gibt die Höhe in logischen Einheiten des Quellrechtecks an.  
  
 *clrTransparent*  
 Der RGB-Farbe in die Quellbitmap, als transparent behandelt werden sollen.  
  
### <a name="return-value"></a>Rückgabewert  
 **"True"** Wenn erfolgreich; andernfalls **"false"**.  
  
### <a name="remarks"></a>Hinweise  
 `TransparentBlt` Transparenz ermöglicht. d. h. die RGB-Farbe erkennbar *ClrTransparent* wird für die Übertragung transparent gerendert.  
  
 Weitere Informationen finden Sie unter [TransparentBlt](http://msdn.microsoft.com/library/windows/desktop/dd145141) im Windows SDK.  
  
##  <a name="updatecolors"></a>  CDC::UpdateColors  
 Updates des Clientbereichs der Systempalette regelmäßig x Pixel mit den Clientbereich des Gerätekontexts durch Vergleich den aktuellen Farben.  
  
```  
void UpdateColors();
```  
  
### <a name="remarks"></a>Hinweise  
 Ein inaktives Fensters mit einer realisierte logische Palette möglicherweise Aufrufen `UpdateColors` als Alternative zum Neuzeichnen seines Clientbereichs, wenn die Systempalette ändert.  
  
 Weitere Informationen zur Verwendung von Farbpaletten finden Sie unter [UpdateColors](http://msdn.microsoft.com/library/windows/desktop/dd145166) im Windows SDK.  
  
 Die `UpdateColors` Memberfunktion aktualisiert in der Regel einen Clientbereich schneller als durch das Neuzeichnen erhalten des Bereichs. Da die Funktion ausführt, die Farbe Übersetzung basierend auf die Farbe der Pixel, bevor die Systempalette geändert wird, führt jeder Aufruf dieser Funktion jedoch zum Verlust von einigen Farbtreue.  
  
##  <a name="widenpath"></a>  CDC::WidenPath  
 Definiert den aktuellen Pfad als der Bereich, der gezeichnet werden würde, wenn der Pfad mit dem aktuell ausgewählten den Gerätekontext Stift gezeichnet wurden.  
  
```  
BOOL WidenPath();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).  
  
### <a name="remarks"></a>Hinweise  
 Diese Funktion ist nur erfolgreich, wenn der aktuelle Stift eine geometrische Stift erstellt, indem die zweite Version der ist `CreatePen` Memberfunktion ist, oder wenn der Stift, mit der ersten Version von erstellt wird `CreatePen` und verfügt über eine Breite in Geräteeinheiten, der größer als 1. Der Gerätekontext muss einen geschlossenen Pfad enthalten. Bzier Kurven im Pfad werden in Sequenzen vom gerade Linien, die die erweiterten Kurven annähern konvertiert. Daher keine Bzier Kurven bleiben im Pfad nach `WidenPath` aufgerufen wird.  
  
## <a name="see-also"></a>Siehe auch  
 [CObject-Klasse](../../mfc/reference/cobject-class.md)   
 [Hierarchiediagramm](../../mfc/hierarchy-chart.md)   
 [CPaintDC-Klasse](../../mfc/reference/cpaintdc-class.md)   
 [CWindowDC-Klasse](../../mfc/reference/cwindowdc-class.md)   
 [CClientDC-Klasse](../../mfc/reference/cclientdc-class.md)   
 [CMetaFileDC-Klasse](../../mfc/reference/cmetafiledc-class.md)
