---
title: CDC-Klasse
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 830c6d068a5074d0918107ca601c51d198a8a912
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/14/2020
ms.locfileid: "81375716"
---
# <a name="cdc-class"></a>CDC-Klasse

Definiert eine Klasse von Gerätekontextobjekten.

## <a name="syntax"></a>Syntax

```
class CDC : public CObject
```

## <a name="members"></a>Member

### <a name="public-constructors"></a>Öffentliche Konstruktoren

|Name|BESCHREIBUNG|
|----------|-----------------|
|[CDC::CDC](#cdc)|Erstellt ein `CDC`-Objekt.|

### <a name="public-methods"></a>Öffentliche Methoden

|Name|BESCHREIBUNG|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Beendet den aktuellen Druckauftrag und löscht alles, was die Anwendung seit `StartDoc` dem letzten Aufruf der Memberfunktion auf das Gerät geschrieben hat.|
|[CDC::AbortPath](#abortpath)|Schließt und verwirft alle Pfade im Gerätekontext.|
|[CDC::AddMetaFileKommentar](#addmetafilecomment)|Kopiert den Kommentar aus einem Puffer in eine angegebene Metadatei im erweiterten Format.|
|[CDC::AlphaBlend](#alphablend)|Zeigt Bitmaps mit transparenten oder halbtransparenten Pixeln an.|
|[CDC::AngleArc](#anglearc)|Zeichnet ein Liniensegment und einen Bogen und verschiebt die aktuelle Position an den Endpunkt des Bogens.|
|[CDC::Arc](#arc)|Zeichnet einen elliptischen Bogen.|
|[CDC::ArcTo](#arcto)|Zeichnet einen elliptischen Bogen. Diese Funktion ähnelt `Arc`, außer dass die aktuelle Position aktualisiert wird.|
|[CDC::Anfügen](#attach)|Fügt diesem `CDC` Objekt einen Windows-Gerätekontext an.|
|[CDC::BeginPath](#beginpath)|Öffnet eine Pfadhalterung im Gerätekontext.|
|[CDC::BitBlt](#bitblt)|Kopiert eine Bitmap aus einem angegebenen Gerätekontext.|
|[CDC::Chord](#chord)|Zeichnet einen Akkord (eine geschlossene Figur, die durch den Schnittpunkt einer Ellipse und eines Liniensegments begrenzt ist).|
|[CDC::CloseFigure](#closefigure)|Schließt eine offene Figur in einem Pfad.|
|[CDC::CreateCompatibleDC](#createcompatibledc)|Erstellt einen Speichergerätekontext, der mit einem anderen Gerätekontext kompatibel ist. Sie können es verwenden, um Bilder im Speicher vorzubereiten.|
|[CDC::CreateDC](#createdc)|Erstellt einen Gerätekontext für ein bestimmtes Gerät.|
|[CDC::CreateIC](#createic)|Erstellt einen Informationskontext für ein bestimmtes Gerät. Dies bietet eine schnelle Möglichkeit, Informationen über das Gerät zu erhalten, ohne einen Gerätekontext zu erstellen.|
|[CDC::DeleteDC](#deletedc)|Löscht den Windows-Gerätekontext, `CDC` der diesem Objekt zugeordnet ist.|
|[CDC::DeleteTempMap](#deletetempmap)|Wird vom `CWinApp` Leerlaufhandler aufgerufen, `CDC` um alle `FromHandle`temporären Objekte zu löschen, die von erstellt wurden. Detachiert auch den Gerätekontext.|
|[CDC::Detach](#detach)|Trennt den Windows-Gerätekontext `CDC` von diesem Objekt.|
|[CDC::DPtoHIMETRIC](#dptohimetric)|Konvertiert Geräteeinheiten in HIMETRIC-Einheiten.|
|[CDC::DPtoLP](#dptolp)|Konvertiert Geräteeinheiten in logische Einheiten.|
|[CDC::Draw3dRect](#draw3drect)|Zeichnet ein dreidimensionales Rechteck.|
|[CDC::DrawDragRect](#drawdragrect)|Löscht und zeichnet ein Rechteck neu, während es gezogen wird.|
|[CDC::DrawEdge](#drawedge)|Zeichnet die Ränder eines Rechtecks.|
|[CDC::DrawEscape](#drawescape)|Greift auf die Zeichnungsfunktionen einer Videoanzeige zu, die nicht direkt über die Grafikgeräteschnittstelle (GDI) verfügbar sind.|
|[CDC::DrawFocusRect](#drawfocusrect)|Zeichnet ein Rechteck in dem Stil, der verwendet wird, um den Fokus anzuzeigen.|
|[CDC::DrawFrameControl](#drawframecontrol)|Zeichnen Sie ein Rahmensteuerelement.|
|[CDC::DrawIcon](#drawicon)|Zeichnet ein Symbol.|
|[CDC::DrawState](#drawstate)|Zeigt ein Bild an und wendet einen visuellen Effekt an, um einen Zustand anzuzeigen.|
|[CDC::DrawText](#drawtext)|Zeichnet formatierten Text im angegebenen Rechteck.|
|[CDC::DrawTextEx](#drawtextex)|Zeichnet formatierten Text im angegebenen Rechteck mit zusätzlichen Formaten.|
|[CDC::Ellipse](#ellipse)|Zeichnet eine Ellipse.|
|[CDC::EndDoc](#enddoc)|Beendet einen Druckauftrag, `StartDoc` der von der Memberfunktion gestartet wurde.|
|[CDC::EndPage](#endpage)|Informiert den Gerätetreiber, dass eine Seite endet.|
|[CDC::EndPath](#endpath)|Schließt eine Pfadhalterung und wählt den von der Klammer definierten Pfad in den Gerätekontext aus.|
|[CDC::EnumObjects](#enumobjects)|Zählt die Stifte und Pinsel auf, die in einem Gerätekontext verfügbar sind.|
|[CDC::Flucht](#escape)|Ermöglicht Anwendungen den Zugriff auf Einrichtungen, die nicht direkt von einem bestimmten Gerät über GDI verfügbar sind. Ermöglicht auch den Zugriff auf Windows-Escape-Funktionen. Escape-Anrufe, die von einer Anwendung getätigt werden, werden übersetzt und an den Gerätetreiber gesendet.|
|[CDC::ExcludeClipRect](#excludecliprect)|Erstellt einen neuen Zuschneidebereich, der aus dem vorhandenen Zuschneidebereich abzüglich des angegebenen Rechtecks besteht.|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Verhindert das Zeichnen innerhalb ungültiger Bereiche eines Fensters, indem ein aktualisierter Bereich im Fenster aus einem Zuschneidebereich ausgeschlossen wird.|
|[CDC::ExtFloodFill](#extfloodfill)|Füllt einen Bereich mit dem aktuellen Pinsel. Bietet mehr Flexibilität als die [CDC::FloodFill-Memberfunktion.](#floodfill)|
|[CDC::ExtTextOut](#exttextout)|Schreibt eine Zeichenfolge innerhalb eines rechteckigen Bereichs mit der aktuell ausgewählten Schriftart.|
|[CDC::FillPath](#fillpath)|Schließt alle offenen Figuren im aktuellen Pfad und füllt das Innere des Pfads mit dem aktuellen Pinsel- und Polygonfüllmodus aus.|
|[CDC::FillRect](#fillrect)|Füllt ein bestimmtes Rechteck mit einem bestimmten Pinsel.|
|[CDC::FillRgn](#fillrgn)|Füllt einen bestimmten Bereich mit dem angegebenen Pinsel.|
|[CDC::FillSolidRect](#fillsolidrect)|Füllt ein Rechteck mit einer Volltonfarbe.|
|[CDC::FlattenPath](#flattenpath)|Transformiert alle Kurven im ausgewählten Pfad in den aktuellen Gerätekontext und verwandelt jede Kurve in eine Folge von Linien.|
|[CDC::FloodFill](#floodfill)|Füllt einen Bereich mit dem aktuellen Pinsel.|
|[CDC::FrameRect](#framerect)|Zeichnet einen Rahmen um ein Rechteck.|
|[CDC::FrameRgn](#framergn)|Zeichnet einen Rahmen um einen bestimmten Bereich mit einem Pinsel.|
|[CDC::FromHandle](#fromhandle)|Gibt einen Zeiger `CDC` auf ein Objekt zurück, wenn einem Gerätekontext ein Handle übergeben wird. Wenn ein `CDC`-Objekt nicht an das Handle angefügt ist, wird ein temporäres `CDC`-Objekt erstellt und angefügt.|
|[CDC::GetArcDirection](#getarcdirection)|Gibt die aktuelle Bogenrichtung für den Gerätekontext zurück.|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Ruft die Einstellung für den aktuellen Seiten-Verhältnis-Filter ab.|
|[CDC::GetBkColor](#getbkcolor)|Ruft die aktuelle Hintergrundfarbe ab.|
|[CDC::GetBkMode](#getbkmode)|Ruft den Hintergrundmodus ab.|
|[CDC::GetBoundsRect](#getboundsrect)|Gibt das aktuelle akkumulierte Umgrenzungsrechteck für den angegebenen Gerätekontext zurück.|
|[CDC::GetBrushOrg](#getbrushorg)|Ruft den Ursprung des aktuellen Pinsels ab.|
|[CDC::GetCharABCBreiten](#getcharabcwidths)|Ruft die Breiten in logischen Einheiten von aufeinander folgenden Zeichen in einem bestimmten Bereich von der aktuellen Schriftart ab.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Ruft die Breiten in logischen Einheiten von aufeinander folgenden Glyphenindizes in einem angegebenen Bereich von der aktuellen TrueType-Schriftart ab.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Ruft verschiedene Typen von Informationen zu einer Zeichenfolge ab.|
|[CDC::GetCharWidth](#getcharwidth)|Ruft die Bruchbreiten aufeinander folgender Zeichen in einem bestimmten Bereich von der aktuellen Schriftart ab.|
|[CDC::GetCharWidthI](#getcharwidthi)|Ruft die Breiten in logischen Koordinaten von aufeinander folgenden Glyphenindizes in einem angegebenen Bereich von der aktuellen Schriftart ab.|
|[CDC::GetClipBox](#getclipbox)|Ruft die Bemaßungen des engsten umgrenzenden Rechtecks um die aktuelle Zuschneidegrenze ab.|
|[CDC::GetColorAdjustment](#getcoloradjustment)|Ruft die Farbanpassungswerte für den Gerätekontext ab.|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Gibt einen Zeiger auf `CBitmap` das aktuell ausgewählte Objekt zurück.|
|[CDC::GetCurrentBrush](#getcurrentbrush)|Gibt einen Zeiger auf `CBrush` das aktuell ausgewählte Objekt zurück.|
|[CDC::GetCurrentFont](#getcurrentfont)|Gibt einen Zeiger auf `CFont` das aktuell ausgewählte Objekt zurück.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Gibt einen Zeiger auf `CPalette` das aktuell ausgewählte Objekt zurück.|
|[CDC::GetCurrentPen](#getcurrentpen)|Gibt einen Zeiger auf `CPen` das aktuell ausgewählte Objekt zurück.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Ruft die aktuelle Position des Stifts ab (in logischen Koordinaten).|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Ruft die aktuelle Pinselfarbe ab.|
|[CDC::GetDCPenColor](#getdcpencolor)|Ruft die aktuelle Stiftfarbe ab.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Ruft eine bestimmte Art von gerätespezifischen Informationen über die Funktionen eines bestimmten Anzeigegeräts ab.|
|[CDC::GetFontData](#getfontdata)|Ruft Schriftartmetrikinformationen aus einer skalierbaren Schriftartdatei ab. Die abzurufenden Informationen werden identifiziert, indem ein Offset in der Schriftartdatei und die Länge der zurückzugebenden Informationen angegeben werden.|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Gibt Informationen zur aktuell ausgewählten Schriftart für den angegebenen Anzeigekontext zurück.|
|[CDC::GetGlyphOutline](#getglyphoutline)|Ruft die Gliederungskurve oder Bitmap für ein Gliederungszeichen in der aktuellen Schriftart ab.|
|[CDC::GetGraphicsMode](#getgraphicsmode)|Ruft den aktuellen Grafikmodus für den angegebenen Gerätekontext ab.|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Ruft einen Halbtonpinsel ab.|
|[CDC::GetKerningPairs](#getkerningpairs)|Ruft die Zeichenkerning-Paare für die Schriftart ab, die derzeit im angegebenen Gerätekontext ausgewählt ist.|
|[CDC::GetLayout](#getlayout)|Ruft das Layout eines Gerätekontexts (DC) ab. Das Layout kann entweder von links nach rechts (Standard) oder von rechts nach links (gespiegelt) sein.|
|[CDC::GetMapMode](#getmapmode)|Ruft den aktuellen Zuordnungsmodus ab.|
|[CDC::GetMiterLimit](#getmiterlimit)|Gibt das Gehrungslimit für den Gerätekontext zurück.|
|[CDC::GetNearestColor](#getnearestcolor)|Ruft die nächste logische Farbe zu einer angegebenen logischen Farbe ab, die das angegebene Gerät darstellen kann.|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Ruft Schriftartmetrikinformationen für TrueType-Schriftarten ab.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Ruft die Breiten einzelner Zeichen in einer aufeinanderfolgenden Gruppe von Zeichen aus der aktuellen Schriftart mithilfe des Ausgabegerätekontexts ab.|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Berechnet die Breite und Höhe einer Zeichenfolge im Ausgabegerätekontext.|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Berechnet die Breite und Höhe einer Textzeile im Ausgabegerätekontext mithilfe der aktuellen Schriftart, um die Bemaßungen zu bestimmen.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Ruft die Metriken für die aktuelle Schriftart aus dem Ausgabegerätekontext ab.|
|[CDC::GetPath](#getpath)|Ruft die Koordinaten ab, die die Endpunkte von Linien und die Kontrollpunkte von Kurven definieren, die in dem Pfad gefunden werden, der im Gerätekontext ausgewählt ist.|
|[CDC::GetPixel](#getpixel)|Ruft den RGB-Farbwert des Pixels am angegebenen Punkt ab.|
|[CDC::GetPolyFillMode](#getpolyfillmode)|Ruft den aktuellen Polygonfüllmodus ab.|
|[CDC::GetROP2](#getrop2)|Ruft den aktuellen Zeichnungsmodus ab.|
|[CDC::GetSafeHdc](#getsafehdc)|Gibt [CDC::m_hDC](#m_hdc)zurück, den Kontext des Ausgabegeräts.|
|[CDC::GetStretchBltMode](#getstretchbltmode)|Ruft den aktuellen Bitmap-Stretching-Modus ab.|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Berechnet die Breite und Höhe einer Zeichenfolge im Attributgerätekontext.|
|[CDC::GetTextAlign](#gettextalign)|Ruft die Textausrichtungsflags ab.|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Ruft die aktuelle Einstellung für den Abstand zwischen den Zeichen ab.|
|[CDC::GetTextColor](#gettextcolor)|Ruft die aktuelle Textfarbe ab.|
|[CDC::GetTextExtent](#gettextextent)|Berechnet die Breite und Höhe einer Textzeile im Attributgerätekontext mithilfe der aktuellen Schriftart, um die Bemaßungen zu bestimmen.|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Ruft die Anzahl der Zeichen in einer angegebenen Zeichenfolge ab, die in einen angegebenen Bereich passt, und füllt ein Array mit der Textausdehnung für jedes dieser Zeichen.|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Ruft die Breite und Höhe des angegebenen Arrays von Glyphenindizes ab.|
|[CDC::GetTextFace](#gettextface)|Kopiert den Schriftnamen der aktuellen Schriftart in einen Puffer als null-terminierte Zeichenfolge.|
|[CDC::GetTextMetrics](#gettextmetrics)|Ruft die Metriken für die aktuelle Schriftart aus dem Attributgerätekontext ab.|
|[CDC::GetViewportExt](#getviewportext)|Ruft die x- und y-Ausdehnungen des Ansichtsfensters ab.|
|[CDC::GetViewportOrg](#getviewportorg)|Ruft die x- und y-Koordinaten des Ansichtsfenster-Ursprungs ab.|
|[CDC::GetWindow](#getwindow)|Gibt das Fenster zurück, das dem Kontext des Anzeigegeräts zugeordnet ist.|
|[CDC::GetWindowExt](#getwindowext)|Ruft die x- und y-Ausdehnungen des zugeordneten Fensters ab.|
|[CDC::GetWindowOrg](#getwindoworg)|Ruft die x- und y-Koordinaten des Ursprungs des zugeordneten Fensters ab.|
|[CDC::GetWorldTransform](#getworldtransform)|Ruft den aktuellen Weltraum zur Seitenraumtransformation ab.|
|[CDC::GradientFill](#gradientfill)|Füllt Rechteck- und Dreiecksstrukturen mit einer gratierenden Farbe.|
|[CDC::GrayString](#graystring)|Zeichnet gedimmten (grau)en Text an der angegebenen Position.|
|[CDC::HIMETRICtoDP](#himetrictodp)|Konvertiert HIMETRIC-Einheiten in Geräteeinheiten.|
|[CDC::HIMETRICtoLP](#himetrictolp)|Konvertiert HIMETRIC-Einheiten in logische Einheiten.|
|[CDC::IntersectClipRect](#intersectcliprect)|Erstellt einen neuen Zuschneidebereich, indem der Schnittpunkt des aktuellen Bereichs und eines Rechtecks gebildet wird.|
|[CDC::InvertRect](#invertrect)|Kehrt den Inhalt eines Rechtecks um.|
|[CDC::InvertRgn](#invertrgn)|Kehrt die Farben in einer Region um.|
|[CDC::IsPrinting](#isprinting)|Bestimmt, ob der Gerätekontext zum Drucken verwendet wird.|
|[CDC::LineTo](#lineto)|Zeichnet eine Linie von der aktuellen Position bis zu einem Punkt, aber nicht einschließlich.|
|[CDC::LPtoDP](#lptodp)|Konvertiert logische Einheiten in Geräteeinheiten.|
|[CDC::LPtoHIMETRIC](#lptohimetric)|Konvertiert logische Einheiten in HIMETRIC-Einheiten.|
|[CDC::MaskBlt](#maskblt)|Kombiniert die Farbdaten für die Quell- und Zielbitmaps mithilfe des angegebenen Masken- und Rastervorgangs.|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Ändert die Welttransformation für einen Gerätekontext mithilfe des angegebenen Modus.|
|[CDC::MoveTo](#moveto)|Verschiebt die aktuelle Position.|
|[CDC::OffsetClipRgn](#offsetcliprgn)|Verschiebt den Clipping-Bereich des angegebenen Geräts.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Ändert den Ursprung des Ansichtsfensters relativ zu den Koordinaten des aktuellen Ansichtsfensterursprungs.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Ändert den Fensterursprung relativ zu den Koordinaten des aktuellen Fensterursprungs.|
|[CDC::PaintRgn](#paintrgn)|Füllt einen Bereich mit dem ausgewählten Pinsel.|
|[CDC::PatBlt](#patblt)|Erstellt ein Bitmuster.|
|[CDC::Pie](#pie)|Zeichnet einen tortenförmigen Keil.|
|[CDC::PlayMetaFile](#playmetafile)|Spielt den Inhalt der angegebenen Metadatei auf dem angegebenen Gerät ab. Die erweiterte Version `PlayMetaFile` von zeigt das Bild an, das in der angegebenen Metadatei im erweiterten Format gespeichert ist. Die Metadatei kann bemalungsbehaftet gespielt werden.|
|[CDC::PlgBlt](#plgblt)|Führt eine Bitblockübertragung der Bits von Farbdaten vom angegebenen Rechteck im Quellgerätekontext auf das angegebene Parallelogramm im angegebenen Gerätekontext durch.|
|[CDC::PolyBezier](#polybezier)|Zeichnet eine oder mehrere Bzier-Splines. Die aktuelle Position wird weder verwendet noch aktualisiert.|
|[CDC::PolyBezierTo](#polybezierto)|Zeichnet eine oder mehrere Bzier-Splines und verschiebt die aktuelle Position an den Endpunkt des letzten Bzier-Splines.|
|[CDC::PolyDraw](#polydraw)|Zeichnet eine Reihe von Liniensegmenten und Bzier-Splines. Diese Funktion aktualisiert die aktuelle Position.|
|[CDC::Polygon](#polygon)|Zeichnet ein Polygon, das aus zwei oder mehr Punkten (Scheitelpunkten) besteht, die durch Linien verbunden sind.|
|[CDC::Polyline](#polyline)|Zeichnet eine Reihe von Liniensegmenten, die die angegebenen Punkte verbinden.|
|[CDC::PolylineTo](#polylineto)|Zeichnet eine oder mehrere gerade Linien und verschiebt die aktuelle Position an den Endpunkt der letzten Zeile.|
|[CDC::PolyPolygon](#polypolygon)|Erstellt zwei oder mehr Polygone, die mit dem aktuellen Polygonfüllmodus gefüllt werden. Die Polygone können getrennt sein oder sich überlappen.|
|[CDC::PolyPolyline](#polypolyline)|Zeichnet mehrere Reihen verbundener Liniensegmente. Die aktuelle Position wird von dieser Funktion weder verwendet noch aktualisiert.|
|[CDC::PtVisible](#ptvisible)|Gibt an, ob sich der angegebene Punkt innerhalb des Zuschneidebereichs befindet.|
|[CDC::RealizePalette](#realizepalette)|Ordnet Paletteneinträge in der aktuellen logischen Palette der Systempalette zu.|
|[CDC::Rechteck](#rectangle)|Zeichnet ein Rechteck mit dem aktuellen Stift und füllt es mit dem aktuellen Pinsel aus.|
|[CDC::RectVisible](#rectvisible)|Bestimmt, ob ein Teil des angegebenen Rechtecks innerhalb des Zuschneidebereichs liegt.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Releases `m_hAttribDC`, der Attributgerätekontext.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Releases `m_hDC`, der Kontext des Ausgabegeräts.|
|[CDC::ResetDC](#resetdc)|Aktualisiert `m_hAttribDC` den Gerätekontext.|
|[CDC::RestoreDC](#restoredc)|Stellt den Gerätekontext in einem `SaveDC`vorherigen Zustand wieder her, der mit gespeichert wurde.|
|[CDC::RoundRect](#roundrect)|Zeichnet ein Rechteck mit abgerundeten Ecken mit dem aktuellen Stift und wird mit dem aktuellen Pinsel gefüllt.|
|[CDC::SaveDC](#savedc)|Speichert den aktuellen Status des Gerätekontexts.|
|[CDC::ScaleViewportExt](#scaleviewportext)|Ändert die Ansichtsfensterausdehnung relativ zu den aktuellen Werten.|
|[CDC::ScaleWindowExt](#scalewindowext)|Ändert die Fensterausdehnungen relativ zu den aktuellen Werten.|
|[CDC::ScrollDC](#scrolldc)|Scrollt ein Rechteck aus Bits horizontal und vertikal.|
|[CDC::SelectClipPath](#selectclippath)|Wählt den aktuellen Pfad als Zuschneidebereich für den Gerätekontext aus und kombiniert den neuen Bereich mit einem vorhandenen Clipping-Bereich mithilfe des angegebenen Modus.|
|[CDC::SelectClipRgn](#selectcliprgn)|Kombiniert den angegebenen Bereich mit dem aktuellen Clipping-Bereich mithilfe des angegebenen Modus.|
|[CDC::SelectObject](#selectobject)|Wählt ein GDI-Zeichnungsobjekt wie einen Stift aus.|
|[CDC::SelectPalette](#selectpalette)|Wählt die logische Palette aus.|
|[CDC::SelectStockObject](#selectstockobject)|Wählt einen der vordefinierten Lagerstifte, Pinsel oder Schriftarten aus, die von Windows bereitgestellt werden.|
|[CDC::SetAbortProc](#setabortproc)|Legt eine vom Programmierer bereitgestellte Rückruffunktion fest, die Windows aufruft, wenn ein Druckauftrag abgebrochen werden muss.|
|[CDC::SetArcDirection](#setarcdirection)|Legt die Zeichnungsrichtung fest, die für Bogen- und Rechteckfunktionen verwendet werden soll.|
|[CDC::SetAttribDC](#setattribdc)|Legt `m_hAttribDC`fest, der Attributgerätekontext.|
|[CDC::SetBkColor](#setbkcolor)|Legt die aktuelle Hintergrundfarbe fest.|
|[CDC::SetBkMode](#setbkmode)|Legt den Hintergrundmodus fest.|
|[CDC::SetBoundsRect](#setboundsrect)|Steuert die Akkumulation von Bounding-Rechteck-Informationen für den angegebenen Gerätekontext.|
|[CDC::SetBrushOrg](#setbrushorg)|Gibt den Ursprung für den nächsten Pinsel an, der in einem Gerätekontext ausgewählt wurde.|
|[CDC::SetColorAdjustment](#setcoloradjustment)|Legt die Farbanpassungswerte für den Gerätekontext mithilfe der angegebenen Werte fest.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Legt die aktuelle Pinselfarbe fest.|
|[CDC::SetDCPenColor](#setdcpencolor)|Legt die aktuelle Stiftfarbe fest.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Legt den aktuellen Grafikmodus für den angegebenen Gerätekontext fest.|
|[CDC::SetLayout](#setlayout)|Ändert das Layout eines Gerätekontexts (DC).|
|[CDC::SetMapMode](#setmapmode)|Legt den aktuellen Zuordnungsmodus fest.|
|[CDC::SetMapperFlags](#setmapperflags)|Ändert den Algorithmus, den der Schriftart-Mapper verwendet, wenn er logische Schriftarten physischen Schriftarten zuordnet.|
|[CDC::SetMiterLimit](#setmiterlimit)|Legt den Grenzwert für die Länge der Verknüpfungen für den Gerätekontext fest.|
|[CDC::SetOutputDC](#setoutputdc)|Legt `m_hDC`fest, der Kontext des Ausgabegeräts.|
|[CDC::SetPixel](#setpixel)|Legt das Pixel am angegebenen Punkt auf die nächste Annäherung der angegebenen Farbe fest.|
|[CDC::SetPixelV](#setpixelv)|Legt das Pixel an den angegebenen Koordinaten auf die nächste Annäherung der angegebenen Farbe fest. `SetPixelV`ist schneller, als `SetPixel` weil es nicht den Farbwert des tatsächlich gemalten Punktes zurückgeben muss.|
|[CDC::SetPolyFillMode](#setpolyfillmode)|Legt den Polygonfüllmodus fest.|
|[CDC::SetROP2](#setrop2)|Legt den aktuellen Zeichnungsmodus fest.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Legt den Bitmap-Stretching-Modus fest.|
|[CDC::SetTextAlign](#settextalign)|Legt die Textausrichtungsflags fest.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Legt den Abstand zwischen den Zeichen fest.|
|[CDC::SetTextColor](#settextcolor)|Legt die Textfarbe fest.|
|[CDC::SetTextJustification](#settextjustification)|Fügt den Unterbrechungszeichen in einer Zeichenfolge Platz hinzu.|
|[CDC::SetViewportExt](#setviewportext)|Legt die x- und y-Ausdehnungen des Ansichtsfensters fest.|
|[CDC::SetViewportOrg](#setviewportorg)|Legt den Ursprung des Ansichtsfensters fest.|
|[CDC::SetWindowExt](#setwindowext)|Legt die x- und y-Ausdehnungen des zugeordneten Fensters fest.|
|[CDC::SetWindowOrg](#setwindoworg)|Legt den Fensterursprung des Gerätekontexts fest.|
|[CDC::SetWorldTransform](#setworldtransform)|Legt den aktuellen Weltraum auf Seitenraumtransformation fest.|
|[CDC::StartDoc](#startdoc)|Informiert den Gerätetreiber, dass ein neuer Druckauftrag gestartet wird.|
|[CDC::StartPage](#startpage)|Informiert den Gerätetreiber, dass eine neue Seite gestartet wird.|
|[CDC::StretchBlt](#stretchblt)|Verschiebt eine Bitmap von einem Quellrechteck und Gerät in ein Zielrechteck, indem die Bitmap bei Bedarf gestreckt oder komprimiert wird, um die Bemaßungen des Zielrechtecks anzupassen.|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Schließt alle offenen Figuren in einem Pfad, schlägt die Umrisse des Pfads mit dem aktuellen Stift und füllt sein Inneres mit dem aktuellen Pinsel.|
|[CDC::StrokePath](#strokepath)|Rendert den angegebenen Pfad mithilfe des aktuellen Stifts.|
|[CDC::TabbedTextOut](#tabbedtextout)|Schreibt eine Zeichenfolge an einer angegebenen Position und erweitert Registerkarten auf die Werte, die in einem Array von Tabstopppositionen angegeben sind.|
|[CDC::TextOut](#textout)|Schreibt eine Zeichenfolge an einem angegebenen Speicherort mit der aktuell ausgewählten Schriftart.|
|[CDC::TransparentBlt](#transparentblt)|Überträgt einen Bitblock mit Farbdaten aus dem angegebenen Quellgerätekontext in einen Zielgerätekontext, wodurch eine angegebene Farbe in der Übertragung transparent wird.|
|[CDC::UpdateColors](#updatecolors)|Aktualisiert den Clientbereich des Gerätekontexts, indem die aktuellen Farben im Clientbereich pixelweise mit der Systempalette abgleichen.|
|[CDC::WidenPath](#widenpath)|Definiert den aktuellen Pfad als den Bereich, der gezeichnet würde, wenn der Pfad mit dem derzeit im Gerätekontext ausgewählten Stift gestrichelt würde.|

### <a name="public-operators"></a>Öffentliche Operatoren

|Name|BESCHREIBUNG|
|----------|-----------------|
|[CDC::operator HDC](#operator_hdc)|Ruft das Handle des Gerätekontexts ab.|

### <a name="public-data-members"></a>Öffentliche Datenmember

|Name|BESCHREIBUNG|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|Der Attribut-Geräte-Kontext, `CDC` der von diesem Objekt verwendet wird.|
|[CDC::m_hDC](#m_hdc)|Der Ausgabe-Geräte-Kontext, `CDC` der von diesem Objekt verwendet wird.|

## <a name="remarks"></a>Bemerkungen

Das `CDC` Objekt stellt Memberfunktionen für die Arbeit mit einem Gerätekontext, z. B. einem Display oder Drucker, sowie Member für die Arbeit mit einem Anzeigekontext bereit, der dem Clientbereich eines Fensters zugeordnet ist.

Zeichnen Sie alle Memberfunktionen `CDC` eines Objekts. Die Klasse bietet Memberfunktionen für Gerätekontextoperationen, das Arbeiten mit Zeichenwerkzeugen, die Objektauswahl der Typsicheren Grafikgeräteschnittstelle (GDI) und das Arbeiten mit Farben und Paletten. Es bietet auch Elementfunktionen zum Abrufen und Festlegen von Zeichnungsattributen, Mapping, Arbeiten mit dem Ansichtsfenster, Arbeiten mit der Fensterausdehnung, Konvertieren von Koordinaten, Arbeiten mit Regionen, Zuschneiden, Zeichnen von Linien und Zeichnen einfacher Formen, Ellipsen und Polygone. Memberfunktionen werden auch zum Zeichnen von Text, Arbeiten mit Schriftarten, verwenden von Druckerescapen, Scrollen und Wiedergeben von Metadateien bereitgestellt.

Um ein `CDC` Objekt zu verwenden, erstellen Sie es, und rufen Sie dann seine Memberfunktionen auf, die Parallelfunktionen von Windows-Funktionen, die Gerätekontexte verwenden, verwenden.

> [!NOTE]
> Unter Windows 95/98 sind alle Bildschirmkoordinaten auf 16 Bit beschränkt. Daher muss eine an `CDC` eine Memberfunktion übergebene **int** im Bereich -32768 bis 32767 liegen.

Für bestimmte Anwendungen stellt die Microsoft Foundation-Klassenbibliothek mehrere Klassen bereit, die von `CDC` abgeleitet wurden. `CPaintDC`kapselt Aufrufe von `BeginPaint` und `EndPaint`. `CClientDC`verwaltet einen Anzeigekontext, der dem Clientbereich eines Fensters zugeordnet ist. `CWindowDC`verwaltet einen Anzeigekontext, der einem gesamten Fenster zugeordnet ist, einschließlich seines Rahmens und der Steuerelemente. `CMetaFileDC`ordnet einen Gerätekontext einer Metadatei zu.

`CDC`bietet zwei Memberfunktionen, [GetLayout](#getlayout) und [SetLayout](#setlayout), zum Umkehren des Layouts eines Gerätekontexts, der sein Layout nicht aus einem Fenster erbt. Eine solche Rechts-nach-links-Orientierung ist für Anwendungen erforderlich, die für Kulturen geschrieben wurden, z. B. Arabisch oder Hebräisch, bei denen das Zeichenlayout nicht der europäische Standard ist.

`CDC`enthält zwei Gerätekontexte, [m_hDC](#m_hdc) und [m_hAttribDC](#m_hattribdc), `CDC` die bei der Erstellung eines Objekts auf dasselbe Gerät verweisen. `CDC`leitet alle Ausgabe-GDI-Aufrufe an `m_hDC` und `m_hAttribDC`die meisten Attribut-GDI-Aufrufe an . (Ein Beispiel für einen `GetTextColor`Attributaufruf ist , während `SetTextColor` es sich um einen Ausgabeaufruf handelt.)

Beispielsweise verwendet das Framework diese beiden Gerätekontexte, um ein `CMetaFileDC` Objekt zu implementieren, das ausgaben an eine Metadatei sendet, während Attribute von einem physischen Gerät gelesen werden. Die Druckvorschau wird im Rahmen auf ähnliche Weise implementiert. Sie können die beiden Gerätekontexte auch in Ihrem anwendungsspezifischen Code auf ähnliche Weise verwenden.

Es kann vorkommen, dass Sie Textmetrikinformationen aus dem `m_hDC` und `m_hAttribDC` dem Gerätekontext benötigen. Die folgenden Funktionspaare bieten diese Funktion:

|Verwendet m_hAttribDC|Verwendet m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Weitere Informationen `CDC`zu finden Sie unter [Gerätekontexte](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Vererbungshierarchie

[Cobject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Anforderungen

**Header:** afxwin.h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>CDC::AbortDoc

Beendet den aktuellen Druckauftrag und löscht alles, was die Anwendung seit dem letzten Aufruf der [StartDoc-Memberfunktion](#startdoc) auf das Gerät geschrieben hat.

```
int AbortDoc();
```

### <a name="return-value"></a>Rückgabewert

Ein Wert größer oder gleich 0, wenn erfolgreich, oder ein negativer Wert, wenn ein Fehler aufgetreten ist. Die folgende Liste zeigt allgemeine Fehlerwerte und deren Bedeutung:

- SP_ERROR Allgemeiner Fehler.

- SP_OUTOFDISK Es ist derzeit nicht genügend Speicherplatz für das Spooling verfügbar, und es wird kein Speicherplatz mehr verfügbar.

- SP_OUTOFMEMORY Nicht genügend Arbeitsspeicher steht zum Spoolen zur Verfügung.

- SP_USERABORT Benutzer hat den Auftrag über den Druck-Manager beendet.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion ersetzt den ABORTDOC-Drucker-Escape.

`AbortDoc`sollte verwendet werden, um Folgendes zu beenden:

- Druckvorgänge, die keine Abbruchfunktion mit [SetAbortProc](#setabortproc)angeben.

- Druckvorgänge, die noch nicht ihren ersten NEWFRAME- oder NEXTBAND-Escape-Aufruf erreicht haben.

Wenn bei einer Anwendung ein Druckfehler oder ein abgebrochener Druckvorgang auftritt, darf `AbortDoc` sie nicht `CDC`versuchen, den Vorgang mithilfe der [EndDoc-](#enddoc) oder Memberfunktionen der Klasse zu beenden. GDI beendet den Vorgang automatisch, bevor der Fehlerwert zurückgegeben wird.

Wenn die Anwendung ein Dialogfeld anzeigt, in dem der `AbortDoc` Benutzer den Druckvorgang abbrechen kann, muss sie aufrufen, bevor das Dialogfeld zerstört wird.

Wenn Print Manager zum Starten des `AbortDoc` Druckauftrags verwendet wurde, löscht der Aufruf den gesamten Spoolauftrag – der Drucker erhält nichts. Wenn Der Druck-Manager nicht zum Starten des Druckauftrags verwendet wurde, wurden die Daten möglicherweise an den Drucker gesendet, bevor `AbortDoc` sie aufgerufen wurden. In diesem Fall hätte der Druckertreiber den Drucker (wenn möglich) zurückgesetzt und den Druckauftrag geschlossen.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CDC::StartDoc](#startdoc).

## <a name="cdcabortpath"></a><a name="abortpath"></a>CDC::AbortPath

Schließt und verwirft alle Pfade im Gerätekontext.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Wenn im Gerätekontext eine offene Pfadhalterung vorhanden ist, wird die Pfadhalterung geschlossen, und der Pfad wird verworfen. Wenn im Gerätekontext ein geschlossener Pfad vorhanden ist, wird der Pfad verworfen.

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>CDC::AddMetaFileKommentar

Kopiert den Kommentar aus einem Puffer in eine angegebene Metadatei im erweiterten Format.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parameter

*nDataSize*<br/>
Gibt die Länge des Kommentarpuffers in Bytes an.

*pCommentData*<br/>
Zeigt auf den Puffer, der den Kommentar enthält.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Ein Kommentar kann alle privaten Informationen enthalten, z. B. die Quelle des Bildes und das Datum, an dem es erstellt wurde. Ein Kommentar sollte mit einer Anwendungssignatur beginnen, gefolgt von den Daten. Kommentare sollten keine positionsspezifischen Daten enthalten. Positionsspezifische Daten geben den Speicherort eines Datensatzes an und sollten nicht eingeschlossen werden, da eine Metadatei in eine andere Metadatei eingebettet werden kann. Diese Funktion kann nur mit erweiterten Metadateien verwendet werden.

## <a name="cdcalphablend"></a><a name="alphablend"></a>CDC::AlphaBlend

Rufen Sie diese Memberfunktion auf, um Bitmaps mit transparenten oder halbtransparenten Pixeln anzuzeigen.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parameter

*xDest*<br/>
Gibt die x-Koordinate in logischen Einheiten der oberen linken Ecke des Zielrechtecks an.

*yDest*<br/>
Gibt die y-Koordinate in logischen Einheiten der oberen linken Ecke des Zielrechtecks an.

*nDestWidth*<br/>
Gibt die Breite des Zielrechtecks in logischen Einheiten an.

*nDestHeight*<br/>
Gibt die Höhe des Zielrechtecks in logischen Einheiten an.

*pSrcDC*<br/>
Ein Zeiger auf den Quellgerätekontext.

*xSrc*<br/>
Gibt die x-Koordinate in logischen Einheiten der oberen linken Ecke des Quellrechtecks an.

*ySrc*<br/>
Gibt die y-Koordinate in logischen Einheiten der oberen linken Ecke des Quellrechtecks an.

*nSrcWidth*<br/>
Gibt die Breite des Quellrechtecks in logischen Einheiten an.

*nSrcHeight*<br/>
Gibt die Höhe des Quellrechtecks in logischen Einheiten an.

*Mischung*<br/>
Gibt eine [BLENDFUNCTION-Struktur](/windows/win32/api/wingdi/ns-wingdi-blendfunction) an.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Bemerkungen

Weitere Informationen finden Sie unter [AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) im Windows SDK.

## <a name="cdcanglearc"></a><a name="anglearc"></a>CDC::AngleArc

Zeichnet ein Liniensegment und einen Bogen.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate der Mitte des Kreises an.

*y*<br/>
Gibt die logische y-Koordinate der Mitte des Kreises an.

*nRadius*<br/>
Gibt den Radius des Kreises in logischen Einheiten an. Dieser Wert muss positiv sein.

*fStartAngle*<br/>
Gibt den Startwinkel in Grad relativ zur x-Achse an.

*fSweepAngle*<br/>
Gibt den Sweep-Winkel in Grad relativ zum Startwinkel an.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Bemerkungen

Das Liniensegment wird von der aktuellen Position bis zum Anfang des Bogens gezeichnet. Der Bogen wird entlang des Umfangs eines Kreises mit dem angegebenen Radius und Mittelpunkt gezeichnet. Die Länge des Bogens wird durch die angegebenen Start- und Sweep-Winkel definiert.

`AngleArc`verschiebt die aktuelle Position an den Endpunkt des Bogens. Der von dieser Funktion gezeichnete Bogen kann je nach aktueller Transformation und Zuordnungsmodus elliptisch erscheinen. Vor dem Zeichnen des Bogens zeichnet diese Funktion das Liniensegment von der aktuellen Position bis zum Anfang des Bogens. Der Bogen wird gezeichnet, indem ein imaginärer Kreis mit dem angegebenen Radius um den angegebenen Mittelpunkt erstellt wird. Der Startpunkt des Bogens wird durch Messung gegen den Uhrzeigersinn von der x-Achse des Kreises durch die Anzahl der Grad im Startwinkel bestimmt. Der Endpunkt wird in ähnlicher Weise durch Messung gegen den Uhrzeigersinn vom Startpunkt um die Anzahl der Grad im Sweep-Winkel gemessen.

Wenn der Sweep-Winkel größer als 360 Grad ist, wird der Bogen mehrmals gefegt. Diese Funktion zeichnet Linien mit dem aktuellen Stift. Die Figur ist nicht gefüllt.

## <a name="cdcarc"></a><a name="arc"></a>CDC::Arc

Zeichnet einen elliptischen Bogen.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*x3*<br/>
Gibt die x-Koordinate des Punktes an, der den Startpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen.

*y3*<br/>
Gibt die y-Koordinate des Punktes an, der den Startpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen.

*x4*<br/>
Gibt die x-Koordinate des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen.

*y4*<br/>
Gibt die y-Koordinate des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen.

*lpRect*<br/>
Gibt das umgrenzende Rechteck (in logischen Einheiten) an. Sie können entweder ein LPRECT- oder ein [CRect-Objekt](../../atl-mfc-shared/reference/crect-class.md) für diesen Parameter übergeben.

*ptStart*<br/>
Gibt die x- und y-Koordinaten des Punktes an, der den Startpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen. Sie können entweder eine [POINT-Struktur](/windows/win32/api/windef/ns-windef-point) oder ein [CPoint-Objekt](../../atl-mfc-shared/reference/cpoint-class.md) für diesen Parameter übergeben.

*ptEnd*<br/>
Gibt die x- und y-Koordinaten des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der mit der Funktion gezeichnete Bogen ist ein Segment der Ellipse, das durch das angegebene umgebende Rechteck definiert wird.

Der tatsächliche Ausgangspunkt des Bogens ist der Punkt, an dem ein Strahl, der von der Mitte des umgrenzenden Rechtecks durch den angegebenen Startpunkt gezeichnet wird, die Ellipse schneidet. Der tatsächliche Endpunkt des Bogens ist der Punkt, an dem ein Strahl, der von der Mitte des umhängenden Rechtecks durch den angegebenen Endpunkt gezeichnet wird, die Ellipse schneidet. Der Bogen wird gegen den Uhrzeigersinn gezeichnet. Da ein Bogen keine geschlossene Figur ist, wird er nicht gefüllt. Sowohl die Breite als auch die Höhe des Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>CDC::ArcTo

Zeichnet einen elliptischen Bogen.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*x3*<br/>
Gibt die x-Koordinate des Punktes an, der den Startpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen.

*y3*<br/>
Gibt die y-Koordinate des Punktes an, der den Startpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen.

*x4*<br/>
Gibt die x-Koordinate des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen.

*y4*<br/>
Gibt die y-Koordinate des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen.

*lpRect*<br/>
Gibt das umgrenzende Rechteck (in logischen Einheiten) an. Sie können entweder einen Zeiger an eine [RECT-Datenstruktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Objekt](../../atl-mfc-shared/reference/crect-class.md) für diesen Parameter übergeben.

*ptStart*<br/>
Gibt die x- und y-Koordinaten des Punktes an, der den Startpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen. Sie können entweder [POINT](/windows/win32/api/windef/ns-windef-point) eine POINT-Datenstruktur oder ein [CPoint-Objekt](../../atl-mfc-shared/reference/cpoint-class.md) für diesen Parameter übergeben.

*ptEnd*<br/>
Gibt die x- und y-Koordinaten des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Bogen liegen. Sie können entweder `POINT` eine Datenstruktur oder ein `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Funktion ähnelt `CDC::Arc`, außer dass die aktuelle Position aktualisiert wird. Die Punkte ( *x1*, *y1*) und ( *x2*, *y2*) geben das umgrenzende Rechteck an. Eine Ellipse, die durch das angegebene umgebende Rechteck gebildet wird, definiert die Kurve des Bogens. Der Bogen erstreckt sich gegen den Uhrzeigersinn (die Standardbogenrichtung) von dem Punkt, an dem er die radiale Linie von der Mitte des umgrenzenden Rechtecks bis ( *x3*, *y3*) schneidet. Der Bogen endet an der Stelle, an der er die radiale Linie von der Mitte des umgrenzenden Rechtecks bis ( *x4*, *y4*) schneidet. Wenn der Start- und der Endpunkt identisch sind, wird eine vollständige Ellipse gezeichnet.

Eine Linie wird von der aktuellen Position bis zum Startpunkt des Bogens gezeichnet. Wenn kein Fehler auftritt, wird die aktuelle Position auf den Endpunkt des Bogens festgelegt. Der Bogen wird mit dem aktuellen Stift gezeichnet. es wird nicht gefüllt.

## <a name="cdcattach"></a><a name="attach"></a>CDC::Anfügen

Verwenden Sie diese Memberfunktion, um `CDC` einen *hDC* an das Objekt anzufügen.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parameter

*Hdc*<br/>
Ein Windows-Gerätekontext.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der *hDC* wird `m_hDC`sowohl im , im `m_hAttribDC`Kontext des Ausgabegeräts als auch im Attributgerätekontext gespeichert.

## <a name="cdcbeginpath"></a><a name="beginpath"></a>CDC::BeginPath

Öffnet eine Pfadhalterung im Gerätekontext.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Nachdem eine Pfadklammer geöffnet ist, kann eine Anwendung mit dem Aufruf von GDI-Zeichnungsfunktionen beginnen, um die Punkte zu definieren, die im Pfad liegen. Eine Anwendung kann eine offene Pfadklammer schließen, indem sie die `EndPath` Memberfunktion aufruft. Wenn eine `BeginPath`Anwendung aufruft, werden alle vorherigen Pfade verworfen.

Eine Liste der Zeichnungsfunktionen, die Punkte in einem Pfad definieren, finden Sie unter [BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) im Windows SDK.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>CDC::BitBlt

Kopiert eine Bitmap aus dem Quellgerätekontext in diesen aktuellen Gerätekontext.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Zielrechtecks an.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Zielrechtecks an.

*nWidth*<br/>
Gibt die Breite (in logischen Einheiten) des Zielrechtecks und der Quellbitmap an.

*nHeight*<br/>
Gibt die Höhe (in logischen Einheiten) des Zielrechtecks und der Quellbitmap an.

*pSrcDC*<br/>
Zeiger auf `CDC` ein Objekt, das den Gerätekontext identifiziert, aus dem die Bitmap kopiert wird. Es muss NULL sein, wenn *dwRop* einen Raster-Vorgang angibt, der keine Quelle enthält.

*xSrc*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke der Quellbitmap an.

*ySrc*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke der Quellbitmap an.

*dwRop*<br/>
Gibt das Raster des auszuführenden Vorgangs an. Raster-Vorgangscodes definieren, wie die GDI Farben in Ausgabevorgängen kombiniert, die einen aktuellen Pinsel, eine mögliche Quellbitmap und eine Zielbitmap umfassen. Eine Liste der Raster-Operationscodes für *dwRop* und deren Beschreibungen finden Sie in [BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt) im Windows SDK

Eine vollständige Liste der Raster-Vorgangscodes finden Sie unter Informationen zu [Raster-Vorgangscodes](/windows/win32/gdi/raster-operation-codes) im Windows SDK.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Anwendung kann die Fenster oder Clientbereiche an Bytegrenzen ausrichten, um sicherzustellen, dass die `BitBlt` Vorgänge auf byteausgerichteten Rechtecken ausgeführt werden. (Legen Sie die CS_BYTEALIGNWINDOW oder CS_BYTEALIGNCLIENT-Flags fest, wenn Sie die Fensterklassen registrieren.)

`BitBlt`Vorgänge für byteausgerichtete Rechtecke sind `BitBlt` erheblich schneller als Vorgänge auf Rechtecken, die nicht byteausgerichtet sind. Wenn Sie Klassenstile wie Byteausrichtung für Ihren eigenen Gerätekontext angeben möchten, müssen Sie eine Fensterklasse registrieren, anstatt sich darauf zu verlassen, dass die Microsoft Foundation-Klassen dies für Sie tun. Verwenden Sie die globale Funktion [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

GDI transformiert *nWidth* und *nHeight*einmal mithilfe des Zielgerätekontexts und einmal mithilfe des Quellgerätekontexts. Wenn die resultierenden Ausdehnungen nicht übereinstimmen, verwendet GDI die Windows-Funktion, `StretchBlt` um die Quellbitmap nach Bedarf zu komprimieren oder zu dehnen.

Wenn Ziel-, Quell- und Musterbitmaps nicht das `BitBlt` gleiche Farbformat aufweisen, konvertiert die Funktion die Quell- und Musterbitmaps in das Ziel. Die Vordergrund- und Hintergrundfarben der Zielbitmap werden bei der Konvertierung verwendet.

Wenn `BitBlt` die Funktion eine monochrome Bitmap in Farbe konvertiert, werden weiße Bits (1) auf die Hintergrundfarbe und schwarze Bits (0) auf die Vordergrundfarbe festgelegt. Die Vordergrund- und Hintergrundfarben des Zielgerätekontexts werden verwendet. Um Farbe in Monochrom zu konvertieren, `BitBlt` werden Pixel, die der Hintergrundfarbe entsprechen, auf Weiß und alle anderen Pixel auf Schwarz festgelegt. `BitBlt`verwendet die Vordergrund- und Hintergrundfarben des Farbgerätekontexts, um von Farbe in Monochrom umzuwandeln.

Beachten Sie, dass nicht `BitBlt`alle Gerätekontexte unterstützen. Um zu überprüfen, ob `BitBlt`ein gegebener Gerätekontext unterstützt, verwenden Sie die `GetDeviceCaps` Memberfunktion und geben Sie den RASTERCAPS-Index an.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CDC::CreateCompatibleDC](#createcompatibledc).

## <a name="cdccdc"></a><a name="cdc"></a>CDC::CDC

Erstellt ein `CDC`-Objekt.

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>CDC::Chord

Zeichnet einen Akkord (eine geschlossene Figur, die durch den Schnittpunkt einer Ellipse und eines Liniensegments begrenzt ist).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des umgrenzten Rechtecks des Akkords (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des umgrenzten Rechtecks des Akkords (in logischen Einheiten) an.

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des umgrenzten Rechtecks des Akkords (in logischen Einheiten) an.

*y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umgrenzten Rechtecks des Akkords (in logischen Einheiten) an.

*x3*<br/>
Gibt die x-Koordinate des Punktes an, der den Startpunkt des Akkords definiert (in logischen Einheiten).

*y3*<br/>
Gibt die y-Koordinate des Punktes an, der den Startpunkt des Akkords definiert (in logischen Einheiten).

*x4*<br/>
Gibt die x-Koordinate des Punktes an, der den Endpunkt des Akkords definiert (in logischen Einheiten).

*y4*<br/>
Gibt die y-Koordinate des Punktes an, der den Endpunkt des Akkords definiert (in logischen Einheiten).

*lpRect*<br/>
Gibt das umgrenzende Rechteck (in logischen Einheiten) an. Sie können entweder ein LPRECT- oder ein [CRect-Objekt](../../atl-mfc-shared/reference/crect-class.md) für diesen Parameter übergeben.

*ptStart*<br/>
Gibt die x- und y-Koordinaten des Punktes an, der den Startpunkt des Akkords definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Akkord liegen. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

*ptEnd*<br/>
Gibt die x- und y-Koordinaten des Punktes an, der den Endpunkt des Akkords definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Akkord liegen. Sie können entweder eine [POINT-Struktur](/windows/win32/api/windef/ns-windef-point) oder ein [CPoint-Objekt](../../atl-mfc-shared/reference/cpoint-class.md) für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Parameter ( *x1*, *y1*) und ( *x2*, *y2*) geben die oberen linken bzw. unteren rechten Ecken eines Rechtecks an, das die Ellipse umgibt, die Teil des Akkords ist. Die Parameter ( *x3*, *y3*) und ( *x4*, *y4*) geben die Endpunkte einer Linie an, die die Ellipse schneidet. Der Akkord wird mit dem ausgewählten Stift gezeichnet und mit dem ausgewählten Pinsel gefüllt.

Die von der `Chord` Funktion gezeichnete Figur erstreckt sich bis zu, enthält jedoch nicht die rechten und unteren Koordinaten. Dies bedeutet, dass die Höhe der Figur *y2* - *y1* und die Breite der Figur *x2* - *x1*ist.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>CDC::CloseFigure

Schließt eine offene Figur in einem Pfad.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Funktion schließt die Figur, indem sie eine Linie von der aktuellen Position zum ersten Punkt der `MoveTo` Figur zeichnet (normalerweise der Punkt, der durch den letzten Aufruf der Memberfunktion angegeben wird) und verbindet die Linien mithilfe des Linienverknüpfungsstils. Wenn eine Figur mit `LineTo` der Memberfunktion `CloseFigure`anstelle von geschlossen wird, werden Endkappen verwendet, um die Ecke anstelle einer Verknüpfung zu erstellen. `CloseFigure`sollte nur aufgerufen werden, wenn im Gerätekontext eine offene Pfadhalterung vorhanden ist.

Eine Figur in einem Pfad ist geöffnet, es sei denn, sie wird explizit mit dieser Funktion geschlossen. (Eine Zahl kann auch dann geöffnet sein, wenn der aktuelle Punkt und der Ausgangspunkt der Abbildung identisch sind.) Jede Linie oder Kurve, `CloseFigure` die dem Pfad hinzugefügt wird, nachdem eine neue Figur gestartet wurde.

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>CDC::CreateCompatibleDC

Erstellt einen Speichergerätekontext, der mit dem von *pDC*angegebenen Gerät kompatibel ist.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parameter

*pDC*<br/>
Ein Zeiger zu einem Gerätekontext. Wenn *pDC* NULL ist, erstellt die Funktion einen Speichergerätekontext, der mit der Systemanzeige kompatibel ist.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Ein Speichergerätekontext ist ein Speicherblock, der eine Anzeigeoberfläche darstellt. Es kann verwendet werden, um Bilder im Speicher vorzubereiten, bevor sie auf die tatsächliche Geräteoberfläche des kompatiblen Geräts kopiert werden.

Wenn ein Speichergerätekontext erstellt wird, wählt GDI automatisch eine 1-by-1-Monochrom-Stock-Bitmap dafür aus. GDI-Ausgabefunktionen können nur dann mit einem Speichergerätekontext verwendet werden, wenn eine Bitmap erstellt und in diesem Kontext ausgewählt wurde.

Diese Funktion kann nur zum Erstellen kompatibler Gerätekontexte für Geräte verwendet werden, die Raster-Vorgänge unterstützen. Informationen zu Bitblockübertragungen zwischen Gerätekontexten finden Sie in der [MEMBERfunktion CDC::BitBlt.](#bitblt) Informationen dazu, ob ein Gerätekontext Raster-Operationen unterstützt, `CDC::GetDeviceCaps`finden Sie in der RC_BITBLT-Raster-Funktion in der Memberfunktion .

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>CDC::CreateDC

Erstellt einen Gerätekontext für das angegebene Gerät.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parameter

*lpszDriverName*<br/>
Zeigt auf eine null-terminierte Zeichenfolge, die den Dateinamen (ohne Erweiterung) des Gerätetreibers angibt (z. B. "EPSON"). Sie können auch `CString` ein Objekt für diesen Parameter übergeben.

*lpszDeviceName*<br/>
Zeigt auf eine null-terminierte Zeichenfolge, die den Namen des zu unterstützenden Geräts angibt (z. B. "EPSON FX-80"). Der Parameter *lpszDeviceName* wird verwendet, wenn das Modul mehr als ein Gerät unterstützt. Sie können auch `CString` ein Objekt für diesen Parameter übergeben.

*lpszOutput*<br/>
Zeigt auf eine null-terminierte Zeichenfolge, die den Datei- oder Gerätenamen für das physische Ausgabemedium (Datei oder Ausgabeport) angibt. Sie können auch `CString` ein Objekt für diesen Parameter übergeben.

*lpInitData*<br/>
Verweist auf `DEVMODE` eine Struktur, die gerätespezifische Initialisierungsdaten für den Gerätetreiber enthält. Die `DocumentProperties` Windows-Funktion ruft diese Struktur ab, die für ein bestimmtes Gerät ausgefüllt wurde. Der *Parameter lpInitData* muss NULL sein, wenn der Gerätetreiber die vom Benutzer über die Systemsteuerung angegebene Standardinitialisierung (falls vorhanden) verwenden soll.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der PRINT. H-Header-Datei ist erforderlich, wenn die [DEVMODE-Struktur](/windows/win32/api/wingdi/ns-wingdi-devmodea) verwendet wird.

Gerätenamen folgen diesen Konventionen: ein Endpunkt (:) wird empfohlen, ist jedoch optional. Windows entfernt den beendenden Doppelpunkt, sodass ein Gerätename, der mit einem Doppelpunkt endet, demselben Port zugeordnet wird wie derselbe Name ohne Doppelpunkt. Die Treiber- und Portnamen dürfen keine führenden oder nachgestellten Leerzeichen enthalten. GDI-Ausgabefunktionen können nicht mit Informationskontexten verwendet werden.

## <a name="cdccreateic"></a><a name="createic"></a>CDC::CreateIC

Erstellt einen Informationskontext für das angegebene Gerät.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parameter

*lpszDriverName*<br/>
Zeigt auf eine null-terminierte Zeichenfolge, die den Dateinamen (ohne Erweiterung) des Gerätetreibers angibt (z. B. "EPSON"). Sie können `CString` ein Objekt für diesen Parameter übergeben.

*lpszDeviceName*<br/>
Zeigt auf eine null-terminierte Zeichenfolge, die den Namen des zu unterstützenden Geräts angibt (z. B. "EPSON FX-80"). Der Parameter *lpszDeviceName* wird verwendet, wenn das Modul mehr als ein Gerät unterstützt. Sie können `CString` ein Objekt für diesen Parameter übergeben.

*lpszOutput*<br/>
Zeigt auf eine null-terminierte Zeichenfolge, die den Datei- oder Gerätenamen für das physische Ausgabemedium (Datei oder Port) angibt. Sie können `CString` ein Objekt für diesen Parameter übergeben.

*lpInitData*<br/>
Verweist auf gerätespezifische Initialisierungsdaten für den Gerätetreiber. Der *Parameter lpInitData* muss NULL sein, wenn der Gerätetreiber die vom Benutzer über die Systemsteuerung angegebene Standardinitialisierung (falls vorhanden) verwenden soll. Das `CreateDC` Datenformat für die gerätespezifische Initialisierung finden Sie unter .

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Bemerkungen

Der Informationskontext bietet eine schnelle Möglichkeit, Informationen über das Gerät abzubekommen, ohne einen Gerätekontext zu erstellen.

Gerätenamen folgen diesen Konventionen: ein Endpunkt (:) wird empfohlen, ist jedoch optional. Windows entfernt den beendenden Doppelpunkt, sodass ein Gerätename, der mit einem Doppelpunkt endet, demselben Port zugeordnet wird wie derselbe Name ohne Doppelpunkt. Die Treiber- und Portnamen dürfen keine führenden oder nachgestellten Leerzeichen enthalten. GDI-Ausgabefunktionen können nicht mit Informationskontexten verwendet werden.

## <a name="cdcdeletedc"></a><a name="deletedc"></a>CDC::DeleteDC

Rufen Sie diese Funktion im Allgemeinen nicht auf. der Destruktor wird es für Sie tun.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich Null, wenn die Funktion erfolgreich abgeschlossen wurde; andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Die `DeleteDC` Memberfunktion löscht die Windows-Gerätekontexte, `m_hDC` die `CDC` im aktuellen Objekt zugeordnet sind. Wenn `CDC` dieses Objekt der letzte aktive Gerätekontext für ein bestimmtes Gerät ist, wird das Gerät benachrichtigt, und alle vom Gerät verwendeten Speicher- und Systemressourcen werden freigegeben.

Eine Anwendung sollte `DeleteDC` nicht aufrufen, wenn Objekte im Gerätekontext ausgewählt wurden. Objekte müssen zuerst aus dem Gerätekontext ausgewählt werden, bevor sie gelöscht werden.

Eine Anwendung darf keinen Gerätekontext löschen, dessen Handle durch Aufrufen von [CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc)abgerufen wurde. Stattdessen muss [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) aufrufen, um den Gerätekontext freizugeben. Die [CClientDC-](../../mfc/reference/cclientdc-class.md) und [CWindowDC-Klassen](../../mfc/reference/cwindowdc-class.md) werden bereitgestellt, um diese Funktionalität zu umschließen.

Die `DeleteDC` Funktion wird im Allgemeinen zum Löschen von Gerätekontexten verwendet, die mit [CreateDC](#createdc), [CreateIC](#createic)oder [CreateCompatibleDC](#createcompatibledc)erstellt wurden.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>CDC::DeleteTempMap

Wird automatisch `CWinApp` vom Leerlaufzeithandler aufgerufen, `CDC` löscht `FromHandle`alle temporären Objekte, `DeleteTempMap` die von `hDC`erstellt wurden, `CDC` zerstört jedoch nicht die Gerätekontexthandles (s), die den Objekten vorübergehend zugeordnet sind.

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>CDC::Detach

Rufen Sie diese `m_hDC` Funktion auf, um (den Kontext des Ausgabegeräts) vom `CDC` Objekt zu trennen, und legen Sie sowohl als `m_hDC` `m_hAttribDC` auch null fest.

```
HDC Detach();
```

### <a name="return-value"></a>Rückgabewert

Ein Windows-Gerätekontext.

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>CDC::DPtoHIMETRIC

Verwenden Sie diese Funktion, wenn Sie OLE HIMETRIC-Größen geben und Pixel in HIMETRIC konvertieren.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpSize*<br/>
Zeigt auf eine [SIZE-Struktur](/windows/win32/api/windef/ns-windef-size) oder ein [CSize-Objekt.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Bemerkungen

Wenn der Zuordnungsmodus des Gerätekontextobjekts MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC oder MM_HIMETRIC ist, basiert die Konvertierung auf der Anzahl der Pixel im physischen Zoll. Wenn der Zuordnungsmodus einer der anderen nicht eingeschränkten Modi ist (z. B. MM_TEXT), basiert die Konvertierung auf der Anzahl der Pixel im logischen Zoll.

## <a name="cdcdptolp"></a><a name="dptolp"></a>CDC::DPtoLP

Konvertiert Geräteeinheiten in logische Einheiten.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein Array von [POINT-Strukturen](/windows/win32/api/windef/ns-windef-point) oder [CPoint-Objekten.](../../atl-mfc-shared/reference/cpoint-class.md)

*nCount*<br/>
Die Anzahl der Punkte im Array.

*lpRect*<br/>
Zeigt auf eine [RECT-Struktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Objekt.](../../atl-mfc-shared/reference/crect-class.md) Dieser Parameter wird für den einfachen Fall verwendet, ein Rechteck von Gerätepunkten in logische Punkte zu konvertieren.

*lpSize*<br/>
Zeigt auf eine [SIZE-Struktur](/windows/win32/api/windef/ns-windef-size) oder ein [CSize-Objekt.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Bemerkungen

Die Funktion ordnet die Koordinaten jedes Punktes oder jeder Dimension einer Größe vom Gerätekoordinatensystem zum logischen Koordinatensystem von GDI zu. Die Konvertierung hängt vom aktuellen Zuordnungsmodus und den Einstellungen der Ursprünge und Ausdehnungen für das Fenster und das Ansichtsfenster des Geräts ab.

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>CDC::Draw3dRect

Rufen Sie diese Memberfunktion auf, um ein dreidimensionales Rechteck zu zeichnen.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Gibt das umgrenzende Rechteck (in logischen Einheiten) an. Sie können entweder einen Zeiger an eine [RECT-Struktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Objekt](../../atl-mfc-shared/reference/crect-class.md) für diesen Parameter übergeben.

*clrTopLeft*<br/>
Gibt die Farbe der oberen und linken Seite des dreidimensionalen Rechtecks an.

*clrBottomRight*<br/>
Gibt die Farbe der unteren und rechten Seite des dreidimensionalen Rechtecks an.

*X*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des dreidimensionalen Rechtecks an.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des dreidimensionalen Rechtecks an.

*Cx*<br/>
Gibt die Breite des dreidimensionalen Rechtecks an.

*Cy*<br/>
Gibt die Höhe des dreidimensionalen Rechtecks an.

### <a name="remarks"></a>Bemerkungen

Das Rechteck wird mit der oberen und linken Seite in der Farbe gezeichnet, die von *clrTopLeft* angegeben wird, und die untere und rechte Seite in der Farbe, die von *clrBottomRight*angegeben wird.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>CDC::DrawDragRect

Rufen Sie diese Memberfunktion wiederholt auf, um ein Ziehrechteck neu zu zeichnen.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Zeigt auf eine [RECT-Struktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Objekt,](../../atl-mfc-shared/reference/crect-class.md) das die logischen Koordinaten eines Rechtecks angibt – in diesem Fall die Endposition des neu gezeichneten Rechtecks.

*Größe*<br/>
Gibt die Verschiebung von der oberen linken Ecke des äußeren Rahmens in die obere linke Ecke des inneren Rahmens (d. h. die Dicke des Rahmens) eines Rechtecks an.

*lpRectLast*<br/>
Zeigt auf eine [RECT-Struktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Objekt,](../../atl-mfc-shared/reference/crect-class.md) das die logischen Koordinaten der Position eines Rechtecks angibt – in diesem Fall die ursprüngliche Position des neu gezeichneten Rechtecks.

*sizeLast*<br/>
Gibt die Verschiebung von der oberen linken Ecke des äußeren Rahmens in die obere linke Ecke des inneren Rahmens (d. h. die Dicke des Rahmens) des ursprünglichen Rechtecks an, das neu gezeichnet wird.

*pBrush*<br/>
Zeiger auf ein Pinselobjekt. Legen Sie null fest, um den Standard-Halbtonpinsel zu verwenden.

*pBrushLast*<br/>
Zeiger auf das zuletzt verwendete Pinselobjekt. Legen Sie null fest, um den Standard-Halbtonpinsel zu verwenden.

### <a name="remarks"></a>Bemerkungen

Rufen Sie es in einer Schleife an, während Sie die Mausposition abtasten, um visuelles Feedback zu geben. Wenn Sie `DrawDragRect`aufrufen, wird das vorherige Rechteck ausgegrüsst und ein neues rechteckig gezeichnet. Wenn der Benutzer beispielsweise ein Rechteck über `DrawDragRect` den Bildschirm zieht, wird das ursprüngliche Rechteck ausgegeugnet und ein neues rechteckt. Zeichnet das `DrawDragRect` Rechteck standardmäßig mit einem Halbtonpinsel, um Flimmern zu vermeiden und das Erscheinungsbild eines sich sanft bewegenden Rechtecks zu erstellen.

Beim ersten Aufruf `DrawDragRect`sollte der *parameter lpRectLast* NULL sein.

## <a name="cdcdrawedge"></a><a name="drawedge"></a>CDC::DrawEdge

Rufen Sie diese Memberfunktion auf, um die Kanten eines Rechtecks des angegebenen Typs und Stils zu zeichnen.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Ein Zeiger auf `RECT` eine Struktur, die die logischen Koordinaten des Rechtecks enthält.

*nEdge*<br/>
Gibt den Typ der inneren und äußeren Kante an, die gezeichnet werden soll. Dieser Parameter muss eine Kombination aus einer inneren Rahmenflagge und einer äußeren Rahmenflagge sein. Eine Tabelle mit den Typen des Parameters finden Sie unter [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) im Windows SDK.

*nFlags*<br/>
Die Flags, die den Typ des zu zeichnenden Rahmens angeben. Eine `DrawEdge` Tabelle mit den Werten des Parameters finden Sie im Windows SDK. Bei diagonalen Linien geben die BF_RECT-Flags den Endpunkt des Vektors an, der durch den Rechteckparameter begrenzt wird.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

## <a name="cdcdrawescape"></a><a name="drawescape"></a>CDC::DrawEscape

Greift auf die Zeichnungsfunktionen einer Videoanzeige zu, die nicht direkt über die Grafikgeräteschnittstelle (GDI) verfügbar sind.

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parameter

*nEscape*<br/>
Gibt die zu erfüllende Escapefunktion an.

*nInputSize*<br/>
Gibt die Anzahl der Bytes an Daten an, auf die der Parameter *lpszInputData* zeigt.

*lpszInputData*<br/>
Zeigt auf die Eingabestruktur, die für das angegebene Escape-Escape erforderlich ist.

### <a name="return-value"></a>Rückgabewert

Gibt das Ergebnis der Funktion an. Größer als Null, wenn erfolgreich, mit Ausnahme der QUERYESCSUPPORT-Zeichnungsescape, die nur auf Implementierung überprüft; oder Null, wenn der Escape-Wert nicht implementiert wird; oder kleiner als Null, wenn ein Fehler aufgetreten ist.

### <a name="remarks"></a>Bemerkungen

Wenn eine `DrawEscape`Anwendung aufruft, werden die von *nInputSize* und *lpszInputData* identifizierten Daten direkt an den angegebenen Anzeigetreiber übergeben.

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>CDC::DrawFocusRect

Zeichnet ein Rechteck in dem Stil, der verwendet wird, um anzuzeigen, dass das Rechteck den Fokus hat.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Zeigt auf eine [RECT-Struktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Objekt,](../../atl-mfc-shared/reference/crect-class.md) das die logischen Koordinaten des zu zeichnenden Rechtecks angibt.

### <a name="remarks"></a>Bemerkungen

Da es sich um eine boolesche XOR-Funktion handelt, entfernt das Aufrufen dieser Funktion ein zweites Mal mit demselben Rechteck das Rechteck aus der Anzeige. Das von dieser Funktion gezeichnete Rechteck kann nicht gescrollt werden. Um einen Bereich zu scrollen, der `DrawFocusRect` ein von dieser Funktion gezeichnetes Rechteck enthält, `DrawFocusRect` rufen Sie zuerst an, um das Rechteck aus der Anzeige zu entfernen, scrollen Sie dann den Bereich, und rufen Sie dann erneut auf, um das Rechteck an der neuen Position zu zeichnen.

> [!CAUTION]
> `DrawFocusRect`funktioniert nur im MM_TEXT Modus. In anderen Modi zeichnet diese Funktion das Fokusrechteck nicht korrekt, gibt jedoch keine Fehlerwerte zurück.

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>CDC::DrawFrameControl

Rufen Sie diese Memberfunktion auf, um ein Framesteuerelement des angegebenen Typs und Stils zu zeichnen.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Ein Zeiger auf `RECT` eine Struktur, die die logischen Koordinaten des Rechtecks enthält.

*nType*<br/>
Gibt den Typ des zu zeichnenden Rahmensteuerelements an. Eine Liste der möglichen Werte dieses Parameters finden Sie im *UType-Parameter* in [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol) im Windows SDK.

*nState*<br/>
Gibt den Anfangszustand des Framesteuerelements an. Kann einer oder mehrere der Werte sein, `DrawFrameControl` die für den *uState-Parameter* im Windows SDK beschrieben werden. Verwenden Sie den *nState-Wert* DFCS_ADJUSTRECT, um das umgebende Rechteck anzupassen, um die umgebende Kante der Drucktaste auszuschließen.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Bemerkungen

In mehreren Fällen hängt *nState* vom *nType-Parameter* ab. Die folgende Liste zeigt die Beziehung zwischen den vier *nType-Werten* und *nState:*

- DFC_BUTTON

  - DFCS_BUTTON3STATE Drei-Zustand-Taste

  - Kontrollkästchen DFCS_BUTTONCHECK

  - DFCS_BUTTONPUSH-Taste

  - DFCS_BUTTONRADIO-Radio-Taste

  - DFCS_BUTTONRADIOIMAGE Bild für Radiotaste (nicht quadratisch benötigt Bild)

  - DFCS_BUTTONRADIOMASK Maske für Radio-Taste (nicht Quadrat braucht Maske)

- DFC_CAPTION

  - DFCS_CAPTIONCLOSE Schaltfläche Schließen

  - DFCS_CAPTIONHELP Hilfe-Schaltfläche

  - DFCS_CAPTIONMAX Maximierungstaste

  - DFCS_CAPTIONMIN Minimieren-Taste

  - DFCS_CAPTIONRESTORE-Wiederherstellungstaste

- DFC_MENU

  - DFCS_MENUARROW Untermenüpfeil

  - DFCS_MENUBULLET Bullet

  - DFCS_MENUCHECK-Prüfzeichen

- DFC_SCROLL

  - DFCS_SCROLLCOMBOBOX Combo-Box-Scrollleiste

  - DFCS_SCROLLDOWN Pfeil nach unten der Bildlaufleiste

  - DFCS_SCROLLLEFT Linker Pfeil der Bildlaufleiste

  - DFCS_SCROLLRIGHT Pfeil der Schriftleiste nach rechts

  - DFCS_SCROLLSIZEGRIP Größengriff in der rechten unteren Fensterecke

  - DFCS_SCROLLUP Pfeil nach oben der Bildlaufleiste

### <a name="example"></a>Beispiel

Dieser Code zeichnet den Größengreifer in der rechten unteren Ecke des Fensters. Es eignet sich `OnPaint` für den Handler eines Dialogfelds, das keine Stile hat und normalerweise keine anderen Steuerelemente (z. B. eine Statusleiste) enthält, die ihm einen Größengreifer verleihen können.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>CDC::DrawIcon

Zeichnet ein Symbol auf dem `CDC` Gerät, das durch das aktuelle Objekt dargestellt wird.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Symbols an.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Symbols an.

*hIcon*<br/>
Identifiziert das Handle des zu zeichnenden Symbols.

*Punkt*<br/>
Gibt die logischen x- und y-Koordinaten der oberen linken Ecke des Symbols an. Sie können eine [POINT-Struktur](/windows/win32/api/windef/ns-windef-point) oder ein [CPoint-Objekt](../../atl-mfc-shared/reference/cpoint-class.md) für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich Null, wenn die Funktion erfolgreich abgeschlossen wurde; andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Die Funktion platziert die obere linke Ecke des Symbols an der von *x* und *y*angegebenen Position. Der Standort unterliegt dem aktuellen Zuordnungsmodus des Gerätekontexts.

Die Symbolressource muss zuvor mit den `CWinApp::LoadIcon` `CWinApp::LoadStandardIcon`Funktionen `CWinApp::LoadOEMIcon`, oder geladen worden sein. Der `MM_TEXT` Zuordnungsmodus muss vor der Verwendung dieser Funktion ausgewählt werden.

### <a name="example"></a>Beispiel

  Siehe beispiel für [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

## <a name="cdcdrawstate"></a><a name="drawstate"></a>CDC::DrawState

Rufen Sie diese Memberfunktion auf, um ein Bild anzuzeigen und einen visuellen Effekt anzuwenden, um einen Zustand anzugeben, z. B. einen deaktivierten oder Standardstatus.

> [!NOTE]
> Für alle *nFlag-Zustände* außer DSS_NORMAL wird das Bild in Monochrom konvertiert, bevor der visuelle Effekt angewendet wird.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parameter

*Pt*<br/>
Gibt die Position des Bildes an.

*Größe*<br/>
Gibt die Größe des Bildes an.

*hBitmap*<br/>
Ein Handle für eine Bitmap.

*nFlags*<br/>
Flags, die den Bildtyp und den Status angeben. Siehe [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) im Windows SDK für die möglichen *nFlags-Typen* und -Zustände.

*hBrush*<br/>
Ein Griff zu einem Pinsel.

*pBitmap*<br/>
Ein Zeiger auf ein CBitmap-Objekt.

*pBrush*<br/>
Ein Zeiger auf ein CBrush-Objekt.

*hIcon*<br/>
Ein Handle für ein Symbol.

*lpszText*<br/>
Ein Zeiger auf text.

*bPrefixText*<br/>
Text, der einen Beschleuniger mnemonic enthalten kann. Der Parameter *lData* gibt die Adresse der Zeichenfolge an, und der Parameter *nTextLen* gibt die Länge an. Wenn *nTextLen* 0 ist, wird davon ausgegangen, dass die Zeichenfolge null-beendet ist.

*nTextLen*<br/>
Länge der Textzeichenfolge, auf die von *lpszText*verwiesen wird. Wenn *nTextLen* 0 ist, wird davon ausgegangen, dass die Zeichenfolge null-beendet ist.

*lpDrawProc*<br/>
Ein Zeiger auf eine Rückruffunktion, die zum Rendern eines Bildes verwendet wird. Dieser Parameter ist erforderlich, wenn der Bildtyp in *nFlags* DST_COMPLEX ist. Es ist optional und kann NULL sein, wenn der Bildtyp DST_TEXT ist. Bei allen anderen Bildtypen wird dieser Parameter ignoriert. Weitere Informationen zur Rückruffunktion finden Sie unter Die [DrawStateProc-Funktion](/windows/win32/api/winuser/nc-winuser-drawstateproc) im Windows SDK.

*lDaten*<br/>
Gibt Informationen zum Bild an. Die Bedeutung dieses Parameters hängt vom Bildtyp ab.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

## <a name="cdcdrawtext"></a><a name="drawtext"></a>CDC::DrawText

Rufen Sie diese Memberfunktion auf, um Text im angegebenen Rechteck zu formatieren. Um zusätzliche Formatierungsoptionen anzugeben, verwenden Sie [CDC::DrawTextEx](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Zeigt auf die zu zeichnende Zeichenfolge. Wenn *nCount* -1 ist, muss die Zeichenfolge null-beendet werden.

*nCount*<br/>
Gibt die Anzahl der Zeichen in der Zeichenfolge an. Wenn *nCount* -1 ist, wird *lpszString* als langer Zeiger auf eine `DrawText` null-terminierte Zeichenfolge angenommen und berechnet die Zeichenanzahl automatisch.

*lpRect*<br/>
Zeigt auf eine [RECT-Struktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Objekt,](../../atl-mfc-shared/reference/crect-class.md) das das Rechteck (in logischen Koordinaten) enthält, in dem der Text formatiert werden soll.

*Str*<br/>
Ein [CString-Objekt,](../../atl-mfc-shared/reference/cstringt-class.md) das die angegebenen Zeichen enthält, die gezeichnet werden sollen.

*nFormat*<br/>
Gibt die Methode zum Formatieren des Textes an. Dabei kann es sich um eine beliebige Kombination der für den *Parameter uFormat* in [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) im Windows SDK beschriebenen Werte handeln. (Kombination mit dem bitweisen ODER-Operator):

> [!NOTE]
> Einige *uFormat* uFormat-Flag-Kombinationen können dazu führen, dass die übergebene Zeichenfolge geändert wird. Die Verwendung DT_MODIFYSTRING mit DT_END_ELLIPSIS oder DT_PATH_ELLIPSIS kann dazu führen, `CString` dass die Zeichenfolge geändert wird, was zu einer Assertion in der Außerkraftsetzung führt. Die Werte DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP und DT_NOPREFIX können nicht mit dem DT_TABSTOP-Wert verwendet werden.

### <a name="return-value"></a>Rückgabewert

Die Höhe des Textes, wenn die Funktion erfolgreich ist.

### <a name="remarks"></a>Bemerkungen

Es formatiert Text, indem Registerkarten in geeignete Leerzeichen erweitert, Text nach links, rechts oder in der Mitte des angegebenen Rechtecks ausgerichtet und Text in Linien aufgeteilt wird, die in das angegebene Rechteck passen. Der Formatierungstyp wird von *nFormat*angegeben.

Diese Memberfunktion verwendet die ausgewählte Schriftart, Textfarbe und Hintergrundfarbe des Gerätekontexts, um den Text zu zeichnen. Wenn nicht das formatDT_NOCLIP verwendet wird, `DrawText` wird der Text so abschneidet, dass der Text nicht außerhalb des angegebenen Rechtecks angezeigt wird. Es wird davon ausgegangen, dass alle Formatierungen mehrere Zeilen haben, es sei denn, das DT_SINGLELINE Format wird angegeben.

Wenn die ausgewählte Schriftart für das `DrawText` angegebene Rechteck zu groß ist, versucht die Memberfunktion nicht, eine kleinere Schriftart zu ersetzen.

Wenn das DT_CALCRECT-Flag angegeben wird, wird das von *lpRect* angegebene Rechteck aktualisiert, um die Breite und Höhe widerzuspiegeln, die zum Zeichnen des Textes erforderlich sind.

Wenn das TA_UPDATECP Textausrichtungsflag festgelegt wurde (siehe [CDC::SetTextAlign](#settextalign)), `DrawText` wird Text angezeigt, der an der aktuellen Position beginnt und nicht links vom angegebenen Rechteck. `DrawText`wird Text nicht umbrochen, wenn das TA_UPDATECP-Flag gesetzt wurde (d. h., das DT_WORDBREAK-Flag hat keine Auswirkungen).

Die Textfarbe kann von [CDC::SetTextColor](#settextcolor)festgelegt werden.

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>CDC::DrawTextEx

Formatiert Text im angegebenen Rechteck.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Zeigt auf die zu zeichnende Zeichenfolge. Wenn *nCount* -1 ist, muss die Zeichenfolge null beendet werden.

*nCount*<br/>
Gibt die Anzahl der Zeichen in der Zeichenfolge an. Wenn *nCount* -1 ist, wird *lpszString* als langer Zeiger auf eine `DrawText` null-terminierte Zeichenfolge angenommen und berechnet die Zeichenanzahl automatisch.

*lpRect*<br/>
Zeigt auf eine [RECT-Struktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Objekt,](../../atl-mfc-shared/reference/crect-class.md) das das Rechteck (in logischen Koordinaten) enthält, in dem der Text formatiert werden soll.

*Str*<br/>
Ein [CString-Objekt,](../../atl-mfc-shared/reference/cstringt-class.md) das die angegebenen Zeichen enthält, die gezeichnet werden sollen.

*nFormat*<br/>
Gibt die Methode zum Formatieren des Textes an. Dabei kann es sich um eine beliebige Kombination der für den *Parameter uFormat* in [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) im Windows SDK beschriebenen Werte handeln. (Kombinieren mit dem bitweisen **ODER-Operator):**

> [!NOTE]
> Einige *uFormat* uFormat-Flag-Kombinationen können dazu führen, dass die übergebene Zeichenfolge geändert wird. Die Verwendung DT_MODIFYSTRING mit DT_END_ELLIPSIS oder DT_PATH_ELLIPSIS kann dazu führen, `CString` dass die Zeichenfolge geändert wird, was zu einer Assertion in der Außerkraftsetzung führt. Die Werte DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP und DT_NOPREFIX können nicht mit dem DT_TABSTOP-Wert verwendet werden.

*lpDTParams*<br/>
Zeiger auf eine [DRAWTEXTPARAMS-Struktur,](/windows/win32/api/winuser/ns-winuser-drawtextparams) die zusätzliche Formatierungsoptionen angibt. Dieser Parameter kann NULL sein.

### <a name="remarks"></a>Bemerkungen

Es formatiert Text, indem Registerkarten in geeignete Leerzeichen erweitert, Text nach links, rechts oder in der Mitte des angegebenen Rechtecks ausgerichtet und Text in Linien aufgeteilt wird, die in das angegebene Rechteck passen. Der Formatierungstyp wird durch *nFormat* und *lpDTParams*angegeben. Weitere Informationen finden Sie unter [CDC::DrawText](#drawtext) und [DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) im Windows SDK.

Die Textfarbe kann von [CDC::SetTextColor](#settextcolor)festgelegt werden.

## <a name="cdcellipse"></a><a name="ellipse"></a>CDC::Ellipse

Zeichnet eine Ellipse.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des umgehenden Rechtecks der Ellipse an.

*y1*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des umgehenden Rechtecks der Ellipse an.

*x2*<br/>
Gibt die logische x-Koordinate der unteren rechten Ecke des umgehenden Rechtecks der Ellipse an.

*y2*<br/>
Gibt die logische y-Koordinate der unteren rechten Ecke des umgehenden Rechtecks der Ellipse an.

*lpRect*<br/>
Gibt das umgrenzende Rechteck der Ellipse an. Sie können auch ein [CRect-Objekt](../../atl-mfc-shared/reference/crect-class.md) für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Mittelpunkt der Ellipse ist der Mittelpunkt des umgebenden Rechtecks, das durch *x1*, *y1*, *x2*und *y2*, oder *lpRect*angegeben wird. Die Ellipse wird mit dem aktuellen Stift gezeichnet, und ihr Inneres ist mit dem aktuellen Pinsel gefüllt.

Die von dieser Funktion gezeichnete Figur erstreckt sich bis zu den rechten und unteren Koordinaten, aber nicht. Dies bedeutet, dass die Höhe der Figur *y2* - *y1* und die Breite der Figur *x2* - *x1*ist.

Wenn die Breite oder die Höhe des umgrenzten Rechtecks 0 ist, wird keine Ellipse gezeichnet.

## <a name="cdcenddoc"></a><a name="enddoc"></a>CDC::EndDoc

Beendet einen Druckauftrag, der durch einen Aufruf der [StartDoc-Memberfunktion](#startdoc) gestartet wird.

```
int EndDoc();
```

### <a name="return-value"></a>Rückgabewert

Größer oder gleich 0, wenn die Funktion erfolgreich ist, oder ein negativer Wert, wenn ein Fehler aufgetreten ist.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion ersetzt den ENDDOC-Druckerescapevorgang und sollte sofort nach Abschluss eines erfolgreichen Druckauftrags aufgerufen werden.

Wenn bei einer Anwendung ein Druckfehler oder ein abgebrochener Druckvorgang auftritt, darf sie nicht versuchen, den Vorgang mithilfe von entweder `EndDoc` oder [AbortDoc](#abortdoc)zu beenden. GDI beendet den Vorgang automatisch, bevor der Fehlerwert zurückgegeben wird.

Diese Funktion sollte nicht in Metadateien verwendet werden.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CDC::StartDoc](#startdoc).

## <a name="cdcendpage"></a><a name="endpage"></a>CDC::EndPage

Informiert das Gerät darüber, dass die Anwendung das Schreiben auf eine Seite beendet hat.

```
int EndPage();
```

### <a name="return-value"></a>Rückgabewert

Größer oder gleich 0, wenn die Funktion erfolgreich ist, oder ein negativer Wert, wenn ein Fehler aufgetreten ist.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion wird in der Regel verwendet, um den Gerätetreiber anzuweisen, zu einer neuen Seite zu gelangen.

Diese Memberfunktion ersetzt den NEWFRAME-Drucker-Escape. Im Gegensatz zu NEWFRAME wird diese Funktion immer nach dem Drucken einer Seite aufgerufen.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CDC::StartDoc](#startdoc).

## <a name="cdcendpath"></a><a name="endpath"></a>CDC::EndPath

Schließt eine Pfadhalterung und wählt den von der Klammer definierten Pfad in den Gerätekontext aus.

```
BOOL EndPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CDC::BeginPath](#beginpath).

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>CDC::EnumObjects

Zählt die Stifte und Pinsel auf, die in einem Gerätekontext verfügbar sind.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parameter

*nObjectType*<br/>
Gibt den Objekttyp an. Es kann die Werte OBJ_BRUSH oder OBJ_PEN haben.

*lpfn*<br/>
Die Prozedurinstanzadresse der von der Anwendung bereitgestellten Rückruffunktion. Siehe den Abschnitt "Bemerkungen" weiter unten.

*lpData*<br/>
Verweist auf die von der Anwendung bereitgestellten Daten. Die Daten werden zusammen mit den Objektinformationen an die Rückruffunktion übergeben.

### <a name="return-value"></a>Rückgabewert

Gibt den letzten Wert an, der von der [Rückruffunktion](callback-functions-used-by-mfc.md#enum_objects)zurückgegeben wird. Seine Bedeutung ist benutzerdefiniert.

### <a name="remarks"></a>Bemerkungen

Für jedes Objekt eines bestimmten Typs wird die Vonruffunktion, die Sie übergeben, mit den Informationen für dieses Objekt aufgerufen. Das System ruft die Rückruffunktion auf, bis keine Objekte mehr vorhanden sind oder die Rückruffunktion 0 zurückgibt.

Beachten Sie, dass Sie mit neuen Features von Microsoft Visual `EnumObjects`C++ eine gewöhnliche Funktion als an übergebene Funktion verwenden können. Die adresse, `EnumObjects` an die übergeben wird, ist ein Zeiger auf eine Funktion, die mit **EXPORT** und mit der Pascal-Aufrufkonvention exportiert wird. In Anwendungen im Schutzmodus müssen Sie diese Funktion nicht mit der Windows MakeProcInstance-Funktion erstellen oder die Funktion nach der Verwendung mit der FreeProcInstance Windows-Funktion freisetzen.

Sie müssen auch den Funktionsnamen nicht in einer **EXPORTS-Anweisung** in der Moduldefinitionsdatei Ihrer Anwendung exportieren. Sie können stattdessen den Modifikator **EXPORT-Funktion** verwenden, wie in

**int CALLBACK EXPORT** AFunction **(LPSTR**, **LPSTR);**

, damit der Compiler den richtigen Exportdatensatz für den Export mit Namen ohne Aliasing ausgibt. Dies funktioniert für die meisten Bedürfnisse. Für einige Sonderfälle, z. B. das Exportieren einer Funktion durch Ordinal oder das Aliasing des Exports, müssen Sie weiterhin eine **EXPORTS-Anweisung** in einer Moduldefinitionsdatei verwenden.

Zum Kompilieren von Microsoft Foundation-Programmen verwenden Sie normalerweise die Compileroptionen /GA und /GEs. Die Compileroption /Gw wird nicht mit den Microsoft Foundation-Klassen verwendet. (Wenn Sie die Windows-Funktion `MakeProcInstance`verwenden, müssen Sie den zurückgegebenen Funktionszeiger explizit aus FARPROC in den typ geben, der in dieser API benötigt wird.) Rückrufregistrierungsschnittstellen sind jetzt typsicher (Sie müssen einen Funktionszeiger übergeben, der auf die richtige Art von Funktion für den jeweiligen Rückruf verweist).

Beachten Sie außerdem, dass alle Rückruffunktionen Microsoft Foundation-Ausnahmen abfangen müssen, bevor sie zu Windows zurückkehren, da Ausnahmen nicht über Rückrufgrenzen hinweg ausgelöst werden können. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>CDC::Flucht

Diese Memberfunktion ist für die Win32-Programmierung praktisch veraltet.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parameter

*nEscape*<br/>
Gibt die zu erfüllende Escapefunktion an.

Eine vollständige Liste der Escape-Funktionen finden Sie unter [Escape](/windows/win32/api/wingdi/nf-wingdi-escape) im Windows SDK.

*nCount*<br/>
Gibt die Anzahl der Bytes an Daten an, auf die von *lpszInData*verwiesen wird.

*lpszInData*<br/>
Zeigt auf die Eingabedatenstruktur, die für diesen Escapepunkt erforderlich ist.

*lpOutData*<br/>
Zeigt auf die Struktur, die die Ausgabe von diesem Escape-Escape empfangen soll. Der *parameter lpOutData* ist NULL, wenn keine Daten zurückgegeben werden.

*nInputSize*<br/>
Gibt die Anzahl der Bytes an Daten an, auf die der Parameter *lpszInputData* zeigt.

*lpszInputData*<br/>
Zeigt auf die Eingabestruktur, die für das angegebene Escape-Escape erforderlich ist.

*nOutputSize*<br/>
Gibt die Anzahl der Bytes an Daten an, auf die der Parameter *lpszOutputData* zeigt.

*lpszOutputData*<br/>
Zeigt auf die Struktur, die die Ausgabe von diesem Escape-Escape empfängt. Dieser Parameter sollte NULL sein, wenn keine Daten zurückgegeben werden.

### <a name="return-value"></a>Rückgabewert

Ein positiver Wert wird zurückgegeben, wenn die Funktion erfolgreich ist, mit Ausnahme des QUERYESCSUPPORT-Escape, der nur auf Implementierung überprüft. Null wird zurückgegeben, wenn die Escape nicht implementiert wird. Ein negativer Wert wird zurückgegeben, wenn ein Fehler aufgetreten ist. Im Folgenden finden Sie allgemeine Fehlerwerte:

- SP_ERROR Allgemeiner Fehler.

- SP_OUTOFDISK Es ist derzeit nicht genügend Speicherplatz für das Spooling verfügbar, und es wird kein Speicherplatz mehr verfügbar.

- SP_OUTOFMEMORY Nicht genügend Arbeitsspeicher steht zum Spoolen zur Verfügung.

- SP_USERABORT Benutzer hat den Auftrag über den Druck-Manager beendet.

### <a name="remarks"></a>Bemerkungen

Von den ursprünglichen Drucker-Escapes wird nur QUERYESCSUPPORT für Win32-Anwendungen unterstützt. Alle anderen Drucker-Escapes sind veraltet und werden nur aus Kompatibilitätsgründen mit 16-Bit-Anwendungen unterstützt.

Für die Win32-Programmierung bietet jetzt sechs Memberfunktionen, `CDC` die die entsprechenden Druckerfluchten ablösen:

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

Darüber hinaus unterstützt [CDC::GetDeviceCaps](#getdevicecaps) Win32-Indizes, die andere Druckerfluchten ablösen. Weitere Informationen finden Sie unter [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) im Windows SDK.

Diese Memberfunktion ermöglicht Anwendungen den Zugriff auf Einrichtungen eines bestimmten Geräts, die nicht direkt über GDI verfügbar sind.

Verwenden Sie die erste Version, wenn Ihre Anwendung vordefinierte Escapewerte verwendet. Verwenden Sie die zweite Version, wenn Ihre Anwendung private Escapewerte definiert. Weitere Informationen zur zweiten Version finden Sie unter [ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) im Windows SDK.

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>CDC::ExcludeClipRect

Erstellt einen neuen Zuschneidebereich, der aus dem vorhandenen Zuschneidebereich abzüglich des angegebenen Rechtecks besteht.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Rechtecks an.

*y1*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks an.

*x2*<br/>
Gibt die logische x-Koordinate der unteren rechten Ecke des Rechtecks an.

*y2*<br/>
Gibt die logische y-Koordinate der unteren rechten Ecke des Rechtecks an.

*lpRect*<br/>
Gibt das Rechteck an. Kann auch `CRect` ein Objekt sein.

### <a name="return-value"></a>Rückgabewert

Gibt den Typ des neuen Zuschneidebereichs an. Dabei kann es sich um einen der folgenden Werte handeln:

- COMPLEXREGION Die Region hat überlappende Grenzen.

- FEHLER Es wurde keine Region erstellt.

- NULLREGION Die Region ist leer.

- SIMPLEREGION Die Region hat keine überlappenden Grenzen.

### <a name="remarks"></a>Bemerkungen

Die Breite des Rechtecks, die durch den absoluten Wert von *x2* - *x1*angegeben wird, darf 32.767 Einheiten nicht überschreiten. Diese Grenze gilt auch für die Höhe des Rechtecks.

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>CDC::ExcludeUpdateRgn

Verhindert das Zeichnen innerhalb ungültiger Bereiche eines Fensters, indem ein aktualisierter `CDC` Bereich im Fenster aus dem dem Objekt zugeordneten Zuschneidebereich ausgeschlossen wird.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parameter

*pWnd*<br/>
Zeigt auf das Fensterobjekt, dessen Fenster aktualisiert wird.

### <a name="return-value"></a>Rückgabewert

Der Typ des ausgeschlossenen Bereichs. Es kann einer der folgenden Werte sein:

- COMPLEXREGION Die Region hat überlappende Grenzen.

- FEHLER Es wurde keine Region erstellt.

- NULLREGION Die Region ist leer.

- SIMPLEREGION Die Region hat keine überlappenden Grenzen.

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>CDC::ExtFloodFill

Füllt einen Bereich der Anzeigefläche mit dem aktuellen Pinsel.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate des Punkts an, an dem die Füllung beginnt.

*y*<br/>
Gibt die logische y-Koordinate des Punkts an, an dem die Füllung beginnt.

*crColor*<br/>
Gibt die Farbe der Begrenzung oder des zu füllenden Bereichs an. Die Interpretation von *crColor* hängt vom Wert von *nFillType ab.*

*nFillType*<br/>
Gibt den Typ der durchzuführenden Überflutunganfüllung an. Es muss einer der folgenden Werte sein:

- FLOODFILLBORDER Der Füllbereich wird durch die von *crColor*angegebene Farbe begrenzt. Dieser Stil ist identisch mit `FloodFill`der Füllung, die von ausgeführt wird.

- FLOODFILLSURFACE Der Füllbereich wird durch die von *crColor*angegebene Farbe definiert. Die Füllung geht nach außen in alle Richtungen weiter, solange die Farbe angetroffen wird. Dieser Stil ist nützlich, um Bereiche mit mehrfarbigen Grenzen zu füllen.

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich Null, wenn die Funktion erfolgreich ist; Andernfalls 0, wenn die Füllung nicht abgeschlossen werden konnte, wenn der angegebene Punkt die von *crColor* angegebene Begrenzungsfarbe aufweist (wenn FLOODFILLBORDER angefordert wurde), wenn der angegebene Punkt nicht die von *crColor* angegebene Farbe aufweist (wenn FLOODFILLSURFACE angefordert wurde), oder wenn sich der Punkt außerhalb des Clipping-Bereichs befindet.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion bietet `FloodFill` mehr Flexibilität, als da Sie einen Fülltyp in *nFillType*angeben können.

Wenn *nFillType* auf FLOODFILLBORDER festgelegt ist, wird davon ausgegangen, dass der Bereich vollständig durch die von *crColor*angegebene Farbe begrenzt ist. Die Funktion beginnt an dem punkt, der durch *x* und *y* angegeben wird, und füllt in alle Richtungen zur Farbgrenze aus.

Wenn *nFillType* auf FLOODFILLSURFACE festgelegt ist, beginnt die Funktion an dem punkt, der durch *x* und *y* angegeben wird, und wird in alle Richtungen fortgesetzt, indem alle angrenzenden Bereiche gefüllt werden, die die von *crColor*angegebene Farbe enthalten.

Nur Speichergerätekontexte und Geräte, die Raster-Display-Technologie `ExtFloodFill`unterstützen. Weitere Informationen finden Sie in der [GetDeviceCaps-Memberfunktion.](#getdevicecaps)

## <a name="cdcexttextout"></a><a name="exttextout"></a>CDC::ExtTextOut

Rufen Sie diese Memberfunktion auf, um eine Zeichenfolge innerhalb eines rechteckigen Bereichs mit der aktuell ausgewählten Schriftart zu schreiben.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate der Zeichenzelle für das erste Zeichen in der angegebenen Zeichenfolge an.

*y*<br/>
Gibt die logische y-Koordinate des oberen Rands der Zeichenzelle für das erste Zeichen in der angegebenen Zeichenfolge an.

*nOptionen*<br/>
Gibt den Rechtecktyp an. Dieser Parameter kann ein, beide oder keiner der folgenden Werte sein:

- ETO_CLIPPED Gibt an, dass Text auf das Rechteck abgeschnitten wird.

- ETO_OPAQUE Gibt an, dass die aktuelle Hintergrundfarbe das Rechteck ausfüllt. (Sie können die aktuelle Hintergrundfarbe mit den [Elementfunktionen SetBkColor](#setbkcolor) und [GetBkColor](#getbkcolor) festlegen und abfragen.)

*lpRect*<br/>
Zeigt auf eine [RECT-Struktur,](/windows/win32/api/windef/ns-windef-rect) die die Abmessungen des Rechtecks bestimmt. Dieser Parameter kann NULL sein. Sie können auch ein [CRect-Objekt](../../atl-mfc-shared/reference/crect-class.md) für diesen Parameter übergeben.

*lpszString*<br/>
Zeigt auf die angegebene Zeichenfolge, die gezeichnet werden soll. Sie können auch ein [CString-Objekt](../../atl-mfc-shared/reference/cstringt-class.md) für diesen Parameter übergeben.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an.

*lpDxWidths*<br/>
Zeigt auf ein Array von Werten, die den Abstand zwischen den Ursprüngen benachbarter Zeichenzellen angeben. Beispielsweise trennen *lpDxWidths*[ *i*] logische Einheiten die Ursprünge der Zeichenzelle *i* und der Zeichenzelle *i* + 1. Wenn *lpDxWidths* NULL `ExtTextOut` ist, wird der Standardabstand zwischen Zeichen verwendet.

*Str*<br/>
Ein `CString` Objekt, das die angegebenen Zeichen enthält, die gezeichnet werden sollen.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der rechteckige Bereich kann undurchsichtig sein (gefüllt mit der aktuellen Hintergrundfarbe), und es kann ein Zuschneidebereich sein.

Wenn *nOptions* 0 und *lpRect* NULL ist, schreibt die Funktion Text in den Gerätekontext, ohne einen rechteckigen Bereich zu verwenden. Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert. Wenn eine Anwendung `ExtTextOut`beim Aufrufen die aktuelle Position aktualisieren `CDC` muss, kann die Anwendung die Memberfunktion [SetTextAlign](#settextalign) aufrufen, wobei *nFlags* auf TA_UPDATECP festgelegt ist. Wenn dieses Flag gesetzt ist, ignoriert Windows *x* und *y* bei nachfolgenden Aufrufen `ExtTextOut` und verwendet stattdessen die aktuelle Position. Wenn eine Anwendung TA_UPDATECP verwendet, `ExtTextOut` um die aktuelle Position zu aktualisieren, legt die aktuelle Position entweder an das Ende der vorherigen Textzeile oder auf die Position fest, die durch das letzte Element des Arrays angegeben wird, auf das von *lpDxWidths*verwiesen wird, je nachdem, welcher Wert größer ist.

## <a name="cdcfillpath"></a><a name="fillpath"></a>CDC::FillPath

Schließt alle offenen Figuren im aktuellen Pfad und füllt das Innere des Pfads mit dem aktuellen Pinsel- und Polygonfüllmodus aus.

```
BOOL FillPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Nachdem sein Inneres gefüllt wurde, wird der Pfad aus dem Gerätekontext verworfen.

## <a name="cdcfillrect"></a><a name="fillrect"></a>CDC::FillRect

Rufen Sie diese Memberfunktion auf, um ein bestimmtes Rechteck mit dem angegebenen Pinsel auszufüllen.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Zeigt auf eine [RECT-Struktur,](/windows/win32/api/windef/ns-windef-rect) die die logischen Koordinaten des auszufüllenden Rechtecks enthält. Sie können auch ein [CRect-Objekt](../../atl-mfc-shared/reference/crect-class.md) für diesen Parameter übergeben.

*pBrush*<br/>
Identifiziert den Pinsel, der zum Ausfüllen des Rechtecks verwendet wird.

### <a name="remarks"></a>Bemerkungen

Die Funktion füllt das gesamte Rechteck, einschließlich des linken und oberen Rahmens, aber sie füllt nicht den rechten und unteren Rahmen.

Der Pinsel muss entweder mit den [CBrush-Memberfunktionen](../../mfc/reference/cbrush-class.md) [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)und `GetStockObject` [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)erstellt oder von der Windows-Funktion abgerufen werden.

Wenn Sie das `FillRect` angegebene Rechteck füllen, werden die rechte und untere Seite des Rechtecks nicht eingeschlossen. GDI füllt ein Rechteck bis zur rechten Spalte und der unteren Zeile, jedoch nicht, unabhängig vom aktuellen Zuordnungsmodus. `FillRect`vergleicht die Werte `top` `bottom`von `left`, `right` , und den Elementen des angegebenen Rechtecks. Wenn `bottom` kleiner oder gleich `top`, `right` oder wenn kleiner `left`oder gleich ist , wird das Rechteck nicht gezeichnet.

`FillRect`ist ähnlich wie [CDC::FillSolidRect](#fillsolidrect); `FillRect` Nimmt jedoch einen Pinsel und kann daher verwendet werden, um ein Rechteck mit einer Volltonfarbe, einer gezauderten Farbe, geschlüpften Pinsel oder einem Muster zu füllen. `FillSolidRect`verwendet nur Volltonfarben (angezeigt durch einen COLORREF-Parameter). `FillRect`ist in der `FillSolidRect`Regel langsamer als .

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>CDC::FillRgn

Füllt den von *pRgn* angegebenen Bereich mit dem pinsel, der von *pBrush*angegeben wird.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parameter

*pRgn*<br/>
Ein Zeiger auf die zu füllende Region. Die Koordinaten für den angegebenen Bereich werden in logischen Einheiten angegeben.

*pBrush*<br/>
Identifiziert den Pinsel, der zum Ausfüllen der Region verwendet werden soll.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Pinsel muss entweder `CBrush` mit `CreateHatchBrush`den `CreatePatternBrush` `CreateSolidBrush`Memberfunktionen , `GetStockObject`, erstellt oder von abgerufen werden.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>CDC::FillSolidRect

Rufen Sie diese Memberfunktion auf, um das angegebene Rechteck mit der angegebenen Volltonfarbe zu füllen.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Gibt das umgrenzende Rechteck (in logischen Einheiten) an. Sie können entweder einen Zeiger an eine [RECT-Datenstruktur](/windows/win32/api/windef/ns-windef-rect) oder ein `CRect` Objekt für diesen Parameter übergeben.

*clr* Gibt die Farbe an, die zum Ausfüllen des Rechtecks verwendet werden soll.

*X*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Rechtecks an.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Zielrechtecks an.

*Cx*<br/>
Gibt die Breite des Rechtecks an.

*Cy*<br/>
Gibt die Höhe des Rechtecks an.

### <a name="remarks"></a>Bemerkungen

`FillSolidRect`ist CDC sehr [ähnlich::FillRect](#fillrect); `FillSolidRect` Verwendet jedoch nur Volltonfarben (angezeigt durch `FillRect` den Parameter COLORREF), während ein Pinsel verwendet wird und daher verwendet werden kann, um ein Rechteck mit einer Volltonfarbe, einer geditheten Farbe, geschlüpften Pinsel oder einem Muster zu füllen. `FillSolidRect`ist in `FillRect`der Regel schneller als .

> [!NOTE]
> Wenn Sie `FillSolidRect`aufrufen, wird die Hintergrundfarbe, die zuvor mit [SetBkColor](#setbkcolor)festgelegt wurde, auf die von *clr*angezeigte Farbe festgelegt.

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>CDC::FlattenPath

Transformiert alle Kurven im ausgewählten Pfad in den aktuellen Gerätekontext und verwandelt jede Kurve in eine Folge von Linien.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

## <a name="cdcfloodfill"></a><a name="floodfill"></a>CDC::FloodFill

Füllt einen Bereich der Anzeigefläche mit dem aktuellen Pinsel.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate des Punkts an, an dem die Füllung beginnt.

*y*<br/>
Gibt die logische y-Koordinate des Punkts an, an dem die Füllung beginnt.

*crColor*<br/>
Gibt die Farbe der Begrenzung an.

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich Null, wenn die Funktion erfolgreich ist; Andernfalls wird 0 zurückgegeben, wenn die Füllung nicht abgeschlossen werden konnte, der angegebene Punkt die von *crColor*angegebene Begrenzungsfarbe hat oder der Punkt außerhalb des Zuschneidebereichs liegt.

### <a name="remarks"></a>Bemerkungen

Es wird davon ausgegangen, dass der Bereich wie von *crColor*angegeben begrenzt wird. Die `FloodFill` Funktion beginnt an dem punkt, der durch *x* und *y* angegeben wird, und fährt in allen Richtungen zur Farbgrenze fort.

Nur Speichergerätekontexte und Geräte, die Raster-Display-Technologie unterstützen, unterstützen die `FloodFill` Memberfunktion. Informationen zu RC_BITBLT-Funktion `GetDeviceCaps` finden Sie in der Memberfunktion.

Die `ExtFloodFill` Funktion bietet eine ähnliche Fähigkeit, aber mehr Flexibilität.

## <a name="cdcframerect"></a><a name="framerect"></a>CDC::FrameRect

Zeichnet einen Rahmen um das von *lpRect*angegebene Rechteck.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Zeigt auf eine [RECT-Struktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Objekt,](../../atl-mfc-shared/reference/crect-class.md) das die logischen Koordinaten der oberen linken und unteren rechten Ecke des Rechtecks enthält. Sie können auch `CRect` ein Objekt für diesen Parameter übergeben.

*pBrush*<br/>
Identifiziert den Pinsel, der zum Einrahmen des Rechtecks verwendet werden soll.

### <a name="remarks"></a>Bemerkungen

Die Funktion verwendet den angegebenen Pinsel, um den Rahmen zu zeichnen. Die Breite und Höhe des Rahmens ist immer 1 logische Einheit.

Wenn `bottom` die Koordinate des Rechtecks `top`kleiner oder `right` gleich ist oder `left`kleiner oder gleich ist, wird das Rechteck nicht gezeichnet.

Der durchgezogene `FrameRect` Rahmen befindet sich an der `Rectangle` gleichen Position wie ein `Rectangle` Rahmen, der von der Memberfunktion mit denselben Koordinaten gezeichnet wird (wenn ein Stift verwendet wird, der 1 logische Einheit breit ist). Das Innere des Rechtecks `FrameRect`wird nicht von gefüllt.

## <a name="cdcframergn"></a><a name="framergn"></a>CDC::FrameRgn

Zeichnet einen Rahmen um den von *pRgn* angegebenen Bereich mit dem pinsel, der von *pBrush*angegeben wird.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*pRgn*<br/>
Zeigt auf `CRgn` das Objekt, das den Bereich identifiziert, der in einen Rahmen eingeschlossen werden soll. Die Koordinaten für den angegebenen Bereich werden in logischen Einheiten angegeben.

*pBrush*<br/>
Zeigt auf `CBrush` das Objekt, das den Pinsel identifiziert, der zum Zeichnen des Rahmens verwendet werden soll.

*nWidth*<br/>
Gibt die Breite des Rahmens in vertikalen Pinselstrichen in Geräteeinheiten an.

*nHeight*<br/>
Gibt die Höhe des Rahmens in horizontalen Pinselstrichen in Geräteeinheiten an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>CDC::FromHandle

Gibt einen Zeiger `CDC` auf ein Objekt zurück, wenn einem Gerätekontext ein Handle übergeben wird.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parameter

*Hdc*<br/>
Enthält ein Handle für einen Windows-Gerätekontext.

### <a name="return-value"></a>Rückgabewert

Der Zeiger kann temporär sein und sollte nicht über die sofortige Verwendung hinaus gespeichert werden.

### <a name="remarks"></a>Bemerkungen

Wenn ein `CDC`-Objekt nicht an das Handle angefügt ist, wird ein temporäres `CDC`-Objekt erstellt und angefügt.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>CDC::GetArcDirection

Gibt die aktuelle Bogenrichtung für den Gerätekontext zurück.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Rückgabewert

Gibt die aktuelle Bogenrichtung an, wenn sie erfolgreich ist. Im Folgenden sind die gültigen Rückgabewerte:

- AD_COUNTERCLOCKWISE Bögen und Rechtecke, die gegen den Uhrzeigersinn gezeichnet werden.

- AD_CLOCKWISE Bögen und Rechtecke im Uhrzeigersinn gezeichnet.

Wenn ein Fehler auftritt, ist der Rückgabewert Null.

### <a name="remarks"></a>Bemerkungen

Bogen- und Rechteckfunktionen verwenden die Bogenrichtung.

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>CDC::GetAspectRatioFilter

Ruft die Einstellung für den aktuellen Seiten-Verhältnis-Filter ab.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Rückgabewert

Ein `CSize` Objekt, das das Seitenverhältnis darstellt, das vom aktuellen Seitenverhältnisfilter verwendet wird.

### <a name="remarks"></a>Bemerkungen

Das Seitenverhältnis ist das Verhältnis, das durch die Pixelbreite und -höhe eines Geräts gebildet wird. Informationen über das Seitenverhältnis eines Geräts werden bei der Erstellung, Auswahl und Anzeige von Schriftarten verwendet. Windows bietet einen speziellen Filter, den Seiten-Verhältnis-Filter, um Schriftarten auszuwählen, die für ein bestimmtes Seitenverhältnis aus allen verfügbaren Schriftarten entwickelt wurden. Der Filter verwendet das von `SetMapperFlags` der Memberfunktion angegebene Seitenverhältnis.

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>CDC::GetBkColor

Gibt die aktuelle Hintergrundfarbe zurück.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Rückgabewert

Ein RGB-Farbwert.

### <a name="remarks"></a>Bemerkungen

Wenn der Hintergrundmodus OPAQUE ist, verwendet das System die Hintergrundfarbe, um die Lücken in gestylten Linien, die Lücken zwischen schraffierten Linien in Pinsel nund den Hintergrund in Zeichenzellen zu füllen. Das System verwendet auch die Hintergrundfarbe beim Konvertieren von Bitmaps zwischen Farb- und monochromen Gerätekontexten.

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>CDC::GetBkMode

Gibt den Hintergrundmodus zurück.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der aktuelle Hintergrundmodus, der OPAQUE oder TRANSPARENT sein kann.

### <a name="remarks"></a>Bemerkungen

Der Hintergrundmodus definiert, ob das System vorhandene Hintergrundfarben auf der Zeichnungsfläche entfernt, bevor Text, schraffierte Pinsel oder ein Stiftstil gezeichnet werden, der keine durchgezogene Linie ist.

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>CDC::GetBoundsRect

Gibt das aktuelle akkumulierte Umgrenzungsrechteck für den angegebenen Gerätekontext zurück.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parameter

*lpRectBounds*<br/>
Zeigt auf einen Puffer, der das aktuelle umgrenzte Rechteck empfängt. Das Rechteck wird in logischen Koordinaten zurückgegeben.

*Flaggen*<br/>
Gibt an, ob das umgrenzende Rechteck gelöscht werden soll, nachdem es zurückgegeben wurde. Dieser Parameter sollte Null sein oder auf den folgenden Wert festgelegt werden:

- DCB_RESET Erzwingt, dass das umschließende Rechteck nach der Rückgabe gelöscht wird.

### <a name="return-value"></a>Rückgabewert

Gibt den aktuellen Status des umlaufenden Rechtecks an, wenn die Funktion erfolgreich ist. Es kann eine Kombination der folgenden Werte sein:

- DCB_ACCUMULATE Die Akkumulation des gebundenen Rechtecks findet statt.

- DCB_RESET Begrenzungsrechteck ist leer.

- DCB_SET Begrenzungsrechteck ist nicht leer.

- DCB_ENABLE Begrenzungsakkumulation ist eingeschaltet.

- DCB_DISABLE Begrenzungsakkumulation ist aus.

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>CDC::GetBrushOrg

Ruft den Ursprung (in Geräteeinheiten) des Pinsels ab, der derzeit für den Gerätekontext ausgewählt ist.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Rückgabewert

Der aktuelle Ursprung des Pinsels (in Geräteeinheiten) als [CPoint-Objekt.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="remarks"></a>Bemerkungen

Der ursprüngliche Pinselursprung liegt bei (0,0) des Clientbereichs. Der Rückgabewert gibt diesen Punkt in Geräteeinheiten relativ zum Ursprung des Desktopfensters an.

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>CDC::GetCharacterPlacement

Ruft verschiedene Typen von Informationen zu einer Zeichenfolge ab.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parameter

*lpString*<br/>
Ein Zeiger auf die zu verarbeitende Zeichenfolge.

*nCount*<br/>
Gibt die Länge der Zeichenfolge an. Bei der ANSI-Version ist es eine Byteanzahl und bei der Unicode-Funktion ist es eine Wortanzahl. Weitere Informationen finden Sie unter [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw).

*nMaxExtent*<br/>
Gibt der maximale Wertbereich (in logischen Einheiten) an, zu dem die Zeichenfolge verarbeitet wird. Zeichen, die diesen Wertbereich bei Verarbeitung überschreiten würden, werden ignoriert. Berechnungen für alle erforderlichen Reihenfolge- oder Glyphenarrays gelten nur für die enthaltenen Zeichen. Dieser Parameter wird nur verwendet, wenn der GCP_MAXEXTENT Wert im Parameter *dwFlags* angegeben ist. Da die Funktion die Eingabezeichenfolge verarbeitet, wird jedes Zeichen und sein Wertebereich nur dann der Ausgabe, dem Wertebereich und anderen Arrays hinzugefügt, wenn der gesamte Wertebereich das Maximum noch nicht überschritten hat. Bei Erreichen des Limits wird die Verarbeitung beendet.

*lpResults*<br/>
Zeiger auf eine [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) Struktur, die die Ergebnisse der Funktion empfängt.

*dwFlags*<br/>
Gibt das Verarbeiten der Zeichenfolge in die erforderlichen Arrays an. Dieser Parameter kann einer oder mehrere der werte sein, die im Abschnitt *dwFlags* des [GetCharacterPlacement-Themas](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw) aufgeführt sind.

*Str*<br/>
Ein Zeiger auf ein zu verarbeitendes [CString-Objekt.](../../atl-mfc-shared/reference/cstringt-class.md)

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, handelt es sich bei dem Rückgabewert um die Breite und Höhe der Zeichenfolge in logischen Einheiten.

Wenn die Funktion fehlerhaft ist, ist der Rückgabewert null.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion emuliert die Funktionalität der Funktion [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw), wie im Windows SDK beschrieben.

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>CDC::GetCharABCBreiten

Ruft die Breiten aufeinander folgender Zeichen in einem angegebenen Bereich aus der aktuellen TrueType-Schriftart ab.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parameter

*nFirstChar*<br/>
Gibt das erste Zeichen im Zeichenbereich aus der aktuellen Schriftart an, für das Zeichenbreiten zurückgegeben werden.

*nLastChar*<br/>
Gibt das letzte Zeichen im Zeichenbereich aus der aktuellen Schriftart an, für das Zeichenbreiten zurückgegeben werden.

*lpabc*<br/>
Zeigt auf ein Array von [ABC-Strukturen,](/windows/win32/api/wingdi/ns-wingdi-abc) die die Zeichenbreiten erhalten, wenn die Funktion zurückkehrt. Dieses Array muss mindestens `ABC` so viele Strukturen enthalten, wie Zeichen im Bereich vorhanden sind, der durch die Parameter *nFirstChar* und *nLastChar* angegeben wird.

*lpABCF*<br/>
Verweist auf einen von der Anwendung bereitgestellten Puffer mit einem Array von [ABCFLOAT-Strukturen,](/windows/win32/api/wingdi/ns-wingdi-abcfloat) um die Zeichenbreiten zu erhalten, wenn die Funktion zurückgegeben wird. Die von dieser Funktion zurückgegebenen Breiten befinden sich im IEEE-Gleitkommaformat.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Breiten werden in logischen Einheiten zurückgegeben. Diese Funktion ist nur mit TrueType-Schriftarten erfolgreich.

Der TrueType-Rasterizer stellt den Zeichenabstand "ABC" bereit, nachdem eine bestimmte Punktgröße ausgewählt wurde. "A"-Abstand ist der Abstand, der der aktuellen Position hinzugefügt wird, bevor die Glyphe platziert wird. Der Abstand "B" ist die Breite des schwarzen Teils der Glyphe. Der Abstand "C" wird der aktuellen Position hinzugefügt, um den Leerraum rechts neben der Glyphe zu berücksichtigen. Die gesamte erweiterte Breite wird durch A + B + C angegeben.

Wenn `GetCharABCWidths` die Memberfunktion negative "A"- oder "C"-Breiten für ein Zeichen abruft, enthält dieses Zeichen Unterhänge oder Überhänge.

Um die ABC-Breiten in Schriftartentwurfseinheiten zu konvertieren, sollte eine `lfHeight` Anwendung eine Schriftart erstellen, deren Höhe `ntmSizeEM` (wie im Element der [LOGFONT-Struktur](/windows/win32/api/wingdi/ns-wingdi-logfontw) angegeben) dem Wert entspricht, der im Element der [NEWTEXTMETRIC-Struktur](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) gespeichert ist. (Der Wert `ntmSizeEM` des Members kann abgerufen werden, indem die [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) Windows-Funktion aufgerufen wird.)

Die ABC-Breiten des Standardzeichens werden für Zeichen verwendet, die außerhalb des Bereichs der aktuell ausgewählten Schriftart liegen.

Um die Breiten von Zeichen in Nicht-TrueType-Schriftarten abzurufen, sollten Anwendungen die [GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) Windows-Funktion verwenden.

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI

Ruft die Breiten in logischen Einheiten von aufeinander folgenden Glyphenindizes in einem angegebenen Bereich von der aktuellen TrueType-Schriftart ab.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parameter

*giFirst*<br/>
Gibt den ersten Glyphenindex in der Gruppe der aufeinanderfolgenden Glyphenindizes aus der aktuellen Schriftart an. Dieser Parameter wird nur verwendet, wenn der *pgi-Parameter* NULL ist.

*Cgi*<br/>
Gibt die Anzahl der Glyphenindizes an.

*Pgi*<br/>
Ein Zeiger auf ein Array, das Glyphenindizes enthält. Wenn der Wert NULL ist, wird stattdessen der *giFirst-Parameter* verwendet. Der *Parameter cgi* gibt die Anzahl der Glyphenindizes in diesem Array an.

*lpabc*<br/>
Zeiger auf ein Array von [ABC-Strukturen,](/windows/win32/api/wingdi/ns-wingdi-abc) die die Zeichenbreiten empfangen. Dieses Array muss mindestens `ABC` so viele Strukturen enthalten, wie durch den *cgi-Parameter* angegeben sind.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion emuliert die Funktionalität der Funktion [GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi), wie im Windows SDK beschrieben.

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>CDC::GetCharWidth

Ruft die Breiten einzelner Zeichen in einer aufeinanderfolgenden Gruppe von `m_hAttribDC`Zeichen aus der aktuellen Schriftart mithilfe des Eingabegerätekontexts ab.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parameter

*nFirstChar*<br/>
Gibt das erste Zeichen in einer aufeinanderfolgenden Gruppe von Zeichen in der aktuellen Schriftart an.

*nLastChar*<br/>
Gibt das letzte Zeichen in einer aufeinanderfolgenden Gruppe von Zeichen in der aktuellen Schriftart an.

*lpBuffer*<br/>
Zeigt auf einen Puffer, der die Breitenwerte für eine aufeinanderfolgende Gruppe von Zeichen in der aktuellen Schriftart empfängt.

*lpFloatBuffer*<br/>
Zeigt auf einen Puffer, um die Zeichenbreiten zu erhalten. Die zurückgegebenen Breiten befinden sich im 32-Bit-IEEE-Gleitkommaformat. (Die Breiten werden entlang der Grundlinie der Zeichen gemessen.)

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Wenn *nFirstChar* beispielsweise den Buchstaben 'a' und *nLastChar* den Buchstaben 'z' identifiziert, ruft die Funktion die Breiten aller Kleinbuchstaben ab.

Die Funktion speichert die Werte im Puffer, auf den *lpBuffer*zeigt. Dieser Puffer muss groß genug sein, um alle Breiten zu halten. Das heißt, es müssen mindestens 26 Einträge im gegebenen Beispiel enthalten.

Wenn ein Zeichen in der aufeinanderfolgenden Zeichengruppe in einer bestimmten Schriftart nicht vorhanden ist, wird ihm der Breitenwert des Standardzeichens zugewiesen.

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>CDC::GetCharWidthI

Ruft die Breiten in logischen Koordinaten von aufeinander folgenden Glyphenindizes in einem angegebenen Bereich von der aktuellen Schriftart ab.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parameter

*giFirst*<br/>
Gibt den ersten Glyphenindex in der Gruppe der aufeinanderfolgenden Glyphenindizes aus der aktuellen Schriftart an. Dieser Parameter wird nur verwendet, wenn der *pgi-Parameter* NULL ist.

*Cgi*<br/>
Gibt die Anzahl der Glyphenindizes an.

*Pgi*<br/>
Ein Zeiger auf ein Array, das Glyphenindizes enthält. Wenn der Wert NULL ist, wird stattdessen der *giFirst-Parameter* verwendet. Der *Parameter cgi* gibt die Anzahl der Glyphenindizes in diesem Array an.

*lpBuffer*<br/>
Ein Zeiger auf einen Puffer, der die Breiten empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion emuliert die Funktionalität der Funktion [GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi), wie im Windows SDK beschrieben.

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>CDC::GetClipBox

Ruft die Bemaßungen des engsten umgrenzenden Rechtecks um die aktuelle Zuschneidegrenze ab.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Zeigt auf die [RECT-Struktur](/windows/win32/api/windef/ns-windef-rect) oder das [CRect-Objekt,](../../atl-mfc-shared/reference/crect-class.md) das die Rechteckbemaßungen empfangen soll.

### <a name="return-value"></a>Rückgabewert

Der Typ des Clipping-Bereichs. Dabei kann es sich um einen der folgenden Werte handeln:

- COMPLEXREGION Clipping-Bereich hat überlappende Grenzen.

- FEHLER Gerätekontext ist ungültig.

- NULLREGION Clipping-Bereich ist leer.

- SIMPLEREGION Clipping-Bereich hat keine überlappenden Rahmen.

### <a name="remarks"></a>Bemerkungen

Die Dimensionen werden in den Puffer kopiert, auf den *lpRect*zeigt.

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>CDC::GetColorAdjustment

Ruft die Farbanpassungswerte für den Gerätekontext ab.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parameter

*lpColorAdjust*<br/>
Zeigt auf eine [COLORADJUSTMENT-Datenstruktur,](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) um die Farbanpassungswerte zu erhalten.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>CDC::GetCurrentBitmap

Gibt einen Zeiger auf `CBitmap` das aktuell ausgewählte Objekt zurück.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf `CBitmap` ein Objekt, falls erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion kann temporäre Objekte zurückgeben.

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>CDC::GetCurrentBrush

Gibt einen Zeiger auf `CBrush` das aktuell ausgewählte Objekt zurück.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf `CBrush` ein Objekt, falls erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion kann temporäre Objekte zurückgeben.

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>CDC::GetCurrentFont

Gibt einen Zeiger auf `CFont` das aktuell ausgewählte Objekt zurück.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf `CFont` ein Objekt, falls erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion kann temporäre Objekte zurückgeben.

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>CDC::GetCurrentPalette

Gibt einen Zeiger auf `CPalette` das aktuell ausgewählte Objekt zurück.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf `CPalette` ein Objekt, falls erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion kann temporäre Objekte zurückgeben.

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>CDC::GetCurrentPen

Gibt einen Zeiger auf `CPen` das aktuell ausgewählte Objekt zurück.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf `CPen` ein Objekt, falls erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion kann temporäre Objekte zurückgeben.

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>CDC::GetCurrentPosition

Ruft die aktuelle Position ab (in logischen Koordinaten).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Rückgabewert

Die aktuelle Position `CPoint` als Objekt.

### <a name="remarks"></a>Bemerkungen

Die aktuelle Position kann `MoveTo` mit der Memberfunktion eingestellt werden.

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>CDC::GetDCBrushColor

Ruft die aktuelle Pinselfarbe ab.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, ist der Rückgabewert der [COLORREF-Wert](/windows/win32/gdi/colorref) für die aktuelle Pinselfarbe.

Wenn die Funktion fehlerhaft ist, ist der Rückgabewert CLR_INVALID.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion emuliert die Funktionalität der Funktion [GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor), wie im Windows SDK beschrieben.

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>CDC::GetDCPenColor

Ruft die aktuelle Stiftfarbe ab.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, ist der Rückgabewert der [COLORREF-Wert](/windows/win32/gdi/colorref) für die aktuelle Stiftfarbe.

Wenn die Funktion fehlerhaft ist, ist der Rückgabewert CLR_INVALID.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion verwendet die Win32-Funktion [GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor), wie im Windows SDK beschrieben.

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>CDC::GetDeviceCaps

Ruft eine Vielzahl gerätespezifischer Informationen über das Anzeigegerät ab.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parameter

*nIndex*<br/>
Gibt den Typ der zurückzugebenden Informationen an. Eine Liste von Werten finden Sie unter [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) im Windows SDK.

### <a name="return-value"></a>Rückgabewert

Der Wert der angeforderten Funktion, wenn die Funktion erfolgreich ist.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>CDC::GetFontData

Ruft schriftmetrikmetrische Informationen aus einer skalierbaren Schriftartdatei ab.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parameter

*dwTable*<br/>
Gibt den Namen der zurückzugebenden Metriktabelle an. Dieser Parameter kann eine der Metriktabellen sein, die in der TrueType Font Files-Spezifikation dokumentiert sind, die von der Microsoft Corporation veröffentlicht wurde. Wenn dieser Parameter 0 ist, werden die Informationen ab dem Anfang der Schriftartdatei abgerufen.

*dwOffset*<br/>
Gibt den Offset vom Anfang der Tabelle an, an dem mit dem Abrufen von Informationen begonnen werden soll. Wenn dieser Parameter 0 ist, werden die Informationen ab dem Anfang der Tabelle abgerufen, die durch den Parameter *dwTable* angegeben wird. Wenn dieser Wert größer oder gleich der Größe `GetFontData` der Tabelle ist, wird 0 zurückgegeben.

*lpData*<br/>
Verweist auf einen Puffer, der die Schriftartinformationen empfängt. Wenn dieser Wert NULL ist, gibt die Funktion die Größe des Puffers zurück, der für die im *Parameter dwTable* angegebenen Schriftartdaten erforderlich ist.

*cbData*<br/>
Gibt die Länge der abzuholenden Informationen in Bytes an. Wenn dieser Parameter `GetFontData` 0 ist, wird die Größe der im *Parameter dwTable* angegebenen Daten zurückgegeben.

### <a name="return-value"></a>Rückgabewert

Gibt die Anzahl der Bytes an, auf die im Puffer von *lpData* verwiesen wird, wenn die Funktion erfolgreich ist. andernfalls -1.

### <a name="remarks"></a>Bemerkungen

Die abzurufenden Informationen werden identifiziert, indem ein Offset in der Schriftartdatei und die Länge der zurückzugebenden Informationen angegeben werden.

Eine Anwendung kann `GetFontData` manchmal die Memberfunktion verwenden, um eine TrueType-Schriftart mit einem Dokument zu speichern. Dazu bestimmt die Anwendung, ob die Schriftart eingebettet werden kann, und ruft dann die gesamte Schriftartdatei ab, die 0 für die Parameter *dwTable*, *dwOffset*und *cbData* angibt.

Anwendungen können bestimmen, ob eine Schriftart eingebettet werden kann, indem sie das `otmfsType` Element der [OUTLINETEXTMETRIC-Struktur](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) überprüfen. Wenn Bit `otmfsType` 1 von gesetzt ist, ist das Einbetten für die Schriftart nicht zulässig. Wenn Bit 1 klar ist, kann die Schriftart eingebettet werden. Wenn Bit 2 gesetzt ist, ist die Einbettung schreibgeschützt.

Wenn eine Anwendung versucht, diese Funktion zum Abrufen von Informationen `GetFontData` für eine Nicht-TrueType-Schriftart zu verwenden, gibt die Memberfunktion -1 zurück.

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>CDC::GetFontLanguageInfo

Gibt Informationen zur aktuell ausgewählten Schriftart für den angegebenen Anzeigekontext zurück.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Rückgabewert

Der Rückgabewert identifiziert die Merkmale der aktuell ausgewählten Schriftart. Eine vollständige Auflistung möglicher Werte finden Sie unter [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion emuliert die Funktionalität der Funktion [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo), wie im Windows SDK beschrieben.

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>CDC::GetGlyphOutline

Ruft die Gliederungskurve oder Bitmap für ein Gliederungszeichen in der aktuellen Schriftart ab.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parameter

*Nchar*<br/>
Gibt das Zeichen an, für das Informationen zurückgegeben werden sollen.

*nFormat*<br/>
Gibt das Format an, in dem die Funktion Informationen zurückgeben soll. Dabei kann es sich um einen der folgenden Werte oder 0 handelt:

|Wert|Bedeutung|
|-----------|-------------|
|GGO_BITMAP|Gibt die Glyphenbitmap zurück. Wenn die Funktion zurückkehrt, enthält der Puffer, auf den *lpBuffer* zeigt, eine Bitmap mit 1 Bit pro Pixel, deren Zeilen mit Doppelwortgrenzen beginnen.|
|GGO_NATIVE|Gibt die Kurvendatenpunkte im nativen Format des Rasterizers mithilfe von Geräteeinheiten zurück. Wenn dieser Wert angegeben wird, wird jede in *lpmat2* angegebene Transformation ignoriert.|

Wenn der Wert von *nFormat* 0 ist, füllt die Funktion eine [GLYPHMETRICS-Struktur](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) aus, gibt jedoch keine Glyphenumrissdaten zurück.

*lpgm*<br/>
Zeigt auf eine GLYPHMETRICS-Struktur, die die Platzierung der Glyphe in der Zeichenzelle beschreibt.

*cbBuffer*<br/>
Gibt die Größe des Puffers an, in den die Funktion Informationen über das Gliederungszeichen kopiert. Wenn dieser Wert 0 ist und der *nFormat-Parameter* entweder der GGO_BITMAP oder GGO_NATIVE Werte ist, gibt die Funktion die erforderliche Größe des Puffers zurück.

*lpBuffer*<br/>
Zeigt auf einen Puffer, in den die Funktion Informationen über das Gliederungszeichen kopiert. Wenn *nFormat* den GGO_NATIVE Wert angibt, werden die Informationen in Form von TTPOLYGONHEADER- und TTPOLYCURVE-Strukturen kopiert. Wenn dieser Wert NULL ist und *nFormat* entweder der GGO_BITMAP- oder GGO_NATIVE-Wert ist, gibt die Funktion die erforderliche Größe des Puffers zurück.

*lpmat2*<br/>
Zeigt auf eine [MAT2-Struktur,](/windows/win32/api/wingdi/ns-wingdi-mat2) die eine Transformationsmatrix für das Zeichen enthält. Dieser Parameter kann nicht NULL sein, auch wenn der GGO_NATIVE Wert für *nFormat*angegeben ist.

### <a name="return-value"></a>Rückgabewert

Die Größe des Puffers, der für die abgerufenen Informationen erforderlich ist, wenn *cbBuffer* 0 oder *lpBuffer* NULL ist, in Bytes. Andernfalls ist es ein positiver Wert, wenn die Funktion erfolgreich ist, oder -1, wenn ein Fehler auftritt.

### <a name="remarks"></a>Bemerkungen

Eine Anwendung kann Zeichen drehen, die im Bitmapformat abgerufen werden, indem sie eine 2-mal-2-Transformationsmatrix in der Struktur angibt, auf die *lpmat2*zeigt.

Eine Glyphenumrisslinie wird als eine Reihe von Konturen zurückgegeben. Jede Kontur wird durch eine [TTPOLYGONHEADER-Struktur](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) definiert, gefolgt von so vielen `TTPOLYCURVE` Strukturen, wie erforderlich sind, um sie zu beschreiben. Alle Punkte werden als [POINTFX-Strukturen](/windows/win32/api/wingdi/ns-wingdi-pointfx) zurückgegeben und stellen absolute Positionen und keine relativen Bewegungen dar. Der vom `pfxStart` Element der [TTPOLYGONHEADER-Struktur](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) angegebene Ausgangspunkt ist der Punkt, an dem die Kontur für eine Kontur beginnt. Die [folgenden TTPOLYCURVE-Strukturen](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) können entweder Polyliniendatensätze oder Spline-Datensätze sein. Polyliniendatensätze sind eine Reihe von Punkten. Zwischen den Punkten gezeichnete Linien beschreiben die Umrisse des Zeichens. Spline-Datensätze stellen die quadratischen Kurven dar, die von TrueType verwendet werden (d. h. quadratische b-Splines).

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>CDC::GetGraphicsMode

Ruft den aktuellen Grafikmodus für den angegebenen Gerätekontext ab.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Rückgabewert

Gibt den aktuellen Grafikmodus bei Erfolg zurück. Eine Liste der Werte, die diese Methode zurückgeben kann, finden Sie unter [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

Gibt 0 bei Einem Fehler zurück.

Um erweiterte Fehlerinformationen zu erhalten, rufen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)an.

### <a name="remarks"></a>Bemerkungen

Diese Methode umschließt die Windows GDI-Funktion [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>CDC::GetHalftoneBrush

Rufen Sie diese Memberfunktion auf, um einen Halbtonpinsel abzurufen.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf `CBrush` ein Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Ein Halbtonpinsel zeigt Pixel an, die abwechselnd Vordergrund- und Hintergrundfarben sind, um ein gezaudertes Muster zu erstellen. Im Folgenden finden Sie ein Beispiel für ein gezaudertes Muster, das von einem Halbtonpinsel erstellt wird.

![Detail eines geditherten Stiftstrichs](../../mfc/reference/media/vc318s1.gif "Detail eines geditherten Stiftstrichs")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>CDC::GetKerningPairs

Ruft die Zeichenkerning-Paare für die Schriftart ab, die derzeit im angegebenen Gerätekontext ausgewählt ist.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parameter

*nPaare*<br/>
Gibt die Anzahl der [KERNINGPAIR-Strukturen](/windows/win32/api/wingdi/ns-wingdi-kerningpair) an, auf die *lpkrnpair*zeigt. Die Funktion kopiert nicht mehr Kerning-Paare als von *nPairs*angegeben.

*lpkrnpair*<br/>
Zeigt auf ein `KERNINGPAIR` Array von Strukturen, die die Kerning-Paare empfangen, wenn die Funktion zurückkehrt. Dieses Array muss mindestens so viele Strukturen enthalten, wie von *nPairs*angegeben. Wenn dieser Parameter NULL ist, gibt die Funktion die Gesamtzahl der Kerning-Paare für die Schriftart zurück.

### <a name="return-value"></a>Rückgabewert

Gibt die Anzahl der abgerufenen Kerning-Paare oder die Gesamtzahl der Kerning-Paare in der Schriftart an, wenn die Funktion erfolgreich ist. Null wird zurückgegeben, wenn die Funktion fehlschlägt oder keine Kerning-Paare für die Schriftart vorhanden sind.

## <a name="cdcgetlayout"></a><a name="getlayout"></a>CDC::GetLayout

Rufen Sie diese Memberfunktion auf, um das Layout des Textes und der Grafiken für einen Gerätekontext, z. B. einen Drucker oder eine Metadatei, zu bestimmen.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Rückgabewert

Bei Erfolg werden die Layoutflags für den aktuellen Gerätekontext flags. Andernfalls GDI_ERROR. Für erweiterte Fehlerinformationen rufen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)auf. Eine Liste der Layoutflags finden Sie unter [CDC::SetLayout](#setlayout).

### <a name="remarks"></a>Bemerkungen

Das Standardlayout ist von links nach rechts.

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>CDC::GetMapMode

Ruft den aktuellen Zuordnungsmodus ab.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der Zuordnungsmodus.

### <a name="remarks"></a>Bemerkungen

Eine Beschreibung der Zuordnungsmodi finden `SetMapMode` Sie in der Memberfunktion.

> [!NOTE]
> Wenn Sie [SetLayout](#setlayout) aufrufen, um den Domänencontroller `SetLayout` in ein Layout von rechts nach links zu ändern, ändert automatisch der Zuordnungsmodus in MM_ISOTROPIC. Folglich `GetMapMode` wird jeder nachfolgende Aufruf MM_ISOTROPIC zurück.

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>CDC::GetMiterLimit

Gibt das Gehrungslimit für den Gerätekontext zurück.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Gehrungsgrenze wird beim Zeichnen geometrischer Linien mit Gehrungsverknüpfungen verwendet.

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>CDC::GetNearestColor

Gibt die Volltonfarbe zurück, die am besten mit einer angegebenen logischen Farbe übereinstimmt.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parameter

*crColor*<br/>
Gibt die Farbe an, die abgeglichen werden soll.

### <a name="return-value"></a>Rückgabewert

Ein RGB-Farbwert (rot, grün, blau), der die Volltonfarbe definiert, die dem *crColor-Wert* am nächsten kommt, den das Gerät darstellen kann.

### <a name="remarks"></a>Bemerkungen

Das angegebene Gerät muss in der Lage sein, diese Farbe darzustellen.

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>CDC::GetOutlineTextMetrics

Ruft Metrikinformationen für TrueType-Schriftarten ab.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parameter

*lpotm*<br/>
Verweist auf ein Array von [OUTLINETEXTMETRIC-Strukturen.](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) Wenn dieser Parameter NULL ist, gibt die Funktion die Größe des Puffers zurück, der für die abgerufenen Metrikdaten erforderlich ist.

*cbData*<br/>
Gibt die Größe des Puffers in Bytes an, an den Informationen zurückgegeben werden.

*lpotm*<br/>
Zeigt auf `OUTLINETEXTMETRIC` eine Struktur. Wenn dieser Parameter NULL ist, gibt die Funktion die Größe des Puffers zurück, der für die abgerufenen Metrikinformationen erforderlich ist.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die [OUTLINETEXTMETRIC-Struktur](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) enthält die meisten Informationen zur Schriftmetrik, die mit dem TrueType-Format bereitgestellt werden, einschließlich einer [TEXTMETRIC-Struktur.](/windows/win32/api/wingdi/ns-wingdi-textmetricw) Die letzten vier `OUTLINETEXTMETRIC` Elemente der Struktur sind Zeiger auf Zeichenfolgen. Anwendungen sollten platzfür diese Zeichenfolgen zusätzlich zu dem Platzzuweisen, der für die anderen Member benötigt wird. Da es keine vom System auferlegte Begrenzung für die Größe der Zeichenfolgen gibt, besteht die einfachste Methode zum Zuweisen von `GetOutlineTextMetrics` Speicher darin, die erforderliche Größe abzurufen, indem im ersten Aufruf der Funktion NULL für *lpotm* angegeben wird.

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth

Verwendet den Kontext `m_hDC`des Ausgabegeräts und ruft die Breiten einzelner Zeichen in einer aufeinander folgenden Gruppe von Zeichen aus der aktuellen Schriftart ab.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parameter

*nFirstChar*<br/>
Gibt das erste Zeichen in einer aufeinanderfolgenden Gruppe von Zeichen in der aktuellen Schriftart an.

*nLastChar*<br/>
Gibt das letzte Zeichen in einer aufeinanderfolgenden Gruppe von Zeichen in der aktuellen Schriftart an.

*lpBuffer*<br/>
Zeigt auf einen Puffer, der die Breitenwerte für eine aufeinanderfolgende Gruppe von Zeichen in der aktuellen Schriftart empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Wenn *nFirstChar* beispielsweise den Buchstaben 'a' und *nLastChar* den Buchstaben 'z' identifiziert, ruft die Funktion die Breiten aller Kleinbuchstaben ab.

Die Funktion speichert die Werte im Puffer, auf den *lpBuffer*zeigt. Dieser Puffer muss groß genug sein, um alle Breiten zu halten. d. h., es müssen mindestens 26 Einträge im gegebenen Beispiel enthalten sein.

Wenn ein Zeichen in der aufeinanderfolgenden Zeichengruppe in einer bestimmten Schriftart nicht vorhanden ist, wird ihm der Breitenwert des Standardzeichens zugewiesen.

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>CDC::GetOutputTabbedTextExtent

Rufen Sie diese Memberfunktion auf, um die Breite und Höhe einer Zeichenfolge mithilfe [von m_hDC](#m_hdc), dem Ausgabegerätekontext, zu berechnen.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Zeigt auf eine zu messende Zeichenfolge. Sie können auch ein [CString-Objekt](../../atl-mfc-shared/reference/cstringt-class.md) für diesen Parameter übergeben.

*nCount*<br/>
Gibt die [Länge der Zeichenfolge](/windows/win32/gdi/specifying-length-of-text-output-string) an, auf die von *lpszString*verwiesen wird.

*nTabPositionen*<br/>
Gibt die Anzahl der Tabstopppositionen im Array an, auf die *lpnTabStopPositions*zeigt.

*lpnTabStopPositionen*<br/>
Zeigt auf ein Array von Ganzzahlen, die die Tabstopppositionen in logischen Einheiten enthalten. Die Tabstopps müssen in zunehmender Reihenfolge sortiert werden. der kleinste x-Wert sollte das erste Element im Array sein. Registerkarten zurück sind nicht zulässig.

*Str*<br/>
Ein `CString` Objekt, das die angegebenen Zeichen enthält, die gemessen werden sollen.

### <a name="return-value"></a>Rückgabewert

Die Dimensionen der Zeichenfolge (in logischen Einheiten) in einem [CSize-Objekt.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Bemerkungen

Wenn die Zeichenfolge ein oder mehrere Tabulatorzeichen enthält, basiert die Breite der Zeichenfolge auf den von *lpnTabStopPositions*angegebenen Tabstopps. Die Funktion verwendet die aktuell ausgewählte Schriftart, um die Dimensionen der Zeichenfolge zu berechnen.

Der aktuelle Zuschneidebereich versetzt die von `GetOutputTabbedTextExtent` der Funktion zurückgegebene Breite und Höhe nicht.

Da einige Geräte keine Zeichen in regulären Zellarrays platzieren (d. h. die Zeichen kernen), ist die Summe der Ausdehnungen der Zeichen in einer Zeichenfolge möglicherweise nicht gleich der Ausdehnung der Zeichenfolge.

Wenn *nTabPositions* 0 und *lpnTabStopPositions* NULL ist, werden Tabstopps auf acht durchschnittliche Zeichenbreiten erweitert. Wenn *nTabPositions* 1 ist, werden die Tabstopps durch den Abstand getrennt, der durch den ersten Wert im Array angegeben wird, auf das *lpnTabStopPositions* zeigt. Wenn *lpnTabStopPositions* auf mehr als einen einzelnen Wert verweist, wird für jeden Wert im Array ein Tabstopp festgelegt, bis zu der von *nTabPositions*angegebenen Zahl.

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>CDC::GetOutputTextExtent

Rufen Sie diese Memberfunktion auf, um den Kontext des Ausgabegeräts zu verwenden, [m_hDC,](#m_hdc)und berechnen Sie die Breite und Höhe einer Textzeile mithilfe der aktuellen Schriftart.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Zeigt auf eine Zeichenfolge. Sie können auch ein [CString-Objekt](../../atl-mfc-shared/reference/cstringt-class.md) für diesen Parameter übergeben.

*nCount*<br/>
Gibt die [Länge der Zeichenfolge](/windows/win32/gdi/specifying-length-of-text-output-string) an, auf die von *lpszString*verwiesen wird.

*Str*<br/>
Ein `CString` Objekt, das die angegebenen Zeichen enthält, die gemessen werden sollen.

### <a name="return-value"></a>Rückgabewert

Die Dimensionen der Zeichenfolge (in logischen Einheiten), die in einem [CSize-Objekt](../../atl-mfc-shared/reference/csize-class.md) zurückgegeben werden.

### <a name="remarks"></a>Bemerkungen

Der aktuelle Zuschneidebereich wirkt sich nicht `GetOutputTextExtent`auf die Breite und Höhe aus, die von zurückgegeben werden.

Da einige Geräte keine Zeichen in regulären Zellarrays platzieren (d. h. sie führen Kerning durch), ist die Summe der Ausdehnungen der Zeichen in einer Zeichenfolge möglicherweise nicht gleich der Ausdehnung der Zeichenfolge.

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics

Ruft die Metriken für die `m_hDC`aktuelle Schriftart mithilfe des Ausgabegerätekontexts ab.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parameter

*lpMetrics*<br/>
Zeigt auf die [TEXTMETRIC-Struktur,](/windows/win32/api/wingdi/ns-wingdi-textmetricw) die die Metriken empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

## <a name="cdcgetpath"></a><a name="getpath"></a>CDC::GetPath

Ruft die Koordinaten ab, die die Endpunkte von Linien und die Kontrollpunkte von Kurven definieren, die in dem Pfad gefunden werden, der im Gerätekontext ausgewählt ist.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein Array von `CPoint` [POINT-Datenstrukturen](/windows/win32/api/windef/ns-windef-point) oder -Objekten, in denen die Linienendpunkte und Kurvenkontrollpunkte platziert werden.

*lpTypes*<br/>
Zeigt auf ein Array von Bytes, in dem die Scheitelpunkttypen platziert werden. Werte sind einer der folgenden:

- PT_MOVETO Gibt an, dass der entsprechende Punkt in *lpPoints* eine unzusammenhängende Abbildung startet.

- PT_LINETO Gibt an, dass der vorherige Punkt und der entsprechende Punkt in *lpPoints* die Endpunkte einer Linie sind.

- PT_BEZIERTO Gibt an, dass der entsprechende Punkt in *lpPoints* ein Kontrollpunkt oder Endpunkt für eine Bzier-Kurve ist.

PT_BEZIERTO Typen treten immer in Dreiergruppen auf. Der Punkt im Pfad unmittelbar vor ihnen definiert den Startpunkt für die Bzier-Kurve. Die ersten beiden PT_BEZIERTO Punkte sind die Kontrollpunkte, und der dritte PT_BEZIERTO Punkt ist der Endpunkt (falls hartcodiert).

   Ein PT_LINETO oder PT_BEZIERTO Typ kann mit dem folgenden Flag kombiniert werden (mit dem bitweisen Operator **ODER**), um anzugeben, dass der entsprechende Punkt der letzte Punkt in einer Abbildung ist und dass die Zahl geschlossen werden sollte:

- PT_CLOSEFIGURE Gibt an, dass die Figur automatisch geschlossen wird, nachdem die entsprechende Linie oder Kurve gezeichnet wurde. Die Figur wird geschlossen, indem eine Linie vom Linien- oder Kurvenendpunkt bis zu dem Punkt gezeichnet wird, der dem letzten PT_MOVETO entspricht.

*nCount*<br/>
Gibt die Gesamtzahl [POINT](/windows/win32/api/windef/ns-windef-point) der POINT-Datenstrukturen an, die im *lpPoints-Array* platziert werden können. Dieser Wert muss mit der Anzahl der Bytes identisch sein, die im *lpTypes-Array* platziert werden können.

### <a name="return-value"></a>Rückgabewert

Wenn der *nCount-Parameter* ungleich Null ist, wird die Anzahl der aufgezählten Punkte aufgezählt. Wenn *nCount* 0 ist, die Gesamtzahl der `GetPath` Punkte im Pfad (und schreibt nichts in die Puffer). Wenn *nCount* ungleich Null ist und kleiner als die Anzahl der Punkte im Pfad ist, ist der Rückgabewert -1.

### <a name="remarks"></a>Bemerkungen

Der Gerätekontext muss einen geschlossenen Pfad enthalten. Die Punkte des Pfads werden in logischen Koordinaten zurückgegeben. Punkte werden im Pfad in Gerätekoordinaten gespeichert, sodass `GetPath` die Punkte von Gerätekoordinaten in logische Koordinaten geändert werden, indem die Umkehrung der aktuellen Transformation verwendet wird. Die `FlattenPath` Memberfunktion kann `GetPath`vor aufgerufen werden, um alle Kurven im Pfad in Liniensegmente zu konvertieren.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CDC::BeginPath](#beginpath).

## <a name="cdcgetpixel"></a><a name="getpixel"></a>CDC::GetPixel

Ruft den RGB-Farbwert des Pixels an dem punktab, der durch *x* und *y*angegeben wird.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate des zu untersuchenden Punktes an.

*y*<br/>
Gibt die logische y-Koordinate des zu untersuchenden Punktes an.

*Punkt*<br/>
Gibt die logischen x- und y-Koordinaten des zu untersuchenden Punktes an.

### <a name="return-value"></a>Rückgabewert

Für beide Versionen der Funktion einen RGB-Farbwert für die Farbe des angegebenen Punkts. Es ist -1, wenn die Koordinaten keinen Punkt im Zuschneidebereich angeben.

### <a name="remarks"></a>Bemerkungen

Der Punkt muss sich im Clipping-Bereich befinden. Wenn sich der Punkt nicht im Zuschneidebereich befindet, hat die Funktion keine Wirkung und gibt -1 zurück.

Nicht alle Geräte unterstützen die `GetPixel`-Funktion. Weitere Informationen finden Sie in der RC_BITBLT-Raster-Funktion unter der [GetDeviceCaps-Memberfunktion.](#getdevicecaps)

Die `GetPixel` Memberfunktion hat zwei Formulare. Der erste nimmt zwei Koordinatenwerte an; Die zweite nimmt entweder eine [POINT-Struktur](/windows/win32/api/windef/ns-windef-point) oder ein [CPoint-Objekt](../../atl-mfc-shared/reference/cpoint-class.md) an.

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>CDC::GetPolyFillMode

Ruft den aktuellen Polygonfüllmodus ab.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der aktuelle polygongefüllte Modus ALTERNATE oder WINDING, wenn die Funktion erfolgreich ist.

### <a name="remarks"></a>Bemerkungen

Eine `SetPolyFillMode` Beschreibung der Polygonfüllmodi finden Sie in der Memberfunktion.

## <a name="cdcgetrop2"></a><a name="getrop2"></a>CDC::GetROP2

Ruft den aktuellen Zeichnungsmodus ab.

```
int GetROP2() const;
```

### <a name="return-value"></a>Rückgabewert

Der Zeichnungsmodus. Eine Liste der Zeichnungsmoduswerte `SetROP2` finden Sie in der Memberfunktion.

### <a name="remarks"></a>Bemerkungen

Der Zeichenmodus gibt an, wie die Farben des Stifts und das Innere gefüllter Objekte mit der Farbe kombiniert werden, die sich bereits auf der Anzeigefläche befindet.

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>CDC::GetSafeHdc

Rufen Sie diese Memberfunktion auf, um [m_hDC](#m_hdc), den Kontext des Ausgabegeräts, abzurufen.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Gerätekontexthandle.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion funktioniert auch mit Nullzeigern.

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>CDC::GetStretchBltMode

Ruft den aktuellen Bitmap-Stretching-Modus ab.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der Rückgabewert gibt den aktuellen Bitmap-Stretching-Modus an , STRETCH_ANDSCANS, STRETCH_DELETESCANS oder STRETCH_ORSCANS , wenn die Funktion erfolgreich ist.

### <a name="remarks"></a>Bemerkungen

Der Bitmap-Stretching-Modus definiert, wie Informationen aus Bitmaps entfernt `StretchBlt` werden, die von der Memberfunktion gestreckt oder komprimiert werden.

Die STRETCH_ANDSCANS- und STRETCH_ORSCANS-Modi werden in der Regel verwendet, um Vordergrundpixel in monochromen Bitmaps beizubehalten. Der STRETCH_DELETESCANS-Modus wird in der Regel verwendet, um Farbe in Farbbitmaps beizubehalten.

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>CDC::GetTabbedTextExtent

Rufen Sie diese Memberfunktion auf, um die Breite und Höhe einer Zeichenfolge mithilfe von [m_hAttribDC](#m_hattribdc), dem Attributgerätekontext, zu berechnen.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Zeigt auf eine Zeichenfolge. Sie können auch ein [CString-Objekt](../../atl-mfc-shared/reference/cstringt-class.md) für diesen Parameter übergeben.

*nCount*<br/>
Gibt die [Länge der Zeichenfolge](/windows/win32/gdi/specifying-length-of-text-output-string) an, auf die von *lpszString*verwiesen wird.

*nTabPositionen*<br/>
Gibt die Anzahl der Tabstopppositionen im Array an, auf die *lpnTabStopPositions*zeigt.

*lpnTabStopPositionen*<br/>
Zeigt auf ein Array von Ganzzahlen, die die Tabstopppositionen in logischen Einheiten enthalten. Die Tabstopps müssen in zunehmender Reihenfolge sortiert werden. der kleinste x-Wert sollte das erste Element im Array sein. Registerkarten zurück sind nicht zulässig.

*Str*<br/>
Ein `CString` Objekt, das die angegebenen Zeichen enthält, die gezeichnet werden sollen.

### <a name="return-value"></a>Rückgabewert

Die Dimensionen der Zeichenfolge (in logischen Einheiten) in einem [CSize-Objekt.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Bemerkungen

Wenn die Zeichenfolge ein oder mehrere Tabulatorzeichen enthält, basiert die Breite der Zeichenfolge auf den von *lpnTabStopPositions*angegebenen Tabstopps. Die Funktion verwendet die aktuell ausgewählte Schriftart, um die Dimensionen der Zeichenfolge zu berechnen.

Der aktuelle Zuschneidebereich versetzt die von `GetTabbedTextExtent` der Funktion zurückgegebene Breite und Höhe nicht.

Da einige Geräte keine Zeichen in regulären Zellarrays platzieren (d. h. die Zeichen kernen), ist die Summe der Ausdehnungen der Zeichen in einer Zeichenfolge möglicherweise nicht gleich der Ausdehnung der Zeichenfolge.

Wenn *nTabPositions* 0 und *lpnTabStopPositions* NULL ist, werden Tabstopps auf das Achtfache der durchschnittlichen Zeichenbreite erweitert. Wenn *nTabPositions* 1 ist, werden die Tabstopps durch den Abstand getrennt, der durch den ersten Wert im Array angegeben wird, auf das *lpnTabStopPositions* zeigt. Wenn *lpnTabStopPositions* auf mehr als einen einzelnen Wert verweist, wird für jeden Wert im Array ein Tabstopp festgelegt, bis zu der von *nTabPositions*angegebenen Zahl.

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>CDC::GetTextAlign

Ruft den Status der Textausrichtungsflags für den Gerätekontext ab.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Rückgabewert

Der Status der Textausrichtungsflags. Der Rückgabewert ist einer oder mehrere der folgenden Werte:

- TA_BASELINE Gibt die Ausrichtung der x-Achse und der Grundlinie der ausgewählten Schriftart innerhalb des umgrenzenden Rechtecks an.

- TA_BOTTOM Gibt die Ausrichtung der x-Achse und den unteren Rand des umgrenzenden Rechtecks an.

- TA_CENTER Gibt die Ausrichtung der y-Achse und der Mitte des umgrenzenden Rechtecks an.

- TA_LEFT Gibt die Ausrichtung der y-Achse und der linken Seite des umgrenzenden Rechtecks an.

- TA_NOUPDATECP Gibt an, dass die aktuelle Position nicht aktualisiert wird.

- TA_RIGHT Gibt die Ausrichtung der y-Achse und der rechten Seite des umgrenzenden Rechtecks an.

- TA_TOP Gibt die Ausrichtung der x-Achse und den oberen Rand des umgrenzenden Rechtecks an.

- TA_UPDATECP Gibt an, dass die aktuelle Position aktualisiert wird.

### <a name="remarks"></a>Bemerkungen

Die Textausrichtungsflags bestimmen, wie die `TextOut` und `ExtTextOut` Memberfunktionen eine Textzeichenfolge in Bezug auf den Anfangspunkt der Zeichenfolge ausrichten. Die Textausrichtungsflags sind nicht unbedingt Ein-Bit-Flags und können gleich 0 sein. Um zu testen, ob ein Flag gesetzt ist, sollte eine Anwendung die folgenden Schritte ausführen:

1. Wenden Sie den bitweisen ODER-Operator auf das Flag und die zugehörigen Flags an, gruppiert wie folgt:

   - TA_LEFT, TA_CENTER und TA_RIGHT

   - TA_BASELINE, TA_BOTTOM und TA_TOP

   - TA_NOUPDATECP und TA_UPDATECP

1. Wenden Sie den bitwise-AND-Operator auf `GetTextAlign`das Ergebnis und den Rückgabewert von an.

1. Testen Sie die Gleichheit dieses Ergebnisses und der Flagge.

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>CDC::GetTextCharacterExtra

Ruft die aktuelle Einstellung für den Abstand zwischen den Zeichen ab.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Rückgabewert

Die Menge des Intercharacter-Abstands.

### <a name="remarks"></a>Bemerkungen

GDI fügt jedem Zeichen diesen Abstand hinzu, einschließlich Bruchzeichen, wenn eine Textzeile in den Gerätekontext geschrieben wird.

Der Standardwert für den Abstand zwischen den Zeichen ist 0.

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>CDC::GetTextColor

Ruft die aktuelle Textfarbe ab.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Rückgabewert

Die aktuelle Textfarbe als RGB-Farbwert.

### <a name="remarks"></a>Bemerkungen

Die Textfarbe ist die Vordergrundfarbe von Zeichen, die mit den GDI-Textausgabeelementfunktionen [TextOut](#textout), [ExtTextOut](#exttextout)und [TabbedTextOut](#tabbedtextout)gezeichnet werden.

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>CDC::GetTextExtent

Rufen Sie diese Memberfunktion auf, um die Breite und Höhe einer Textzeile mithilfe der aktuellen Schriftart zu berechnen, um die Bemaßungen zu bestimmen.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Zeigt auf eine Zeichenfolge. Sie können auch ein [CString-Objekt](../../atl-mfc-shared/reference/cstringt-class.md) für diesen Parameter übergeben.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an.

*Str*<br/>
Ein `CString` Objekt, das die angegebenen Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Die Dimensionen der Zeichenfolge (in logischen Einheiten) in einem [CSize-Objekt.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Bemerkungen

Die Informationen werden aus [m_hAttribDC](#m_hattribdc), dem Attributgerätekontext, abgerufen.

Nimmt standardmäßig `GetTextExtent` an, dass der Text, für den die Bemaßung abgerufen wird, entlang einer horizontalen Linie festgelegt ist (d. h., die Hemmung ist 0). Wenn Sie eine Schriftart erstellen, die eine Escapement-Datei ungleich Null angibt, müssen Sie den Winkel des Textes explizit konvertieren, um die Bemaßungen der Zeichenfolge abzubekommen.

Der aktuelle Zuschneidebereich wirkt sich nicht `GetTextExtent`auf die Breite und Höhe aus, die von zurückgegeben werden.

Da einige Geräte keine Zeichen in regulären Zellarrays platzieren (d. h. sie führen Kerning durch), ist die Summe der Ausdehnungen der Zeichen in einer Zeichenfolge möglicherweise nicht gleich der Ausdehnung der Zeichenfolge.

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>CDC::GetTextExtentExPointI

Ruft die Anzahl der Zeichen in einer angegebenen Zeichenfolge ab, die in einen angegebenen Bereich passt, und füllt ein Array mit der Textausdehnung für jedes dieser Zeichen.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*pgiIn*<br/>
Ein Zeiger auf ein Array von Glyphenindizes, für die Ausdehnungen abgerufen werden sollen.

*Cgi*<br/>
Gibt die Anzahl der Glyphen im Array an, auf die *pgiIn*zeigt.

*nMaxExtent*<br/>
Gibt die maximal zulässige Breite der formatierten Zeichenfolge in logischen Einheiten an.

*lpnFit*<br/>
Ein Zeiger auf eine ganze Zahl, die eine Anzahl der maximalen Anzahl von Zeichen erhält, die in den von *nMaxExtent*angegebenen Bereich passen. Wenn *lpnFit* NULL ist, wird *nMaxExtent* ignoriert.

*alpDx*<br/>
Ein Zeiger auf ein Array von Ganzzahlen, das partielle Glyphenausdehnungen empfängt. Jedes Element im Array gibt den Abstand in logischen Einheiten zwischen dem Anfang des Glyphenindizes-Arrays und einer der Glyphen an, die in den von *nMaxExtent*angegebenen Raum passt. Obwohl dieses Array mindestens so viele Elemente haben sollte wie die von *cgi*angegebenen Glyphenindizes, füllt die Funktion das Array nur für so viele Glyphenindizes aus, wie von *lpnFit*angegeben. Wenn *lpnDx* NULL ist, berechnet die Funktion keine partiellen Zeichenfolgenbreiten.

*lpSize*<br/>
Zeiger auf [SIZE](/windows/win32/api/windef/ns-windef-size) eine SIZE-Struktur, die die Dimensionen des Glyphenindizes-Arrays in logischen Einheiten empfängt. Dieser Wert kann nicht NULL sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion emuliert die Funktionalität der Funktion [GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi), wie im Windows SDK beschrieben.

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>CDC::GetTextExtentPointI

Ruft die Breite und Höhe des angegebenen Arrays von Glyphenindizes ab.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*pgiIn*<br/>
Ein Zeiger auf ein Array von Glyphenindizes, für die Ausdehnungen abgerufen werden sollen.

*Cgi*<br/>
Gibt die Anzahl der Glyphen im Array an, auf die *pgiIn*zeigt.

*lpSize*<br/>
Zeiger auf [SIZE](/windows/win32/api/windef/ns-windef-size) eine SIZE-Struktur, die die Dimensionen des Glyphenindizes-Arrays in logischen Einheiten empfängt. Dieser Wert kann nicht NULL sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion emuliert die Funktionalität der Funktion [GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi), wie im Windows SDK beschrieben.

## <a name="cdcgettextface"></a><a name="gettextface"></a>CDC::GetTextFace

Rufen Sie diese Memberfunktion auf, um den Schriftnamen der aktuellen Schriftart in einen Puffer zu kopieren.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parameter

*nCount*<br/>
Gibt die Größe des Puffers (in Bytes) an. Wenn der Schriftname länger ist als die von diesem Parameter angegebene Anzahl von Bytes, wird der Name abgeschnitten.

*lpszFacename*<br/>
Zeigt auf den Puffer für den Schriftnamen.

*rString*<br/>
Ein Verweis auf ein [CString-Objekt.](../../atl-mfc-shared/reference/cstringt-class.md)

### <a name="return-value"></a>Rückgabewert

Die Anzahl der in den Puffer kopierten Bytes, ohne das beendende Nullzeichen. Es ist 0, wenn ein Fehler auftritt.

### <a name="remarks"></a>Bemerkungen

Der Schrifttypwird wird als null-terminierte Zeichenfolge kopiert.

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>CDC::GetTextMetrics

Ruft die Metriken für die aktuelle Schriftart mithilfe des Attributgerätekontexts ab.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parameter

*lpMetrics*<br/>
Zeigt auf die [TEXTMETRIC-Struktur,](/windows/win32/api/wingdi/ns-wingdi-textmetricw) die die Metriken empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>CDC::GetViewportExt

Ruft die x- und y-Ausdehnungen des Ansichtsfensters des Gerätekontexts ab.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Rückgabewert

Die x- und y-Extents (in `CSize` Geräteeinheiten) als Objekt.

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>CDC::GetViewportOrg

Ruft die x- und y-Koordinaten des Ursprungs des Ansichtsfensters ab, das dem Gerätekontext zugeordnet ist.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Rückgabewert

Der Ursprung des Ansichtsfensters (in `CPoint` Gerätekoordinaten) als Objekt.

## <a name="cdcgetwindow"></a><a name="getwindow"></a>CDC::GetWindow

Gibt das Fenster zurück, das dem Kontext des Anzeigegeräts zugeordnet ist.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf `CWnd` ein Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Dies ist eine erweiterte Funktion. Diese Memberfunktion gibt z. B. das Ansichtsfenster beim Drucken oder in der Druckvorschau möglicherweise nicht zurück. Es gibt immer das Fenster zurück, das der Ausgabe zugeordnet ist. Ausgabefunktionen, die den angegebenen DC verwenden, ziehen in dieses Fenster.

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>CDC::GetWindowExt

Ruft die x- und y-Ausdehnungen des Fensters ab, das dem Gerätekontext zugeordnet ist.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Rückgabewert

Die x- und y-Ausdehnungen (in `CSize` logischen Einheiten) als Objekt.

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>CDC::GetWindowOrg

Ruft die x- und y-Koordinaten des Ursprungs des Fensters ab, das dem Gerätekontext zugeordnet ist.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Rückgabewert

Der Ursprung des Fensters (in `CPoint` logischen Koordinaten) als Objekt.

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>CDC::GetWorldTransform

Ruft den aktuellen Weltraum zur Seitenraumtransformation ab.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parameter

*rXform*<br/>
Verweis auf eine [XFORM-Struktur,](/windows/win32/api/wingdi/ns-wingdi-xform) die den aktuellen Weltraum zur Seitenraumtransformation empfängt.

### <a name="return-value"></a>Rückgabewert

Gibt einen Wert ungleich Null für den Erfolg zurück.

Gibt 0 bei Einem Fehler zurück.

Um erweiterte Fehlerinformationen zu erhalten, rufen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)an.

### <a name="remarks"></a>Bemerkungen

Diese Methode umschließt die Windows GDI-Funktion [GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform).

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>CDC::GradientFill

Rufen Sie diese Memberfunktion auf, um Rechteck- und Dreiecksstrukturen mit Einer Seite zur anderen zu füllen.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parameter

*pVertices*<br/>
Zeiger auf ein Array von [TRIVERTEX-Strukturen,](/windows/win32/api/wingdi/ns-wingdi-trivertex) die jeweils einen Dreiecksscheitelpunkt definieren.

*nVertices*<br/>
Die Anzahl der Scheitelpunkte.

*pMesh*<br/>
Array von [GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) Strukturen im Dreiecksmodus oder ein Array [von GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) Strukturen im Rechteckmodus.

*nMeshElements*<br/>
Die Anzahl der Elemente (Dreiecke oder Rechtecke) in *pMesh*.

*dwMode*<br/>
Gibt den Farbverlaufsfüllmodus an. Eine Liste möglicher Werte finden Sie unter [GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) im Windows SDK.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Bemerkungen

Weitere Informationen finden `GradientFill` Sie im Windows SDK.

## <a name="cdcgraystring"></a><a name="graystring"></a>CDC::GrayString

Zeichnet abgeblendeten (grauen) Text an der angegebenen Position, indem der Text in eine Speicherbitmap geschrieben, die Bitmap abgeblendet und dann in die Anzeige kopiert wird.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*pBrush*<br/>
Identifiziert den Pinsel, der zum Dimmen verwendet werden soll (Grauung).

*lpfnOutput*<br/>
Gibt die Prozedurinstanzadresse der von der Anwendung bereitgestellten Rückruffunktion an, die die Zeichenfolge zeichnet. Weitere Informationen finden Sie in `OutputFunc` der Beschreibung der [Windows-Rückruffunktion](callback-functions-used-by-mfc.md#graystring). Wenn dieser Parameter NULL ist, `TextOut` verwendet das System die Windows-Funktion, um die Zeichenfolge zu zeichnen, und *lpData* wird als langer Zeiger auf die auszugebende Zeichenfolge angenommen.

*lpData*<br/>
Gibt einen weiten Zeiger auf Daten an, die an die Ausgabefunktion übergeben werden sollen. Wenn *lpfnOutput* NULL ist, muss *lpData* ein langer Zeiger auf die Zeichenfolge sein, die ausgegeben werden soll.

*nCount*<br/>
Gibt die Anzahl der Zeichen an, die ausgegeben werden sollen. Wenn dieser Parameter `GrayString` 0 ist, berechnet die Länge der Zeichenfolge (vorausgesetzt, *lpData* ist ein Zeiger auf die Zeichenfolge). Wenn *nCount* 1 ist und die Funktion, auf die von *lpfnOutput* verwiesen wird, 0 zurückgibt, wird das Bild angezeigt, aber nicht abgeblendet.

*X*<br/>
Gibt die logische x-Koordinate der Startposition des Rechtecks an, das die Zeichenfolge umschließt.

*y*<br/>
Gibt die logische y-Koordinate der Startposition des Rechtecks an, das die Zeichenfolge umschließt.

*nWidth*<br/>
Gibt die Breite (in logischen Einheiten) des Rechtecks an, das die Zeichenfolge umschließt. Wenn *nWidth* 0 `GrayString` ist, berechnet die Breite des Bereichs, vorausgesetzt, *lpData* ist ein Zeiger auf die Zeichenfolge.

*nHeight*<br/>
Gibt die Höhe (in logischen Einheiten) des Rechtecks an, das die Zeichenfolge umschließt. Wenn *nHeight* 0 `GrayString` ist, wird die Höhe des Bereichs berechnet, vorausgesetzt, *lpData* ist ein Zeiger auf die Zeichenfolge.

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich Null, wenn die `TextOut` Zeichenfolge gezeichnet wird, oder 0, wenn entweder die Funktion oder die von der Anwendung bereitgestellte Ausgabefunktion 0 zurückgegeben hat oder wenn nicht genügend Arbeitsspeicher vorhanden war, um eine Speicherbitmap zum Dimmen zu erstellen.

### <a name="remarks"></a>Bemerkungen

Die Funktion dimt den Text unabhängig vom ausgewählten Pinsel und Hintergrund. Die `GrayString` Memberfunktion verwendet die aktuell ausgewählte Schriftart. Der MM_TEXT Zuordnungsmodus muss ausgewählt werden, bevor Sie diese Funktion verwenden.

Eine Anwendung kann abgeblendete (graue) Zeichenfolgen auf Geräten zeichnen, die eine graue Farbe unterstützen, ohne die `GrayString` Memberfunktion aufzurufen. Die Systemfarbe COLOR_GRAYTEXT ist die vollgraue Systemfarbe, die zum Zeichnen von deaktiviertem Text verwendet wird. Die Anwendung kann `GetSysColor` die Windows-Funktion aufrufen, um den Farbwert von COLOR_GRAYTEXT abzurufen. Wenn die Farbe eine andere als 0 (schwarz) ist, kann die Anwendung die `SetTextColor` Memberfunktion aufrufen, um die Textfarbe auf den Farbwert festzulegen und dann die Zeichenfolge direkt zu zeichnen. Wenn die abgerufene Farbe schwarz `GrayString` ist, muss die Anwendung den Text abfärben (grau).

Wenn *lpfnOutput* NULL ist, verwendet GDI die Windows [TextOut-Funktion,](/windows/win32/api/wingdi/nf-wingdi-textoutw) und *lpData* wird als ein weiter Zeiger auf das ausgabeende Zeichen angenommen. Wenn die auszuliefernden Zeichen nicht `TextOut` von der Memberfunktion verarbeitet werden können (z. B. wird die Zeichenfolge als Bitmap gespeichert), muss die Anwendung eine eigene Ausgabefunktion bereitstellen.

Beachten Sie außerdem, dass alle Rückruffunktionen Microsoft Foundation-Ausnahmen abfangen müssen, bevor sie zu Windows zurückkehren, da Ausnahmen nicht über Rückrufgrenzen hinweg ausgelöst werden können. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).

Die Rückruffunktion, `GrayString` an die `__stdcall` übergeben wird, muss `__declspec`die aufrufende Konvention verwenden und mit exportiert werden.

Wenn sich das Framework im Vorschaumodus `GrayString` befindet, wird `TextOut` ein Aufruf der Memberfunktion in einen Aufruf übersetzt, und die Rückruffunktion wird nicht aufgerufen.

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>CDC::HIMETRICtoDP

Verwenden Sie diese Funktion, wenn Sie HIMETRIC-Größen von OLE in Pixel konvertieren.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpSize*<br/>
Zeigt auf eine [SIZE-Struktur](/windows/win32/api/windef/ns-windef-size) oder ein [CSize-Objekt.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Bemerkungen

Wenn der Zuordnungsmodus des Gerätekontextobjekts MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC oder MM_HIMETRIC ist, basiert die Konvertierung auf der Anzahl der Pixel im physischen Zoll. Wenn der Zuordnungsmodus einer der anderen nicht eingeschränkten Modi ist (z. B. MM_TEXT), basiert die Konvertierung auf der Anzahl der Pixel im logischen Zoll.

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>CDC::HIMETRICtoLP

Rufen Sie diese Funktion auf, um HIMETRIC-Einheiten in logische Einheiten zu konvertieren.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpSize*<br/>
Zeigt auf eine [SIZE-Struktur](/windows/win32/api/windef/ns-windef-size) oder ein [CSize-Objekt.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Bemerkungen

Verwenden Sie diese Funktion, wenn Sie HIMETRIC-Größen von OLE abrufen und sie in den natürlichen Zuordnungsmodus Ihrer Anwendung konvertieren möchten.

Die Konvertierung erfolgt, indem zuerst die HIMETRIC-Einheiten in Pixel konvertiert und diese Einheiten dann mithilfe der aktuellen Zuordnungseinheiten des Gerätekontexts in logische Einheiten konvertiert werden. Beachten Sie, dass sich die Ausdehnungen des Fensters und Ansichtsfensters des Geräts auf das Ergebnis auswirken.

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>CDC::IntersectClipRect

Erstellt einen neuen Zuschneidebereich, indem der Schnittpunkt des aktuellen Bereichs und des durch *x1*, *y1*, *x2*und *y2*angegebenen Rechtecks gebildet wird.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Rechtecks an.

*y1*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks an.

*x2*<br/>
Gibt die logische x-Koordinate der unteren rechten Ecke des Rechtecks an.

*y2*<br/>
Gibt die logische y-Koordinate der unteren rechten Ecke des Rechtecks an.

*lpRect*<br/>
Gibt das Rechteck an. Sie können entweder `CRect` ein Objekt oder `RECT` einen Zeiger an eine Struktur für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Der Typ des neuen Clipping-Bereichs. Es kann einer der folgenden Werte sein:

- COMPLEXREGION Neuer Zuschneidebereich hat überlappende Grenzen.

- FEHLER Gerätekontext ist ungültig.

- NULLREGION Neuer Clipping-Bereich ist leer.

- SIMPLEREGION Neuer Zuschneidebereich hat keine überlappenden Rahmen.

### <a name="remarks"></a>Bemerkungen

GDI schneidet alle nachfolgenden Ausgaben ab, um innerhalb der neuen Grenze zu passen. Die Breite und Höhe darf 32.767 nicht überschreiten.

## <a name="cdcinvertrect"></a><a name="invertrect"></a>CDC::InvertRect

Kehrt den Inhalt des angegebenen Rechtecks um.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Zeigt auf `RECT` eine, die die logischen Koordinaten des rechteckigen Rechtecks enthält, das invertiert werden soll. Sie können auch `CRect` ein Objekt für diesen Parameter übergeben.

### <a name="remarks"></a>Bemerkungen

Inversion ist eine logische NICHT-Operation und kippt die Bits jedes Pixels um. Auf monochromen Displays macht die Funktion weiße Pixel schwarz und schwarz weiß. Bei Farbanzeigen hängt die Inversion davon ab, wie Farben für die Anzeige generiert werden. Wenn `InvertRect` Sie zweimal mit demselben Rechteck aufrufen, wird die Anzeige auf die vorherigen Farben zurückgestellt.

Wenn das Rechteck leer ist, wird nichts gezeichnet.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>CDC::InvertRgn

Kehrt die Farben in dem von *pRgn*angegebenen Bereich um.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parameter

*pRgn*<br/>
Identifiziert die Region, die invertiert werden soll. Die Koordinaten für den Bereich werden in logischen Einheiten angegeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Auf monochromen Displays macht die Funktion weiße Pixel schwarz und schwarz weiß. Bei Farbanzeigen hängt die Inversion davon ab, wie die Farben für die Anzeige generiert werden.

## <a name="cdcisprinting"></a><a name="isprinting"></a>CDC::IsPrinting

Bestimmt, ob der Gerätekontext zum Drucken verwendet wird.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Wert `CDC` ungleich Null, wenn es sich bei dem Objekt um einen Drucker-DC handelt; andernfalls 0.

## <a name="cdclineto"></a><a name="lineto"></a>CDC::LineTo

Zeichnet eine Linie von der aktuellen Position bis zu dem durch *x* und *y* (oder *Punkt)* angegebenen Punkt, aber nicht einschließlich .

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate des Endpunkts für die Linie an.

*y*<br/>
Gibt die logische y-Koordinate des Endpunkts für die Linie an.

*Punkt*<br/>
Gibt den Endpunkt für die Linie an. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich Null, wenn die Linie gezeichnet wird; andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Die Linie wird mit dem ausgewählten Stift gezeichnet. Die aktuelle Position wird auf *x*, *y* oder *auf Point*gesetzt.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdclptodp"></a><a name="lptodp"></a>CDC::LPtoDP

Konvertiert logische Einheiten in Geräteeinheiten.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein Array von Punkten. Jeder Punkt im Array ist eine [POINT-Struktur](/windows/win32/api/windef/ns-windef-point) oder ein [CPoint-Objekt.](../../atl-mfc-shared/reference/cpoint-class.md)

*nCount*<br/>
Die Anzahl der Punkte im Array.

*lpRect*<br/>
Zeigt auf eine [RECT-Struktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Objekt.](../../atl-mfc-shared/reference/crect-class.md) Dieser Parameter wird für den allgemeinen Fall verwendet, bei dem ein Rechteck von logischen zu Geräteeinheiten zugeordnet wird.

*lpSize*<br/>
Zeigt auf eine [SIZE-Struktur](/windows/win32/api/windef/ns-windef-size) oder ein [CSize-Objekt.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Bemerkungen

Die Funktion ordnet die Koordinaten jedes Punktes oder bemaßungen einer Größe aus dem logischen Koordinatensystem von GDI einem Gerätekoordinatensystem zu. Die Konvertierung hängt vom aktuellen Zuordnungsmodus und den Einstellungen der Ursprünge und Ausdehnungen des Gerätefensters und Desansichtsfensters ab.

Die x- und y-Koordinaten von Punkten sind 2-Byte-signierte Ganzzahlen im Bereich -32.768 bis 32.767. In Fällen, in denen der Zuordnungsmodus werte größer als diese Grenzwerte führen würde, legt das System die Werte auf -32.768 bzw. 32.767 fest.

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>CDC::LPtoHIMETRIC

Rufen Sie diese Funktion auf, um logische Einheiten in HIMETRIC-Einheiten zu konvertieren.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpSize*<br/>
Zeigt auf `SIZE` eine `CSize` Struktur oder ein Objekt.

### <a name="remarks"></a>Bemerkungen

Verwenden Sie diese Funktion, wenn Sie OLE HIMETRIC-Größen geben und aus dem natürlichen Zuordnungsmodus Ihrer Anwendung konvertieren. Beachten Sie, dass sich die Ausdehnungen des Fensters und Ansichtsfensters des Geräts auf das Ergebnis auswirken.

Die Konvertierung erfolgt, indem die logischen Einheiten zunächst mithilfe der aktuellen Zuordnungseinheiten des Gerätekontexts in Pixel konvertiert und diese Einheiten dann in HIMETRIC-Einheiten konvertiert werden.

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>CDC::m_hAttribDC

Der Attributgerätekontext `CDC` für dieses Objekt.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Bemerkungen

Standardmäßig ist dieser Gerätekontext `m_hDC`gleich . Im Allgemeinen `CDC` werden GDI-Aufrufe, die Informationen `m_hAttribDC`aus dem Gerätekontext anfordern, an geleitet. Weitere Informationen zur Verwendung dieser beiden Gerätekontexte finden Sie in der Beschreibung der [CDC-Klasse.](../../mfc/reference/cdc-class.md)

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>CDC::m_hDC

Der Kontext des `CDC` Ausgabegeräts für dieses Objekt.

```
HDC m_hDC;
```

### <a name="remarks"></a>Bemerkungen

Standardmäßig `m_hDC` ist gleich `m_hAttribDC`, der andere Gerätekontext, der von `CDC`umbrochen wird. Im Allgemeinen `CDC` gehen GDI-Aufrufe, `m_hDC` die eine Ausgabe erstellen, an den Gerätekontext. Sie können `m_hDC` verschiedene `m_hAttribDC` Geräte initialisieren und darauf verweisen. Weitere Informationen zur Verwendung dieser beiden Gerätekontexte finden Sie in der Beschreibung der [CDC-Klasse.](../../mfc/reference/cdc-class.md)

## <a name="cdcmaskblt"></a><a name="maskblt"></a>CDC::MaskBlt

Kombiniert die Farbdaten für die Quell- und Zielbitmaps mithilfe des angegebenen Masken- und Rastervorgangs.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Zielrechtecks an.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Zielrechtecks an.

*nWidth*<br/>
Gibt die Breite des Zielrechtecks und der Quellbitmap in logischen Einheiten an.

*nHeight*<br/>
Gibt die Höhe des Zielrechtecks und der Quellbitmap in logischen Einheiten an.

*pSrcDC*<br/>
Identifiziert den Gerätekontext, aus dem die Bitmap kopiert werden soll. Sie muss Null sein, wenn der *parameter dwRop* einen Raster-Vorgang angibt, der keine Quelle enthält.

*xSrc*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke der Quellbitmap an.

*ySrc*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke der Quellbitmap an.

*maskBitmap*<br/>
Identifiziert die monochrome Maskenbitmap in Kombination mit der Farbbitmap im Quellgerätekontext.

*xMaske*<br/>
Gibt den horizontalen Pixelversatz für die Maskenbitmap an, die durch den *Parameter maskBitmap* angegeben wird.

*yMask*<br/>
Gibt den vertikalen Pixelversatz für die Maskenbitmap an, die durch den *Parameter maskBitmap* angegeben wird.

*dwRop*<br/>
Gibt sowohl Vordergrund- als auch Hintergrund-Raster-Arbeitscodes an, die von der Funktion verwendet werden, um die Kombination von Quell- und Zieldaten zu steuern. Der Hintergrund-Raster-Vorgangscode wird im hohen Byte des hohen Wortes dieses Werts gespeichert. der Vordergrund-Raster-Vorgangscode wird im niedrigen Byte des hohen Wortes dieses Werts gespeichert. Das niedrige Wort dieses Werts wird ignoriert und sollte Null sein. Das Makro MAKEROP4 erstellt solche Kombinationen von Vordergrund- und Hintergrund-Raster-Operationscodes. Im Abschnitt "Bemerkungen" finden Sie eine Erläuterung von Vordergrund und Hintergrund im Kontext dieser Funktion. Eine `BitBlt` Liste der allgemeinen Raster-Vorgangscodes finden Sie in der Memberfunktion.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der von *maskBitmap* angegebene Wert 1 in der Maske gibt an, dass der von *dwRop* angegebene Vordergrund-Raster-Vorgangscode an dieser Position angewendet werden soll. Der Wert 0 in der Maske gibt an, dass der von *dwRop* angegebene Hintergrund-Raster-Vorgangscode an dieser Position angewendet werden soll. Wenn die Raster-Operationen eine Quelle erfordern, muss das Maskenrechteck das Quellrechteck abdecken. Andernfalls schlägt die Funktion fehl. Wenn für die Raster-Operationen keine Quelle erforderlich sind, muss das Maskenrechteck das Zielrechteck abdecken. Andernfalls schlägt die Funktion fehl.

Wenn beim Aufruf dieser Funktion eine Drehung oder Schertransformation für den Quellgerätekontext wirksam ist, tritt ein Fehler auf. Andere Arten von Transformationen sind jedoch zulässig.

Wenn sich die Farbformate der Quell-, Muster- und Zielbitmaps unterscheiden, konvertiert diese Funktion das Muster- oder Quellformat oder beides in das Zielformat. Wenn es sich bei der Maskenbitmap nicht um eine monochrome Bitmap handelt, tritt ein Fehler auf. Wenn eine erweiterte Metadatei aufgezeichnet wird, tritt ein Fehler auf (und die Funktion gibt 0 zurück), wenn der Kontext des Quellgeräts einen erweiterten Metadatei-Gerätekontext identifiziert. Nicht alle `MaskBlt`Geräte unterstützen . Eine Anwendung `GetDeviceCaps` sollte aufrufen, um zu bestimmen, ob ein Gerät diese Funktion unterstützt. Wenn keine Maskenbitmap angegeben ist, verhält `BitBlt`sich diese Funktion genau wie , mit dem Vordergrund-Raster-Operation-Code. Die Pixelversätze in der Maskenbitmapzuordnung zum Punkt (0,0) in der Bitmap des Quellgerätekontexts. Dies ist nützlich für Fälle, in denen eine Maskenbitmap einen Satz von Masken enthält. Eine Anwendung kann problemlos eine beliebige Anwendung auf eine Maskenblitting-Aufgabe anwenden, indem `MaskBlt`sie die Pixelversätze und Rechteckgrößen an passt, die an gesendet werden.

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>CDC::ModifyWorldTransform

Ändert die Welttransformation für einen Gerätekontext mithilfe des angegebenen Modus.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parameter

*rXform*<br/>
Verweis auf eine [XFORM-Struktur,](/windows/win32/api/wingdi/ns-wingdi-xform) die zum Ändern der Welttransformation für den angegebenen Gerätekontext verwendet wird.

*Imode*<br/>
Gibt an, wie die Transformationsdaten die aktuelle Welttransformation ändern. Eine Liste der Werte, die dieser Parameter annehmen kann, finden Sie unter [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Rückgabewert

Gibt einen Wert ungleich Null für den Erfolg zurück.

Gibt 0 bei Einem Fehler zurück.

Um erweiterte Fehlerinformationen zu erhalten, rufen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)an.

### <a name="remarks"></a>Bemerkungen

Diese Methode umschließt die Windows GDI-Funktion [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

## <a name="cdcmoveto"></a><a name="moveto"></a>CDC::MoveTo

Verschiebt die aktuelle Position auf den punkt, der durch *x* und *y* (oder *nach Punkt)* angegeben wird.

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate der neuen Position an.

*y*<br/>
Gibt die logische y-Koordinate der neuen Position an.

*Punkt*<br/>
Gibt die neue Position an. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Die x- und y-Koordinaten der `CPoint` vorherigen Position als Objekt.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>CDC::OffsetClipRgn

Verschiebt den Zuschneidebereich des Gerätekontexts um die angegebenen Offsets.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die Anzahl der logischen Einheiten an, die nach links oder rechts verschoben werden sollen.

*y*<br/>
Gibt die Anzahl der logischen Einheiten an, die nach oben oder unten verschoben werden sollen.

*Größe*<br/>
Gibt den zu versetzenden Betrag an.

### <a name="return-value"></a>Rückgabewert

Der Typ der neuen Region. Es kann einer der folgenden Werte sein:

- COMPLEXREGION Clipping-Bereich hat überlappende Grenzen.

- FEHLER Gerätekontext ist ungültig.

- NULLREGION Clipping-Bereich ist leer.

- SIMPLEREGION Clipping-Bereich hat keine überlappenden Rahmen.

### <a name="remarks"></a>Bemerkungen

Die Funktion verschiebt die *Bereichs-x-Einheiten* entlang der x-Achse und *y-Einheiten* entlang der y-Achse.

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>CDC::OffsetViewportOrg

Ändert die Koordinaten des Ansichtsfensterursprungs relativ zu den Koordinaten des aktuellen Ansichtsfensterursprungs.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*nWidth*<br/>
Gibt die Anzahl der Geräteeinheiten an, die der x-Koordinate des aktuellen Ursprungs hinzugefügt werden sollen.

*nHeight*<br/>
Gibt die Anzahl der Geräteeinheiten an, die der y-Koordinate des aktuellen Ursprungs hinzugefügt werden sollen.

### <a name="return-value"></a>Rückgabewert

Der vorherige Ansichtsfensterursprung (in `CPoint` Gerätekoordinaten) als Objekt.

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>CDC::OffsetWindowOrg

Ändert die Koordinaten des Fensterursprungs relativ zu den Koordinaten des aktuellen Fensterursprungs.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*nWidth*<br/>
Gibt die Anzahl der logischen Einheiten an, die der x-Koordinate des aktuellen Ursprungs hinzugefügt werden sollen.

*nHeight*<br/>
Gibt die Anzahl der logischen Einheiten an, die der y-Koordinate des aktuellen Ursprungs hinzugefügt werden sollen.

### <a name="return-value"></a>Rückgabewert

Der vorherige Fensterursprung (in logischen Koordinaten) als `CPoint` Objekt.

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>CDC::operator HDC

Verwenden Sie diesen Operator, um `CDC` das Gerätekontexthandle des Objekts abzurufen.

```
operator HDC() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn erfolgreich, das Handle des Gerätekontextobjekts; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Sie können das Handle verwenden, um Windows-APIs direkt aufzurufen.

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>CDC::PaintRgn

Füllt den von *pRgn* angegebenen Bereich mit dem aktuellen Pinsel.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parameter

*pRgn*<br/>
Identifiziert die zu füllende Region. Die Koordinaten für den angegebenen Bereich werden in logischen Einheiten angegeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

## <a name="cdcpatblt"></a><a name="patblt"></a>CDC::PatBlt

Erstellt ein Bitmuster auf dem Gerät.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Rechtecks an, die das Muster empfangen soll.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks an, das das Muster empfangen soll.

*nWidth*<br/>
Gibt die Breite (in logischen Einheiten) des Rechtecks an, das das Muster empfangen soll.

*nHeight*<br/>
Gibt die Höhe (in logischen Einheiten) des Rechtecks an, das das Muster empfangen soll.

*dwRop*<br/>
Gibt den Raster-Vorgangscode an. Raster-Operationscodes (ROPs) definieren, wie GDI Farben in Ausgabevorgängen kombiniert, die einen aktuellen Pinsel, eine mögliche Quellbitmap und eine Zielbitmap umfassen. Dieser Parameter kann einer der folgenden Werte sein:

- PATCOPY Kopiert Muster zur Zielbitmap.

- PATINVERT Kombiniert Zielbitmap mit Muster mit dem Boolean XOR-Operator.

- DSTINVERT Kehrt die Zielbitmap um.

- BLACKNESS Dreht alle Ausgabe schwarz.

- WHITENESS Dreht alle Ausgabe weiß.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Das Muster ist eine Kombination aus dem ausgewählten Pinsel und dem Muster, das sich bereits auf dem Gerät befindet. Der von *dwRop* angegebene Raster-Operationscode definiert, wie die Muster kombiniert werden sollen. Die für diese Funktion aufgelisteten Raster-Operationen sind eine begrenzte Teilmenge der vollständigen 256 ternären Raster-Operation-Codes. Insbesondere kann ein Raster-Vorgangscode, der auf eine Quelle verweist, nicht verwendet werden.

Nicht alle Gerätekontexte `PatBlt` unterstützen die Funktion. Um zu bestimmen, `PatBlt`ob ein `GetDeviceCaps` Gerätekontext unterstützt, rufen Sie die Memberfunktion mit dem RASTERCAPS-Index auf und überprüfen Sie den Rückgabewert für das RC_BITBLT-Flag.

## <a name="cdcpie"></a><a name="pie"></a>CDC::Pie

Zeichnet einen kreisförmigen Keil, indem ein elliptischer Bogen gezeichnet wird, dessen Mittelpunkt und zwei Endpunkte durch Linien verbunden sind.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umgrenzenden Rechtecks (in logischen Einheiten) an.

*x3*<br/>
Gibt die x-Koordinate des Anfangspunkts des Bogens (in logischen Einheiten) an. Dieser Punkt muss nicht genau auf dem Bogen liegen.

*y3*<br/>
Gibt die y-Koordinate des Anfangspunkts des Bogens (in logischen Einheiten) an. Dieser Punkt muss nicht genau auf dem Bogen liegen.

*x4*<br/>
Gibt die x-Koordinate des Endpunkts des Bogens (in logischen Einheiten) an. Dieser Punkt muss nicht genau auf dem Bogen liegen.

*y4*<br/>
Gibt die y-Koordinate des Endpunkts des Bogens (in logischen Einheiten) an. Dieser Punkt muss nicht genau auf dem Bogen liegen.

*lpRect*<br/>
Gibt das umgrenzende Rechteck an. Sie können entweder `CRect` ein Objekt oder `RECT` einen Zeiger an eine Struktur für diesen Parameter übergeben.

*ptStart*<br/>
Gibt den Startpunkt des Bogens an. Dieser Punkt muss nicht genau auf dem Bogen liegen. Sie können entweder eine [POINT-Struktur](/windows/win32/api/windef/ns-windef-point) oder ein [CPoint-Objekt](../../atl-mfc-shared/reference/cpoint-class.md) für diesen Parameter übergeben.

*ptEnd*<br/>
Gibt den Endpunkt des Bogens an. Dieser Punkt muss nicht genau auf dem Bogen liegen. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Mittelpunkt des Bogens ist der Mittelpunkt des umgebenden Rechtecks, der durch *x1*, *y1*, *x2*und *y2* (oder von *lpRect)* angegeben wird. Die Start- und Endpunkte des Bogens werden durch *x3*, *y3*, *x4*und *y4* (oder durch *ptStart* und *ptEnd)* angegeben.

Der Bogen wird mit dem ausgewählten Stift gezeichnet und bewegt sich gegen den Uhrzeigersinn. Zwei zusätzliche Linien werden von jedem Endpunkt bis zum Mittelpunkt des Bogens gezeichnet. Der kreisförmige Bereich ist mit dem aktuellen Pinsel gefüllt. Wenn *x3* *gleich x4* und *y3* *y4*ist, ist das Ergebnis eine Ellipse mit einer einzelnen Linie von der Mitte der Ellipse bis zum Punkt ( *x3*, *y3*) oder ( *x4*, *y4*).

Die von dieser Funktion gezeichnete Figur erstreckt sich bis zu den rechten und unteren Koordinaten, aber nicht. Dies bedeutet, dass die Höhe der Figur *y2* - *y1* und die Breite der Figur *x2* - *x1*ist. Sowohl die Breite als auch die Höhe des umgrenzenden Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>CDC::PlayMetaFile

Spielt den Inhalt der angegebenen Metadatei im Gerätekontext ab.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parameter

*hMF*<br/>
Identifiziert die metadatei, die wiedergegeben werden soll.

*hEnhMetaFile*<br/>
Identifiziert die erweiterte Metadatei.

*lpBounds*<br/>
Zeigt auf `RECT` eine `CRect` Struktur oder ein Objekt, das die Koordinaten des umgrenzenden Rechtecks enthält, das zum Anzeigen des Bildes verwendet wird. Die Koordinaten werden in logischen Einheiten angegeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Metadatei kann bemalungsbehaftet gespielt werden.

In der `PlayMetaFile` zweiten Version von wird das Bild angezeigt, das in der angegebenen Metadatei im erweiterten Format gespeichert ist. Wenn eine Anwendung die `PlayMetaFile`zweite Version von aufruft, verwendet Windows den Bildrahmen im Header für erweiterte Metadatei, um das Bild dem Rechteck zuzuordnen, auf das der Parameter *lpBounds* zeigt. (Dieses Bild kann durch Festlegen der Welttransformation im Ausgabegerät vor `PlayMetaFile`dem Aufruf vererbt oder gedreht werden.) Punkte entlang der Ränder des Rechtecks sind im Bild enthalten. Ein erweitertes Metadateibild kann abgeschnitten werden, indem der Clipping-Bereich im Ausgabegerät definiert wird, bevor die erweiterte Metadatei wiedergegeben wird.

Wenn eine erweiterte Metadatei eine optionale Palette enthält, kann eine Anwendung konsistente Farben erzielen, `PlayMetaFile`indem sie eine Farbpalette auf dem Ausgabegerät einrichtet, bevor sie die zweite Version von aufruft. Verwenden Sie die `GetEnhMetaFilePaletteEntries` Windows-Funktion, um die optionale Palette abzurufen. Eine erweiterte Metadatei kann in eine neu erstellte erweiterte Metadatei `PlayMetaFile` eingebettet werden, indem die zweite Version der erweiterten Quellmetadatei aufgerufen und in den Gerätekontext für die neue erweiterte Metadatei abgespielt wird.

Die Zustände des Ausgabegerätekontexts werden durch diese Funktion beibehalten. Jedes Objekt, das in der erweiterten Metadatei erstellt, aber nicht gelöscht wurde, wird von dieser Funktion gelöscht. Um diese Funktion zu beenden, `CancelDC` kann eine Anwendung die Windows-Funktion aus einem anderen Thread aufrufen, um den Vorgang zu beenden. In diesem Fall gibt die Funktion Null zurück.

## <a name="cdcplgblt"></a><a name="plgblt"></a>CDC::PlgBlt

Führt eine Bitblockübertragung der Bits von Farbdaten vom angegebenen Rechteck im Quellgerätekontext auf das angegebene Parallelogramm im angegebenen Gerätekontext durch.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parameter

*lpPoint*<br/>
Zeigt auf ein Array von drei Punkten im logischen Raum, das drei Ecken des Zielparallelogramms identifiziert. Die obere linke Ecke des Quellrechtecks wird dem ersten Punkt in diesem Array, der oberen rechten Ecke dem zweiten Punkt in diesem Array und der unteren linken Ecke dem dritten Punkt zugeordnet. Die untere rechte Ecke des Quellrechtecks wird dem impliziten vierten Punkt im Parallelogramm zugeordnet.

*pSrcDC*<br/>
Identifiziert den Quellgerätekontext.

*xSrc*<br/>
Gibt die x-Koordinate in logischen Einheiten der oberen linken Ecke des Quellrechtecks an.

*ySrc*<br/>
Gibt die y-Koordinate in logischen Einheiten der oberen linken Ecke des Quellrechtecks an.

*nWidth*<br/>
Gibt die Breite des Quellrechtecks in logischen Einheiten an.

*nHeight*<br/>
Gibt die Höhe des Quellrechtecks in logischen Einheiten an.

*maskBitmap*<br/>
Identifiziert eine optionale monochrome Bitmap, die zum Maskieren der Farben des Quellrechtecks verwendet wird.

*xMaske*<br/>
Gibt die x-Koordinate der oberen linken Ecke der monochromen Bitmap an.

*yMask*<br/>
Gibt die y-Koordinate der oberen linken Ecke der monochromen Bitmap an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Wenn das angegebene Bitmaskenhandle eine gültige monochrome Bitmap identifiziert, verwendet die Funktion diese Bitmap, um die Bits von Farbdaten aus dem Quellrechteck zu maskieren.

Der vierte Scheitelpunkt des Parallelogramms (D) wird definiert, indem die ersten drei Punkte (A, B und C) als Vektoren und Daten D = B + C - A behandelt werden.

Wenn die Bitmaske vorhanden ist, gibt der Wert 1 in der Maske an, dass die Quellpixelfarbe in das Ziel kopiert werden soll. Der Wert 0 in der Maske gibt an, dass die Pixelfarbe des Ziels nicht geändert werden soll.

Wenn das Maskenrechteck kleiner als das Quell- und das Zielrechteck ist, repliziert die Funktion das Maskenmuster.

Skalierungs-, Übersetzungs- und Reflexionstransformationen sind im Quellgerätekontext zulässig. Rotations- und Schertransformationen sind jedoch nicht. Wenn es sich bei der Maskenbitmap nicht um eine monochrome Bitmap handelt, tritt ein Fehler auf. Der Dehnmodus für den Zielgerätekontext wird verwendet, um zu bestimmen, wie die Pixel dehnbar oder komprimiert werden, falls dies erforderlich ist. Wenn eine erweiterte Metadatei aufgezeichnet wird, tritt ein Fehler auf, wenn der Kontext des Quellgeräts einen erweiterten Metadatei-Gerätekontext identifiziert.

Die Zielkoordinaten werden gemäß dem Zielgerätekontext transformiert. Die Quellkoordinaten werden gemäß dem Quellgerätekontext transformiert. Wenn die Quelltransformation eine Drehung oder Scherung aufweist, wird ein Fehler zurückgegeben. Wenn die Ziel- und Quellrechtecke nicht `PlgBlt` das gleiche Farbformat aufweisen, konvertiert das Quellrechteck in das Zielrechteck. Nicht alle `PlgBlt`Geräte unterstützen . Weitere Informationen finden Sie in der Beschreibung `CDC::GetDeviceCaps` der RC_BITBLT-Raster-Funktion in der Memberfunktion.

Wenn die Kontexte des Quell- und `PlgBlt` Zielgeräts inkompatible Geräte darstellen, wird ein Fehler zurückgegeben.

## <a name="cdcpolybezier"></a><a name="polybezier"></a>CDC::PolyBezier

Zeichnet eine oder mehrere Bzier-Splines.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein [POINT](/windows/win32/api/windef/ns-windef-point) Array von POINT-Datenstrukturen, die die Endpunkte und Kontrollpunkte der Spline(s) enthalten.

*nCount*<br/>
Gibt die Anzahl der Punkte im *lpPoints-Array* an. Dieser Wert muss ein sthaniger der Anzahl der zu zeichnenden Splines sein, da jeder Bzier-Spline zwei Kontrollpunkte und einen Endpunkt erfordert und der anfangse Spline einen zusätzlichen Startpunkt erfordert.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Funktion zeichnet kubische Bzier-Splines mithilfe der Endpunkte und Kontrollpunkte, die durch den Parameter *lpPoints* angegeben werden. Der erste Spline wird vom ersten punkt zum vierten Punkt gezeichnet, indem der zweite und dritte Punkt als Kontrollpunkte verwendet werden. Jeder nachfolgende Spline in der Sequenz benötigt genau drei weitere Punkte: Der Endpunkt des vorherigen Splines wird als Ausgangspunkt verwendet, die nächsten zwei Punkte in der Sequenz sind Kontrollpunkte und der dritte ist der Endpunkt.

Die aktuelle Position wird von `PolyBezier` der Funktion weder verwendet noch aktualisiert. Die Figur ist nicht gefüllt. Diese Funktion zeichnet Linien mit dem aktuellen Stift.

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>CDC::PolyBezierTo

Zeichnet eine oder mehrere Bzier-Splines.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Verweist auf ein [POINT](/windows/win32/api/windef/ns-windef-point) Array von POINT-Datenstrukturen, das die Endpunkte und Kontrollpunkte enthält.

*nCount*<br/>
Gibt die Anzahl der Punkte im *lpPoints-Array* an. Dieser Wert muss dreimal so viele Splines wie auszeichnen, da jeder Bzier-Spline zwei Kontrollpunkte und einen Endpunkt erfordert.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Funktion zeichnet kubische Bzier-Splines mithilfe der durch den Parameter *lpPoints* angegebenen Kontrollpunkte. Der erste Spline wird von der aktuellen Position zum dritten Punkt gezeichnet, indem die ersten beiden Punkte als Kontrollpunkte verwendet werden. Für jeden nachfolgenden Spline benötigt die Funktion genau drei weitere Punkte und verwendet den Endpunkt des vorherigen Splines als Ausgangspunkt für den nächsten. `PolyBezierTo`verschiebt die aktuelle Position an den Endpunkt des letzten Bzier-Splines. Die Figur ist nicht gefüllt. Diese Funktion zeichnet Linien mit dem aktuellen Stift.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CDC::BeginPath](#beginpath).

## <a name="cdcpolydraw"></a><a name="polydraw"></a>CDC::PolyDraw

Zeichnet eine Reihe von Liniensegmenten und Bzier-Splines.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein [POINT](/windows/win32/api/windef/ns-windef-point) Array von POINT-Datenstrukturen, das die Endpunkte für jedes Liniensegment und die Endpunkte und Kontrollpunkte für jeden Bzier-Spline enthält.

*lpTypes*<br/>
Verweist auf ein Array, das angibt, wie jeder Punkt im *lpPoints-Array* verwendet wird. Folgende Werte sind möglich:

- PT_MOVETO Gibt an, dass dieser Punkt eine getrennte Abbildung startet. Dieser Punkt wird zur neuen aktuellen Position.

- PT_LINETO Gibt an, dass eine Linie von der aktuellen Position zu diesem Punkt gezeichnet werden soll, der dann zur neuen aktuellen Position wird.

- PT_BEZIERTO Gibt an, dass dieser Punkt ein Kontrollpunkt oder Endpunkt für einen Bzier-Spline ist.

PT_BEZIERTO Typen treten immer in Dreiergruppen auf. Die aktuelle Position definiert den Startpunkt für den Bzier-Spline. Die ersten beiden PT_BEZIERTO Punkte sind die Kontrollpunkte, und der dritte PT_BEZIERTO Punkt ist der Endpunkt. Der Endpunkt wird zur neuen aktuellen Position. Wenn nicht drei aufeinanderfolgende PT_BEZIERTO Punkte liegen, ergibt sich ein Fehler.

   Ein PT_LINETO oder PT_BEZIERTO Typ kann mit der folgenden Konstante kombiniert werden, indem der bitweise Operator ODER verwendet wird, um anzugeben, dass der entsprechende Punkt der letzte Punkt in einer Abbildung ist und die Abbildung geschlossen wird:

- PT_CLOSEFIGURE Gibt an, dass die Abbildung automatisch geschlossen wird, nachdem der PT_LINETO- oder PT_BEZIERTO Typ für diesen Punkt abgeschlossen ist. Von diesem Punkt wird eine Linie bis `MoveTo` zum letzten PT_MOVETO oder Punkt gezogen.

   Dieses Flag wird mit dem PT_LINETO Typ für eine Linie oder mit dem PT_BEZIERTO Typ des Endpunkts für einen Bzier-Spline kombiniert, indem der bitweise **ODER-Operator** verwendet wird. Die aktuelle Position wird auf den Endpunkt der Schlusslinie festgelegt.

*nCount*<br/>
Gibt die Gesamtzahl der Punkte im *lpPoints-Array* an, die mit der Anzahl der Bytes im *lpTypes-Array* identisch ist.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Funktion kann verwendet werden, um getrennte Zahlen `CDC::MoveTo` `CDC::LineTo`anstelle `CDC::PolyBezierTo` von aufeinanderfolgenden Aufrufen von , und Memberfunktionen zu zeichnen. Die Linien und Splines werden mit dem aktuellen Stift gezeichnet, und die Zahlen werden nicht gefüllt. Wenn ein aktiver Pfad durch `CDC::BeginPath` Aufrufen der `PolyDraw` Memberfunktion gestartet wird, fügt er dem Pfad hinzu. Die im *lpPoints-Array* und in *lpTypes* enthaltenen Punkte `CDC::MoveTo`geben `CDC::LineTo`an, `CDC::BezierTo` ob jeder Punkt Teil eines , a oder eines Vorgangs ist. Es ist auch möglich, Zahlen zu schließen. Diese Funktion aktualisiert die aktuelle Position.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CDC::BeginPath](#beginpath).

## <a name="cdcpolygon"></a><a name="polygon"></a>CDC::Polygon

Zeichnet ein Polygon, das aus zwei oder mehr Punkten (Scheitelpunkten) besteht, die durch Linien verbunden sind, mit dem aktuellen Stift.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein Array von Punkten, das die Scheitelpunkte des Polygons angibt. Jeder Punkt im Array `POINT` ist `CPoint` eine Struktur oder ein Objekt.

*nCount*<br/>
Gibt die Anzahl der Scheitelpunkte im Array an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Das System schließt das Polygon bei Bedarf automatisch, indem es eine Linie vom letzten Scheitelpunkt zum ersten Zeichen zeichnet.

Der aktuelle Polygon-Füllmodus kann mit den `GetPolyFillMode` `SetPolyFillMode` und Memberfunktionen abgerufen oder eingestellt werden.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>CDC::Polyline

Zeichnet eine Reihe von Liniensegmenten, die die von *lpPoints*angegebenen Punkte verbinden.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein `POINT` Array `CPoint` von Strukturen oder Objekten, die verbunden werden sollen.

*nCount*<br/>
Gibt die Anzahl der Punkte im Array an. Dieser Wert muss mindestens 2 sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Linien werden vom ersten Punkt durch nachfolgende Punkte mit dem aktuellen Stift gezeichnet. Im `LineTo` Gegensatz zur `Polyline` Memberfunktion verwendet die Funktion die aktuelle Position weder und aktualisiert sie auch nicht.

Weitere Informationen finden Sie unter [PolyLine](/windows/win32/api/wingdi/nf-wingdi-polyline) im Windows SDK.

## <a name="cdcpolylineto"></a><a name="polylineto"></a>CDC::PolylineTo

Zeichnet eine oder mehrere gerade Linien.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein [POINT](/windows/win32/api/windef/ns-windef-point) Array von POINT-Datenstrukturen, das die Scheitelpunkte der Zeile enthält.

*nCount*<br/>
Gibt die Anzahl der Punkte im Array an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Eine Linie wird von der aktuellen Position zum ersten Punkt gezeichnet, der durch den Parameter *lpPoints* mit dem aktuellen Stift angegeben wird. Für jede zusätzliche Linie zeichnet die Funktion vom Endpunkt der vorherigen Linie bis zum nächsten Punkt, der von *lpPoints*angegeben wird. `PolylineTo`verschiebt die aktuelle Position an den Endpunkt der letzten Zeile. Wenn die liniensegmente, die von dieser Funktion gezeichnet werden, eine geschlossene Figur bilden, wird die Figur nicht ausgefüllt.

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>CDC::PolyPolygon

Erstellt zwei oder mehr Polygone, die mit dem aktuellen Polygonfüllmodus gefüllt werden.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein `POINT` Array `CPoint` von Strukturen oder Objekten, die die Scheitelpunkte der Polygone definieren.

*lpPolyCounts*<br/>
Zeigt auf ein Array von Ganzzahlen, von denen jeder die Anzahl der Punkte in einem der Polygone im *lpPoints-Array* angibt.

*nCount*<br/>
Die Anzahl der Einträge im *lpPolyCounts-Array.* Diese Zahl gibt die Anzahl der polygonen an, die gezeichnet werden sollen. Dieser Wert muss mindestens 2 sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Polygone können getrennt oder überlappend sein.

Jedes Polygon, das in `PolyPolygon` einem Aufruf der Funktion angegeben wird, muss geschlossen werden. Im Gegensatz zu `Polygon` Polygonen, die von `PolyPolygon` der Memberfunktion erstellt werden, werden die polygonen, die von erstellt wurden, nicht automatisch geschlossen.

Die Funktion erstellt zwei oder mehr Polygone. Um ein einzelnes Polygon zu `Polygon` erstellen, sollte eine Anwendung die Memberfunktion verwenden.

Der aktuelle Polygon-Füllmodus kann mit den `GetPolyFillMode` `SetPolyFillMode` und Memberfunktionen abgerufen oder eingestellt werden.

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>CDC::PolyPolyline

Zeichnet mehrere Reihen verbundener Liniensegmente.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein Array von Strukturen, das die Scheitelpunkte der Polylinien enthält. Die Polylinien werden fortlaufend angegeben.

*lpPolyPoints*<br/>
Zeigt auf ein Array von Variablen, die die Anzahl der Punkte im *lpPoints-Array* für das entsprechende Polygon angeben. Jeder Eintrag muss größer oder gleich 2 sein.

*nCount*<br/>
Gibt die Gesamtzahl der Zählungen im *lpPolyPoints-Array* an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Liniensegmente werden mit dem aktuellen Stift gezeichnet. Die von den Segmenten gebildeten Figuren werden nicht gefüllt. Die aktuelle Position wird von dieser Funktion weder verwendet noch aktualisiert.

## <a name="cdcptvisible"></a><a name="ptvisible"></a>CDC::PtVisible

Bestimmt, ob sich der angegebene Punkt innerhalb des Zuschneidebereichs des Gerätekontexts befindet.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate des Punktes an.

*y*<br/>
Gibt die logische y-Koordinate des Punktes an.

*Punkt*<br/>
Gibt den Punkt an, der logische Koordinaten einchecken soll. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich Null, wenn sich der angegebene Punkt innerhalb des Zuschneidebereichs befindet; andernfalls 0.

## <a name="cdcqueryabort"></a><a name="queryabort"></a>CDC::QueryAbort

Ruft die Abbruchfunktion auf, die von der [SetAbortProc-Memberfunktion](#setabortproc) für eine Druckanwendung installiert wurde, und fragt ab, ob der Druckvorgang beendet werden soll.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Rückgabewert

Der Rückgabewert ist ungleich Null, wenn der Druckvorgang fortgesetzt werden soll oder wenn keine Abbruchprozedur vorliegt. Es ist 0, wenn der Druckauftrag beendet werden soll. Der Rückgabewert wird von der Abbruchfunktion bereitgestellt.

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>CDC::RealizePalette

Ordnet Einträge aus der aktuellen logischen Palette der Systempalette zu.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Rückgabewert

Gibt an, wie viele Einträge in der logischen Palette verschiedenen Einträgen in der Systempalette zugeordnet wurden. Dies stellt die Anzahl der Einträge dar, die diese Funktion neu zugeordnet hat, um Änderungen in der Systempalette seit der letzten Realisierung der logischen Palette zu berücksichtigen.

### <a name="remarks"></a>Bemerkungen

Eine logische Farbpalette fungiert als Puffer zwischen farbintensiven Anwendungen und dem System, sodass eine Anwendung so viele Farben wie erforderlich verwenden kann, ohne die eigenen angezeigten Farben oder die von anderen Fenstern angezeigten Farben zu stören.

Wenn ein Fenster den Eingabefokus hat und Aufrufe `RealizePalette`, Windows stellt sicher, dass das Fenster alle angeforderten Farben anzeigt, bis zu der maximalen Anzahl, die gleichzeitig auf dem Bildschirm verfügbar ist. Windows zeigt auch Farben an, die in der Palette des Fensters nicht gefunden wurden, indem sie mit den verfügbaren Farben übereinstimmen.

Darüber hinaus entspricht Windows den Farben, die von inaktiven Fenstern angefordert werden, die die Funktion so nahe wie möglich an die verfügbaren Farben aufrufen. Dadurch werden unerwünschte Änderungen in den Farben, die in inaktiven Fenstern angezeigt werden, deutlich reduziert.

## <a name="cdcrectangle"></a><a name="rectangle"></a>CDC::Rechteck

Zeichnet ein Rechteck mit dem aktuellen Stift.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des Rechtecks (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*lpRect*<br/>
Gibt das Rechteck in logischen Einheiten an. Sie können entweder `CRect` ein Objekt oder `RECT` einen Zeiger an eine Struktur für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Das Innere des Rechtecks wird mit dem aktuellen Pinsel gefüllt.

Das Rechteck erstreckt sich bis zu den rechten und unteren Koordinaten, aber nicht. Dies bedeutet, dass die Höhe des Rechtecks *y2* - *y1* und die Breite des Rechtecks *x2* - *x1*ist. Sowohl die Breite als auch die Höhe eines Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>CDC::RectVisible

Bestimmt, ob ein Teil des angegebenen Rechtecks innerhalb des Zuschneidebereichs des Anzeigekontexts liegt.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Zeigt auf `RECT` eine `CRect` Struktur oder ein Objekt, das die logischen Koordinaten des angegebenen Rechtecks enthält.

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich Null, wenn sich ein Teil des angegebenen Rechtecks innerhalb des Zuschneidebereichs befindet. andernfalls 0.

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>CDC::ReleaseAttribDC

Rufen Sie diese `m_hAttribDC` Memberfunktion auf, um auf NULL zu setzen.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Bemerkungen

Dies führt `Detach` nicht dazu, dass eine auftritt. Nur der Kontext des Ausgabegeräts ist an das `CDC` Objekt angefügt, und nur er kann getrennt werden.

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>CDC::ReleaseOutputDC

Rufen Sie diese Memberfunktion auf, um den `m_hDC` Member auf NULL festzulegen.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion kann nicht aufgerufen werden, wenn `CDC` der Kontext des Ausgabegeräts an das Objekt angefügt ist. Verwenden `Detach` Sie die Memberfunktion, um den Kontext des Ausgabegeräts zu trennen.

## <a name="cdcresetdc"></a><a name="resetdc"></a>CDC::ResetDC

Rufen Sie diese Memberfunktion auf, `CDC` um den vom Objekt umschlossenen Gerätekontext zu aktualisieren.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parameter

*lpDevMode*<br/>
Ein Zeiger auf `DEVMODE` eine Windows-Struktur.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Gerätekontext wird anhand der in `DEVMODE` der Windows-Struktur angegebenen Informationen aktualisiert. Diese Memberfunktion setzt nur den Attributgerätekontext zurück.

Eine Anwendung verwendet `ResetDC` in der Regel die `WM_DEVMODECHANGE` Memberfunktion, wenn ein Fenster eine Nachricht verarbeitet. Sie können diese Memberfunktion auch verwenden, um die Papierausrichtung oder Papierbehälter beim Drucken eines Dokuments zu ändern.

Sie können diese Memberfunktion nicht verwenden, um den Treibernamen, den Gerätenamen oder den Ausgabeanschluss zu ändern. Wenn der Benutzer die Portverbindung oder den Gerätenamen ändert, müssen Sie den ursprünglichen Gerätekontext löschen und mit den neuen Informationen einen neuen Gerätekontext erstellen.

Bevor Sie diese Memberfunktion aufrufen, müssen Sie sicherstellen, dass alle Objekte (mit weniger als Lagerobjekte), die im Gerätekontext ausgewählt wurden, ausgewählt wurden.

## <a name="cdcrestoredc"></a><a name="restoredc"></a>CDC::RestoreDC

Stellt den Gerätekontext in den vorherigen Zustand wieder her, der von *nSavedDC*identifiziert wurde.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parameter

*nSavedDC*<br/>
Gibt den Gerätekontext an, der wiederhergestellt werden soll. Es kann sich um einen `SaveDC` Wert handelt, der von einem vorherigen Funktionsaufruf zurückgegeben wird. Wenn *nSavedDC* -1 ist, wird der zuletzt gespeicherte Gerätekontext wiederhergestellt.

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich Null, wenn der angegebene Kontext wiederhergestellt wurde; andernfalls 0.

### <a name="remarks"></a>Bemerkungen

`RestoreDC`stellt den Gerätekontext wieder her, indem Statusinformationen aus `SaveDC` einem Stapel entfernt werden, der durch frühere Aufrufe der Memberfunktion erstellt wurde.

Der Stapel kann die Statusinformationen für mehrere Gerätekontexte enthalten. Wenn sich der von *nSavedDC* angegebene Kontext nicht `RestoreDC` am oberen Rand des Stapels befindet, werden alle Statusinformationen zwischen dem von *nSavedDC* angegebenen Gerätekontext und dem oberen Rand des Stapels gelöscht. Die gelöschten Informationen gehen verloren.

## <a name="cdcroundrect"></a><a name="roundrect"></a>CDC::RoundRect

Zeichnet ein Rechteck mit abgerundeten Ecken mit dem aktuellen Stift.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des Rechtecks (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*x3*<br/>
Gibt die Breite der Ellipse an, die zum Zeichnen der abgerundeten Ecken (in logischen Einheiten) verwendet wird.

*y3*<br/>
Gibt die Höhe der Ellipse an, die zum Zeichnen der abgerundeten Ecken (in logischen Einheiten) verwendet wird.

*lpRect*<br/>
Gibt das umgrenzende Rechteck in logischen Einheiten an. Sie können entweder `CRect` ein Objekt oder `RECT` einen Zeiger an eine Struktur für diesen Parameter übergeben.

*Punkt*<br/>
Die x-Koordinate des *Punkts* gibt die Breite der Ellipse an, um die abgerundeten Ecken (in logischen Einheiten) zu zeichnen. Die y-Koordinate des *Punkts* gibt die Höhe der Ellipse an, um die abgerundeten Ecken (in logischen Einheiten) zu zeichnen. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Das Innere des Rechtecks wird mit dem aktuellen Pinsel gefüllt.

Die Figur, die diese Funktion zeichnet, erstreckt sich bis zu, enthält aber nicht die rechten und unteren Koordinaten. Dies bedeutet, dass die Höhe der Figur *y2* - *y1* und die Breite der Figur *x2* - *x1*ist. Sowohl die Höhe als auch die Breite des umgrenzenden Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>CDC::SaveDC

Speichert den aktuellen Status des Gerätekontexts, indem Statusinformationen (z. B. Zuschneidebereich, ausgewählte Objekte und Zuordnungsmodus) in einen von Windows verwalteten Kontextstapel kopiert werden.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Rückgabewert

Eine ganze Zahl, die den gespeicherten Gerätekontext identifiziert. Es ist 0, wenn ein Fehler auftritt. Dieser Rückgabewert kann verwendet werden, um `RestoreDC`den Gerätekontext durch Aufrufen von wiederherzustellen.

### <a name="remarks"></a>Bemerkungen

Der gespeicherte Gerätekontext kann später `RestoreDC`mithilfe von wiederhergestellt werden.

`SaveDC`kann bemalungsbehaftet verwendet werden, um eine beliebige Anzahl von Gerätekontextzuständen zu speichern.

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>CDC::ScaleViewportExt

Ändert die Ansichtsfensterausdehnungen relativ zu den aktuellen Werten.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parameter

*xNum*<br/>
Gibt den Betrag an, mit dem die aktuelle x-Ausdehnung multipliziert werden soll.

*xDenom*<br/>
Gibt den Betrag an, um den das Ergebnis der Multiplikation der aktuellen x-Ausdehnung mit dem Wert des *parameters xNum* dividiert werden soll.

*yNum*<br/>
Gibt den Betrag an, mit dem die aktuelle y-Ausdehnung multipliziert werden soll.

*yDenom*<br/>
Gibt den Betrag an, um den das Ergebnis der Multiplikation der aktuellen y-Ausdehnung mit dem Wert des *parameters yNum* dividiert werden soll.

### <a name="return-value"></a>Rückgabewert

Die vorherigen Ansichtsfenstererweiterungen (in `CSize` Geräteeinheiten) als Objekt.

### <a name="remarks"></a>Bemerkungen

Die Formeln sind wie folgt geschrieben:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Die neuen Ansichtsfensterausdehnungen werden berechnet, indem die aktuellen Ausdehnungen mit dem angegebenen Zähler multipliziert und dann durch den angegebenen Nenner dividiert werden.

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>CDC::ScaleWindowExt

Ändert die Fensterausdehnungen relativ zu den aktuellen Werten.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parameter

*xNum*<br/>
Gibt den Betrag an, mit dem die aktuelle x-Ausdehnung multipliziert werden soll.

*xDenom*<br/>
Gibt den Betrag an, um den das Ergebnis der Multiplikation der aktuellen x-Ausdehnung mit dem Wert des *parameters xNum* dividiert werden soll.

*yNum*<br/>
Gibt den Betrag an, mit dem die aktuelle y-Ausdehnung multipliziert werden soll.

*yDenom*<br/>
Gibt den Betrag an, um den das Ergebnis der Multiplikation der aktuellen y-Ausdehnung mit dem Wert des *parameters yNum* dividiert werden soll.

### <a name="return-value"></a>Rückgabewert

Die vorherigen Fenstererweiterungen (in logischen Einheiten) als `CSize` Objekt.

### <a name="remarks"></a>Bemerkungen

Die Formeln sind wie folgt geschrieben:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Die neuen Fensterausdehnungen werden berechnet, indem die aktuellen Ausdehnungen mit dem angegebenen Zähler multipliziert und dann durch den angegebenen Nenner dividiert werden.

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>CDC::ScrollDC

Scrollt ein Rechteck aus Bits horizontal und vertikal.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parameter

*Dx*<br/>
Gibt die Anzahl der horizontalen Bildlaufeinheiten an.

*Dy*<br/>
Gibt die Anzahl der vertikalen Bildlaufeinheiten an.

*lpRectScroll*<br/>
Zeigt auf `RECT` die `CRect` Struktur oder das Objekt, das die Koordinaten des Bildlaufrechtecks enthält.

*lpRectClip*<br/>
Zeigt auf `RECT` die `CRect` Struktur oder das Objekt, das die Koordinaten des Zuschneiderechtecks enthält. Wenn dieses Rechteck kleiner ist als das ursprüngliche Rechteck, auf das von *lpRectScroll*verwiesen wird, erfolgt der Bildlauf nur im kleineren Rechteck.

*pRgnUpdate*<br/>
Identifiziert den Bereich, der durch den Bildlaufprozess aufgedeckt wurde. Die `ScrollDC` Funktion definiert diesen Bereich; es ist nicht unbedingt ein Rechteck.

*lpRectUpdate*<br/>
Zeigt auf `RECT` die `CRect` Struktur oder das Objekt, das die Koordinaten des Rechtecks empfängt, das den Bildlaufaktualisierungsbereich begrenzt. Dies ist der größte rechteckige Bereich, der neu gestrichen werden muss. Die Werte in der Struktur oder dem Objekt, wenn die Funktion zurückgegeben wird, befinden sich in Clientkoordinaten, unabhängig vom Zuordnungsmodus für den angegebenen Gerätekontext.

### <a name="return-value"></a>Rückgabewert

Ein Wert ungleich Null, wenn ein Bildlauf ausgeführt wird; andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Wenn *lpRectUpdate* NULL ist, berechnet Windows das Updaterechteck nicht. Wenn sowohl *pRgnUpdate* als auch *lpRectUpdate* NULL sind, berechnet Windows die Updateregion nicht. Wenn *pRgnUpdate* nicht NULL ist, geht Windows davon aus, dass es einen gültigen Zeiger `ScrollDC` auf den Bereich enthält, der durch den Bildlaufprozess (definiert durch die Memberfunktion) aufgedeckt wurde. Der in *lpRectUpdate* zurückgegebene Aktualisierungsbereich kann `CWnd::InvalidateRgn` bei Bedarf übergeben werden.

Eine Anwendung sollte `ScrollWindow` die Memberfunktion der Klasse `CWnd` verwenden, wenn ein Bild vom Bildlauf im gesamten Clientbereich eines Fensters erforderlich ist. Andernfalls sollte es `ScrollDC`verwenden.

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>CDC::SelectClipPath

Wählt den aktuellen Pfad als Zuschneidebereich für den Gerätekontext aus und kombiniert den neuen Bereich mit einem vorhandenen Clipping-Bereich mithilfe des angegebenen Modus.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parameter

*nMode*<br/>
Gibt die Art und Weise an, wie der Pfad verwendet werden soll. Folgende Werte sind zulässig:

- RGN_AND Der neue Schnittbereich enthält den Schnittpunkt (überlappende Bereiche) des aktuellen Zuschneidebereichs und des aktuellen Pfads.

- RGN_COPY Der neue Zuschneidebereich ist der aktuelle Pfad.

- RGN_DIFF Der neue Zuschneidebereich enthält die Bereiche des aktuellen Zuschneidebereichs und die Bereiche des aktuellen Pfads werden ausgeschlossen.

- RGN_OR Der neue Clipping-Bereich enthält die Union (kombinierte Bereiche) des aktuellen Clipping-Bereichs und den aktuellen Pfad.

- RGN_XOR Der neue Zuschneidebereich enthält die Vereinigung des aktuellen Clipping-Bereichs und des aktuellen Pfads, jedoch ohne die überlappenden Bereiche.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der identifizierte Gerätekontext muss einen geschlossenen Pfad enthalten.

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>CDC::SelectClipRgn

Wählt den angegebenen Bereich als aktuellen Zuschneidebereich für den Gerätekontext aus.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parameter

*pRgn*<br/>
Identifiziert die region, die ausgewählt werden soll.

- Wenn dieser Wert für die erste Version dieser Funktion NULL ist, wird der gesamte Clientbereich ausgewählt, und die Ausgabe wird weiterhin in das Fenster abgeschnitten.

- Für die zweite Version dieser Funktion kann dieses Handle nur dann NULL sein, wenn der RGN_COPY Modus angegeben ist.

*nMode*<br/>
Gibt den auszuführenden Vorgang an. Es muss einer der folgenden Werte sein:

- RGN_AND Der neue Zuschneidebereich kombiniert die überlappenden Bereiche des aktuellen Zuschneidebereichs und des von *pRgn*identifizierten Bereichs.

- RGN_COPY Der neue Zuschneidebereich ist eine Kopie der region, die von *pRgn*identifiziert wurde. Dies ist die Funktionalität, `SelectClipRgn`die mit der ersten Version von identisch ist. Wenn der von *pRgn* identifizierte Bereich NULL ist, wird der neue Clipping-Bereich zum Standard-Clipping-Bereich (ein Null-Bereich).

- RGN_DIFF Der neue Clipping-Bereich kombiniert die Bereiche des aktuellen Clipping-Bereichs mit den Bereichen, die von der von *pRgn*identifizierten Region ausgeschlossen sind.

- RGN_OR Der neue Zuschneidebereich kombiniert den aktuellen Zuschneidebereich und den von *pRgn*identifizierten Bereich.

- RGN_XOR Der neue Zuschneidebereich kombiniert den aktuellen Zuschneidebereich und den von *pRgn* identifizierten Bereich, schließt jedoch überlappende Bereiche aus.

### <a name="return-value"></a>Rückgabewert

Der Typ der Region. Dabei kann es sich um einen der folgenden Werte handeln:

- COMPLEXREGION Neuer Zuschneidebereich hat überlappende Grenzen.

- FEHLER Gerätekontext oder -Region ist ungültig.

- NULLREGION Neuer Clipping-Bereich ist leer.

- SIMPLEREGION Neuer Zuschneidebereich hat keine überlappenden Rahmen.

### <a name="remarks"></a>Bemerkungen

Es wird nur eine Kopie des ausgewählten Bereichs verwendet. Die Region selbst kann für eine beliebige Anzahl anderer Gerätekontexte ausgewählt oder gelöscht werden.

Die Funktion geht davon aus, dass die Koordinaten für den angegebenen Bereich in Geräteeinheiten angegeben werden. Einige Druckergeräte unterstützen die Textausgabe mit einer höheren Auflösung als die Grafikausgabe, um die Fürstliche Textmetriken zu gewährleisten. Diese Geräte melden Geräteeinheiten mit der höheren Auflösung, d. h. in Texteinheiten. Diese Geräte skalieren dann Koordinaten für Grafiken, sodass mehrere gemeldete Geräteeinheiten nur einer Grafikeinheit zugeordnet sind. Sie sollten die `SelectClipRgn` Funktion immer mithilfe von Texteinheiten aufrufen.

Anwendungen, die die Skalierung von Grafikobjekten in der GDI übernehmen müssen, können den GETSCALINGFACTOR-Druckerescapeverwenden verwenden, um den Skalierungsfaktor zu bestimmen. Dieser Skalierungsfaktor wirkt sich auf das Clipping aus. Wenn ein Bereich zum Schneiden von Grafiken verwendet wird, teilt GDI die Koordinaten durch den Skalierungsfaktor. Wenn der Bereich zum Schneiden von Text verwendet wird, nimmt GDI keine Skalierungsanpassung vor. Ein Skalierungsfaktor von 1 bewirkt, dass die Koordinaten durch 2 geteilt werden. ein Skalierungsfaktor von 2 bewirkt, dass die Koordinaten durch 4 geteilt werden; Und so weiter.

## <a name="cdcselectobject"></a><a name="selectobject"></a>CDC::SelectObject

Wählt ein Objekt im Gerätekontext aus.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parameter

*pPen*<br/>
Ein Zeiger auf ein [auszuwählendes CPen-Objekt.](../../mfc/reference/cpen-class.md)

*pBrush*<br/>
Ein Zeiger auf ein [ausgewähltes CBrush-Objekt.](../../mfc/reference/cbrush-class.md)

*pFont*<br/>
Ein Zeiger auf ein [ausgewähltes CFont-Objekt.](../../mfc/reference/cfont-class.md)

*pBitmap*<br/>
Ein Zeiger auf ein [ausgewähltes CBitmap-Objekt.](../../mfc/reference/cbitmap-class.md)

*pRgn*<br/>
Ein Zeiger auf ein [cRgn-Objekt,](../../mfc/reference/crgn-class.md) das ausgewählt werden soll.

*pObject*<br/>
Ein Zeiger auf ein [cGdiObject-Objekt,](../../mfc/reference/cgdiobject-class.md) das ausgewählt werden soll.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf das zu ersetzende Objekt. Dies ist ein Zeiger auf ein Objekt `CGdiObject`einer der `CPen`von abgeleiteten Klassen, z. B. , je nachdem, welche Version der Funktion verwendet wird. Der Rückgabewert ist NULL, wenn ein Fehler auftritt. Diese Funktion gibt möglicherweise einen Zeiger auf ein temporäres Objekt zurück. Dieses temporäre Objekt ist nur während der Verarbeitung einer Windows-Nachricht gültig. Weitere Informationen finden Sie unter `CGdiObject::FromHandle`.

Die Version der Memberfunktion, die einen Regionsparameter `SelectClipRgn` übernimmt, führt dieselbe Aufgabe aus wie die Memberfunktion. Sein Rückgabewert kann einer der folgenden sein:

- COMPLEXREGION Neuer Zuschneidebereich hat überlappende Grenzen.

- FEHLER Gerätekontext oder -Region ist ungültig.

- NULLREGION Neuer Clipping-Bereich ist leer.

- SIMPLEREGION Neuer Zuschneidebereich hat keine überlappenden Rahmen.

### <a name="remarks"></a>Bemerkungen

Die `CDC` Klasse bietet fünf Versionen, die auf bestimmte Arten von GDI-Objekten spezialisiert sind, einschließlich Stifte, Pinsel, Schriftarten, Bitmaps und Regionen. Das neu ausgewählte Objekt ersetzt das vorherige Objekt desselben Typs. Wenn z. B. *pObject* `SelectObject` der allgemeinen Version von Punkten auf ein [CPen-Objekt,](../../mfc/reference/cpen-class.md) ersetzt die Funktion den aktuellen Stift durch den von *pObject*angegebenen Stift .

Eine Anwendung kann eine Bitmap nur in Speichergerätekontexten und jeweils nur in einem Speichergerätekontext auswählen. Das Format der Bitmap muss entweder monochrom oder mit dem Gerätekontext kompatibel sein. Wenn dies `SelectObject` nicht der Fall ist, wird ein Fehler zurückgegeben.

Für Windows 3.1 und `SelectObject` höher gibt die Funktion denselben Wert zurück, unabhängig davon, ob er in einer Metadatei verwendet wird oder nicht. In früheren Versionen `SelectObject` von Windows wurde ein Wert ungleich Null für Erfolg und 0 für Fehler zurückgegeben, wenn er in einer Metadatei verwendet wurde.

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>CDC::SelectPalette

Wählt die logische Palette aus, die von *pPalette* als ausgewähltes Palettenobjekt des Gerätekontexts angegeben wird.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parameter

*pPalette*<br/>
Identifiziert die zu wählende logische Palette. Diese Palette muss bereits mit `CPalette` der Memberfunktion [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)erstellt worden sein.

*bForceBackground*<br/>
Gibt an, ob die logische Palette gezwungen ist, eine Hintergrundpalette zu sein. Wenn *bForceBackground* ungleich Null ist, ist die ausgewählte Palette immer eine Hintergrundpalette, unabhängig davon, ob das Fenster den Eingabefokus hat. Wenn *bForceBackground* 0 ist und der Gerätekontext an ein Fenster angefügt ist, ist die logische Palette eine Vordergrundpalette, wenn das Fenster den Eingabefokus hat.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf `CPalette` ein Objekt, das die logische Palette identifiziert, die durch die von *pPalette*angegebene Palette ersetzt wird. Es ist NULL, wenn ein Fehler auftritt.

### <a name="remarks"></a>Bemerkungen

Die neue Palette wird zum Palettenobjekt, das von GDI verwendet wird, um die im Gerätekontext angezeigten Farben zu steuern und die vorherige Palette zu ersetzen.

Eine Anwendung kann eine logische Palette in mehr als einem Gerätekontext auswählen. Änderungen an einer logischen Palette wirken sich jedoch auf alle Gerätekontexte aus, für die sie ausgewählt ist. Wenn eine Anwendung eine Palette in mehr als einem Gerätekontext auswählt, müssen die Gerätekontexte alle zum gleichen physischen Gerät gehören.

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>CDC::SelectStockObject

Wählt ein [CGdiObject-Objekt](../../mfc/reference/cgdiobject-class.md) aus, das einem der vordefinierten Stockstifte, Pinsel oder Schriftarten entspricht.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parameter

*nIndex*<br/>
Gibt die Art des gewünschten Lagerobjekts an. Es kann sich um einen der folgenden Werte handeln:

- BLACK_BRUSH schwarze Bürste.

- DKGRAY_BRUSH dunkelgrauer Pinsel.

- GRAY_BRUSH grauer Pinsel.

- HOLLOW_BRUSH Hohlbürste.

- LTGRAY_BRUSH hellgrauer Pinsel.

- NULL_BRUSH Null-Pinsel.

- WHITE_BRUSH weißer Pinsel.

- BLACK_PEN schwarzer Stift.

- NULL_PEN Null-Stift.

- WHITE_PEN weißer Stift.

- ANSI_FIXED_FONT ANSI-Systemschriftart behoben.

- ANSI_VAR_FONT ANSI-Variablensystemschriftart.

- DEVICE_DEFAULT_FONT geräteabhängige Schriftart.

- OEM_FIXED_FONT OEM-abhängige feste Schriftart.

- SYSTEM_FONT Die Systemschriftart. Standardmäßig verwendet Windows die Systemschriftart, um Menüs, Dialogfeldsteuerelemente und anderen Text zu zeichnen. Es ist jedoch am besten, sich nicht auf SYSTEM_FONT zu verlassen, um die Schriftart zu erhalten, die von Dialogen und Fenstern verwendet wird. Verwenden Sie `SystemParametersInfo` stattdessen die Funktion mit dem Parameter SPI_GETNONCLIENTMETRICS, um die aktuelle Schriftart abzurufen. `SystemParametersInfo`berücksichtigt das aktuelle Design und stellt Schriftartinformationen für Beschriftungen, Menüs und Meldungsdialoge bereit.

- SYSTEM_FIXED_FONT Die Systemschriftart mit fester Breite, die in Windows vor Version 3.0 verwendet wurde. Dieses Objekt ist für die Kompatibilität mit früheren Windows-Versionen verfügbar.

- DEFAULT_PALETTE Standardfarbpalette. Diese Palette besteht aus den 20 statischen Farben in der Systempalette.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf `CGdiObject` das Objekt, das ersetzt wurde, wenn die Funktion erfolgreich ist. Das eigentliche Objekt, auf das verwiesen wird, ist ein [CPen-,](../../mfc/reference/cpen-class.md) [CBrush-](../../mfc/reference/cbrush-class.md)oder [CFont-Objekt.](../../mfc/reference/cfont-class.md) Wenn der Aufruf nicht erfolgreich ist, lautet der Rückgabewert NULL.

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>CDC::SetAbortProc

Installiert das Abbruchverfahren für den Druckauftrag.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parameter

*lpfn*<br/>
Ein Zeiger auf die Abbruchfunktion, die als Abbruchprozedur installiert werden soll. Weitere Informationen zur Rückruffunktion finden Sie unter [Callback-Funktion für CDC::SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Rückgabewert

Gibt das Ergebnis `SetAbortProc` der Funktion an. Einige der folgenden Werte sind wahrscheinlicher als andere, aber alle sind möglich.

- SP_ERROR Allgemeiner Fehler.

- SP_OUTOFDISK Es ist derzeit nicht genügend Speicherplatz für das Spooling verfügbar, und es wird kein Speicherplatz mehr verfügbar.

- SP_OUTOFMEMORY Nicht genügend Arbeitsspeicher steht zum Spoolen zur Verfügung.

- SP_USERABORT Benutzer hat den Auftrag über den Druck-Manager beendet.

### <a name="remarks"></a>Bemerkungen

Wenn eine Anwendung zulassen soll, dass der Druckauftrag während des Spoolings abgebrochen wird, muss sie die Abbruchfunktion festlegen, bevor der Druckauftrag mit der [StartDoc-Memberfunktion](#startdoc) gestartet wird. Der Druck-Manager ruft die Abbruchfunktion während des Spoolings auf, damit die Anwendung den Druckauftrag abbrechen oder Nicht-Festplattenplatzbedingungen verarbeiten kann. Wenn keine Abbruchfunktion festgelegt ist, schlägt der Druckauftrag fehl, wenn nicht genügend Speicherplatz zum Spoolen vorhanden ist.

Beachten Sie, dass die Features von Microsoft Visual C++ `SetAbortProc`die Erstellung der Rückruffunktion vereinfachen, die an übergeben wird. Die an die `EnumObjects` Memberfunktion übergebene Adresse ist `__declspec(dllexport)` ein Zeiger `__stdcall` auf eine Funktion, die mit und mit der aufrufenden Konvention exportiert wird.

Sie müssen auch den Funktionsnamen nicht in einer **EXPORTS-Anweisung** in der Moduldefinitionsdatei Ihrer Anwendung exportieren. Sie können stattdessen den Modifikator **EXPORT-Funktion** verwenden, wie in

**BOOL CALLBACK EXPORT** AFunction( **HDC**, `int` **);**

, damit der Compiler den richtigen Exportdatensatz für den Export mit Namen ohne Aliasing ausgibt. Dies funktioniert für die meisten Bedürfnisse. Für einige Sonderfälle, z. B. das Exportieren einer Funktion durch Ordinal oder das Aliasing des Exports, müssen Sie weiterhin eine **EXPORTS-Anweisung** in einer Moduldefinitionsdatei verwenden.

Rückrufregistrierungsschnittstellen sind jetzt typsicher (Sie müssen einen Funktionszeiger übergeben, der auf die richtige Art von Funktion für den jeweiligen Rückruf verweist).

Beachten Sie außerdem, dass alle Rückruffunktionen Microsoft Foundation-Ausnahmen abfangen müssen, bevor sie zu Windows zurückkehren, da Ausnahmen nicht über Rückrufgrenzen hinweg ausgelöst werden können. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>CDC::SetArcDirection

Legt die Zeichnungsrichtung fest, die für Bogen- und Rechteckfunktionen verwendet werden soll.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parameter

*nArcDirection*<br/>
Gibt die neue Bogenrichtung an. Dieser Parameter kann einer der folgenden Werte sein:

- AD_COUNTERCLOCKWISE Figuren gegen den Uhrzeigersinn gezeichnet.

- AD_CLOCKWISE Figuren im Uhrzeigersinn gezeichnet.

### <a name="return-value"></a>Rückgabewert

Gibt die alte Bogenrichtung an, falls erfolgreich; andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Die Standardrichtung ist gegen den Uhrzeigersinn. Die `SetArcDirection` Funktion gibt die Richtung an, in die die folgenden Funktionen zeichnen:

|Arc|Kreisdiagramm|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>CDC::SetAttribDC

Rufen Sie diese Funktion auf, `m_hAttribDC`um den Attributgerätekontext festzulegen.

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parameter

*Hdc*<br/>
Ein Windows-Gerätekontext.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion fügt den Gerätekontext `CDC` nicht an das Objekt an. Nur der Kontext des Ausgabegeräts ist an ein `CDC` Objekt angefügt.

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>CDC::SetBkColor

Legt die aktuelle Hintergrundfarbe auf die angegebene Farbe fest.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crColor*<br/>
Gibt die neue Hintergrundfarbe an.

### <a name="return-value"></a>Rückgabewert

Die vorherige Hintergrundfarbe als RGB-Farbwert. Wenn ein Fehler auftritt, lautet der Rückgabewert 0x8000000.

### <a name="remarks"></a>Bemerkungen

Wenn der Hintergrundmodus OPAQUE ist, verwendet das System die Hintergrundfarbe, um die Lücken in gestylten Linien, die Lücken zwischen schraffierten Linien in Pinsel nund den Hintergrund in Zeichenzellen zu füllen. Das System verwendet auch die Hintergrundfarbe beim Konvertieren von Bitmaps zwischen Farb- und monochromen Gerätekontexten.

Wenn das Gerät die angegebene Farbe nicht anzeigen kann, legt das System die Hintergrundfarbe auf die nächste physische Farbe fest.

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>CDC::SetBkMode

Legt den Hintergrundmodus fest.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parameter

*nBkMode*<br/>
Gibt den festzulegenden Modus an. Dieser Parameter kann einer der folgenden Werte sein:

- OPAQUE Hintergrund wird mit der aktuellen Hintergrundfarbe gefüllt, bevor der Text, der geschlüpfte Pinsel oder der Stift gezeichnet wird. Dies ist der Standardhintergrundmodus.

- TRANSPARENT Hintergrund wird vor dem Zeichnen nicht geändert.

### <a name="return-value"></a>Rückgabewert

Der vorherige Hintergrundmodus.

### <a name="remarks"></a>Bemerkungen

Der Hintergrundmodus definiert, ob das System vorhandene Hintergrundfarben auf der Zeichnungsfläche entfernt, bevor Text, schraffierte Pinsel oder ein Stiftstil gezeichnet werden, der keine durchgezogene Linie ist.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>CDC::SetBoundsRect

Steuert die Akkumulation von Bounding-Rechteck-Informationen für den angegebenen Gerätekontext.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parameter

*lpRectBounds*<br/>
Zeigt auf `RECT` eine `CRect` Struktur oder ein Objekt, das zum Festlegen des umgrenzenden Rechtecks verwendet wird. Rechteckbemaßungen werden in logischen Koordinaten angegeben. Dieser Parameter kann NULL sein.

*Flaggen*<br/>
Gibt an, wie das neue Rechteck mit dem akkumulierten Rechteck kombiniert wird. Dieser Parameter kann eine Kombination der folgenden Werte sein:

- DCB_ACCUMULATE Fügen Sie das von *lpRectBounds* angegebene Rechteck zum umgebenden Rechteck hinzu (mit einem Rechteck-Union-Vorgang).

- DCB_DISABLE Deaktivieren Sie die Begrenzungsakkumulation.

- DCB_ENABLE Schalten Sie die Begrenzungsakkumulation ein. (Die Standardeinstellung für die Begrenzungsakkumulation ist deaktiviert.)

### <a name="return-value"></a>Rückgabewert

Der aktuelle Status des umlaufenden Rechtecks, wenn die Funktion erfolgreich ist. Wie *Flags*kann der Rückgabewert eine Kombination **aus DCB_** Werten sein:

- DCB_ACCUMULATE Das umgrenzte Rechteck ist nicht leer. Dieser Wert wird immer festgelegt.

- DCB_DISABLE Die Akkumulation der Grenzen ist aus.

- DCB_ENABLE Die Akkumulation der Grenzen ist eingeschaltet.

### <a name="remarks"></a>Bemerkungen

Windows kann ein umgrenzendes Rechteck für alle Zeichnungsvorgänge beibehalten. Dieses Rechteck kann von der Anwendung abgefragt und zurückgesetzt werden. Die Zeichnungsgrenzen sind nützlich, um Bitmap-Caches zu ungültig zu machen.

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>CDC::SetBrushOrg

Gibt den Ursprung an, den GDI dem nächsten Pinsel zuweist, den die Anwendung im Gerätekontext auswählt.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die x-Koordinate (in Geräteeinheiten) des neuen Ursprungs an. Dieser Wert muss im Bereich 0-7 liegen.

*y*<br/>
Gibt die y-Koordinate (in Geräteeinheiten) des neuen Ursprungs an. Dieser Wert muss im Bereich 0-7 liegen.

*Punkt*<br/>
Gibt die x- und y-Koordinaten des neuen Ursprungs an. Jeder Wert muss im Bereich 0-7 liegen. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Der vorherige Ursprung der Bürste in Geräteeinheiten.

### <a name="remarks"></a>Bemerkungen

Die Standardkoordinaten für den Pinselursprung sind (0, 0). Um den Ursprung eines Pinsels `UnrealizeObject` zu `CBrush` ändern, `SetBrushOrg`rufen Sie die `SelectObject` Funktion für das Objekt auf, rufen Sie an, und rufen Sie dann die Memberfunktion auf, um den Pinsel in den Gerätekontext auszuwählen.

Nicht mit `SetBrushOrg` Lagerobjekten `CBrush` verwenden.

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>CDC::SetColorAdjustment

Legt die Farbanpassungswerte für den Gerätekontext mithilfe der angegebenen Werte fest.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parameter

*lpColorAdjust*<br/>
Zeigt auf eine [COLORADJUSTMENT-Datenstruktur,](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) die die Farbanpassungswerte enthält.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Bemerkungen

Die Farbanpassungswerte werden verwendet, um die Eingabefarbe der `CDC::StretchBlt` Quellbitmap für Aufrufe an die Memberfunktion anzupassen, wenn der HALFTONE-Modus eingestellt ist.

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>CDC::SetDCBrushColor

Legt die Pinselfarbe des aktuellen Gerätekontexts (DC) auf den angegebenen Farbwert fest.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crColor*<br/>
Gibt die neue Pinselfarbe an.

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, gibt der Rückgabewert die vorherige DC-Pinselfarbe als COLORREF-Wert an.

Wenn die Funktion fehlerhaft ist, ist der Rückgabewert CLR_INVALID.

### <a name="remarks"></a>Bemerkungen

Diese Methode emuliert die Funktionalität der Funktion [SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor), wie im Windows SDK beschrieben.

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>CDC::SetDCPenColor

Legt die Stiftfarbe des aktuellen Gerätekontexts (DC) auf den angegebenen Farbwert fest.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crColor*<br/>
Gibt die neue Stiftfarbe an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion verwendet die Win32-Funktion [SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor), wie im Windows SDK beschrieben.

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>CDC::SetGraphicsMode

Legt den Grafikmodus für den angegebenen Gerätekontext fest.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parameter

*Imode*<br/>
Gibt den Grafikmodus an. Eine Liste der Werte, die dieser Parameter annehmen kann, finden Sie unter [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Rückgabewert

Gibt den alten Grafikmodus bei Erfolg zurück.

Gibt 0 bei Einem Fehler zurück. Um erweiterte Fehlerinformationen zu erhalten, rufen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)an.

### <a name="remarks"></a>Bemerkungen

Diese Methode umschließt die Windows GDI-Funktion [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

## <a name="cdcsetlayout"></a><a name="setlayout"></a>CDC::SetLayout

Rufen Sie diese Memberfunktion auf, um das Layout des Textes und der Grafiken für einen Gerätekontext von rechts nach links zu ändern, das Standardlayout für Kulturen wie Arabisch und Hebräisch.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parameter

*dwLayout*<br/>
Gerätekontextlayout und Bitmap-Steuerflags. Es kann eine Kombination der folgenden Werte sein.

|Wert|Bedeutung|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Deaktiviert alle Reflexionen für Aufrufe von [CDC::BitBlt](#bitblt) und [CDC::StretchBlt](#stretchblt).|
|LAYOUT_RTL|Legt fest, dass das horizontale Standardlayout von rechts nach links angezeigt wird.|
|LAYOUT_LTR|Legt fest, dass das Standardlayout von links nach rechts angezeigt wird.|

### <a name="return-value"></a>Rückgabewert

Wenn erfolgreich, das vorherige Layout des Gerätekontexts.

Wenn dies nicht der GDI_ERROR. Um erweiterte Fehlerinformationen zu erhalten, rufen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)an.

### <a name="remarks"></a>Bemerkungen

Normalerweise würden Sie `SetLayout` kein Fenster anrufen. Stattdessen steuern Sie das Rechts-nach-links-Layout in einem Fenster, indem Sie die [erweiterten Fensterstile](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) wie WS_EX_RTLREADING festlegen. Ein Gerätekontext, z. B. ein Drucker oder eine Metadatei, erbt dieses Layout nicht. Die einzige Möglichkeit, den Gerätekontext für ein Rechts-nach-links-Layout festzulegen, ist der Aufruf `SetLayout`von .

Wenn Sie **SetLayout(LAYOUT_RTL** ) aufrufen, `SetLayout` ändert sich der Zuordnungsmodus automatisch in MM_ISOTROPIC. Daher gibt ein nachfolgender Aufruf von [GetMapMode](#getmapmode) MM_ISOTROPIC anstelle von MM_TEXT zurück.

In einigen Fällen, z. B. bei vielen Bitmaps, möchten Sie möglicherweise das Layout von links nach rechts beibehalten. Rendern Sie in diesen `BitBlt` Fällen `StretchBlt`das Bild durch Aufrufen oder , und legen Sie dann das Bitmap-Steuerelementflag für *dwLayout* auf LAYOUT_BITMAPORIENTATIONPRESERVED.

Nachdem Sie das Layout mit dem LAYOUT_RTL-Flag geändert haben, werden die Flags, die normalerweise rechts oder links angeben, umgekehrt. Um Verwechslungen zu vermeiden, können Sie alternative Namen für die Standardflags definieren. Eine Liste der vorgeschlagenen alternativen Flagnamen finden Sie unter [SetLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) im Windows SDK.

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>CDC::SetMapMode

Legt den Zuordnungsmodus fest.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parameter

*nMapMode*<br/>
Gibt den neuen Zuordnungsmodus an. Es kann einer der folgenden Werte sein:

- MM_ANISOTROPIC Logische Einheiten werden in beliebige Einheiten mit beliebig skalierten Achsen konvertiert. Wenn Sie den Zuordnungsmodus auf MM_ANISOTROPIC festlegen, werden die aktuellen Fenster- oder Ansichtsfenstereinstellungen nicht geändert. Um die Einheiten, die Ausrichtung und die Skalierung zu ändern, rufen Sie die [Elementfunktionen SetWindowExt](#setwindowext) und [SetViewportExt](#setviewportext) auf.

- MM_HIENGLISH Jede logische Einheit wird in 0,001 Zoll konvertiert. Positiv x ist rechts; positiv y ist auf.

- MM_HIMETRIC Jede logische Einheit wird in 0,01 Millimeter konvertiert. Positiv x ist rechts; positiv y ist auf.

- MM_ISOTROPIC Logische Einheiten werden in beliebige Einheiten mit gleich skalierten Achsen konvertiert; d. h., 1 Einheit entlang der x-Achse entspricht 1 Einheit entlang der y-Achse. Verwenden `SetWindowExt` Sie `SetViewportExt` die und Member-Funktionen, um die gewünschten Einheiten und die Ausrichtung der Achsen anzugeben. GDI nimmt bei Bedarf Anpassungen vor, um sicherzustellen, dass die x- und y-Einheiten gleich groß bleiben.

- MM_LOENGLISH Jede logische Einheit wird in 0,01 Zoll konvertiert. Positiv x ist rechts; positiv y ist auf.

- MM_LOMETRIC Jede logische Einheit wird in 0,1 Millimeter konvertiert. Positiv x ist rechts; positiv y ist auf.

- MM_TEXT Jede logische Einheit wird in 1 Gerätepixel konvertiert. Positiv x ist rechts; positiv y ist unten.

- MM_TWIPS Jede logische Einheit wird in 1/20 eines Punktes konvertiert. (Da ein Punkt 1/72 Zoll ist, ist ein Twip 1/1440 Zoll.) Positiv x ist rechts; positiv y ist auf.

### <a name="return-value"></a>Rückgabewert

Der vorherige Zuordnungsmodus.

### <a name="remarks"></a>Bemerkungen

Der Zuordnungsmodus definiert die Maßeinheit, die zum Konvertieren logischer Einheiten in Geräteeinheiten verwendet wird. es definiert auch die Ausrichtung der x- und y-Achsen des Geräts. GDI verwendet den Mapping-Modus, um logische Koordinaten in die entsprechenden Gerätekoordinaten zu konvertieren. Der MM_TEXT-Modus ermöglicht anwendungen das Arbeiten in Gerätepixeln, wobei 1 Einheit gleich 1 Pixel ist. Die physische Größe eines Pixels variiert von Gerät zu Gerät.

Die MM_HIENGLISH-, MM_HIMETRIC-, MM_LOENGLISH-, MM_LOMETRIC- und MM_TWIPS-Modi sind nützlich für Anwendungen, die physikalisch sinnvolle Einheiten (z. B. Zoll oder Millimeter) zeichnen müssen. Der MM_ISOTROPIC-Modus sorgt für ein Seitenverhältnis von 1:1, was nützlich ist, wenn es wichtig ist, die genaue Form eines Bildes beizubehalten. Der MM_ANISOTROPIC-Modus ermöglicht die unabhängige Einstellung der x- und y-Koordinaten.

> [!NOTE]
> Wenn Sie [SetLayout](#setlayout) aufrufen, um den Dc (Gerätekontext) `SetLayout` in ein Layout von rechts nach links zu ändern, ändert automatisch der Zuordnungsmodus in MM_ISOTROPIC.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>CDC::SetMapperFlags

Ändert die vom Schriftart-Mapper verwendete Methode, wenn eine logische Schriftart in eine physische Schriftart konvertiert wird.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parameter

*dwFlag*<br/>
Gibt an, ob der Schriftart-Mapper versucht, die Seitenhöhe und -breite einer Schriftart mit dem Gerät abzugleichen. Wenn dieser Wert ASPECT_FILTERING ist, wählt der Mapper nur Schriftarten aus, deren x-Aspekt und y-Aspekt genau mit denen des angegebenen Geräts übereinstimmen.

### <a name="return-value"></a>Rückgabewert

Der vorherige Wert des font-mapper-Flags.

### <a name="remarks"></a>Bemerkungen

Eine Anwendung `SetMapperFlags` kann verwenden, um zu bewirken, dass der Schriftart-Mapper versucht, nur eine physische Schriftart auszuwählen, die genau dem Seitenverhältnis des angegebenen Geräts entspricht.

Eine Anwendung, die nur Raster-Schriftarten verwendet, kann die `SetMapperFlags` Funktion verwenden, um sicherzustellen, dass die vom Schriftart-Mapper ausgewählte Schriftart auf dem angegebenen Gerät attraktiv und lesbar ist. Anwendungen, die skalierbare (TrueType) `SetMapperFlags`Schriftarten verwenden, verwenden in der Regel keine .

Wenn keine physische Schriftart ein Seitenverhältnis aufweist, das der Spezifikation in der logischen Schriftart entspricht, wählt GDI ein neues Seitenverhältnis aus und wählt eine Schriftart aus, die diesem neuen Seitenverhältnis entspricht.

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>CDC::SetMiterLimit

Legt den Grenzwert für die Länge der Verknüpfungen für den Gerätekontext fest.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parameter

*fMiterLimit*<br/>
Gibt die neue Gehrungsgrenze für den Gerätekontext an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Gehrungslänge ist definiert als der Abstand vom Schnittpunkt der Linienwände auf der Innenseite der Verknüpfung zum Schnittpunkt der Linienwände an der Außenseite der Verknüpfung. Die Gehrungsgrenze ist das maximal zulässige Verhältnis der Gehrungslänge zur Linienbreite. Das standardmäßige Gehrungslimit ist 10.0.

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>CDC::SetOutputDC

Rufen Sie diese Memberfunktion auf, `m_hDC`um den Kontext des Ausgabegeräts festzulegen.

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parameter

*Hdc*<br/>
Ein Windows-Gerätekontext.

### <a name="remarks"></a>Bemerkungen

Diese Memberfunktion kann nur aufgerufen werden, wenn kein `CDC` Gerätekontext an das Objekt angefügt wurde. Diese Memberfunktion `m_hDC` legt fest, fügt jedoch `CDC` den Gerätekontext nicht an das Objekt an.

## <a name="cdcsetpixel"></a><a name="setpixel"></a>CDC::SetPixel

Legt das Pixel an dem punktfest, der auf die nächste Annäherung der von *crColor*angegebenen Farbe festgelegt ist.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate des festzulegenden Punktes an.

*y*<br/>
Gibt die logische y-Koordinate des festzulegenden Punktes an.

*crColor*<br/>
Ein COLORREF RGB-Wert, der die Farbe angibt, die zum Malen des Punkts verwendet wird. Eine Beschreibung dieses Werts finden Sie unter [COLORREF](/windows/win32/gdi/colorref) im Windows SDK.

*Punkt*<br/>
Gibt die logische x- und y-Koordinaten des festzulegenden Punktes an. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ein RGB-Wert für die Farbe, die der Punkt tatsächlich gezeichnet wird. Dieser Wert kann sich von dem von *crColor* angegebenen wertlegen, wenn eine Annäherung dieser Farbe verwendet wird. Wenn die Funktion fehlschlägt (wenn sich der Punkt außerhalb des Zuschneidebereichs befindet), ist der Rückgabewert -1.

### <a name="remarks"></a>Bemerkungen

Der Punkt muss sich im Clipping-Bereich befinden. Wenn sich der Punkt nicht im Clipping-Bereich befindet, führt die Funktion nichts aus.

Nicht alle Geräte unterstützen die `SetPixel`-Funktion. Um zu bestimmen, `SetPixel`ob `GetDeviceCaps` ein Gerät unterstützt, rufen Sie die Memberfunktion mit dem RASTERCAPS-Index auf und überprüfen Sie den Rückgabewert für das RC_BITBLT-Flag.

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>CDC::SetPixelV

Legt das Pixel an den angegebenen Koordinaten auf die nächste Annäherung der angegebenen Farbe fest.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die x-Koordinate des festzulegenden Punktes in logischen Einheiten an.

*y*<br/>
Gibt die y-Koordinate des festzulegenden Punktes in logischen Einheiten an.

*crColor*<br/>
Gibt die Farbe an, die zum Malen des Punkts verwendet werden soll.

*Punkt*<br/>
Gibt die logische x- und y-Koordinaten des festzulegenden Punktes an. Sie können entweder [POINT](/windows/win32/api/windef/ns-windef-point) eine POINT-Datenstruktur oder ein [CPoint-Objekt](../../atl-mfc-shared/reference/cpoint-class.md) für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Punkt muss sich sowohl im Zuschneidebereich als auch im sichtbaren Teil der Geräteoberfläche befinden. Nicht alle Geräte unterstützen die Memberfunktion. Weitere Informationen finden Sie in `CDC::GetDeviceCaps` der RC_BITBLT Funktion in der Memberfunktion. `SetPixelV`ist schneller, als `SetPixel` weil es nicht den Farbwert des tatsächlich gemalten Punktes zurückgeben muss.

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>CDC::SetPolyFillMode

Legt den Polygonfüllmodus fest.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parameter

*nPolyFillMode*<br/>
Gibt den neuen Füllmodus an. Dieser Wert kann entweder ALTERNATE oder WINDING sein. Der in Windows festgelegte Standardmodus ist ALTERNATE.

### <a name="return-value"></a>Rückgabewert

Der vorherige Füllmodus, falls erfolgreich; andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Wenn der Polygonfüllmodus ALTERNATE ist, füllt das System den Bereich zwischen ungeraden und geraden Polygonseiten auf jeder Scanlinie. Das heißt, das System füllt den Bereich zwischen der ersten und zweiten Seite, zwischen der dritten und vierten Seite usw. Dies ist der Standardmodus.

Wenn der Polygonfüllmodus WINDING ist, verwendet das System die Richtung, in der eine Figur gezeichnet wurde, um zu bestimmen, ob ein Bereich gefüllt werden soll. Jedes Liniensegment in einem Polygon wird entweder im Uhrzeigersinn oder gegen den Uhrzeigersinn gezeichnet. Wenn eine imaginäre Linie, die von einem geschlossenen Bereich nach außen nach einer Figur gezogen wird, durch ein Liniensegment im Uhrzeigersinn verläuft, wird eine Anzahl erhöht. Wenn die Linie ein Gegen-Uhrzeigerz-Liniensegment durchläuft, wird die Anzahl verringert. Der Bereich wird gefüllt, wenn die Anzahl ungleich Null ist, wenn die Linie die Außenseite der Abbildung erreicht.

## <a name="cdcsetrop2"></a><a name="setrop2"></a>CDC::SetROP2

Legt den aktuellen Zeichnungsmodus fest.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parameter

*nDrawMode*<br/>
Gibt den neuen Zeichnungsmodus an. Dabei kann es sich um einen der folgenden Werte handeln:

- R2_BLACK Pixel ist immer schwarz.

- R2_WHITE Pixel ist immer weiß.

- R2_NOP Pixel bleibt unverändert.

- R2_NOT Pixel ist die Umkehrung der Bildschirmfarbe.

- R2_COPYPEN Pixel ist die Stiftfarbe.

- R2_NOTCOPYPEN Pixel ist die Umkehrung der Stiftfarbe.

- R2_MERGEPENNOT Pixel ist eine Kombination aus der Stiftfarbe und der Umkehrung der Bildschirmfarbe (endgültiges Pixel = (NICHT Bildschirmpixel) ODER Stift).

- R2_MASKPENNOT Pixel ist eine Kombination der Farben, die sowohl dem Stift als auch dem Umkehrungsbild des Bildschirms gemeinsam sind (endgültiges Pixel = (NICHT Bildschirmpixel) UND Stift).

- R2_MERGENOTPEN Pixel ist eine Kombination aus bildschirmfarbe und der Umkehrung der Stiftfarbe (endgültiges Pixel = (NOT Stift) ODER Bildschirmpixel).

- R2_MASKNOTPEN Pixel ist eine Kombination der Farben, die sowohl dem Bildschirm als auch der Umkehrung des Stifts gemeinsam sind (endgültiges Pixel = (NOT-Stift) UND Bildschirmpixel).

- R2_MERGEPEN Pixel ist eine Kombination aus Stiftfarbe und Bildschirmfarbe (endgültiges Pixel = Stift- oder Bildschirmpixel).

- R2_NOTMERGEPEN Pixel ist die Umkehrung der R2_MERGEPEN Farbe (endgültiges Pixel = NOT (Stift- oder Bildschirmpixel)).

- R2_MASKPEN Pixel ist eine Kombination der Farben, die sowohl dem Stift als auch dem Bildschirm gemeinsam sind (endgültiges Pixel = Stift- UND Bildschirmpixel).

- R2_NOTMASKPEN Pixel ist die Umkehrung der R2_MASKPEN Farbe (endgültiges Pixel = NOT(Pen AND Screen Pixel)).

- R2_XORPEN Pixel ist eine Kombination der Farben, die sich im Stift oder auf dem Bildschirm befinden, jedoch nicht in beiden (endgültiges Pixel = Stift XOR-Bildschirmpixel).

- R2_NOTXORPEN Pixel ist die Umkehrung der R2_XORPEN Farbe (endgültiges Pixel = NOT(Pen XOR-Bildschirmpixel)).

### <a name="return-value"></a>Rückgabewert

Der vorherige Zeichnungsmodus.

Dabei kann es sich um einen beliebigen Wert im Windows SDK handeln.

### <a name="remarks"></a>Bemerkungen

Der Zeichenmodus gibt an, wie die Farben des Stifts und das Innere gefüllter Objekte mit der Farbe kombiniert werden, die sich bereits auf der Anzeigefläche befindet.

Der Zeichnungsmodus ist nur für Raster-Geräte vorgesehen. Sie gilt nicht für Vektorgeräte. Zeichnungsmodi sind binäre Raster-Operationscodes, die alle möglichen booleschen Kombinationen zweier Variablen darstellen, indem die binären Operatoren AND, OR und XOR (exklusives ODER) und die unäre Operation NOT verwendet werden.

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>CDC::SetStretchBltMode

Legt den Bitmap-Stretching-Modus für die `StretchBlt` Memberfunktion fest.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parameter

*nStretchMode*<br/>
Gibt den Dehnmodus an. Dabei kann es sich um einen der folgenden Werte handeln:

|Wert|BESCHREIBUNG|
|-----------|-----------------|
|BLACKONWHITE|Führt einen booleschen UND-Vorgang unter Verwendung der Farbwerte für die eliminierten und vorhandenen Pixel aus. Wenn es sich bei der Bitmap um eine monochrome Bitmap handelt, werden in diesem Modus schwarze Pixel auf Kosten weißer Pixel beibehalten.|
|COLORONCOLOR|Löscht die Pixel. Dieser Modus löscht alle eliminierten Pixellinien, ohne zu versuchen, ihre Informationen beizubehalten.|
|Halbton|Ordnet Pixel aus dem Quellrechteck Pixel in Pixelblöcke im Zielrechteck zu. Die durchschnittliche Farbe über dem Zielblock von Pixeln entspricht der Farbe der Quellpixel.|
||Nach dem Festlegen des HALFTONE-Stretching-Modus muss eine Anwendung die Win32-Funktion [SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) aufrufen, um den Pinselursprung festzulegen. Wenn dies nicht der Fall ist, tritt eine Fehlausrichtung des Pinsels auf.|
|STRETCH_ANDSCANS|**Windows 95/98**: Wie BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: Wie COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: Wie HALFTONE.|
|STRETCH_ORSCANS|**Windows 95/98**: Wie WHITEONBLACK|
|WHITEONBLACK|Führt einen booleschen ODER-Vorgang unter Verwendung der Farbwerte für die eliminierten und vorhandenen Pixel aus. Wenn es sich bei der Bitmap um eine monochrome Bitmap handelt, behält dieser Modus weiße Pixel auf Kosten schwarzer Pixel bei.|

### <a name="return-value"></a>Rückgabewert

Der vorherige Dehnmodus. Es kann STRETCH_ANDSCANS, STRETCH_DELETESCANS oder STRETCH_ORSCANS sein.

### <a name="remarks"></a>Bemerkungen

Der Bitmap-Stretching-Modus definiert, wie Informationen aus Bitmaps entfernt werden, die mithilfe der Funktion komprimiert werden.

Die Modi BLACKONWHITE ( STRETCH_ANDSCANS) und WHITEONBLACK ( STRETCH_ORSCANS) werden in der Regel verwendet, um Vordergrundpixel in monochromen Bitmaps beizubehalten. Der COLORONCOLOR-Modus (STRETCH_DELETESCANS) wird in der Regel verwendet, um Die Farbe in Farbbitmaps beizubehalten.

Der HALFTONE-Modus erfordert mehr Verarbeitung des Quellbildes als die anderen drei Modi. es ist langsamer als die anderen, aber produziert qualitativ hochwertigere Bilder. Beachten Sie `SetBrushOrgEx` auch, dass nach dem Festlegen des HALFTONE-Modus aufgerufen werden muss, um eine Fehlausrichtung des Pinsels zu vermeiden.

Je nach den Funktionen des Gerätetreibers können auch zusätzliche Dehnmodi verfügbar sein.

## <a name="cdcsettextalign"></a><a name="settextalign"></a>CDC::SetTextAlign

Legt die Textausrichtungsflags fest.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parameter

*nFlags*<br/>
Gibt Textausrichtungsflags an. Die Flags geben die Beziehung zwischen einem Punkt und einem Rechteck an, das den Text umgrenzt. Der Punkt kann entweder die aktuelle Position oder die Koordinaten sein, die durch eine Textausgabefunktion angegeben werden. Das Rechteck, das den Text umgrenzt, wird durch die benachbarten Zeichenzellen in der Textzeichenfolge definiert. Der *parameter nFlags* kann ein oder mehrere Flags aus den folgenden drei Kategorien sein. Wählen Sie nur ein Flag aus jeder Kategorie aus. Die erste Kategorie wirkt sich auf die Textausrichtung in x-Richtung aus:

- TA_CENTER Richtet den Punkt mit der horizontalen Mitte des umschließenden Rechtecks aus.

- TA_LEFT Richtet den Punkt mit der linken Seite des umschließenden Rechtecks aus. Dies ist die Standardeinstellung.

- TA_RIGHT Richtet den Punkt an der rechten Seite des umschließenden Rechtecks aus.

Die zweite Kategorie wirkt sich auf die Textausrichtung in y-Richtung aus:

- TA_BASELINE Richtet den Punkt an der Grundlinie der ausgewählten Schriftart aus.

- TA_BOTTOM Richtet den Punkt am unteren Rand des umschließenden Rechtecks aus.

- TA_TOP Richtet den Punkt am oberen Rand des umschließenden Rechtecks aus. Dies ist die Standardeinstellung.

Die dritte Kategorie bestimmt, ob die aktuelle Position aktualisiert wird, wenn Text geschrieben wird:

- TA_NOUPDATECP Aktualisiert die aktuelle Position nach jedem Aufruf einer Textausgabefunktion nicht. Dies ist die Standardeinstellung.

- TA_UPDATECP Aktualisiert die aktuelle x-Position nach jedem Aufruf einer Textausgabefunktion. Die neue Position befindet sich auf der rechten Seite des umgrenzenden Rechtecks für den Text. Wenn dieses Flag festgelegt wird, werden `TextOut` die in Aufrufen der Memberfunktion angegebenen Koordinaten ignoriert.

### <a name="return-value"></a>Rückgabewert

Die vorherige Textausrichtungseinstellung, falls erfolgreich. Das Low-Order-Byte enthält die horizontale Einstellung und das Byte hoher Ordnung die vertikale Einstellung. andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Die `TextOut` `ExtTextOut` und Memberfunktionen verwenden diese Flags, wenn Sie eine Textzeichenfolge auf einem Display oder Gerät positionieren. Die Flags geben die Beziehung zwischen einem bestimmten Punkt und einem Rechteck an, das den Text umgrenzt. Die Koordinaten dieses Punktes werden `TextOut` als Parameter an die Memberfunktion übergeben. Das Rechteck, das den Text umgrenzt, wird durch die benachbarten Zeichenzellen in der Textzeichenfolge gebildet.

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra

Legt den Abstand zwischen den Zeichen fest.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parameter

*nCharExtra*<br/>
Gibt den zusätzlichen Speicherplatz (in logischen Einheiten) an, der jedem Zeichen hinzugefügt werden soll. Wenn der aktuelle Zuordnungsmodus nicht `MM_TEXT`ist, wird *nCharExtra* transformiert und auf das nächste Pixel gerundet.

### <a name="return-value"></a>Rückgabewert

Die Menge des vorherigen Intercharacter-Abstands.

### <a name="remarks"></a>Bemerkungen

GDI fügt jedem Zeichen diesen Abstand hinzu, einschließlich Bruchzeichen, wenn eine Textzeile in den Gerätekontext geschrieben wird. Der Standardwert für den Abstand zwischen den Zeichen ist 0.

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>CDC::SetTextColor

Legt die Textfarbe auf die angegebene Farbe fest.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crColor*<br/>
Gibt die Farbe des Textes als RGB-Farbwert an.

### <a name="return-value"></a>Rückgabewert

Ein RGB-Wert für die vorherige Textfarbe.

### <a name="remarks"></a>Bemerkungen

Das System verwendet diese Textfarbe beim Schreiben von Text in diesen Gerätekontext und auch beim Konvertieren von Bitmaps zwischen Farb- und monochromen Gerätekontexten.

Wenn das Gerät die angegebene Farbe nicht darstellen kann, legt das System die Textfarbe auf die nächste physische Farbe fest. Die Hintergrundfarbe für ein Zeichen `SetBkColor` `SetBkMode` wird durch die und Memberfunktionen angegeben.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>CDC::SetTextJustification

Fügt den Unterbrechungszeichen in einer Zeichenfolge Platz hinzu.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parameter

*nBreakExtra*<br/>
Gibt den gesamten zusätzlichen Speicherplatz an, der der Textzeile hinzugefügt werden soll (in logischen Einheiten). Wenn der aktuelle Zuordnungsmodus nicht `MM_TEXT`ist, wird der von diesem Parameter angegebene Wert in den aktuellen Zuordnungsmodus konvertiert und auf die nächste Geräteeinheit gerundet.

*nBreakCount*<br/>
Gibt die Anzahl der Bruchzeichen in der Zeile an.

### <a name="return-value"></a>Rückgabewert

Eine, wenn die Funktion erfolgreich ist; andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Eine Anwendung kann `GetTextMetrics` die Memberfunktionen verwenden, um das Unterbrechungszeichen einer Schriftart abzurufen.

Nachdem `SetTextJustification` die Memberfunktion aufgerufen wurde, verteilt ein Aufruf `TextOut`einer Textausgabefunktion (z. B. ) den angegebenen zusätzlichen Platz gleichmäßig auf die angegebene Anzahl von Bruchzeichen. Das Unterbrechungszeichen ist in der Regel das Leerzeichen (ASCII 32), kann jedoch durch eine Schriftart als ein anderes Zeichen definiert werden.

Die Memberfunktion `GetTextExtent` wird `SetTextJustification`in der Regel mit verwendet. `GetTextExtent`berechnet die Breite einer bestimmten Linie vor der Ausrichtung. Eine Anwendung kann bestimmen, wie viel Speicherplatz im *nBreakExtra-Parameter* `GetTextExtent` angegeben werden soll, indem der Wert, der von der Breite der Zeichenfolge nach der Ausrichtung zurückgegeben wird, subtrahiert wird.

Die `SetTextJustification` Funktion kann verwendet werden, um eine Linie auszurichten, die mehrere Durchläufe in verschiedenen Schriftarten enthält. In diesem Fall muss die Zeile Stückwerk erstellt werden, indem jeder Lauf einzeln ausgerichtet und geschrieben wird.

Da während der Ausrichtung Rundungsfehler auftreten können, behält das System einen ausgeführten Fehlerbegriff bei, der den aktuellen Fehler definiert. Beim Ausrichten einer Linie, `GetTextExtent` die mehrere Durchläufe enthält, wird dieser Fehlerbegriff automatisch verwendet, wenn die Ausdehnung der nächsten Ausführung berechnet wird. Dadurch kann die Textausgabefunktion den Fehler in die neue Ausführung überblenden.

Nachdem jede Zeile ausgerichtet wurde, muss dieser Fehlerbegriff gelöscht werden, um zu verhindern, dass er in die nächste Zeile integriert wird. Der Begriff kann gelöscht `SetTextJustification` werden, indem der Aufruf mit *nBreakExtra* auf 0 gesetzt ist.

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>CDC::SetViewportExt

Legt die x- und y-Ausdehnungen des Ansichtsfensters des Gerätekontexts fest.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parameter

*Cx*<br/>
Gibt die x-Ausdehnung des Ansichtsfensters (in Geräteeinheiten) an.

*Cy*<br/>
Gibt die y-Ausdehnung des Ansichtsfensters (in Geräteeinheiten) an.

*Größe*<br/>
Gibt die x- und y-Ausdehnungen des Ansichtsfensters (in Geräteeinheiten) an.

### <a name="return-value"></a>Rückgabewert

Die vorherigen Ausdehnungen des Ansichtsfensters als [CSize-Objekt.](../../atl-mfc-shared/reference/csize-class.md) Wenn ein Fehler auftritt, werden die x- `CSize` und y-Koordinaten des zurückgegebenen Objekts auf 0 gesetzt.

### <a name="remarks"></a>Bemerkungen

Das Ansichtsfenster definiert zusammen mit dem Gerätekontextfenster, wie GDI Punkte im logischen Koordinatensystem Punkten im Koordinatensystem des eigentlichen Geräts zuordnet. Mit anderen Worten, sie definieren, wie GDI logische Koordinaten in Gerätekoordinaten umwandelt.

Wenn die folgenden Zuordnungsmodi festgelegt `SetWindowExt` `SetViewportExt` sind, werden Aufrufe an und ignoriert:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Wenn MM_ISOTROPIC Modus festgelegt ist, `SetWindowExt` muss eine Anwendung `SetViewportExt`die Memberfunktion aufrufen, bevor sie aufruft.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>CDC::SetViewportOrg

Legt den Ansichtsfensterursprung des Gerätekontexts fest.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die x-Koordinate (in Geräteeinheiten) des Ursprungs des Ansichtsfensters an. Der Wert muss sich innerhalb des Bereichs des Gerätekoordinatensystems befinden.

*y*<br/>
Gibt die y-Koordinate (in Geräteeinheiten) des Ursprungs des Ansichtsfensters an. Der Wert muss sich innerhalb des Bereichs des Gerätekoordinatensystems befinden.

*Punkt*<br/>
Gibt den Ursprung des Ansichtsfensters an. Die Werte müssen sich innerhalb des Bereichs des Gerätekoordinatensystems befinden. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Der vorherige Ursprung des Ansichtsfensters (in Gerätekoordinaten) als `CPoint` Objekt.

### <a name="remarks"></a>Bemerkungen

Das Ansichtsfenster definiert zusammen mit dem Gerätekontextfenster, wie GDI Punkte im logischen Koordinatensystem Punkten im Koordinatensystem des eigentlichen Geräts zuordnet. Mit anderen Worten, sie definieren, wie GDI logische Koordinaten in Gerätekoordinaten umwandelt.

Der Ansichtsfensterursprung markiert den Punkt im Gerätekoordinatensystem, dem GDI den Fensterursprung zuordnet, einen Punkt im logischen Koordinatensystem, der von der `SetWindowOrg` Memberfunktion angegeben wird. GDI ordnet alle anderen Punkte zu, indem er den gleichen Prozess befolgt, der erforderlich ist, um den Fensterursprung dem Ursprungspunkt des Ansichtsfensters zuzuordnen. Beispielsweise befinden sich alle Punkte in einem Kreis um den Punkt am Fensterursprung in einem Kreis um den Punkt am Ursprung des Ansichtsfensters. Ebenso befinden sich alle Punkte in einer Linie, die durch den Fensterursprung verläuft, in einer Linie, die den Ursprungspunkt des Ansichtsfensters durchläuft.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>CDC::SetWindowExt

Legt die x- und y-Ausdehnungen des Fensters fest, das dem Gerätekontext zugeordnet ist.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parameter

*Cx*<br/>
Gibt die x-Ausdehnung (in logischen Einheiten) des Fensters an.

*Cy*<br/>
Gibt die y-Ausdehnung (in logischen Einheiten) des Fensters an.

*Größe*<br/>
Gibt die x- und y-Ausdehnungen (in logischen Einheiten) des Fensters an.

### <a name="return-value"></a>Rückgabewert

Die vorherigen Ausdehnungen des Fensters (in logischen Einheiten) als `CSize` Objekt. Wenn ein Fehler auftritt, werden die x- `CSize` und y-Koordinaten des zurückgegebenen Objekts auf 0 gesetzt.

### <a name="remarks"></a>Bemerkungen

Das Fenster definiert zusammen mit dem Gerätekontext-Ansichtsfenster, wie GDI Punkte im logischen Koordinatensystem Punkten im Gerätekoordinatensystem zuordnet.

Wenn die folgenden Zuordnungsmodi festgelegt `SetWindowExt` `SetViewportExt` sind, werden Aufrufe und Funktionen ignoriert:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Wenn MM_ISOTROPIC Modus festgelegt ist, `SetWindowExt` muss eine `SetViewportExt`Anwendung die Memberfunktion aufrufen, bevor sie aufruft.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>CDC::SetWindowOrg

Legt den Fensterursprung des Gerätekontexts fest.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate des neuen Ursprungs des Fensters an.

*y*<br/>
Gibt die logische y-Koordinate des neuen Ursprungs des Fensters an.

*Punkt*<br/>
Gibt die logischen Koordinaten des neuen Ursprungs des Fensters an. Sie können entweder `POINT` eine `CPoint` Struktur oder ein Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Der vorherige Ursprung des `CPoint` Fensters als Objekt.

### <a name="remarks"></a>Bemerkungen

Das Fenster definiert zusammen mit dem Gerätekontext-Ansichtsfenster, wie GDI Punkte im logischen Koordinatensystem Punkten im Gerätekoordinatensystem zuordnet.

Der Fensterursprung markiert den Punkt im logischen Koordinatensystem, von dem aus GDI den `SetWindowOrg` Ursprung des Ansichtsfensters zuordnet, einen Punkt im Gerätekoordinatensystem, der von der Funktion angegeben wird. GDI ordnet alle anderen Punkte zu, indem er den gleichen Prozess befolgt, der erforderlich ist, um den Fensterursprung dem Ursprungspunkt des Ansichtsfensters zuzuordnen. Beispielsweise befinden sich alle Punkte in einem Kreis um den Punkt am Fensterursprung in einem Kreis um den Punkt am Ursprung des Ansichtsfensters. Ebenso befinden sich alle Punkte in einer Linie, die durch den Fensterursprung verläuft, in einer Linie, die den Ursprungspunkt des Ansichtsfensters durchläuft.

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>CDC::SetWorldTransform

Legt eine zweidimensionale lineare Transformation zwischen Welt- und Seitenraum für den angegebenen Gerätekontext fest. Diese Transformation kann zum Skalieren, Drehen, Scheren oder Übersetzen der Grafikausgabe verwendet werden.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parameter

*rXform*<br/>
Verweis auf eine [XFORM-Struktur,](/windows/win32/api/wingdi/ns-wingdi-xform) die die Transformationsdaten enthält.

### <a name="return-value"></a>Rückgabewert

Gibt einen Wert ungleich Null für den Erfolg zurück.

Gibt 0 bei Einem Fehler zurück.

Um erweiterte Fehlerinformationen zu erhalten, rufen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)an.

### <a name="remarks"></a>Bemerkungen

Diese Methode umschließt die Windows GDI-Funktion [SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform).

## <a name="cdcstartdoc"></a><a name="startdoc"></a>CDC::StartDoc

Informiert den Gerätetreiber darüber, dass ein neuer `StartPage` Druckauftrag gestartet wird und dass alle nachfolgenden und `EndPage` Aufrufe unter demselben Auftrag gepoolt werden sollten, bis ein `EndDoc` Anruf erfolgt.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parameter

*lpDocInfo*<br/>
Zeigt auf eine [DOCINFO-Struktur,](/windows/win32/api/wingdi/ns-wingdi-docinfow) die den Namen der Dokumentdatei und den Namen der Ausgabedatei enthält.

*lpszDocName*<br/>
Zeiger auf eine Zeichenfolge, die den Namen der Dokumentdatei enthält.

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, ist der Rückgabewert größer als Null. Dieser Wert ist die Druckauftragskennung für das Dokument.

Wenn die Funktion fehlschlägt, ist der Rückgabewert kleiner oder gleich Null.

### <a name="remarks"></a>Bemerkungen

Dadurch wird sichergestellt, dass Dokumente, die länger als eine Seite sind, nicht mit anderen Aufträgen durchsetzt werden.

Für Windows-Versionen 3.1 und höher ersetzt diese Funktion den STARTDOC-Druckerescape. Durch die Verwendung dieser Funktion wird sichergestellt, dass Dokumente, die mehr als eine Seite enthalten, nicht mit anderen Druckaufträgen durchsetzt sind.

`StartDoc`sollte nicht in Metadateien verwendet werden.

### <a name="example"></a>Beispiel

Dieses Codefragment ruft den Standarddrucker ab, öffnet einen Druckauftrag und summiert eine Seite mit "Hallo, Welt!" darauf. Da der von diesem Code gedruckte Text nicht auf die logischen Einheiten des Druckers skaliert wird, kann der Ausgabetext in so kleinen Buchstaben sein, dass das Ergebnis nicht lesbar ist. Die CDC-Skalierungsfunktionen `SetMapMode` `SetViewportOrg`, `SetWindowExt`z. B. , und , können verwendet werden, um die Skalierung zu beheben.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>CDC::StartPage

Rufen Sie diese Memberfunktion auf, um den Druckertreiber auf den Datenempfang vorzubereiten.

```
int StartPage();
```

### <a name="return-value"></a>Rückgabewert

Größer oder gleich 0, wenn die Funktion erfolgreich ist, oder ein negativer Wert, wenn ein Fehler aufgetreten ist.

### <a name="remarks"></a>Bemerkungen

`StartPage`ersetzt die ESCAPEs NEWFRAME und BANDINFO.

Eine Übersicht über die Reihenfolge der [StartDoc](#startdoc) Druckaufrufe finden Sie in der StartDoc-Memberfunktion.

Das System deaktiviert `ResetDC` die Memberfunktion `StartPage` `EndPage`zwischen Aufrufen von und .

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CDC::StartDoc](#startdoc).

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>CDC::StretchBlt

Kopiert eine Bitmap aus einem Quellrechteck in ein Zielrechteck, wobei das Bitmap gestreckt oder komprimiert wird, falls dies notwendig ist, um zu den Maßen des Zielrechtecks zu passen.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Zielrechtecks an.

*y*<br/>
Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Zielrechtecks an.

*nWidth*<br/>
Gibt die Breite (in logischen Einheiten) des Zielrechtecks an.

*nHeight*<br/>
Gibt die Höhe (in logischen Einheiten) des Zielrechtecks an.

*pSrcDC*<br/>
Gibt den Quellgerätekontext an.

*xSrc*<br/>
Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quellrechtecks an.

*ySrc*<br/>
Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quellrechtecks an.

*nSrcWidth*<br/>
Gibt die Breite (in logischen Einheiten) des Quellrechtecks an.

*nSrcHeight*<br/>
Gibt die Höhe (in logischen Einheiten) des Quellrechtecks an.

*dwRop*<br/>
Gibt das Raster des auszuführenden Vorgangs an. Rastervorgangscode definiert, wie GDI Farben in Ausgabevorgängen kombiniert, an denen ein aktueller Pinsel, eine mögliche Quellbitmap und eine Zielbitmap beteiligt sind. Dieser Parameter kann möglicherweise einen der folgenden Werte aufweisen:

- BLACKNESS Dreht alle Ausgabe schwarz.

- DSTINVERT Kehrt die Zielbitmap um.

- MERGECOPY Kombiniert das Muster und die Quellbitmap mit dem Operator Boolean AND.

- MERGEPAINT Kombiniert die invertierte Quellbitmap mit der Zielbitmap mithilfe des Booleschen ODER-Operators.

- NOTSRCCOPY Kopiert die invertierte Quellbitmap an das Ziel.

- NOTSRCERASE Invertiert das Ergebnis der Kombination von Ziel- und Quellbitmaps mit dem Operator Boolean OR.

- PATCOPY Kopiert das Muster in die Zielbitmap.

- PATINVERT Kombiniert die Zielbitmap mit dem Muster mit dem Boolean XOR-Operator.

- PATPAINT Kombiniert die invertierte Quellbitmap mit dem Muster mithilfe des Booleschen ODER-Operators. Hierdurch wird das Ziel dieses Vorgangs mithilfe des booleschen OR-Operators mit dem Zielbitmap kombiniert.

- SRCAND Kombiniert Pixel der Ziel- und Quellbitmaps mit dem Operator Boolean AND.

- SRCCOPY Kopiert die Quellbitmap in die Zielbitmap.

- SRCERASE Kehrt die Zielbitmap um und kombiniert das Ergebnis mit der Quellbitmap mithilfe des Booleschen AND-Operators.

- SRCINVERT Kombiniert Pixel der Ziel- und Quellbitmaps mit dem Boolean XOR-Operator.

- SRCPAINT kombiniert Pixel der Ziel- und Quellbitmaps mithilfe des Booleschen ODER-Operators.

- WHITENESS Dreht alle Ausgabe weiß.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Bitmap gezeichnet wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Funktion verwendet den Streckmodus des Zielgerätkontexts (durch `SetStretchBltMode` festgelegt), um zu bestimmen, wie die Bitmap gestreckt oder komprimiert werden soll.

Die `StretchBlt` Funktion verschiebt die Bitmap vom Quellgerät, das von *pSrcDC* gegeben wird, auf das Zielgerät, das durch das Device-Context-Objekt dargestellt wird, dessen Memberfunktion aufgerufen wird. Die Parameter *xSrc*, *ySrc*, *nSrcWidth*und *nSrcHeight* definieren die obere linke Ecke und die Abmessungen des Quellrechtecks. Die Parameter *x*, *y*, *nWidth*und *nHeight* geben die obere linke Ecke und die Dimensionen des Zielrechtecks an. Der von *dwRop* angegebene Raster-Vorgang definiert, wie die Quellbitmap und die Bits, die sich bereits auf dem Zielgerät befinden, kombiniert werden.

Die `StretchBlt` Funktion erstellt ein Spiegelbild einer Bitmap, wenn sich die Vorzeichen der Parameter *nSrcWidth* und *nWidth* oder *nSrcHeight* und *nHeight* unterscheiden. Wenn *nSrcWidth* und *nWidth* unterschiedliche Vorzeichen haben, erstellt die Funktion ein Spiegelbild der Bitmap entlang der x-Achse. Wenn *nSrcHeight* und *nHeight* unterschiedliche Zeichen haben, erstellt die Funktion ein Spiegelbild der Bitmap entlang der y-Achse.

Die Funktion `StretchBlt` streckt oder komprimiert die Quellbitmap im Speicher und kopiert dann das Ergebnis in das Ziel. Wenn ein Muster mit dem Ergebnis zusammengeführt werden soll, wird es erst zusammengeführt, wenn die gestreckte Quellbitmap in das Ziel kopiert wurde. Wenn ein Pinsel verwendet wird, ist es der ausgewählte Pinsel im Zielgerätekontext. Die Zielkoordinaten werden gemäß dem Zielgerätekontext transformiert. Die Quellkoordinaten werden gemäß dem Quellgerätekontext transformiert.

Wenn das Ziel, die Quelle und die Musterbitmaps nicht dasselbe Farbformat haben, konvertiert `StretchBlt` die Quelle und die Musterbitmaps so, dass sie mit den Zielbitmaps übereinstimmen. Die Vordergrund- und Hintergrundfarben des Zielgerätekontexts werden bei der Konvertierung verwendet.

Wenn `StretchBlt` eine monochrome Bitmap in eine farbige konvertiere muss, legt sie weiße Bits (1) für die Hintergrundfarbe und schwarze Bits (0) für die Vordergrundfarbe fest. Um Farbe in monochrom zu verwandeln, legt sie Pixel, die mit der Hintergrundfarbe übereinstimmen, auf weiß (1) fest und legt alle anderen Pixel auf schwarz (0) fest. Die Vordergrund- und Hintergrundfarben des Gerätekontexts mit Farbe werden verwendet.

Nicht alle Geräte unterstützen die `StretchBlt`-Funktion. Um zu bestimmen, `StretchBlt`ob `GetDeviceCaps` ein Gerät unterstützt, rufen Sie die Memberfunktion mit dem RASTERCAPS-Index auf und überprüfen Sie den Rückgabewert für das RC_STRETCHBLT-Flag.

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>CDC::StrokeAndFillPath

Schließt alle offenen Figuren in einem Pfad, streift die Umrisse des Pfads mithilfe des aktuellen Stifts und füllt dessen Inneres mit dem aktuellen Pinsel.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Gerätekontext muss einen geschlossenen Pfad enthalten. Die `StrokeAndFillPath` Memberfunktion hat den gleichen Effekt wie das Schließen aller offenen Zahlen im Pfad und das Streichen und Füllen des Pfads getrennt, mit der Ausnahme, dass der ausgefüllte Bereich den gestrichelten Bereich nicht überlappt, selbst wenn der Stift breit ist.

## <a name="cdcstrokepath"></a><a name="strokepath"></a>CDC::StrokePath

Rendert den angegebenen Pfad mithilfe des aktuellen Stifts.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Gerätekontext muss einen geschlossenen Pfad enthalten.

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>CDC::TabbedTextOut

Rufen Sie diese Memberfunktion auf, um eine Zeichenfolge an der angegebenen Position zu schreiben, und erweitern Sie Die Registerkarten auf die Werte, die im Array von Tabstopppositionen angegeben sind.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate des Startpunkts der Zeichenfolge an.

*y*<br/>
Gibt die logische y-Koordinate des Startpunkts der Zeichenfolge an.

*lpszString*<br/>
Zeigt auf die zu zeichnende Zeichenkette. Sie können entweder einen Zeiger an ein Array von Zeichen oder ein [CString-Objekt](../../atl-mfc-shared/reference/cstringt-class.md) für diesen Parameter übergeben.

*nCount*<br/>
Gibt die [Länge der Zeichenfolge](/windows/win32/gdi/specifying-length-of-text-output-string) an, auf die von *lpszString*verwiesen wird.

*nTabPositionen*<br/>
Gibt die Anzahl der Werte im Array von Tabstopppositionen an.

*lpnTabStopPositionen*<br/>
Zeigt auf ein Array, das die Tabstopppositionen (in logischen Einheiten) enthält. Die Tabstopps müssen in zunehmender Reihenfolge sortiert werden. der kleinste x-Wert sollte das erste Element im Array sein.

*nTabOrigin*<br/>
Gibt die x-Koordinate der Startposition an, von der aus Registerkarten erweitert werden (in logischen Einheiten).

*Str*<br/>
Ein `CString` Objekt, das die angegebenen Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Die Dimensionen der Zeichenfolge (in logischen Einheiten) als `CSize` Objekt.

### <a name="remarks"></a>Bemerkungen

Text wird in der aktuell ausgewählten Schriftart geschrieben. Wenn *nTabPositions* 0 und *lpnTabStopPositions* NULL ist, werden Tabstopps auf das Achtfache der durchschnittlichen Zeichenbreite erweitert.

Wenn *nTabPositions* 1 ist, werden die Tabstopps durch den Abstand getrennt, der durch den ersten Wert im Array *lpnTabStopPositions* angegeben wird. Wenn das Array *lpnTabStopPositions* mehr als einen Wert enthält, wird für jeden Wert im Array ein Tabstopp festgelegt, bis zu der von *nTabPositions*angegebenen Zahl. Der Parameter *nTabOrigin* ermöglicht es `TabbedTextOut` einer Anwendung, die Funktion mehrmals für eine einzelne Leitung aufzurufen. Wenn die Anwendung die Funktion mehr als einmal aufruft, wobei der *nTabOrigin* jedes Mal auf denselben Wert festgelegt ist, erweitert die Funktion alle Registerkarten relativ zu der von *nTabOrigin*angegebenen Position.

Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert. Wenn eine Anwendung die aktuelle Position aktualisieren muss, wenn sie die Funktion aufruft, kann die Anwendung die [SetTextAlign-Memberfunktion](#settextalign) aufrufen, wobei *nFlags* auf TA_UPDATECP festgelegt ist. Wenn dieses Flag gesetzt ist, ignoriert Windows die *x-* und *y-Parameter* bei nachfolgenden Aufrufen von `TabbedTextOut`, indem stattdessen die aktuelle Position verwendet wird.

## <a name="cdctextout"></a><a name="textout"></a>CDC::TextOut

Schreibt mithilfe der aktuell ausgewählten Schriftart eine Zeichenfolge an dem angegebenen Speicherort.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parameter

*X*<br/>
Gibt die logische x-Koordinate des Anfangspunkts des Texts an.

*y*<br/>
Gibt die logische y-Koordinate des Anfangspunkts des Texts an.

*lpszString*<br/>
Zeigt auf die zu zeichnende Zeichenfolge.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an.

*Str*<br/>
Ein `CString`-Objekt, das die zu zeichnenden Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Zeichenursprünge befindet sich in der oberen linken Ecke der Zeichenzelle. Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert.

Wenn eine Anwendung beim Aufrufen `TextOut`die aktuelle Position aktualisieren `SetTextAlign` muss, kann die Anwendung die Memberfunktion aufrufen, wobei *nFlags* auf TA_UPDATECP festgelegt ist. Wenn dieses Flag gesetzt ist, ignoriert Windows die *x-* und *y-Parameter* bei nachfolgenden Aufrufen von `TextOut`, indem stattdessen die aktuelle Position verwendet wird.

### <a name="example"></a>Beispiel

  Siehe Beispiel für [CDC::BeginPath](#beginpath).

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>CDC::TransparentBlt

Rufen Sie diese Memberfunktion auf, um einen Bitblock der Farbdaten, der einem Rechteck von Pixeln aus dem angegebenen Quellgerätekontext entspricht, in einen Zielgerätekontext zu übertragen.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parameter

*xDest*<br/>
Gibt die x-Koordinate in logischen Einheiten der oberen linken Ecke des Zielrechtecks an.

*yDest*<br/>
Gibt die y-Koordinate in logischen Einheiten der oberen linken Ecke des Zielrechtecks an.

*nDestWidth*<br/>
Gibt die Breite des Zielrechtecks in logischen Einheiten an.

*nDestHeight*<br/>
Gibt die Höhe des Zielrechtecks in logischen Einheiten an.

*pSrcDC*<br/>
Zeiger auf den Quellgerätekontext.

*xSrc*<br/>
Gibt die x-Koordinate des Quellrechtecks in logischen Einheiten an.

*ySrc*<br/>
Gibt die y-Koordinate des Quellrechtecks in logischen Einheiten an.

*nSrcWidth*<br/>
Gibt die Breite des Quellrechtecks in logischen Einheiten an.

*nSrcHeight*<br/>
Gibt die Höhe des Quellrechtecks in logischen Einheiten an.

*clrTransparent*<br/>
Die RGB-Farbe in der Quellbitmap, die als transparent behandelt werden soll.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Bemerkungen

`TransparentBlt`ermöglicht Transparenz; Das heißt, die von *clrTransparent* angezeigte RGB-Farbe wird für die Übertragung transparent gemacht.

Weitere Informationen finden Sie unter [TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) im Windows SDK.

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>CDC::UpdateColors

Aktualisiert den Clientbereich des Gerätekontexts, indem die aktuellen Farben im Clientbereich pixelweise mit der Systempalette abgleichen.

```
void UpdateColors();
```

### <a name="remarks"></a>Bemerkungen

Ein inaktives Fenster mit einer `UpdateColors` realisierten logischen Palette kann als Alternative zum Neuzeichnen des Clientbereichs aufrufen, wenn sich die Systempalette ändert.

Weitere Informationen zur Verwendung von Farbpaletten finden Sie unter [UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) im Windows SDK.

Die `UpdateColors` Memberfunktion aktualisiert in der Regel einen Clientbereich schneller als das erneute Zeichnen des Bereichs. Da die Funktion jedoch die Farbübersetzung basierend auf der Farbe jedes Pixels vor der Änderung der Systempalette durchführt, führt jeder Aufruf dieser Funktion zum Verlust einer gewissen Farbgenauigkeit.

## <a name="cdcwidenpath"></a><a name="widenpath"></a>CDC::WidenPath

Definiert den aktuellen Pfad als den Bereich, der gezeichnet würde, wenn der Pfad mit dem derzeit im Gerätekontext ausgewählten Stift gestrichelt würde.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Funktion ist nur erfolgreich, wenn es sich bei `CreatePen` dem aktuellen Stift um einen geometrischen Stift `CreatePen` handelt, der von der zweiten Version der Memberfunktion erstellt wurde, oder wenn der Stift mit der ersten Version von erstellt wurde und eine Breite von mehr als 1 in Geräteeinheiten aufweist. Der Gerätekontext muss einen geschlossenen Pfad enthalten. Alle Bzier-Kurven im Pfad werden in Sequenzen gerader Linien konvertiert, die die verbreiterten Kurven angrenzen. Daher bleiben keine Bzier-Kurven im `WidenPath` Pfad, nachdem aufgerufen wird.

## <a name="see-also"></a>Siehe auch

[CObject-Klasse](../../mfc/reference/cobject-class.md)<br/>
[Hierarchiediagramm](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC-Klasse](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC-Klasse](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC-Klasse](../../mfc/reference/cclientdc-class.md)<br/>
[CMetaFileDC-Klasse](../../mfc/reference/cmetafiledc-class.md)
