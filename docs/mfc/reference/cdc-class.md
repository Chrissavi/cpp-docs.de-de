---
title: CDC-Klasse
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 432d560da0ae3459ba43faed9a50b9771b0de5d1
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/27/2020
ms.locfileid: "87212552"
---
# <a name="cdc-class"></a>CDC-Klasse

Definiert eine Klasse von Gerätekontextobjekten.

## <a name="syntax"></a>Syntax

```
class CDC : public CObject
```

## <a name="members"></a>Member

### <a name="public-constructors"></a>Öffentliche Konstruktoren

|Name|BESCHREIBUNG|
|----------|-----------------|
|[CDC:: CDC](#cdc)|Erstellt ein `CDC`-Objekt.|

### <a name="public-methods"></a>Öffentliche Methoden

|name|BESCHREIBUNG|
|----------|-----------------|
|[CDC:: abortdoc](#abortdoc)|Beendet den aktuellen Druckauftrag und löscht alles, was die Anwendung seit dem letzten-Rückruf der Member-Funktion auf das Gerät geschrieben hat `StartDoc` .|
|[CDC:: abortpath](#abortpath)|Schließt und verwirft alle Pfade im Gerätekontext.|
|[CDC:: AddMetafileComment](#addmetafilecomment)|Kopiert den Kommentar aus einem Puffer in eine angegebene Metadatendatei mit erweitertem Format.|
|[CDC:: AlphaBlend](#alphablend)|Zeigt Bitmaps mit transparenten oder semitransparenten Pixeln an.|
|[CDC:: anglearc](#anglearc)|Zeichnet ein Liniensegment und einen Bogen und verschiebt die aktuelle Position an den Endpunkt des Bogens.|
|[CDC:: Arc](#arc)|Zeichnet einen elliptischen Bogen.|
|[CDC:: ArcTo](#arcto)|Zeichnet einen elliptischen Bogen. Diese Funktion ähnelt `Arc` , mit der Ausnahme, dass die aktuelle Position aktualisiert wird.|
|[CDC:: Attach](#attach)|Fügt einen Windows-Gerätekontext an dieses- `CDC` Objekt an.|
|[CDC:: beginpath](#beginpath)|Öffnet eine Pfad Klammer im Gerätekontext.|
|[CDC::BitBlt](#bitblt)|Kopiert eine Bitmap aus einem angegebenen Gerätekontext.|
|[CDC:: Chord](#chord)|Zeichnet einen Akkord (eine geschlossene Abbildung, die durch die Schnittmenge einer Ellipse und eines Linien Segments begrenzt ist).|
|[CDC:: CloseFigure](#closefigure)|Schließt eine geöffnete Figur in einem Pfad.|
|[CDC:: kreatecompatibledc](#createcompatibledc)|Erstellt einen Speichergeräte Kontext, der mit einem anderen Gerätekontext kompatibel ist. Sie können Sie verwenden, um Images im Speicher vorzubereiten.|
|[CDC:: kreatedc](#createdc)|Erstellt einen Gerätekontext für ein bestimmtes Gerät.|
|[CDC:: kreateic](#createic)|Erstellt einen Informations Kontext für ein bestimmtes Gerät. Dies bietet eine schnelle Möglichkeit, Informationen über das Gerät zu erhalten, ohne einen Gerätekontext zu erstellen.|
|[CDC::D eletedc](#deletedc)|Löscht den Windows-Gerätekontext, der diesem-Objekt zugeordnet ist `CDC` .|
|[CDC::D eletetempmap](#deletetempmap)|Wird vom `CWinApp` Leerlaufzeit Handler aufgerufen, um ein temporäres Objekt zu löschen, das `CDC` von erstellt wurde `FromHandle` . Trennt auch den Gerätekontext.|
|[CDC::D Etach](#detach)|Trennt den Windows-Gerätekontext von diesem- `CDC` Objekt.|
|[CDC::D ptohimetric](#dptohimetric)|Konvertiert Geräte Einheiten in himetrische Einheiten.|
|[CDC::D ptolp](#dptolp)|Konvertiert Geräte Einheiten in logische Einheiten.|
|[CDC::D raw3drect](#draw3drect)|Zeichnet ein dreidimensionales Rechteck.|
|[CDC::D rawdragrect](#drawdragrect)|Löscht ein Rechteck und zeichnet es neu, wenn es gezogen wird.|
|[CDC::D rakeil](#drawedge)|Zeichnet die Ränder eines Rechtecks.|
|[CDC::D rawescape](#drawescape)|Greift auf Zeichnungsfunktionen einer Videoanzeige zu, die nicht direkt über die Graphics Device Interface (GDI) verfügbar sind.|
|[CDC::D rawfocrarect](#drawfocusrect)|Zeichnet ein Rechteck im Stil, mit dem der Fokus angegeben wird.|
|[CDC::D rawframecontrol](#drawframecontrol)|Zeichnen Sie ein Frame-Steuerelement.|
|[CDC::D rawicon](#drawicon)|Zeichnet ein Symbol.|
|[CDC::D rawstate](#drawstate)|Zeigt ein Bild an und wendet einen visuellen Effekt an, um einen Zustand anzugeben.|
|[CDC::DrawText](#drawtext)|Zeichnet formatierten Text im angegebenen Rechteck.|
|[CDC::D rawtextex](#drawtextex)|Zeichnet formatierten Text im angegebenen Rechteck mit zusätzlichen Formaten.|
|[CDC:: Ellipse](#ellipse)|Zeichnet eine Ellipse.|
|[CDC:: EndDoc](#enddoc)|Beendet einen Druckauftrag, der von der Member-Funktion gestartet wurde `StartDoc` .|
|[CDC:: EndPage](#endpage)|Informiert den Gerätetreiber darüber, dass eine Seite beendet wird.|
|[CDC:: endpath](#endpath)|Schließt eine Pfad Klammer und wählt den von der Klammer definierten Pfad in den Gerätekontext aus.|
|[CDC:: umumujects](#enumobjects)|Listet die Stifte und Pinsel auf, die in einem Gerätekontext verfügbar sind.|
|[CDC:: Escape](#escape)|Ermöglicht Anwendungen den Zugriff auf Funktionen, die von einem bestimmten Gerät nicht direkt über GDI verfügbar sind. Ermöglicht auch den Zugriff auf Windows-escapefunktionen. Die von einer Anwendung ausgeführten escapeaufrufe werden übersetzt und an den Gerätetreiber gesendet.|
|[CDC:: excludebug](#excludecliprect)|Erstellt einen neuen Clippingbereich, der aus dem vorhandenen Clippingbereich abzüglich des angegebenen Rechtecks besteht.|
|[CDC:: excluentupdatergn](#excludeupdatergn)|Verhindert, dass innerhalb Ungültiger Bereiche eines Fensters gezeichnet wird, indem ein aktualisierter Bereich im Fenster von einem Clippingbereich ausgeschlossen wird.|
|[CDC:: extflufill](#extfloodfill)|Füllt einen Bereich mit dem aktuellen Pinsel. Bietet mehr Flexibilität als die [CDC:: flufill](#floodfill) -Member-Funktion.|
|[CDC:: exttextout](#exttextout)|Schreibt eine Zeichenfolge in einem rechteckigen Bereich mithilfe der aktuell ausgewählten Schriftart.|
|[CDC:: FillPath](#fillpath)|Schließt alle geöffneten Abbildungen im aktuellen Pfad und füllt das Innere des Pfads mit dem aktuellen Pinsel und dem Polygon Füll Modus aus.|
|[CDC:: fillRect](#fillrect)|Füllt ein angegebenes Rechteck mithilfe eines bestimmten Pinsels.|
|[CDC:: fillrgn](#fillrgn)|Füllt einen bestimmten Bereich mit dem angegebenen Pinsel.|
|[CDC:: fillsolidrect](#fillsolidrect)|Füllt ein Rechteck mit einer voll Tonfarbe aus.|
|[CDC:: vereinfachpfad](#flattenpath)|Wandelt alle Kurven im ausgewählten Pfad in den aktuellen Gerätekontext um und wandelt jede Kurve in eine Sequenz von Zeilen um.|
|[CDC:: flufill](#floodfill)|Füllt einen Bereich mit dem aktuellen Pinsel.|
|[CDC:: frameRect](#framerect)|Zeichnet einen Rahmen um ein Rechteck.|
|[CDC:: framergn](#framergn)|Zeichnet mit einem Pinsel einen Rahmen um einen bestimmten Bereich.|
|[CDC:: FromHandle](#fromhandle)|Gibt einen Zeiger auf ein-Objekt zurück, `CDC` Wenn ein Handle für einen Gerätekontext angegeben wird. Wenn ein `CDC`-Objekt nicht an das Handle angefügt ist, wird ein temporäres `CDC`-Objekt erstellt und angefügt.|
|[CDC:: getarcdirection](#getarcdirection)|Gibt die aktuelle Bogen Richtung für den Gerätekontext zurück.|
|[CDC:: getaspectratiofilter](#getaspectratiofilter)|Ruft die Einstellung für den aktuellen Seitenverhältnis Filter ab.|
|[CDC:: GetBkColor](#getbkcolor)|Ruft die aktuelle Hintergrundfarbe ab.|
|[CDC:: getbkmode](#getbkmode)|Ruft den Hintergrundmodus ab.|
|[CDC:: getboundsrect](#getboundsrect)|Gibt das aktuelle akkumulierte umgebende Rechteck für den angegebenen Gerätekontext zurück.|
|[CDC:: getbrushorg](#getbrushorg)|Ruft den Ursprung des aktuellen Pinsels ab.|
|[CDC:: getcharabcbreiten](#getcharabcwidths)|Ruft die breiten von aufeinander folgenden Zeichen in logischen Einheiten aus der aktuellen Schriftart ab.|
|[CDC:: getcharabcwidthsi](#getcharabcwidthsi)|Ruft die breiten in logischen Einheiten von aufeinander folgenden Glyphe-Indizes in einem angegebenen Bereich aus der aktuellen TrueType-Schriftart ab.|
|[CDC:: getcharakteriplacement](#getcharacterplacement)|Ruft verschiedene Typen von Informationen zu einer Zeichenfolge ab.|
|[CDC:: getcharwidth](#getcharwidth)|Ruft die Bruch Breite von aufeinander folgenden Zeichen in einem angegebenen Bereich aus der aktuellen Schriftart ab.|
|[CDC:: getcharwidthi](#getcharwidthi)|Ruft die breiten in logischen Koordinaten von aufeinander folgenden Glyphe-Indizes in einem angegebenen Bereich aus der aktuellen Schriftart ab.|
|[CDC:: getclipbox](#getclipbox)|Ruft die Dimensionen des Begrenzungs Rechtecks um die aktuelle clippinggrenze ab.|
|[CDC:: getcoloradjustment](#getcoloradjustment)|Ruft die Farb Anpassungs Werte für den Gerätekontext ab.|
|[CDC:: getcurrentbitmap](#getcurrentbitmap)|Gibt einen Zeiger auf das aktuell ausgewählte `CBitmap` Objekt zurück.|
|[CDC:: getcurrentbrush](#getcurrentbrush)|Gibt einen Zeiger auf das aktuell ausgewählte `CBrush` Objekt zurück.|
|[CDC:: getcurrentfont](#getcurrentfont)|Gibt einen Zeiger auf das aktuell ausgewählte `CFont` Objekt zurück.|
|[CDC:: getcurrentpalette](#getcurrentpalette)|Gibt einen Zeiger auf das aktuell ausgewählte `CPalette` Objekt zurück.|
|[CDC:: getcurrentpen](#getcurrentpen)|Gibt einen Zeiger auf das aktuell ausgewählte `CPen` Objekt zurück.|
|[CDC:: GetCurrentPosition](#getcurrentposition)|Ruft die aktuelle Position des Stifts (in logischen Koordinaten) ab.|
|[CDC:: getdcbrushcolor](#getdcbrushcolor)|Ruft die aktuelle Pinselfarbe ab.|
|[CDC:: getdcpcolor](#getdcpencolor)|Ruft die aktuelle Stiftfarbe ab.|
|[CDC:: getde vicecaps](#getdevicecaps)|Ruft eine bestimmte Art Geräte spezifischer Informationen über die Funktionen eines bestimmten Anzeige Geräts ab.|
|[CDC:: getfontdata](#getfontdata)|Ruft Schriftart metrikinformationen aus einer skalierbaren Schriftart Datei ab. Die abzurufenden Informationen werden durch Angabe eines Offsets in der Schriftart Datei und der Länge der zurück zugebende Informationen identifiziert.|
|[CDC:: getfontlanguageingefo](#getfontlanguageinfo)|Gibt Informationen zur aktuell ausgewählten Schriftart für den angegebenen Anzeige Kontext zurück.|
|[CDC:: GetGlyphOutline](#getglyphoutline)|Ruft die Gliederungs Kurve oder Bitmap für ein Umriss Zeichen in der aktuellen Schriftart ab.|
|[CDC:: getgraphicsmode](#getgraphicsmode)|Ruft den aktuellen Grafikmodus für den angegebenen Gerätekontext ab.|
|[CDC:: gethalftonebrush](#gethalftonebrush)|Ruft einen halbftone-Pinsel ab.|
|[CDC:: getkerningpairs](#getkerningpairs)|Ruft die Zeichen für die Zeichenauswahl für die Schriftart ab, die derzeit im angegebenen Gerätekontext ausgewählt ist.|
|[CDC:: getLayout](#getlayout)|Ruft das Layout eines Geräte Kontexts (DC) ab. Das Layout kann entweder von links nach rechts (Standard) oder von rechts nach links (gespiegelt) erfolgen.|
|[CDC:: getmapmode](#getmapmode)|Ruft den aktuellen Mapping-Modus ab.|
|[CDC:: getMiterLimit](#getmiterlimit)|Gibt das miterLimit für den Gerätekontext zurück.|
|[CDC:: GetNearestColor](#getnearestcolor)|Ruft die nächstgelegene logische Farbe an eine angegebene logische Farbe ab, die das angegebene Gerät darstellen kann.|
|[CDC:: getoutlinetextmetrics](#getoutlinetextmetrics)|Ruft Schriftart metrikinformationen für TrueType-Schriftarten ab.|
|[CDC:: getoutputcharwidth](#getoutputcharwidth)|Ruft die Breite einzelner Zeichen in einer aufeinanderfolgenden Gruppe von Zeichen aus der aktuellen Schriftart mithilfe des Ausgabegeräte Kontexts ab.|
|[CDC:: getoutputtabbedtextextent](#getoutputtabbedtextextent)|Berechnet die Breite und Höhe einer Zeichenfolge im Ausgabegeräte Kontext.|
|[CDC:: getoutputtextextent](#getoutputtextextent)|Berechnet die Breite und Höhe einer Textzeile im Ausgabegeräte Kontext mithilfe der aktuellen Schriftart, um die Dimensionen zu bestimmen.|
|[CDC:: getoutputtextmetrics](#getoutputtextmetrics)|Ruft die Metriken für die aktuelle Schriftart aus dem Ausgabegeräte Kontext ab.|
|[CDC:: getpath](#getpath)|Ruft die Koordinaten ab, die die Endpunkte von Linien definieren, sowie die Steuerungs Punkte der Kurven, die sich in dem Pfad befinden, der im Gerätekontext ausgewählt wird.|
|[CDC:: GetPixel](#getpixel)|Ruft den RGB-Farbwert des Pixels an der angegebenen Stelle ab.|
|[CDC:: getpolyfillmode](#getpolyfillmode)|Ruft den aktuellen Polygon Füll Modus ab.|
|[CDC:: GetROP2](#getrop2)|Ruft den aktuellen Zeichnungsmodus ab.|
|[CDC:: Geder afehdc](#getsafehdc)|Gibt [CDC:: m_hDC](#m_hdc)zurück, den Ausgabegeräte Kontext.|
|[CDC:: getstretchbltmode](#getstretchbltmode)|Ruft den aktuellen bitmapstreckungs Modus ab.|
|[CDC:: gettabbedtextextent](#gettabbedtextextent)|Berechnet die Breite und Höhe einer Zeichenfolge im Attribut Gerätekontext.|
|[CDC:: gettextalign](#gettextalign)|Ruft die Flags für die Textausrichtung ab.|
|[CDC:: gettextcharakteriextra](#gettextcharacterextra)|Ruft die aktuelle Einstellung für die Menge der intercharacter-Abstände ab.|
|[CDC:: gettextcolor](#gettextcolor)|Ruft die aktuelle Textfarbe ab.|
|[CDC:: GetTextExtent](#gettextextent)|Berechnet die Breite und Höhe einer Textzeile im Attribut Gerätekontext unter Verwendung der aktuellen Schriftart zum Bestimmen der Dimensionen.|
|[CDC:: gettextextentexpointi](#gettextextentexpointi)|Ruft die Anzahl der Zeichen in einer angegebenen Zeichenfolge ab, die in einen angegebenen Bereich passen und ein Array mit dem TextBlock für jedes dieser Zeichen füllt.|
|[CDC:: gettextextentpointi](#gettextextentpointi)|Ruft die Breite und Höhe des angegebenen Arrays von Symbol Indizes ab.|
|[CDC:: gettextface](#gettextface)|Kopiert den Schriftart Namen der aktuellen Schriftart als NULL-terminierte Zeichenfolge in einen Puffer.|
|[CDC:: GetTextMetrics](#gettextmetrics)|Ruft die Metriken für die aktuelle Schriftart aus dem Attribut Gerätekontext ab.|
|[CDC:: getviewportext](#getviewportext)|Ruft die x-und y-Blöcke des Viewports ab.|
|[CDC:: getviewportor g](#getviewportorg)|Ruft die x-und y-Koordinaten des viewportursprungs ab.|
|[CDC:: GetWindow](#getwindow)|Gibt das Fenster zurück, das dem Anzeigegeräte Kontext zugeordnet ist.|
|[CDC:: getwindowext](#getwindowext)|Ruft die x-und y-Blöcke des zugeordneten Fensters ab.|
|[CDC:: getwindoworg](#getwindoworg)|Ruft die x-und y-Koordinaten des Ursprungs des zugeordneten Fensters ab.|
|[CDC:: getworldtransform](#getworldtransform)|Ruft die aktuelle Transformation für Welt Raum zu Seiten Raum ab.|
|[CDC:: GradientFill](#gradientfill)|Füllt Rechteck-und Dreieck Strukturen mit einer graderfarbe aus.|
|[CDC:: graystring](#graystring)|Zeichnet abgeblendet (grau) Text an der angegebenen Position.|
|[CDC:: himetricdedp](#himetrictodp)|Konvertiert HIMETRIC-Einheiten in Geräte Einheiten.|
|[CDC:: himetrictolp](#himetrictolp)|Konvertiert HIMETRIC-Einheiten in logische Einheiten.|
|[CDC:: IntersectClipRect](#intersectcliprect)|Erstellt einen neuen Clippingbereich, indem die Schnittmenge des aktuellen Bereichs und eines Rechtecks gebildet wird.|
|[CDC:: invertrect](#invertrect)|Kehrt den Inhalt eines Rechtecks um.|
|[CDC:: invertrgn](#invertrgn)|Kehrt die Farben in einem Bereich um.|
|[CDC:: IsPrinting](#isprinting)|Bestimmt, ob der Gerätekontext zum Drucken verwendet wird.|
|[CDC:: LineTo](#lineto)|Zeichnet eine Linie von der aktuellen Position bis zum, jedoch nicht einschließlich eines Punkts.|
|[CDC:: lptodp](#lptodp)|Konvertiert logische Einheiten in Geräte Einheiten.|
|[CDC:: lptohimetric](#lptohimetric)|Konvertiert logische Einheiten in himetrische Einheiten.|
|[CDC:: MaskBlt](#maskblt)|Kombiniert die Farbdaten für die Quell-und Ziel Bitmaps mithilfe der angegebenen Maske und des Raster Vorgangs.|
|[CDC:: modifyworldtransform](#modifyworldtransform)|Ändert die globale Transformation für einen Gerätekontext unter Verwendung des angegebenen Modus.|
|[CDC:: muveto](#moveto)|Verschiebt die aktuelle Position.|
|[CDC:: offsetcliprgn](#offsetcliprgn)|Verschiebt den Ausschneide Bereich des angegebenen Geräts.|
|[CDC:: offsetviewportor](#offsetviewportorg)|Ändert den Viewportursprung in Relation zu den Koordinaten des aktuellen viewportursprungs.|
|[CDC:: offsetwindoworg](#offsetwindoworg)|Ändert den Fenster Ursprung in Relation zu den Koordinaten des aktuellen Fenster Ursprungs.|
|[CDC::P aintrgn](#paintrgn)|Füllt einen Bereich mit dem ausgewählten Pinsel.|
|[CDC::P atblt](#patblt)|Erstellt ein Bitmuster.|
|[CDC::P IE](#pie)|Zeichnet einen kreisförmigen Keil.|
|[CDC::P laymetafile](#playmetafile)|Gibt den Inhalt der angegebenen Metadatei auf dem angegebenen Gerät wieder. Die erweiterte Version von `PlayMetaFile` zeigt das Bild an, das in der angegebenen Metadatei mit erweitertem Format gespeichert ist. Die Metadatei kann beliebig oft wiedergegeben werden.|
|[CDC::P lgblt](#plgblt)|Führt eine Bitblock Übertragung der Bits von Farbdaten aus dem angegebenen Rechteck im Quell Gerätekontext in das angegebene Parallelogramm im angegebenen Gerätekontext aus.|
|[CDC::P olybezier](#polybezier)|Zeichnet eine oder mehrere Bzier-Splines. Die aktuelle Position wird weder verwendet noch aktualisiert.|
|[CDC::P olybezierto](#polybezierto)|Zeichnet eine oder mehrere Bzier-Splines und verschiebt die aktuelle Position an den Endpunkt der letzten Bzier-Spline.|
|[CDC::P olydraw](#polydraw)|Zeichnet eine Reihe von Liniensegmenten und Bzier-Splines. Diese Funktion aktualisiert die aktuelle Position.|
|[CDC::P olygon](#polygon)|Zeichnet ein Polygon, das aus zwei oder mehr Punkten (Vertices) besteht, die durch Linien verbunden sind.|
|[CDC::P olyline](#polyline)|Zeichnet eine Reihe von Liniensegmenten, die die angegebenen Punkte verbinden.|
|[CDC::P olylineto](#polylineto)|Zeichnet eine oder mehrere gerade Linien und verschiebt die aktuelle Position an den Endpunkt der letzten Zeile.|
|[CDC::P olypolygon](#polypolygon)|Erstellt zwei oder mehr Polygone, die mit dem aktuellen Polygon Füll Modus gefüllt werden. Die Polygone können zusammen hanglos sein, oder Sie können sich überlappen.|
|[CDC::P olypolyline](#polypolyline)|Zeichnet mehrere Reihe verbundener Liniensegmente. Die aktuelle Position wird von dieser Funktion weder verwendet noch aktualisiert.|
|[CDC::P tvisible](#ptvisible)|Gibt an, ob sich der angegebene Punkt innerhalb des Clippingbereichs befindet.|
|[CDC:: RealizePalette](#realizepalette)|Ordnet Paletteneinträge in der aktuellen logischen Palette der Systempalette zu.|
|[CDC:: Rechteck](#rectangle)|Zeichnet ein Rechteck mithilfe des aktuellen Stifts und füllt es mit dem aktuellen Pinsel.|
|[CDC:: rectvisible](#rectvisible)|Bestimmt, ob ein Teil des angegebenen Rechtecks innerhalb des Clippingbereichs liegt.|
|[CDC:: releaseattribdc](#releaseattribdc)|Releases `m_hAttribDC` , das Attribut Gerätekontext.|
|[CDC:: releaseoutputdc](#releaseoutputdc)|Releases `m_hDC` , den Ausgabegeräte Kontext.|
|[CDC:: ResetDC](#resetdc)|Aktualisiert den `m_hAttribDC` Gerätekontext.|
|[CDC:: restoredc](#restoredc)|Stellt den Gerätekontext in einem vorherigen Zustand wieder her, der mit gespeichert wird `SaveDC` .|
|[CDC:: roundRect](#roundrect)|Zeichnet ein Rechteck mit abgerundeten Ecken unter Verwendung des aktuellen Stifts und füllt mit dem aktuellen Pinsel.|
|[CDC:: savedc](#savedc)|Speichert den aktuellen Zustand des Geräte Kontexts.|
|[CDC:: scaleviewportext](#scaleviewportext)|Ändert den viewportwert in Bezug auf die aktuellen Werte.|
|[CDC:: scalewindowext](#scalewindowext)|Ändert die Fensterblöcke in Bezug auf die aktuellen Werte.|
|[CDC:: scrolldc](#scrolldc)|Führt einen horizontalen und vertikalen Bildlauf für ein Rechteck von Bits aus.|
|[CDC:: selectclippath](#selectclippath)|Wählt den aktuellen Pfad als Clippingbereich für den Gerätekontext aus, wobei die neue Region mit einem beliebigen vorhandenen Clippingbereich unter Verwendung des angegebenen Modus kombiniert wird.|
|[CDC:: selectcliprgn](#selectcliprgn)|Kombiniert den angegebenen Bereich mit dem aktuellen Clippingbereich unter Verwendung des angegebenen Modus.|
|[CDC::SelectObject](#selectobject)|Wählt ein GDI-Zeichnungsobjekt aus, z. b. einen Stift.|
|[CDC:: SelectPalette](#selectpalette)|Wählt die logische Palette aus.|
|[CDC::SelectStockObject](#selectstockobject)|Wählt einen der vordefinierten, von Windows bereitgestellten Kurs Stifte, Pinsel oder Schriftarten aus.|
|[CDC:: abtabortproc](#setabortproc)|Legt eine vom Programmierer bereitgestellte Rückruffunktion fest, die von Windows aufgerufen wird, wenn ein Druckauftrag abgebrochen werden muss.|
|[CDC:: tartarcdirection](#setarcdirection)|Legt die Zeichnungs Richtung fest, die für Bogen-und Rechteck Funktionen verwendet werden soll.|
|[CDC:: ""](#setattribdc)|Legt fest `m_hAttribDC` , das Attribut Gerätekontext.|
|[CDC:: SetBkColor](#setbkcolor)|Legt die aktuelle Hintergrundfarbe fest.|
|[CDC:: setbkmode](#setbkmode)|Legt den Hintergrundmodus fest.|
|[CDC:: setboundsrect](#setboundsrect)|Steuert die Ansammlung von umgebenden Rechteck Informationen für den angegebenen Gerätekontext.|
|[CDC:: setbrushorg](#setbrushorg)|Gibt den Ursprung für den nächsten Pinsel an, der in einen Gerätekontext ausgewählt wird.|
|[CDC:: setcoloradjustment](#setcoloradjustment)|Legt die Farb Anpassungs Werte für den Gerätekontext mithilfe der angegebenen Werte fest.|
|[CDC:: setdcbrushcolor](#setdcbrushcolor)|Legt die aktuelle Pinsel Farbe fest.|
|[CDC:: setdcpcolor](#setdcpencolor)|Legt die aktuelle Stift Farbe fest.|
|[CDC:: setgraphicsmode](#setgraphicsmode)|Legt den aktuellen Grafikmodus für den angegebenen Gerätekontext fest.|
|[CDC:: setLayout](#setlayout)|Ändert das Layout eines Geräte Kontexts (DC).|
|[CDC:: setmapmode](#setmapmode)|Legt den aktuellen Kartenmodus fest.|
|[CDC:: setmapperflags](#setmapperflags)|Ändert den Algorithmus, den die Schriftart Mapper verwendet, wenn logische Schriftarten physischen Schriftarten zugeordnet werden.|
|[CDC:: setmiterlimit](#setmiterlimit)|Legt den Grenzwert für die Länge von Gehrungs-Joins für den Gerätekontext fest.|
|[CDC:: setoutputdc](#setoutputdc)|Legt `m_hDC` den Ausgabegeräte Kontext fest.|
|[CDC:: SetPixel](#setpixel)|Legt das Pixel am angegebenen Punkt auf die nächstgelegene Näherung der angegebenen Farbe fest.|
|[CDC:: setpixelv](#setpixelv)|Legt das Pixel an den angegebenen Koordinaten auf die nächstgelegene Näherung der angegebenen Farbe fest. `SetPixelV`ist schneller als `SetPixel` , weil der Farbwert des tatsächlich gezeichneten Punkts nicht zurückgegeben werden muss.|
|[CDC:: setpolyfillmode](#setpolyfillmode)|Legt den Polygon Füll Modus fest.|
|[CDC:: SetROP2](#setrop2)|Legt den aktuellen Zeichnungsmodus fest.|
|[CDC:: setstretchbltmode](#setstretchbltmode)|Legt den Modus für die Bitmap-Streckung fest.|
|[CDC:: setTextAlign](#settextalign)|Legt die Flags für die Textausrichtung fest.|
|[CDC:: settextcharakteriextra](#settextcharacterextra)|Legt den Abstand zwischen Leerzeichen fest.|
|[CDC:: SetTextColor](#settextcolor)|Legt die Textfarbe fest.|
|[CDC:: settextbegrün dung](#settextjustification)|Fügt den Break-Zeichen in einer Zeichenfolge Leerzeichen hinzu.|
|[CDC:: setviewportext](#setviewportext)|Legt die x-und y-Blöcke des Viewports fest.|
|[CDC:: setviewportor](#setviewportorg)|Legt den Viewportursprung fest.|
|[CDC:: setwindowext](#setwindowext)|Legt die x-und y-Blöcke des zugeordneten Fensters fest.|
|[CDC:: setwindoworg](#setwindoworg)|Legt den Fenster Ursprung des Geräte Kontexts fest.|
|[CDC:: setworldtransform](#setworldtransform)|Legt die aktuelle Transformation für den Welt Raum auf den Seiten Raum fest.|
|[CDC:: StartDoc](#startdoc)|Informiert den Gerätetreiber darüber, dass ein neuer Druckauftrag gestartet wird.|
|[CDC:: Startpage](#startpage)|Informiert den Gerätetreiber darüber, dass eine neue Seite gestartet wird.|
|[CDC:: StretchBlt](#stretchblt)|Verschiebt eine Bitmap aus einem Quell Rechteck und einem Gerät in ein Ziel Rechteck, wobei die Bitmap bei Bedarf gestreckt oder komprimiert wird, um die Abmessungen des Ziel Rechtecks anzupassen.|
|[CDC:: strokeandfillpath](#strokeandfillpath)|Schließt alle geöffneten Abbildungen in einem Pfad, schlägt die Gliederung des Pfades mithilfe des aktuellen Stifts und füllt das Innere mit dem aktuellen Pinsel.|
|[CDC:: strokePath](#strokepath)|Rendert den angegebenen Pfad mit dem aktuellen Stift.|
|[CDC:: tabbedtextout](#tabbedtextout)|Schreibt eine Zeichenfolge an einer angegebenen Position und erweitert die Registerkarten auf die Werte, die in einem Array von Tabstopp Positionen angegeben sind.|
|[CDC:: TextOut](#textout)|Schreibt eine Zeichenfolge an einer angegebenen Position mithilfe der aktuell ausgewählten Schriftart.|
|[CDC:: TransparentBlt](#transparentblt)|Überträgt einen Bitblock von Farbdaten aus dem angegebenen Quell Gerätekontext in einen Zielgeräte Kontext und rendert eine angegebene Farbe transparent in der Übertragung.|
|[CDC:: updatecolors](#updatecolors)|Aktualisiert den Client Bereich des Geräte Kontexts, indem die aktuellen Farben im Client Bereich auf pixelweise mit der Systempalette übereinstimmen.|
|[CDC:: widenpath](#widenpath)|Definiert den aktuellen Pfad neu als den Bereich, der gezeichnet werden würde, wenn der Pfad mithilfe des derzeit im Gerätekontext ausgewählten Stifts gezeichnet würde.|

### <a name="public-operators"></a>Öffentliche Operatoren

|Name|BESCHREIBUNG|
|----------|-----------------|
|[CDC:: Operator-HDC](#operator_hdc)|Ruft das Handle des Geräte Kontexts ab.|

### <a name="public-data-members"></a>Öffentliche Datenmember

|Name|BESCHREIBUNG|
|----------|-----------------|
|[CDC:: m_hAttribDC](#m_hattribdc)|Der von diesem-Objekt verwendete Attribut-Gerätekontext `CDC` .|
|[CDC:: m_hDC](#m_hdc)|Der Ausgabe-Gerätekontext, der von diesem-Objekt verwendet wird `CDC` .|

## <a name="remarks"></a>Bemerkungen

Das- `CDC` Objekt stellt Element Funktionen zum Arbeiten mit einem Gerätekontext, z. b. eine Anzeige oder einen Drucker, sowie Member zum Arbeiten mit einem Anzeige Kontext bereit, der dem Client Bereich eines Fensters zugeordnet ist.

Alle zeichnen die Element Funktionen eines- `CDC` Objekts. Die-Klasse stellt Element Funktionen für Gerätekontext Vorgänge, das Arbeiten mit Zeichnungs Tools, die typsichere GDI-Objektauswahl (Graphics Device Interface) und das Arbeiten mit Farben und Paletten bereit. Außerdem werden Element Funktionen zum erhalten und Festlegen von Zeichnungs Attributen, zuordnen, arbeiten mit dem Viewport, arbeiten mit dem Fensterblock, Konvertieren von Koordinaten, arbeiten mit Bereichen, Clipping, Zeichnen von Linien und Zeichnen von einfachen Formen, Ellipsen und Polygonen bereitstellt. Element Funktionen werden auch für das Zeichnen von Text, das Arbeiten mit Schriftarten, das Verwenden von Drucker Escapezeichen, den Bildlauf und das Abspielen von Metadateien

Um ein `CDC` -Objekt zu verwenden, erstellen Sie es, und nennen Sie dann seine Member-Funktionen, die parallele Windows-Funktionen verwenden, die Geräte Kontexte verwenden.

> [!NOTE]
> Unter Windows 95/98 sind alle Bildschirm Koordinaten auf 16 Bits beschränkt. Daher muss eine **`int`** , die an eine Member-Funktion übermittelt wird, `CDC` im Bereich von-32768 bis 32767 liegen.

Bei bestimmten Verwendungsmöglichkeiten stellt der Microsoft Foundation Class-Bibliothek mehrere von abgeleitete Klassen bereit `CDC` . `CPaintDC`kapselt Aufrufe von `BeginPaint` und `EndPaint` . `CClientDC`verwaltet einen Anzeige Kontext, der dem Client Bereich eines Fensters zugeordnet ist. `CWindowDC`verwaltet einen einem gesamten Fenster zugeordneten Anzeige Kontext, einschließlich des Frames und der Steuerelemente. `CMetaFileDC`ordnet einen Gerätekontext einer Metadatei zu.

`CDC`stellt die zwei Member-Funktionen [getLayout](#getlayout) und [setLayout](#setlayout)zum Umkehren des Layouts eines Geräte Kontexts bereit, der das Layout nicht von einem Fenster erbt. Eine solche Ausrichtung von rechts nach links ist für Anwendungen erforderlich, die für Kulturen geschrieben wurden, wie z. b. Arabisch oder Hebräisch, wobei das Zeichen Layout nicht der Europäische Standard ist.

`CDC`enthält zwei Geräte Kontexte [m_hDC](#m_hdc) und [m_hAttribDC](#m_hattribdc), die bei der Erstellung eines- `CDC` Objekts auf das gleiche Gerät verweisen. `CDC`leitet alle GDI-Ausgabe Aufrufe an `m_hDC` und die meisten Attribute-GDI-Aufrufe an `m_hAttribDC` . (Ein Beispiel für einen Attribut Aufrufwert ist `GetTextColor` , während ein Ausgabe--Befehl `SetTextColor` ist.)

Das Framework verwendet beispielsweise diese beiden Geräte Kontexte, um ein- `CMetaFileDC` Objekt zu implementieren, das beim Lesen von Attributen von einem physischen Gerät eine Ausgabe an eine Metadatei sendet. Die Seitenansicht wird im Framework auf ähnliche Weise implementiert. Sie können die beiden Geräte Kontexte auch auf ähnliche Weise in Ihrem anwendungsspezifischen Code verwenden.

Es gibt Zeiten, in denen Sie möglicherweise Text metrikinformationen aus dem `m_hDC` -und dem- `m_hAttribDC` Gerätekontext benötigen. Diese Funktion wird von den folgenden Funktions Paaren bereitgestellt:

|Verwendet m_hAttribDC|Verwendet m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[Getoutputtextextent](#getoutputtextextent)|
|[Gettabbedtextextent](#gettabbedtextextent)|[Getoutputtabbedtextextent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[Getoutputtextmetrics](#getoutputtextmetrics)|
|[Getcharwidth](#getcharwidth)|[Getoutputcharwidth](#getoutputcharwidth)|

Weitere Informationen zu `CDC` finden Sie unter [Geräte Kontexte](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Vererbungshierarchie

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Requirements (Anforderungen)

**Header:** afxwin.h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>CDC:: abortdoc

Beendet den aktuellen Druckauftrag und löscht alle Elemente, die von der Anwendung seit dem letzten Aufrufen der [StartDoc](#startdoc) -Member-Funktion auf das Gerät geschrieben wurden.

```
int AbortDoc();
```

### <a name="return-value"></a>Rückgabewert

Ein Wert größer oder gleich 0 (null), wenn erfolgreich, oder ein negativer Wert, wenn ein Fehler aufgetreten ist. In der folgenden Liste werden häufige Fehler Werte und ihre Bedeutung angezeigt:

- Allgemeiner Fehler SP_ERROR.

- SP_OUTOFDISK nicht genügend Speicherplatz zum Spoolvorgang verfügbar, und es wird kein Speicherplatz mehr verfügbar.

- SP_OUTOFMEMORY nicht genügend Arbeitsspeicher zum Spoolvorgang verfügbar.

- SP_USERABORT Benutzer den Auftrag über den Druck-Manager beendet hat.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion ersetzt den abortdoc-druckerescapezeichen.

`AbortDoc`sollte verwendet werden, um Folgendes zu beenden:

- Druckvorgänge, bei denen keine Abbruch [Funktion mithilfe von](#setabortproc)"" festgelegt wird.

- Druckvorgänge, die ihren ersten newframe-oder nextband-escapebefehl noch nicht erreicht haben.

Wenn eine Anwendung auf einen Druckfehler oder einen abgebrochenen Druckvorgang stößt, darf Sie nicht versuchen, den Vorgang mit den [EndDoc](#enddoc) -oder Element `AbortDoc` Funktionen der-Klasse zu beenden `CDC` . GDI beendet den Vorgang automatisch, bevor der Fehlerwert zurückgegeben wird.

Wenn in der Anwendung ein Dialogfeld angezeigt wird, in dem der Benutzer den Druckvorgang abbrechen kann, muss `AbortDoc` vor dem Zerstören des Dialog Felds aufgerufen werden.

Wenn der Druck-Manager verwendet wurde, um den Druckauftrag zu starten, wird durch Aufrufen von `AbortDoc` der gesamte Spoolauftrag gelöscht – der Drucker empfängt nichts. Wenn der Druck-Manager zum Starten des Druckauftrags nicht verwendet wurde, wurden die Daten möglicherweise vor dem Aufruf von an den Drucker gesendet `AbortDoc` . In diesem Fall würde der Druckertreiber (sofern möglich) den Drucker zurücksetzen und den Druckauftrag schließen.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CDC:: StartDoc](#startdoc).

## <a name="cdcabortpath"></a><a name="abortpath"></a>CDC:: abortpath

Schließt und verwirft alle Pfade im Gerätekontext.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Wenn im Gerätekontext eine öffnende Pfad Klammer vorhanden ist, wird die Pfad Klammer geschlossen, und der Pfad wird verworfen. Wenn im Gerätekontext ein geschlossener Pfad vorhanden ist, wird der Pfad verworfen.

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>CDC:: AddMetafileComment

Kopiert den Kommentar aus einem Puffer in eine angegebene Metadatendatei mit erweitertem Format.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parameter

*ndatasize*<br/>
Gibt die Länge des Kommentar Puffers in Bytes an.

*pcommentdata*<br/>
Verweist auf den Puffer, der den Kommentar enthält.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Ein Kommentar kann beliebige private Informationen enthalten, z. –. die Quelle des Bilds und das Erstellungsdatum. Ein Kommentar sollte mit einer Anwendungs Signatur beginnen, gefolgt von den Daten. Kommentare dürfen keine Positions spezifischen Daten enthalten. Positions spezifische Daten geben den Speicherort eines Datensatzes an und sollten nicht eingeschlossen werden, da eine Metadatei möglicherweise in eine andere Metadatendatei eingebettet ist. Diese Funktion kann nur mit erweiterten Metafiles verwendet werden.

## <a name="cdcalphablend"></a><a name="alphablend"></a>CDC:: AlphaBlend

Mit dieser Member-Funktion können Sie Bitmaps mit transparenten oder semitransparenten Pixeln anzeigen.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parameter

*xdest*<br/>
Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Ziel Rechtecks an.

*ydest*<br/>
Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Ziel Rechtecks an.

*ndestwidth*<br/>
Gibt die Breite (in logischen Einheiten) des Ziel Rechtecks an.

*ndestheight*<br/>
Gibt die Höhe (in logischen Einheiten) des Ziel Rechtecks an.

*psrcdc*<br/>
Ein Zeiger auf den Quell Gerätekontext.

*xsrc*<br/>
Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quell Rechtecks an.

*ysrc*<br/>
Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quell Rechtecks an.

*nsrcwidth*<br/>
Gibt die Breite des Quell Rechtecks in logischen Einheiten an.

*nsrcheight*<br/>
Gibt die Höhe des Quell Rechtecks in logischen Einheiten an.

*EMI*<br/>
Gibt eine [BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction) -Struktur an.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Bemerkungen

Weitere Informationen finden Sie unter [AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) in der Windows SDK.

## <a name="cdcanglearc"></a><a name="anglearc"></a>CDC:: anglearc

Zeichnet ein Liniensegment und einen Bogen.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate der Mitte des Kreises an.

*Teenie*<br/>
Gibt die logische y-Koordinate der Mitte des Kreises an.

*nradius*<br/>
Gibt den Radius des Kreises in logischen Einheiten an. Dieser Wert muss positiv sein.

*"Start"*<br/>
Gibt den Anfangs Winkel in Grad relativ zur x-Achse an.

*""*<br/>
Gibt den Mittelpunktswinkel in Grad relativ zum Anfangs Winkel an.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Bemerkungen

Das Liniensegment wird von der aktuellen Position bis zum Anfang des Bogens gezeichnet. Der Bogen wird entlang des Umkreis Bereichs eines Kreises mit dem angegebenen Radius und Mittelpunkt gezeichnet. Die Länge des Bogens wird durch die angegebenen Start-und Sweep-Winkel definiert.

`AngleArc`Verschiebt die aktuelle Position an den Endpunkt des Bogens. Der von dieser Funktion gezeichnete Bogen ist möglicherweise elliptisch, abhängig von der aktuellen Transformation und dem Zuordnungs Modus. Vor dem Zeichnen des Bogens zeichnet diese Funktion das Liniensegment von der aktuellen Position bis zum Anfang des Bogens. Der Bogen wird durch das Erstellen eines imaginären Kreises mit dem angegebenen Radius um den angegebenen Mittelpunkt gezeichnet. Der Anfangspunkt des Bogens wird bestimmt, indem er gegen den Uhrzeigersinn von der x-Achse des Kreises um die Anzahl der Grad im Start Winkel gemessen wird. Der Endpunkt befindet sich auf ähnliche Weise, indem er gegen den Uhrzeigersinn zwischen dem Anfangspunkt und der Anzahl von Grad im Mittelpunktswinkel gemessen wird.

Wenn der Mittelpunktswinkel größer als 360 Grad ist, wird der Bogen mehrmals gefegt. Diese Funktion zeichnet Zeilen mithilfe des aktuellen Stifts. Die Abbildung ist nicht ausgefüllt.

## <a name="cdcarc"></a><a name="arc"></a>CDC:: Arc

Zeichnet einen elliptischen Bogen.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*Y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*Y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*x3*<br/>
Gibt die x-Koordinate des Punkts an, der den Anfangspunkt des Bogens (in logischen Einheiten) definiert. Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*Y3*<br/>
Gibt die y-Koordinate des Punkts an, der den Anfangspunkt des Bogens (in logischen Einheiten) definiert. Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*x4*<br/>
Gibt die x-Koordinate des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*Y4*<br/>
Gibt die y-Koordinate des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*lprect*<br/>
Gibt das umgebende Rechteck an (in logischen Einheiten). Sie können entweder ein lprect-oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt für diesen Parameter übergeben.

*ptstart*<br/>
Gibt die x-und y-Koordinaten des Punkts an, der den Anfangspunkt des Bogens (in logischen Einheiten) definiert. Dieser Punkt muss sich nicht genau auf dem Bogen befinden. Sie können entweder eine [Punkt](/windows/win32/api/windef/ns-windef-point) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) -Objekt für diesen Parameter übergeben.

*ptend*<br/>
Gibt die x-und y-Koordinaten des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss sich nicht genau auf dem Bogen befinden. Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der mit der-Funktion gezeichnete Bogen ist ein Segment der Ellipse, das durch das angegebene umgebende Rechteck definiert wird.

Der eigentliche Ausgangspunkt des Bogens ist der Punkt, an dem ein Strahl, der aus der Mitte des umgebenden Rechtecks durch den angegebenen Startpunkt gezeichnet wurde, die Ellipse überlappt. Der tatsächliche Endpunkt des Bogens ist der Punkt, an dem ein Strahl, der aus der Mitte des umgebenden Rechtecks durch den angegebenen Endpunkt gezogen wurde, die Ellipse überschneidet. Der Bogen wird in der Richtung gegen den Uhrzeigersinn gezeichnet. Da ein Bogen keine geschlossene Abbildung ist, wird er nicht ausgefüllt. Sowohl die Breite als auch die Höhe des Rechtecks müssen größer als 2 Einheiten und kleiner als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>CDC:: ArcTo

Zeichnet einen elliptischen Bogen.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*Y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*Y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*x3*<br/>
Gibt die x-Koordinate des Punkts an, der den Anfangspunkt des Bogens (in logischen Einheiten) definiert. Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*Y3*<br/>
Gibt die y-Koordinate des Punkts an, der den Anfangspunkt des Bogens (in logischen Einheiten) definiert. Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*x4*<br/>
Gibt die x-Koordinate des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*Y4*<br/>
Gibt die y-Koordinate des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*lprect*<br/>
Gibt das umgebende Rechteck an (in logischen Einheiten). Sie können entweder einen Zeiger auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Datenstruktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt für diesen Parameter übergeben.

*ptstart*<br/>
Gibt die x-und y-Koordinaten des Punkts an, der den Anfangspunkt des Bogens (in logischen Einheiten) definiert. Dieser Punkt muss sich nicht genau auf dem Bogen befinden. Sie können entweder eine [Punkt](/windows/win32/api/windef/ns-windef-point) Datenstruktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) -Objekt für diesen Parameter übergeben.

*ptend*<br/>
Gibt die x-und y-Koordinaten des Punkts an, der den Endpunkt des Bogens definiert (in logischen Einheiten). Dieser Punkt muss sich nicht genau auf dem Bogen befinden. Sie können entweder eine `POINT` Datenstruktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Funktion ähnelt `CDC::Arc` , mit der Ausnahme, dass die aktuelle Position aktualisiert wird. Die Punkte ( *x1*, *Y1*) und ( *x2*, *Y2*) geben das umgebende Rechteck an. Eine Ellipse, die durch das angegebene umgebende Rechteck gebildet wird, definiert die Kurve des Bogens. Der Bogen erweitert den gegen Uhrzeigersinn (die Standard Bogen Richtung) von dem Punkt, an dem er die radiale Linie von der Mitte des umgebenden Rechtecks zu ( *X3*, *Y3*) schneidet. Der Bogen endet an der Stelle, an der er die radiale Linie von der Mitte des umgebenden Rechtecks in ( *X4*, *Y4*) schneidet. Wenn der Anfangspunkt und der Endpunkt identisch sind, wird eine komplette Ellipse gezeichnet.

Eine Linie wird von der aktuellen Position bis zum Anfangspunkt des Bogens gezeichnet. Wenn kein Fehler auftritt, wird die aktuelle Position auf den Endpunkt des Bogens festgelegt. Der Bogen wird mit dem aktuellen Stift gezeichnet. Er ist nicht ausgefüllt.

## <a name="cdcattach"></a><a name="attach"></a>CDC:: Attach

Verwenden Sie diese Member-Funktion, um einen *hdc* an das-Objekt anzufügen `CDC` .

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parameter

*HDC*<br/>
Ein Windows-Gerätekontext.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der *hdc* wird sowohl in als auch im `m_hDC` Ausgabegeräte Kontext und in `m_hAttribDC` , dem Attribut Gerätekontext, gespeichert.

## <a name="cdcbeginpath"></a><a name="beginpath"></a>CDC:: beginpath

Öffnet eine Pfad Klammer im Gerätekontext.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Nachdem eine Pfad Klammer geöffnet ist, kann eine Anwendung mit dem Aufrufen von GDI-Zeichnungsfunktionen beginnen, um die Punkte zu definieren, die im Pfad liegen. Eine Anwendung kann eine öffnende Pfad Klammer schließen, indem Sie die `EndPath` Member-Funktion aufrufen. Wenn eine Anwendung aufruft `BeginPath` , werden alle vorherigen Pfade verworfen.

Eine Liste der Zeichnungsfunktionen, die Punkte in einem Pfad definieren, finden Sie unter [beginpath](/windows/win32/api/wingdi/nf-wingdi-beginpath) im Windows SDK.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>CDC:: BitBLT

Kopiert eine Bitmap aus dem Quell Gerätekontext in diesen aktuellen Gerätekontext.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Ziel Rechtecks an.

*Teenie*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Ziel Rechtecks an.

*nwidth*<br/>
Gibt die Breite (in logischen Einheiten) des Ziel Rechtecks und der Quell Bitmap an.

*nheight*<br/>
Gibt die Höhe (in logischen Einheiten) des Ziel Rechtecks und der Quell Bitmap an.

*psrcdc*<br/>
Zeiger auf ein- `CDC` Objekt, das den Gerätekontext identifiziert, von dem die Bitmap kopiert wird. Der Wert muss NULL sein, wenn *dwrop* einen Raster Vorgang angibt, der keine Quelle enthält.

*xsrc*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke der Quell Bitmap an.

*ysrc*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke der Quell Bitmap an.

*dwRop*<br/>
Gibt das Raster des auszuführenden Vorgangs an. Raster-Vorgangs Codes definieren, wie das GDI Farben in Ausgabe Vorgängen kombiniert, die einen aktuellen Pinsel, eine mögliche Quell Bitmap und eine Ziel Bitmap einschließen. Unter [BitBLT](/windows/win32/api/wingdi/nf-wingdi-bitblt) im Windows SDK finden Sie eine Liste der Raster Vorgangs Codes für *dwrop* und deren Beschreibungen.

Eine umfassende Liste der Code für den Raster Betrieb finden Sie unter [Informationen zu Raster Vorgangs Codes](/windows/win32/gdi/raster-operation-codes) im Windows SDK.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Anwendung kann die Windows-oder Client Bereiche an Byte Begrenzungen ausrichten, um sicherzustellen, dass die `BitBlt` Vorgänge in Byte-ausgerichteten Rechtecke ausgeführt werden. (Legen Sie die CS_BYTEALIGNWINDOW-oder CS_BYTEALIGNCLIENT Flags fest, wenn Sie die Fenster Klassen registrieren.)

`BitBlt`Vorgänge an Byte ausgerichteten Rechtecke sind deutlich schneller als `BitBlt` Vorgänge in Rechtecke, die nicht Byte bündig sind. Wenn Sie Klassen Stile wie z. b. Byte Ausrichtung für Ihren eigenen Gerätekontext angeben möchten, müssen Sie eine Fenster Klasse registrieren, anstatt sich auf die Microsoft Foundation Classes zu verlassen, um dies für Sie zu tun. Verwenden Sie die globale Funktion [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

GDI transformiert *nwidth* und *nheight*, einmal mithilfe des Zielgeräte Kontexts und einmal mit dem Quell Gerätekontext. Wenn die resultierenden Blöcke nicht stimmen, verwendet GDI die Windows- `StretchBlt` Funktion, um die Quell Bitmap nach Bedarf zu komprimieren oder zu Strecken.

Wenn Ziel-, Quell-und Muster Bitmaps nicht das gleiche Farb Format aufweisen, `BitBlt` konvertiert die-Funktion die Quell-und Muster Bitmaps so, dass Sie mit dem Ziel übereinstimmen. Die Vordergrund-und Hintergrundfarben der Ziel Bitmap werden bei der Konvertierung verwendet.

Wenn die `BitBlt` Funktion eine monochrome Bitmap in eine Farbe konvertiert, legt Sie weiße Bits (1) auf die Hintergrundfarbe und schwarze Bits (0) auf die Vordergrundfarbe fest. Die Vordergrund-und Hintergrundfarben des Zielgeräte Kontexts werden verwendet. Wenn Sie Farbe in monochrome konvertieren möchten, `BitBlt` legt Pixel, die der Hintergrundfarbe entsprechen, auf weiß fest und legt alle anderen Pixel auf Schwarz fest. `BitBlt`verwendet die Vordergrund-und Hintergrundfarben des Farb Geräte Kontexts, um von der Farbe in den Monochrom zu konvertieren.

Beachten Sie, dass nicht alle Geräte Kontexte unterstützen `BitBlt` . Um zu überprüfen, ob ein bestimmter Gerätekontext unterstützt `BitBlt` , verwenden Sie die `GetDeviceCaps` -Element Funktion und geben den RasterCaps-Index an.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CDC:: kreatecompatibledc](#createcompatibledc).

## <a name="cdccdc"></a><a name="cdc"></a>CDC:: CDC

Erstellt ein `CDC`-Objekt.

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>CDC:: Chord

Zeichnet einen Akkord (eine geschlossene Abbildung, die durch die Schnittmenge einer Ellipse und eines Linien Segments begrenzt ist).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des umgebenden Rechtecks (in logischen Einheiten) des Rechtecks an.

*Y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des Begrenzungs Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des umgebenden Rechtecks des Akkords (in logischen Einheiten) an.

*Y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umgebenden Rechtecks des Akkords (in logischen Einheiten) an.

*x3*<br/>
Gibt die x-Koordinate des Punkts an, der den Anfangspunkt des akkorders definiert (in logischen Einheiten).

*Y3*<br/>
Gibt die y-Koordinate des Punkts an, der den Anfangspunkt des akkorders definiert (in logischen Einheiten).

*x4*<br/>
Gibt die x-Koordinate des Punkts an, der den Endpunkt des akkorders definiert (in logischen Einheiten).

*Y4*<br/>
Gibt die y-Koordinate des Punkts an, der den Endpunkt des akkorders definiert (in logischen Einheiten).

*lprect*<br/>
Gibt das umgebende Rechteck an (in logischen Einheiten). Sie können entweder ein lprect-oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt für diesen Parameter übergeben.

*ptstart*<br/>
Gibt die x-und y-Koordinaten des Punkts an, der den Anfangspunkt des akkorders definiert (in logischen Einheiten). Dieser Punkt muss nicht genau auf dem Akkord liegen. Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

*ptend*<br/>
Gibt die x-und y-Koordinaten des Punkts an, der den Endpunkt des-Endpunkts (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau auf dem Akkord liegen. Sie können entweder eine [Punkt](/windows/win32/api/windef/ns-windef-point) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) -Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Parameter ( *x1*, *Y1*) und ( *x2*, *Y2*) geben die oberen linken und unteren rechten Ecken eines Rechtecks an, das die Ellipse, die Teil des Rechtecks ist, umgebenden. Mit den Parametern ( *X3*, *Y3*) und ( *X4*, *Y4*) werden die Endpunkte einer Zeile angegeben, die die Ellipse überschneidet. Der Akkord wird mithilfe des ausgewählten Stifts gezeichnet und mithilfe des ausgewählten Pinsels aufgefüllt.

Die von der-Funktion gezeichnete Abbildung `Chord` erstreckt sich auf, aber schließt nicht die Rechte und unteren Koordinaten ein. Dies bedeutet, dass die Höhe der Abbildung *Y2*  -  *Y1* und die Breite der Abbildung *x2*  -  *x1*ist.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>CDC:: CloseFigure

Schließt eine geöffnete Figur in einem Pfad.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die-Funktion schließt die Figur, indem eine Linie von der aktuellen Position bis zum ersten Punkt der Abbildung gezeichnet wird (in der Regel der durch den letzten Rückruf der `MoveTo` Member-Funktion angegebene Punkt) und die Zeilen mithilfe der linienjoinart verbunden werden. Wenn eine Abbildung mithilfe der `LineTo` Member-Funktion anstelle von geschlossen wird `CloseFigure` , werden End-Caps zum Erstellen der Ecke anstelle eines Joins verwendet. `CloseFigure`sollte nur aufgerufen werden, wenn im Gerätekontext eine öffnende Pfad Klammer vorhanden ist.

Eine Figur in einem Pfad ist geöffnet, es sei denn, Sie wird mit dieser Funktion explizit geschlossen. (Eine Abbildung kann auch dann geöffnet sein, wenn der aktuelle Punkt und der Anfangspunkt der Abbildung identisch sind.) Alle Zeilen oder Kurven, die dem Pfad hinzugefügt werden, nachdem `CloseFigure` eine neue Abbildung gestartet hat.

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>CDC:: kreatecompatibledc

Erstellt einen Arbeitsspeicher-Gerätekontext, der mit dem durch *PDC*angegebenen Gerät kompatibel ist.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parameter

*PDC*<br/>
Ein Zeiger zu einem Gerätekontext. Wenn *PDC* NULL ist, erstellt die-Funktion einen Speichergeräte Kontext, der mit der System Anzeige kompatibel ist.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Ein Speichergeräte Kontext ist ein Speicherblock, der eine Anzeige Oberfläche darstellt. Sie kann verwendet werden, um Images im Speicher vorzubereiten, bevor Sie auf die tatsächliche Geräteoberfläche des kompatiblen Geräts kopiert werden.

Wenn ein Speichergeräte Kontext erstellt wird, wählt GDI automatisch eine 1-bis-1-monochrome-Bestands Bitmap für die Datei aus. GDI-Ausgabefunktionen können nur mit einem Speichergeräte Kontext verwendet werden, wenn eine Bitmap erstellt und in diesem Kontext ausgewählt wurde.

Diese Funktion kann nur verwendet werden, um kompatible Geräte Kontexte für Geräte zu erstellen, die Raster Vorgänge unterstützen. Informationen zu Bitblock Übertragungen zwischen Geräte Kontexten finden Sie unter der [CDC:: BitBLT](#bitblt) -Member-Funktion. Informationen dazu, ob ein Gerätekontext Raster Vorgänge unterstützt, finden Sie in der RC_BITBLT Rasterfunktion in der Member-Funktion `CDC::GetDeviceCaps` .

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>CDC:: kreatedc

Erstellt einen Gerätekontext für das angegebene Gerät.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parameter

*lpszdrivername*<br/>
Verweist auf eine mit NULL endenden Zeichenfolge, die den Dateinamen (ohne Erweiterung) des Gerätetreibers (z. b. "Epson") angibt. Sie können auch ein- `CString` Objekt für diesen Parameter übergeben.

*lpszdevicename*<br/>
Verweist auf eine auf NULL endende Zeichenfolge, die den Namen des zu unterstützten Geräts angibt (z. b. "Epson FX-80"). Der *lpszdevicename* -Parameter wird verwendet, wenn das Modul mehr als ein Gerät unterstützt. Sie können auch ein- `CString` Objekt für diesen Parameter übergeben.

*lpszoutput*<br/>
Verweist auf eine auf NULL endenden Zeichenfolge, die die Datei oder den Gerätenamen für das physische Ausgabe Medium (Datei-oder Ausgabeport) angibt. Sie können auch ein- `CString` Objekt für diesen Parameter übergeben.

*lpinitdata*<br/>
Verweist auf eine- `DEVMODE` Struktur, die gerätespezifische Initialisierungs Daten für den Gerätetreiber enthält. Die Windows- `DocumentProperties` Funktion ruft diese-Struktur ab, die für ein bestimmtes Gerät ausgefüllt ist. Der *lpinitdata* -Parameter muss NULL sein, wenn der Gerätetreiber die Standard Initialisierung (sofern vorhanden) verwenden soll, die vom Benutzer über die Systemsteuerung angegeben wird.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Druck. Die H-Header Datei ist erforderlich, wenn die [DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea) -Struktur verwendet wird.

Gerätenamen entsprechen den folgenden Konventionen: ein enddoppel Punkt (:) wird empfohlen, ist aber optional. Windows entfernt den abschließenden Doppelpunkt, sodass ein Gerätename, der mit einem Doppelpunkt endet, demselben Port wie der gleiche Name ohne Doppelpunkt zugeordnet wird. Die Treiber-und Port Namen dürfen keine führenden oder nachfolgenden Leerzeichen enthalten. GDI-Ausgabefunktionen können nicht mit Informations Kontexten verwendet werden.

## <a name="cdccreateic"></a><a name="createic"></a>CDC:: kreateic

Erstellt einen Informations Kontext für das angegebene Gerät.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parameter

*lpszdrivername*<br/>
Verweist auf eine mit NULL endenden Zeichenfolge, die den Dateinamen (ohne Erweiterung) des Gerätetreibers (z. b. "Epson") angibt. Sie können ein- `CString` Objekt für diesen Parameter übergeben.

*lpszdevicename*<br/>
Verweist auf eine auf NULL endende Zeichenfolge, die den Namen des zu unterstützten Geräts angibt (z. b. "Epson FX-80"). Der *lpszdevicename* -Parameter wird verwendet, wenn das Modul mehr als ein Gerät unterstützt. Sie können ein- `CString` Objekt für diesen Parameter übergeben.

*lpszoutput*<br/>
Verweist auf eine mit NULL endenden Zeichenfolge, die den Datei-oder Gerätenamen für das physische Ausgabe Medium (Datei oder Port) angibt. Sie können ein- `CString` Objekt für diesen Parameter übergeben.

*lpinitdata*<br/>
Zeigt auf gerätespezifische Initialisierungs Daten für den Gerätetreiber. Der *lpinitdata* -Parameter muss NULL sein, wenn der Gerätetreiber die Standard Initialisierung (sofern vorhanden) verwenden soll, die vom Benutzer über die Systemsteuerung angegeben wird. `CreateDC`Das Datenformat für die gerätespezifische Initialisierung finden Sie unter.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Bemerkungen

Der Informations Kontext bietet eine schnelle Möglichkeit, Informationen über das Gerät zu erhalten, ohne einen Gerätekontext zu erstellen.

Gerätenamen entsprechen den folgenden Konventionen: ein enddoppel Punkt (:) wird empfohlen, ist aber optional. Windows entfernt den abschließenden Doppelpunkt, sodass ein Gerätename, der mit einem Doppelpunkt endet, demselben Port wie der gleiche Name ohne Doppelpunkt zugeordnet wird. Die Treiber-und Port Namen dürfen keine führenden oder nachfolgenden Leerzeichen enthalten. GDI-Ausgabefunktionen können nicht mit Informations Kontexten verwendet werden.

## <a name="cdcdeletedc"></a><a name="deletedc"></a>CDC::D eletedc

Im allgemeinen dürfen Sie diese Funktion nicht aufzurufen. der Dekonstruktor führt dies für Sie aus.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn die Funktion erfolgreich abgeschlossen wurde. andernfalls 0.

### <a name="remarks"></a>Bemerkungen

`DeleteDC`Mit der Member-Funktion werden die Windows-Geräte Kontexte gelöscht, die `m_hDC` im aktuellen-Objekt zugeordnet sind `CDC` . Wenn dieses `CDC` Objekt der letzte aktive Gerätekontext für ein bestimmtes Gerät ist, wird das Gerät benachrichtigt, und alle vom Gerät verwendeten Speicher-und Systemressourcen werden freigegeben.

Eine Anwendung sollte nicht aufgerufen `DeleteDC` werden, wenn Objekte im Gerätekontext ausgewählt wurden. Vor dem löschen müssen Objekte zuerst aus dem Gerätekontext ausgewählt werden.

Eine Anwendung darf keinen Gerätekontext löschen, dessen Handle durch Aufrufen von [CWnd:: GetDC](../../mfc/reference/cwnd-class.md#getdc)abgerufen wurde. Stattdessen muss [CWnd:: ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) aufgerufen werden, um den Gerätekontext freizugeben. Die Klassen [CClientDC](../../mfc/reference/cclientdc-class.md) und [cwindowdc](../../mfc/reference/cwindowdc-class.md) werden bereitgestellt, um diese Funktionalität zu verpacken.

Die- `DeleteDC` Funktion wird im Allgemeinen verwendet, um Geräte Kontexte zu löschen, die mit " [kreatedc](#createdc)", " [kreateic](#createic)" oder "erstellen" erstellt wurden. [CreateCompatibleDC](#createcompatibledc)

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CPrintDialog:: getPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>CDC::D eletetempmap

Wird automatisch vom `CWinApp` Leerlaufzeit Handler aufgerufen und `DeleteTempMap` Löscht alle temporären `CDC` Objekte, die von erstellt `FromHandle` werden. die Gerätekontext Handles, die `hDC` den Objekten vorübergehend zugeordnet sind, werden jedoch nicht zerstört `CDC` .

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>CDC::D Etach

Diese Funktion wird aufgerufen, um `m_hDC` (den Ausgabegeräte Kontext) vom- `CDC` Objekt zu trennen und sowohl `m_hDC` als auch `m_hAttribDC` auf NULL festzulegen.

```
HDC Detach();
```

### <a name="return-value"></a>Rückgabewert

Ein Windows-Gerätekontext.

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>CDC::D ptohimetric

Verwenden Sie diese Funktion, wenn Sie die himetrikgrößen an OLE übergeben und Pixel in HIMETRIC umrechnen.

```cpp
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpsize*<br/>
Verweist auf eine [Größen](/windows/win32/api/windef/ns-windef-size) Struktur oder ein [CSize](../../atl-mfc-shared/reference/csize-class.md) -Objekt.

### <a name="remarks"></a>Bemerkungen

Wenn der Kartenmodus des Gerätekontext Objekts MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC oder MM_HIMETRIC ist, basiert die Konvertierung auf der Anzahl der Pixel im physischen Zoll. Wenn der Kartenmodus einem der anderen nicht eingeschränkten Modi entspricht (z. b. MM_TEXT), basiert die Konvertierung auf der Anzahl der Pixel im logischen Zoll.

## <a name="cdcdptolp"></a><a name="dptolp"></a>CDC::D ptolp

Konvertiert Geräte Einheiten in logische Einheiten.

```cpp
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von [Punkt](/windows/win32/api/windef/ns-windef-point) Strukturen oder [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) -Objekten.

*nCount*<br/>
Die Anzahl der Punkte im Array.

*lprect*<br/>
Verweist auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt. Dieser Parameter wird für die einfache Verwendung eines Rechtecks von gerätepunkten zu logischen Punkten verwendet.

*lpsize*<br/>
Verweist auf eine [Größen](/windows/win32/api/windef/ns-windef-size) Struktur oder ein [CSize](../../atl-mfc-shared/reference/csize-class.md) -Objekt.

### <a name="remarks"></a>Bemerkungen

Die-Funktion ordnet die Koordinaten jedes Punkts oder der Dimension einer Größe vom Geräte Koordinatensystem in das logische Koordinatensystem von GDI auf. Die Konvertierung hängt vom aktuellen Mapping-Modus und den Einstellungen der Ursprünge und Blöcke für das Fenster und den Viewport des Geräts ab.

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>CDC::D raw3drect

Diese Member-Funktion aufrufen, um ein dreidimensionales Rechteck zu zeichnen.

```cpp
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Gibt das umgebende Rechteck an (in logischen Einheiten). Sie können entweder einen Zeiger auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt für diesen Parameter übergeben.

*clrtopleft*<br/>
Gibt die Farbe des oberen und linken Rands des dreidimensionalen Rechtecks an.

*clrbottomright*<br/>
Gibt die Farbe der unteren und rechten Seite des dreidimensionalen Rechtecks an.

*x*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des dreidimensionalen Rechtecks an.

*Teenie*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des dreidimensionalen Rechtecks an.

*verschoben*<br/>
Gibt die Breite des dreidimensionalen Rechtecks an.

*CY*<br/>
Gibt die Höhe des dreidimensionalen Rechtecks an.

### <a name="remarks"></a>Bemerkungen

Das Rechteck wird mit der oberen und linken Seite in der durch *clrtopleft* angegebenen Farbe und der unteren und rechten Seite in der durch *clrbottomright*angegebenen Farbe gezeichnet.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>CDC::D rawdragrect

Diese Member-Funktion wird wiederholt aufgerufen, um ein Zieh Rechteck neu zu zeichnen.

```cpp
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Verweist auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das die logischen Koordinaten eines Rechtecks angibt – in diesem Fall die Endposition des Rechtecks, das neu gezeichnet wird.

*size*<br/>
Gibt die Verschiebung von der linken oberen Ecke des äußeren Rahmens zur linken oberen Ecke des inneren Rahmens (d. h. die Stärke des Rahmens) eines Rechtecks an.

*lprectlast*<br/>
Verweist auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das die logischen Koordinaten der Position eines Rechtecks angibt – in diesem Fall die ursprüngliche Position des Rechtecks, das neu gezeichnet wird.

*sizelast*<br/>
Gibt die Verschiebung von der linken oberen Ecke des äußeren Rahmens zur linken oberen Ecke des inneren Rahmens (d. h. die Stärke des Rahmens) des ursprünglichen Rechtecks an, das neu gezeichnet wird.

*pbrush*<br/>
Zeiger auf ein Pinsel Objekt. Legen Sie auf NULL fest, um den standardmäßigen halbftone-Pinsel zu verwenden.

*pbrushlast*<br/>
Zeiger auf das letzte verwendete Pinsel Objekt. Legen Sie auf NULL fest, um den standardmäßigen halbftone-Pinsel zu verwenden.

### <a name="remarks"></a>Bemerkungen

Nennen Sie es in einer Schleife, wenn Sie eine Stichprobe der Mausposition durchlaufen, um visuelles Feedback zu geben. Wenn Sie aufzurufen `DrawDragRect` , wird das vorherige Rechteck gelöscht und ein neues Rechteck gezeichnet. Wenn der Benutzer z. b. ein Rechteck auf dem Bildschirm zieht, `DrawDragRect` Löscht das ursprüngliche Rechteck und zeichnet es neu an seiner neuen Position. `DrawDragRect`In der Standardeinstellung zeichnet das Rechteck mithilfe eines Halbton-Pinsels, um Flimmern auszuschließen und das Aussehen eines reibungslos verschiebenden Rechtecks zu erstellen.

Wenn Sie zum ersten Mal aufrufen `DrawDragRect` , sollte der *lprectlast* -Parameter NULL sein.

## <a name="cdcdrawedge"></a><a name="drawedge"></a>CDC::D rakeil

Diese Member-Funktion aufrufen, um die Ränder eines Rechtecks vom angegebenen Typ und Stil zu zeichnen.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Ein Zeiger auf eine- `RECT` Struktur, die die logischen Koordinaten des Rechtecks enthält.

*mit Netz*<br/>
Gibt den Typ des inneren und äußeren Kanten an, der gezeichnet werden soll. Dieser Parameter muss eine Kombination aus einem inneren rahmenflag und einem äußeren Rahmen Flag sein. Eine Tabelle mit den Parametertypen finden Sie unter [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) in der Windows SDK.

*nFlags*<br/>
Die Flags, die den Typ des Rahmens angeben, der gezeichnet werden soll. `DrawEdge`Eine Tabelle mit den Werten des Parameters finden Sie unter in der Windows SDK. Bei diagonalen Linien geben die BF_RECT Flags den Endpunkt des Vektors an, der durch den Rechteck Parameter begrenzt ist.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

## <a name="cdcdrawescape"></a><a name="drawescape"></a>CDC::D rawescape

Greift auf Zeichnungsfunktionen einer Videoanzeige zu, die nicht direkt über die Graphics Device Interface (GDI) verfügbar sind.

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parameter

*Nescape*<br/>
Gibt die auszuführende Escape-Funktion an.

*ninputsize*<br/>
Gibt die Anzahl der Daten Bytes an, auf die durch den *lpszinputdata* -Parameter verwiesen wird.

*lpszinputdata*<br/>
Verweist auf die Eingabe Struktur, die für den angegebenen Escapezeichen erforderlich ist.

### <a name="return-value"></a>Rückgabewert

Gibt das Ergebnis der Funktion an. Größer als 0 (null), wenn erfolgreich, mit Ausnahme des Draw-Escapezeichens queryescsupport, das nur die Implementierung überprüft; oder 0 (null), wenn der Escape nicht implementiert ist. oder kleiner als 0 (null), wenn ein Fehler aufgetreten ist.

### <a name="remarks"></a>Bemerkungen

Wenn eine Anwendung aufruft `DrawEscape` , werden die von *ninputsize* und *lpszinputdata* identifizierten Daten direkt an den angegebenen Anzeigetreiber übergeben.

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>CDC::D rawfocrarect

Zeichnet ein Rechteck im Stil, mit dem angegeben wird, dass das Rechteck den Fokus besitzt.

```cpp
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Verweist auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das die logischen Koordinaten des Rechtecks angibt, das gezeichnet werden soll.

### <a name="remarks"></a>Bemerkungen

Da es sich hierbei um eine boolesche XOR-Funktion handelt, wird das Rechteck aus der Anzeige entfernt, wenn diese Funktion ein zweites Mal mit dem gleichen Rechteck aufgerufen wird. Das von dieser Funktion gezeichnete Rechteck kann nicht gescrollt werden. Um einen Bildlauf in einem Bereich durchführen zu können, der ein von dieser Funktion gezeichnetes Rechteck enthält, müssen Sie zunächst aufrufen, `DrawFocusRect` um das Rechteck aus der Anzeige zu entfernen `DrawFocusRect`

> [!CAUTION]
> `DrawFocusRect`funktioniert nur im MM_TEXT Modus. In anderen Modi zeichnet diese Funktion das Fokus Rechteck nicht ordnungsgemäß, aber es werden keine Fehler Werte zurückgegeben.

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>CDC::D rawframecontrol

Diese Member-Funktion aufrufen, um ein Frame-Steuerelement vom angegebenen Typ und Stil zu zeichnen.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Ein Zeiger auf eine- `RECT` Struktur, die die logischen Koordinaten des Rechtecks enthält.

*nType*<br/>
Gibt den Typ des zu zeichnenden Frame Steuer Elements an. Eine Liste mit den möglichen Werten dieses Parameters finden Sie unter der *uType* -Parameter in [drawframecontrol](/windows/win32/api/winuser/nf-winuser-drawframecontrol) in der Windows SDK.

*nstatusinformationen*<br/>
Gibt den Ausgangszustand des Frame-Steuer Elements an. Kann mindestens einer der Werte sein, die für den *ustate* -Parameter in `DrawFrameControl` in der Windows SDK beschrieben werden. Verwenden Sie den Wert DFCS_ADJUSTRECT *nState* , um das umschließende Rechteck so anzupassen, dass der umgebende Rand der Schaltfläche "Push" ausgeschlossen wird.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Bemerkungen

In mehreren Fällen hängt *nState* vom *nType* -Parameter ab. In der folgenden Liste wird die Beziehung zwischen den vier *nType* -Werten und *nState*angezeigt:

- DFC_BUTTON

  - DFCS_BUTTON3STATE Schaltfläche mit drei Zuständen

  - Kontrollkästchen DFCS_BUTTONCHECK

  - Schaltfläche "DFCS_BUTTONPUSH"

  - Optionsfeld "DFCS_BUTTONRADIO"

  - DFCS_BUTTONRADIOIMAGE Bild für Optionsfeld (Bild der nicht quadratischen Anforderungen)

  - DFCS_BUTTONRADIOMASK Maske für Optionsfeld (keine quadratische Bedarfs Maske)

- DFC_CAPTION

  - Schaltfläche zum DFCS_CAPTIONCLOSE schließen

  - Hilfe Schaltfläche DFCS_CAPTIONHELP

  - Schaltfläche "maximieren DFCS_CAPTIONMAX

  - DFCS_CAPTIONMIN minimieren

  - DFCS_CAPTIONRESTORE Restore

- DFC_MENU

  - DFCS_MENUARROW unter Menü Pfeil

  - DFCS_MENUBULLET Kugel

  - DFCS_MENUCHECK Häkchen

- DFC_SCROLL

  - Bild Lauf Leiste für DFCS_SCROLLCOMBOBOX-Kombinations Feld

  - DFCS_SCROLLDOWN Pfeil nach unten in der Scrollleiste

  - DFCS_SCROLLLEFT Pfeil nach links der Scrollleiste

  - DFCS_SCROLLRIGHT Pfeil nach rechts in der Scrollleiste

  - DFCS_SCROLLSIZEGRIP Größen Zieh Punkt in der unteren rechten Ecke des Fensters

  - DFCS_SCROLLUP Pfeil nach oben in der Scrollleiste

### <a name="example"></a>Beispiel

Dieser Code zeichnet den Größen Zieh Punkt in der unteren rechten Ecke des Fensters. Er eignet sich für den `OnPaint` Handler eines Dialog Felds, das keine Stile hat und normalerweise keine anderen Steuerelemente (z. b. eine Statusleiste) enthält, die ihm einen Größen Zieh Punkt zur Verfügung stellen können.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>CDC::D rawicon

Zeichnet ein Symbol auf dem Gerät, das durch das aktuelle-Objekt dargestellt wird `CDC` .

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Symbols an.

*Teenie*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Symbols an.

*hIcon*<br/>
Identifiziert das Handle des Symbols, das gezeichnet werden soll.

*Punkt*<br/>
Gibt die logischen x-und y-Koordinaten der oberen linken Ecke des Symbols an. Sie können eine [Punkt](/windows/win32/api/windef/ns-windef-point) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) -Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn die Funktion erfolgreich abgeschlossen wurde. andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Die-Funktion platziert die linke obere Ecke des Symbols an der von *x* und *y*angegebenen Position. Der Speicherort unterliegt dem aktuellen Kartenmodus des Geräte Kontexts.

Die Symbol Ressource muss zuvor mithilfe der Funktionen, oder geladen worden `CWinApp::LoadIcon` sein `CWinApp::LoadStandardIcon` `CWinApp::LoadOEMIcon` . Der Zuordnungs `MM_TEXT` Modus muss vor der Verwendung dieser Funktion ausgewählt werden.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CWnd:: ISIC](../../mfc/reference/cwnd-class.md#isiconic).

## <a name="cdcdrawstate"></a><a name="drawstate"></a>CDC::D rawstate

Mit dieser Member-Funktion können Sie ein Bild anzeigen und einen visuellen Effekt anwenden, um einen Zustand anzugeben, z. b. einen deaktivierten oder einen Standardzustand.

> [!NOTE]
> Für alle *nflag* -Zustände außer DSS_NORMAL wird das Bild vor dem Anwenden des visuellen Effekts in monochrome konvertiert.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parameter

*PT*<br/>
Gibt den Speicherort des Bilds an.

*size*<br/>
Gibt die Größe des Bilds an.

*HBITMAP*<br/>
Ein Handle für eine Bitmap.

*nFlags*<br/>
Flags, die den Bildtyp und-Zustand angeben. Informationen zu den möglichen *nFlags* -Typen und-Zuständen finden Sie unter [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) in der Windows SDK.

*hBrush*<br/>
Ein Handle für einen Pinsel.

*pbitmap*<br/>
Ein Zeiger auf ein CBitmap-Objekt.

*pbrush*<br/>
Ein Zeiger auf ein CBrush-Objekt.

*hIcon*<br/>
Ein Handle für ein Symbol.

*lpszText*<br/>
Ein Zeiger auf Text.

*bprefixtext*<br/>
Text, der möglicherweise eine Zugriffstaste enthält. Der *ldata* -Parameter gibt die Adresse der Zeichenfolge an, und der *ntextlen* -Parameter gibt die Länge an. Wenn *ntextlen* 0 ist, wird angenommen, dass die Zeichenfolge mit NULL endet.

*ntextlen*<br/>
Länge der Text Zeichenfolge, auf die von *lpszText*verwiesen wird. Wenn *ntextlen* 0 ist, wird angenommen, dass die Zeichenfolge mit NULL endet.

*lpdrawproc*<br/>
Ein Zeiger auf eine Rückruffunktion, die zum Rendering eines Bilds verwendet wird. Dieser Parameter ist erforderlich, wenn der Bildtyp in *nFlags* DST_COMPLEX ist. Sie ist optional und kann NULL sein, wenn der Bildtyp DST_TEXT ist. Für alle anderen Bildtypen wird dieser Parameter ignoriert. Weitere Informationen zur Rückruffunktion finden Sie unter der [drawstateproc](/windows/win32/api/winuser/nc-winuser-drawstateproc) -Funktion in der Windows SDK.

*ldata*<br/>
Gibt Informationen zum Bild an. Die Bedeutung dieses Parameters hängt vom Bildtyp ab.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

## <a name="cdcdrawtext"></a><a name="drawtext"></a>CDC::D rawtext

Diese Member-Funktion zum Formatieren von Text im angegebenen Rechteck aufzurufen. Verwenden Sie zum Angeben zusätzlicher Formatierungsoptionen [CDC::D rawtextex](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parameter

*lpszstring*<br/>
Verweist auf die Zeichenfolge, die gezeichnet werden soll. Wenn *nCount* den Wert-1 hat, muss die Zeichenfolge mit Null beendet werden.

*nCount*<br/>
Gibt die Anzahl der Zeichen in der Zeichenfolge an. Wenn *nCount* den Wert-1 hat, wird angenommen, dass *lpszstring* ein langer Zeiger auf eine mit NULL endende Zeichenfolge ist, und `DrawText` die Zeichen Anzahl wird automatisch berechnet.

*lprect*<br/>
Verweist auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das das Rechteck (in logischen Koordinaten) enthält, in dem der Text formatiert werden soll.

*str*<br/>
Ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt, das die angegebenen Zeichen enthält, die gezeichnet werden sollen.

*nformat*<br/>
Gibt die Methode zum Formatieren des Texts an. Dabei kann es sich um eine beliebige Kombination der Werte handeln, die für den *Uformat* -Parameter in [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) in der Windows SDK beschrieben werden. (kombinieren Sie mit dem bitweisen OR-Operator):

> [!NOTE]
> Einige *uformatflag* -Kombinationen können bewirken, dass die übergebenen Zeichenfolge geändert wird. Wenn Sie DT_MODIFYSTRING mit DT_END_ELLIPSIS oder DT_PATH_ELLIPSIS verwenden, kann dies dazu führen, dass die Zeichenfolge geändert wird. Dies führt zu einer-Überschreibung `CString` . Die Werte DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP und DT_NOPREFIX können nicht mit dem DT_TABSTOP Wert verwendet werden.

### <a name="return-value"></a>Rückgabewert

Die Höhe des Texts, wenn die Funktion erfolgreich ausgeführt wurde.

### <a name="remarks"></a>Bemerkungen

Sie formatiert Text, indem er Tabstopps in entsprechende Leerzeichen einfügt, Text an der linken, rechten oder mittleren Stelle des angegebenen Rechtecks anpasst und Text in Linien umbricht, die in das angegebene Rechteck passen. Der Formatierungstyp wird durch *nformat*angegeben.

Diese Member-Funktion verwendet die ausgewählte Schriftart, Textfarbe und Hintergrundfarbe des Geräte Kontexts, um den Text zu zeichnen. Wenn das DT_NOCLIP-Format nicht verwendet wird, wird der Text von so formatiert, `DrawText` dass der Text nicht außerhalb des angegebenen Rechtecks angezeigt wird. Es wird davon ausgegangen, dass für alle Formatierungen mehrere Zeilen vorhanden sind, es sei denn, das DT_SINGLELINE Format

Wenn die ausgewählte Schriftart für das angegebene Rechteck zu groß ist, `DrawText` versucht die Member-Funktion nicht, eine kleinere Schriftart zu ersetzen.

Wenn das DT_CALCRECT-Flag angegeben ist, wird das von *lprect* angegebene Rechteck entsprechend der zum Zeichnen des Texts erforderlichen Breite und Höhe aktualisiert.

Wenn das TA_UPDATECP Text Ausrichtungs Kennzeichen festgelegt wurde (siehe [CDC:: setTextAlign](#settextalign)), `DrawText` zeigt den Text beginnend an der aktuellen Position an, nicht auf der linken Seite des angegebenen Rechtecks. `DrawText`schließt Text nicht ein, wenn das TA_UPDATECP-Flag festgelegt wurde (d. h., das DT_WORDBREAK-Flag hat keine Auswirkung).

Die Textfarbe kann von [CDC:: SetTextColor](#settextcolor)festgelegt werden.

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>CDC::D rawtextex

Formatiert Text im angegebenen Rechteck.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parameter

*lpszstring*<br/>
Verweist auf die Zeichenfolge, die gezeichnet werden soll. Wenn *nCount* den Wert-1 hat, muss die Zeichenfolge NULL sein.

*nCount*<br/>
Gibt die Anzahl der Zeichen in der Zeichenfolge an. Wenn *nCount* den Wert-1 hat, wird angenommen, dass *lpszstring* ein langer Zeiger auf eine mit NULL endende Zeichenfolge ist, und `DrawText` die Zeichen Anzahl wird automatisch berechnet.

*lprect*<br/>
Verweist auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das das Rechteck (in logischen Koordinaten) enthält, in dem der Text formatiert werden soll.

*str*<br/>
Ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt, das die angegebenen Zeichen enthält, die gezeichnet werden sollen.

*nformat*<br/>
Gibt die Methode zum Formatieren des Texts an. Dabei kann es sich um eine beliebige Kombination der Werte handeln, die für den *Uformat* -Parameter in [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) in der Windows SDK beschrieben werden. (Kombinieren Sie mit dem bitweisen **or** -Operator):

> [!NOTE]
> Einige *uformatflag* -Kombinationen können bewirken, dass die übergebenen Zeichenfolge geändert wird. Wenn Sie DT_MODIFYSTRING mit DT_END_ELLIPSIS oder DT_PATH_ELLIPSIS verwenden, kann dies dazu führen, dass die Zeichenfolge geändert wird. Dies führt zu einer-Überschreibung `CString` . Die Werte DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP und DT_NOPREFIX können nicht mit dem DT_TABSTOP Wert verwendet werden.

*lpdtparametriams*<br/>
Zeiger auf eine [drawtextparameams](/windows/win32/api/winuser/ns-winuser-drawtextparams) -Struktur, die zusätzliche Formatierungsoptionen angibt. Dieser Parameter kann NULL sein.

### <a name="remarks"></a>Bemerkungen

Sie formatiert Text, indem er Tabstopps in entsprechende Leerzeichen einfügt, Text an der linken, rechten oder mittleren Stelle des angegebenen Rechtecks anpasst und Text in Linien umbricht, die in das angegebene Rechteck passen. Der Formatierungstyp wird durch *nformat* und *lpdtparameterams*angegeben. Weitere Informationen finden Sie unter [CDC::D rawtext](#drawtext) und [drawtextex](/windows/win32/api/winuser/nf-winuser-drawtextexw) in der Windows SDK.

Die Textfarbe kann von [CDC:: SetTextColor](#settextcolor)festgelegt werden.

## <a name="cdcellipse"></a><a name="ellipse"></a>CDC:: Ellipse

Zeichnet eine Ellipse.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Begrenzungs Rechtecks der Ellipse an.

*Y1*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Begrenzungs Rechtecks der Ellipse an.

*x2*<br/>
Gibt die logische x-Koordinate der unteren rechten Ecke des umgebenden Rechtecks der Ellipse an.

*Y2*<br/>
Gibt die logische y-Koordinate der unteren rechten Ecke des umgebenden Rechtecks der Ellipse an.

*lprect*<br/>
Gibt das Begrenzungs Rechteck der Ellipse an. Sie können auch ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Mittelpunkt der Ellipse ist die Mitte des umgebenden Rechtecks, das von *x1*, *Y1*, *x2*, *Y2*oder *lprect*angegeben wird. Die Ellipse wird mit dem aktuellen Stift gezeichnet, und das Innere ist mit dem aktuellen Pinsel gefüllt.

Die von dieser Funktion gezeichnete Abbildung erweitert die Rechte-und untere Koordinaten, aber schließt Sie nicht ein. Dies bedeutet, dass die Höhe der Abbildung *Y2*  -  *Y1* und die Breite der Abbildung *x2*  -  *x1*ist.

Wenn die Breite oder die Höhe des umgebenden Rechtecks 0 ist, wird keine Ellipse gezeichnet.

## <a name="cdcenddoc"></a><a name="enddoc"></a>CDC:: EndDoc

Beendet einen Druckauftrag, der durch einen Aufrufen der [StartDoc](#startdoc) -Member-Funktion gestartet wurde.

```
int EndDoc();
```

### <a name="return-value"></a>Rückgabewert

Größer oder gleich 0 (null), wenn die Funktion erfolgreich ist, oder ein negativer Wert, wenn ein Fehler aufgetreten ist.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion ersetzt den EndDoc-druckerescapezeichen und sollte unmittelbar nach Abschluss eines erfolgreichen Druckauftrags aufgerufen werden.

Wenn eine Anwendung auf einen Druckfehler oder einen abgebrochenen Druckvorgang stößt, darf Sie nicht versuchen, den Vorgang mit `EndDoc` oder [abortdoc](#abortdoc)zu beenden. GDI beendet den Vorgang automatisch, bevor der Fehlerwert zurückgegeben wird.

Diese Funktion sollte nicht innerhalb von Metafiles verwendet werden.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CDC:: StartDoc](#startdoc).

## <a name="cdcendpage"></a><a name="endpage"></a>CDC:: EndPage

Informiert das Gerät darüber, dass die Anwendung das Schreiben auf eine Seite abgeschlossen hat.

```
int EndPage();
```

### <a name="return-value"></a>Rückgabewert

Größer oder gleich 0 (null), wenn die Funktion erfolgreich ist, oder ein negativer Wert, wenn ein Fehler aufgetreten ist.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion wird in der Regel verwendet, um den Gerätetreiber anzuweisen, eine neue Seite zu verwenden.

Diese Member-Funktion ersetzt den newframe-Drucker Escapezeichen. Im Gegensatz zu newframe wird diese Funktion immer nach dem Drucken einer Seite aufgerufen.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CDC:: StartDoc](#startdoc).

## <a name="cdcendpath"></a><a name="endpath"></a>CDC:: endpath

Schließt eine Pfad Klammer und wählt den von der Klammer definierten Pfad in den Gerätekontext aus.

```
BOOL EndPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="example"></a>Beispiel

  Sehen Sie sich das Beispiel für [CDC:: beginpath](#beginpath)an.

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>CDC:: umumujects

Listet die Stifte und Pinsel auf, die in einem Gerätekontext verfügbar sind.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parameter

*nobjecttype*<br/>
Gibt den Objekttyp an. Die Werte können OBJ_BRUSH oder OBJ_PEN sein.

*lpfn*<br/>
Die Prozedur-instanzadresse der von der Anwendung bereitgestellten Rückruffunktion. Weitere Informationen finden Sie im Abschnitt "Hinweise" weiter unten.

*lpdata*<br/>
Verweist auf die von der Anwendung bereitgestellten Daten. Die Daten werden zusammen mit den Objektinformationen an die Rückruffunktion weitergegeben.

### <a name="return-value"></a>Rückgabewert

Gibt den letzten von der [Rückruffunktion](callback-functions-used-by-mfc.md#enum_objects)zurückgegebenen Wert an. Seine Bedeutung ist Benutzer definiert.

### <a name="remarks"></a>Bemerkungen

Für jedes Objekt eines bestimmten Typs wird die Rückruffunktion, die Sie übergeben, mit den Informationen für dieses Objekt aufgerufen. Das System ruft die Rückruffunktion auf, bis keine Objekte mehr vorhanden sind oder die Rückruffunktion 0 zurückgibt.

Beachten Sie, dass Sie mit den neuen Funktionen von Microsoft Visual C++ eine gewöhnliche Funktion als Funktion verwenden können, die an übergeben wird `EnumObjects` . Die an übergebenen Adresse `EnumObjects` ist ein Zeiger auf eine Funktion, die mit **Export** und mit der Pascal-Aufruf Konvention exportiert wird. In Anwendungen im Schutzmodus müssen Sie diese Funktion nicht mit der Windows MakeProcInstance-Funktion erstellen oder die Funktion nach der Verwendung mit der freeprocinstance-Windows-Funktion freigeben.

Sie müssen den Funktionsnamen auch nicht in eine **Exports** -Anweisung in der Modul Definitionsdatei Ihrer Anwendung exportieren. Stattdessen können Sie den **Export** funktionsmodifizierer wie in verwenden.

**int-Rückruf Export** Afunction **(LPSTR**, **LPSTR);**

, wenn der Compiler bewirkt, dass der richtige Exportdaten Satz für den Export nach Namen ohne Aliasing ausgegeben wird. Dies funktioniert für die meisten Anforderungen. Für einige Sonderfälle, z. b. das Exportieren einer Funktion durch Ordinalzahl oder Aliasing des Exports, müssen Sie dennoch eine **Exports** -Anweisung in einer Modul Definitionsdatei verwenden.

Zum Kompilieren von Microsoft Foundation-Programmen verwenden Sie normalerweise die Compileroptionen/GA und/GEs. Die/GW-Compileroption wird nicht mit den Microsoft Foundation-Klassen verwendet. (Wenn Sie die Windows-Funktion verwenden `MakeProcInstance` , müssen Sie den zurückgegebenen Funktionszeiger explizit von FARPROC in den in dieser API benötigten Typ umwandeln.) Rückruf Registrierungs Schnittstellen sind nun typsicher (Sie müssen einen Funktionszeiger übergeben, der auf die richtige Funktionsart für den jeweiligen Rückruf zeigt).

Beachten Sie außerdem, dass alle Rückruf Funktionen Microsoft Foundation-Ausnahmen vor der Rückgabe an Windows abfangen müssen, da Ausnahmen nicht über Rückruf Grenzen hinweg ausgelöst werden können. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>CDC:: Escape

Diese Member-Funktion ist für die Win32-Programmierung praktisch veraltet.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parameter

*Nescape*<br/>
Gibt die auszuführende Escape-Funktion an.

Eine umfassende Liste der escapefunktionen finden Sie unter [Escape](/windows/win32/api/wingdi/nf-wingdi-escape) in der Windows SDK.

*nCount*<br/>
Gibt die Anzahl der Daten Bytes an, auf die *lpszindata*verweist.

*lpszindata*<br/>
Zeigt auf die für diesen Escape erforderliche Eingabedaten Struktur.

*lpoutdata*<br/>
Verweist auf die-Struktur, die die Ausgabe von diesem Escapezeichen empfangen soll. Der *lpoutdata* -Parameter ist NULL, wenn keine Daten zurückgegeben werden.

*ninputsize*<br/>
Gibt die Anzahl der Daten Bytes an, auf die durch den *lpszinputdata* -Parameter verwiesen wird.

*lpszinputdata*<br/>
Verweist auf die Eingabe Struktur, die für den angegebenen Escapezeichen erforderlich ist.

*noutputsize*<br/>
Gibt die Anzahl der Daten Bytes an, auf die durch den *lpszoutputdata* -Parameter verwiesen wird.

*lpszoutputdata*<br/>
Verweist auf die-Struktur, die die Ausgabe von diesem Escapezeichen empfängt. Dieser Parameter sollte NULL sein, wenn keine Daten zurückgegeben werden.

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, wird ein positiver Wert zurückgegeben, mit Ausnahme der queryescsupport-Escapesequenz, die nur die Implementierung überprüft. NULL wird zurückgegeben, wenn der Escape nicht implementiert ist. Wenn ein Fehler aufgetreten ist, wird ein negativer Wert zurückgegeben. Im folgenden sind häufige Fehler Werte aufgeführt:

- Allgemeiner Fehler SP_ERROR.

- SP_OUTOFDISK nicht genügend Speicherplatz zum Spoolvorgang verfügbar, und es wird kein Speicherplatz mehr verfügbar.

- SP_OUTOFMEMORY nicht genügend Arbeitsspeicher zum Spoolvorgang verfügbar.

- SP_USERABORT Benutzer den Auftrag über den Druck-Manager beendet hat.

### <a name="remarks"></a>Bemerkungen

Von den ursprünglichen Drucker Escapezeichen wird nur queryescsupport für Win32-Anwendungen unterstützt. Alle anderen Drucker Escapezeichen sind veraltet und werden nur aus Gründen der Kompatibilität mit 16-Bit-Anwendungen unterstützt.

Für die Win32-Programmierung `CDC` stellt nun sechs Element Funktionen bereit, die ihre entsprechenden Drucker Escapezeichen ersetzen:

- [CDC:: abortdoc](#abortdoc)

- [CDC:: EndDoc](#enddoc)

- [CDC:: EndPage](#endpage)

- [CDC:: abtabortproc](#setabortproc)

- [CDC:: StartDoc](#startdoc)

- [CDC:: Startpage](#startpage)

Außerdem unterstützt [CDC:: GetDeviceCaps](#getdevicecaps) Win32-Indizes, die andere Drucker Escapezeichen ablösen. Weitere Informationen finden Sie unter [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) im Windows SDK.

Diese mitgliederfunktion ermöglicht Anwendungen den Zugriff auf Funktionen eines bestimmten Geräts, die nicht direkt über GDI verfügbar sind.

Verwenden Sie die erste Version, wenn die Anwendung vordefinierte Escapewerte verwendet. Verwenden Sie die zweite Version, wenn Ihre Anwendung private Escapewerte definiert. Weitere Informationen zur zweiten Version finden Sie unter [extescape](/windows/win32/api/wingdi/nf-wingdi-extescape) im Windows SDK.

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>CDC:: excludebug

Erstellt einen neuen Clippingbereich, der aus dem vorhandenen Clippingbereich abzüglich des angegebenen Rechtecks besteht.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Rechtecks an.

*Y1*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks an.

*x2*<br/>
Gibt die logische x-Koordinate der unteren rechten Ecke des Rechtecks an.

*Y2*<br/>
Gibt die logische y-Koordinate der unteren rechten Ecke des Rechtecks an.

*lprect*<br/>
Gibt das Rechteck an. Kann auch ein- `CRect` Objekt sein.

### <a name="return-value"></a>Rückgabewert

Gibt den Typ des neuen Clippingbereichs an. Dabei kann es sich um einen der folgenden Werte handeln:

- Complexregion der Bereich weist überlappende Rahmen auf.

- Fehler: Es wurde keine Region erstellt.

- NULLREGION der Bereich ist leer.

- Simpleregion der Bereich weist keine überlappenden Rahmen auf.

### <a name="remarks"></a>Bemerkungen

Die Breite des Rechtecks, das durch den absoluten Wert von *x2*  -  *x1*angegeben wird, darf 32.767 Einheiten nicht überschreiten. Dieser Grenzwert gilt auch für die Höhe des Rechtecks.

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>CDC:: excluentupdatergn

Verhindert, dass innerhalb von ungültigen Bereichen eines Fensters gezeichnet wird, indem ein aktualisierter Bereich im Fenster von dem dem-Objekt zugeordneten Clippingbereich ausgeschlossen wird `CDC` .

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parameter

*folgenden*<br/>
Verweist auf das Fenster Objekt, dessen Fenster aktualisiert wird.

### <a name="return-value"></a>Rückgabewert

Der Typ des ausgeschlossenen Bereichs. Es kann sich um einen der folgenden Werte handeln:

- Complexregion der Bereich weist überlappende Rahmen auf.

- Fehler: Es wurde keine Region erstellt.

- NULLREGION der Bereich ist leer.

- Simpleregion der Bereich weist keine überlappenden Rahmen auf.

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>CDC:: extflufill

Füllt einen Bereich der Anzeige Oberfläche mit dem aktuellen Pinsel.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate des Punkts an, an dem mit dem Auffüllen begonnen wird.

*Teenie*<br/>
Gibt die logische y-Koordinate des Punkts an, an dem mit dem Ausfüllen begonnen wird.

*crcolor*<br/>
Gibt die Farbe der Grenze oder des Bereichs an, der ausgefüllt werden soll. Die Interpretation von *crcolor* hängt vom Wert von *nfilltype*ab.

*nfilltype*<br/>
Gibt den Typ des auszuführenden Überflutungs Füllungs Füllvorgangs an. Es muss sich um einen der folgenden Werte handeln:

- Flufillborder der Füllbereich wird durch die durch *crcolor*angegebene Farbe begrenzt. Dieser Stil ist mit der von ausgeführten Füllung identisch `FloodFill` .

- Flufillsurface der Füllbereich wird durch die durch *crcolor*angegebene Farbe definiert. Das Auffüllen wird in allen Richtungen nach außen fortgesetzt, solange die Farbe erreicht ist. Dieser Stil eignet sich zum Auffüllen von Bereichen mit mehrfarbigen Grenzen.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn die Funktion erfolgreich ist. andernfalls 0, wenn der Füllvorgang nicht abgeschlossen werden konnte,, wenn der angegebene Punkt über die von *crcolor* angegebene Begrenzungs Farbe verfügt (wenn ' flufillborder ' angefordert wurde),, wenn der angegebene Punkt nicht über die von *crcolor* angegebene Farbe verfügt (wenn ' flufillsurface ' angefordert wurde), oder, wenn sich der Punkt außerhalb des Ausschneide Bereichs befindet.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion bietet mehr Flexibilität als `FloodFill` da Sie einen Fülltyp in *nfilltype*angeben können.

Wenn *nfilltype* auf flufillborder festgelegt ist, wird davon ausgegangen, dass der Bereich vollständig durch die von *crcolor*angegebene Farbe begrenzt ist. Die Funktion beginnt an dem Punkt, der von *x* und *y* angegeben wird, und füllt alle Richtungen an der Farb Begrenzung aus.

Wenn *nfilltype* auf flufillsurface festgelegt ist, beginnt die Funktion an dem durch *x* und *y* angegebenen Punkt und wird in allen Richtungen fortgesetzt, wobei alle angrenzenden Bereiche ausgefüllt werden, die die von *crcolor*angegebene Farbe enthalten.

Nur Speichergeräte Kontexte und Geräte, die die Unterstützung für die Raster Anzeige Technologie unterstützen `ExtFloodFill` . Weitere Informationen finden Sie unter der [GetDeviceCaps](#getdevicecaps) -Member-Funktion.

## <a name="cdcexttextout"></a><a name="exttextout"></a>CDC:: exttextout

Mit dieser Member-Funktion können Sie eine Zeichenfolge in einem rechteckigen Bereich mithilfe der aktuell ausgewählten Schriftart schreiben.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate der Zeichen Zelle für das erste Zeichen in der angegebenen Zeichenfolge an.

*Teenie*<br/>
Gibt die logische y-Koordinate des oberen Rands der Zeichen Zelle für das erste Zeichen in der angegebenen Zeichenfolge an.

*noptions*<br/>
Gibt den rechtetyp an. Dieser Parameter kann einen, beide oder keinen der folgenden Werte aufweisen:

- ETO_CLIPPED gibt an, dass der Text auf das Rechteck abgeschnitten wird.

- ETO_OPAQUE gibt an, dass die aktuelle Hintergrundfarbe das Rechteck füllt. (Sie können die aktuelle Hintergrundfarbe mit den Element Funktionen [SetBkColor](#setbkcolor) und [GetBkColor](#getbkcolor) festlegen und Abfragen.)

*lprect*<br/>
Verweist auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur, die die Abmessungen des Rechtecks bestimmt. Dieser Parameter kann NULL sein. Sie können auch ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt für diesen Parameter übergeben.

*lpszstring*<br/>
Verweist auf die angegebene Zeichenfolge, die gezeichnet werden soll. Sie können auch ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt für diesen Parameter übergeben.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an.

*lpdxbreiten*<br/>
Verweist auf ein Array von-Werten, die den Abstand zwischen den Ursprüngen von angrenzenden Zeichen Zellen angeben. Beispielsweise trennen *lpdxbreiten*[ *i*] logische Einheiten die Ursprünge der Zeichen Zelle *i* und der Zeichen Zelle *i* + 1. Wenn *lpdxbreiten* den Wert NULL hat, `ExtTextOut` verwendet den Standardabstand zwischen Zeichen.

*str*<br/>
Ein- `CString` Objekt, das die angegebenen Zeichen enthält, die gezeichnet werden sollen.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der rechteckige Bereich kann nicht transparent sein (mit der aktuellen Hintergrundfarbe gefüllt), und es kann sich um einen Clippingbereich handeln.

Wenn *noptions* den Wert 0 hat und *lprect* den Wert NULL hat, schreibt die Funktion Text in den Gerätekontext, ohne einen rechteckigen Bereich zu verwenden. Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert. Wenn eine Anwendung die aktuelle Position beim Aufrufen aktualisieren muss `ExtTextOut` , kann die Anwendung die `CDC` Member-Funktion [setTextAlign](#settextalign) mit *nFlags* aufrufen, die auf TA_UPDATECP festgelegt sind. Wenn dieses Flag festgelegt ist, ignoriert Windows *x* und *y* bei nachfolgenden Aufrufen von `ExtTextOut` und verwendet stattdessen die aktuelle Position. Wenn eine Anwendung TA_UPDATECP zum Aktualisieren der aktuellen Position verwendet, wird `ExtTextOut` die aktuelle Position entweder auf das Ende der vorherigen Textzeile oder auf die Position festgelegt, die durch das letzte Element des Arrays angegeben wird, auf das von *lpdxbreiten*verwiesen wird, je nachdem, welcher Wert größer ist.

## <a name="cdcfillpath"></a><a name="fillpath"></a>CDC:: FillPath

Schließt alle geöffneten Abbildungen im aktuellen Pfad und füllt das Innere des Pfads mit dem aktuellen Pinsel und dem Polygon Füll Modus aus.

```
BOOL FillPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Nachdem das innere ausgefüllt wurde, wird der Pfad aus dem Gerätekontext verworfen.

## <a name="cdcfillrect"></a><a name="fillrect"></a>CDC:: fillRect

Ruft diese Member-Funktion auf, um ein angegebenes Rechteck mit dem angegebenen Pinsel auszufüllen.

```cpp
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Verweist auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur, die die logischen Koordinaten des zu füllenden Rechtecks enthält. Sie können auch ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt für diesen Parameter übergeben.

*pbrush*<br/>
Identifiziert den Pinsel, der zum Ausfüllen des Rechtecks verwendet wird.

### <a name="remarks"></a>Bemerkungen

Die Funktion füllt das vollständige Rechteck, einschließlich des linken und oberen Rahmens, aber nicht den rechten und unteren Rand.

Der Pinsel muss entweder mithilfe der [CBrush](../../mfc/reference/cbrush-class.md) -Member-Funktionen " [kreatehatchbrush](../../mfc/reference/cbrush-class.md#createhatchbrush)", " [kreatepatternbrush](../../mfc/reference/cbrush-class.md#createpatternbrush)" und " [kreatesolidbrush](../../mfc/reference/cbrush-class.md#createsolidbrush)" erstellt oder von der Windows-Funktion abgerufen werden `GetStockObject` .

Beim Ausfüllen des angegebenen Rechtecks `FillRect` enthält nicht die Rechte und unteren Seiten des Rechtecks. GDI füllt ein Rechteck unabhängig vom aktuellen Kartenmodus bis zum, aber schließt nicht die Rechte Spalte und die untere Zeile aus. `FillRect`Vergleicht die Werte der Member `top` , `bottom` , `left` und `right` des angegebenen Rechtecks. Wenn `bottom` kleiner oder gleich ist `top` oder wenn `right` kleiner oder gleich ist `left` , wird das Rechteck nicht gezeichnet.

`FillRect`ähnelt [CDC:: fillsolidrect](#fillsolidrect); Allerdings `FillRect` verwendet einen Pinsel und kann daher verwendet werden, um ein Rechteck mit einer voll Tonfarbe, einer Dithering-Farbe, einem geschalten Pinsel oder einem Muster auszufüllen. `FillSolidRect`verwendet nur voll Tonfarben (angegeben durch einen COLORREF-Parameter). `FillRect`Normalerweise ist langsamer als `FillSolidRect` .

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>CDC:: fillrgn

Füllt den von der *PRGN* angegebenen Bereich mit dem durch *pbrush*angegebenen Pinsel.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parameter

*PRGN*<br/>
Ein Zeiger auf den Bereich, der ausgefüllt werden soll. Die Koordinaten für den angegebenen Bereich werden in logischen Einheiten angegeben.

*pbrush*<br/>
Identifiziert den Pinsel, der zum Ausfüllen des Bereichs verwendet werden soll.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Pinsel muss entweder mit den Element `CBrush` Funktionen `CreateHatchBrush` ,, oder erstellt werden, die `CreatePatternBrush` `CreateSolidBrush` von abgerufen werden `GetStockObject` .

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [crgn:: kreateroundrectrgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>CDC:: fillsolidrect

Ruft diese Member-Funktion auf, um das angegebene Rechteck mit der angegebenen voll Tonfarbe zu füllen.

```cpp
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Gibt das umgebende Rechteck an (in logischen Einheiten). Sie können entweder einen Zeiger auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Datenstruktur oder ein- `CRect` Objekt für diesen Parameter übergeben.

*CLR* Gibt die Farbe an, die zum Ausfüllen des Rechtecks verwendet werden soll.

*x*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Rechtecks an.

*Teenie*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Ziel Rechtecks an.

*verschoben*<br/>
Gibt die Breite des Rechtecks an.

*CY*<br/>
Gibt die Höhe des Rechtecks an.

### <a name="remarks"></a>Bemerkungen

`FillSolidRect`ähnelt [CDC:: fillRect](#fillrect); verwendet jedoch `FillSolidRect` nur voll Tonfarben (die durch den COLORREF-Parameter angegeben werden), während `FillRect` einen Pinsel verwendet und daher verwendet werden kann, um ein Rechteck mit einer voll Tonfarbe, einer Dithering-Farbe, gebrückten Pinsel oder einem Muster auszufüllen. `FillSolidRect`ist in der Regel schneller als `FillRect` .

> [!NOTE]
> Wenn Sie aufrufen `FillSolidRect` , wird die Hintergrundfarbe, die zuvor mithilfe von [SetBkColor](#setbkcolor)festgelegt wurde, auf die Farbe festgelegt, die von *CLR*angegeben wird.

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>CDC:: vereinfachpfad

Wandelt alle Kurven im ausgewählten Pfad in den aktuellen Gerätekontext um und wandelt jede Kurve in eine Sequenz von Zeilen um.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

## <a name="cdcfloodfill"></a><a name="floodfill"></a>CDC:: flufill

Füllt einen Bereich der Anzeige Oberfläche mit dem aktuellen Pinsel.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate des Punkts an, an dem mit dem Auffüllen begonnen wird.

*Teenie*<br/>
Gibt die logische y-Koordinate des Punkts an, an dem mit dem Ausfüllen begonnen wird.

*crcolor*<br/>
Gibt die Farbe der Grenze an.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn die Funktion erfolgreich ist. Andernfalls wird 0 zurückgegeben, wenn der Füllvorgang nicht abgeschlossen werden konnte, der angegebene Punkt die von *crcolor*angegebene Begrenzungs Farbe aufweist oder der Punkt außerhalb des Ausschneide Bereichs liegt.

### <a name="remarks"></a>Bemerkungen

Es wird davon ausgegangen, dass der Bereich gemäß der *crcolor*-Angabe gebunden ist. Die `FloodFill` Funktion beginnt an dem Punkt, der von *x* und *y* angegeben wird, und wird in allen Richtungen an die Farbgrenze weitergeführt.

Nur Speichergeräte Kontexte und Geräte, die die-Raster Anzeige Technologie unterstützen, unterstützen die- `FloodFill` Member-Funktion. Weitere Informationen zur RC_BITBLT Funktion finden Sie unter der- `GetDeviceCaps` Member-Funktion.

Die `ExtFloodFill` Funktion bietet eine ähnliche Funktion, aber größere Flexibilität.

## <a name="cdcframerect"></a><a name="framerect"></a>CDC:: frameRect

Zeichnet einen Rahmen um das durch *lprect*angegebene Rechteck.

```cpp
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Verweist auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das die logischen Koordinaten der oberen linken und der unteren rechten Ecke des Rechtecks enthält. Sie können auch ein- `CRect` Objekt für diesen Parameter übergeben.

*pbrush*<br/>
Identifiziert den Pinsel, der zum umgestalten des Rechtecks verwendet werden soll.

### <a name="remarks"></a>Bemerkungen

Die-Funktion verwendet den angegebenen Pinsel zum Zeichnen des Rahmens. Breite und Höhe des Rahmens sind immer 1 logische Einheit.

Wenn die Koordinate des Rechtecks `bottom` kleiner als oder gleich ist `top` oder wenn `right` kleiner oder gleich ist `left` , wird das Rechteck nicht gezeichnet.

Der von gezeichnete `FrameRect` Rahmen befindet sich an derselben Position wie ein von der Element Funktion gezeichneter Rahmen `Rectangle` mit denselben Koordinaten (wenn `Rectangle` einen Stift verwendet, der 1 logische Einheit breit ist). Das Innere des Rechtecks wird nicht von ausgefüllt `FrameRect` .

## <a name="cdcframergn"></a><a name="framergn"></a>CDC:: framergn

Zeichnet einen Rahmen um den durch *PRGN* angegebenen Bereich mit dem durch *pbrush*angegebenen Pinsel.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*PRGN*<br/>
Verweist auf das- `CRgn` Objekt, das den Bereich identifiziert, der in einen Rahmen eingeschlossen werden soll. Die Koordinaten für den angegebenen Bereich werden in logischen Einheiten angegeben.

*pbrush*<br/>
Verweist auf das- `CBrush` Objekt, das den Pinsel identifiziert, der zum Zeichnen des Rahmens verwendet werden soll.

*nwidth*<br/>
Gibt die Breite des Rahmens in den vertikalen Pinselstrichen in den Geräte Einheiten an.

*nheight*<br/>
Gibt die Höhe des Rahmens in den horizontalen Pinselstrichen in den Geräte Einheiten an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [crgn:: combinergn](../../mfc/reference/crgn-class.md#combinergn).

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>CDC:: FromHandle

Gibt einen Zeiger auf ein-Objekt zurück, `CDC` Wenn ein Handle für einen Gerätekontext angegeben wird.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parameter

*HDC*<br/>
Enthält ein Handle für einen Windows-Gerätekontext.

### <a name="return-value"></a>Rückgabewert

Der Zeiger kann temporär sein und sollte nicht über eine sofortige Verwendung hinaus gespeichert werden.

### <a name="remarks"></a>Bemerkungen

Wenn ein `CDC`-Objekt nicht an das Handle angefügt ist, wird ein temporäres `CDC`-Objekt erstellt und angefügt.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CPrintDialog:: getPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>CDC:: getarcdirection

Gibt die aktuelle Bogen Richtung für den Gerätekontext zurück.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Rückgabewert

Gibt die aktuelle Bogen Richtung an, wenn erfolgreich. Im folgenden finden Sie die gültigen Rückgabewerte:

- AD_COUNTERCLOCKWISE Arcs und Rechtecke gegen den Uhrzeigersinn gezeichnet.

- AD_CLOCKWISE Arcs und Rechtecke im Uhrzeigersinn gezeichnet.

Wenn ein Fehler auftritt, ist der Rückgabewert 0 (null).

### <a name="remarks"></a>Bemerkungen

Bogen-und Rechteck Funktionen verwenden die Bogen Richtung.

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>CDC:: getaspectratiofilter

Ruft die Einstellung für den aktuellen Seitenverhältnis Filter ab.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Rückgabewert

Ein- `CSize` Objekt, das das Seitenverhältnis darstellt, das vom aktuellen Seitenverhältnis Filter verwendet wird.

### <a name="remarks"></a>Bemerkungen

Das Seitenverhältnis ist das Verhältnis, das durch die Pixel Breite und-Höhe eines Geräts gebildet wird. Informationen über das Seitenverhältnis eines Geräts werden bei der Erstellung, Auswahl und Anzeige von Schriftarten verwendet. Windows stellt einen speziellen Filter, den Seitenverhältnis Filter, bereit, um Schriftarten auszuwählen, die für ein bestimmtes Seitenverhältnis von allen verfügbaren Schriftarten entwickelt wurden. Der Filter verwendet das Seitenverhältnis, das von der Member-Funktion angegeben wird `SetMapperFlags` .

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>CDC:: GetBkColor

Gibt die aktuelle Hintergrundfarbe zurück.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Rückgabewert

Ein RGB-Farbwert.

### <a name="remarks"></a>Bemerkungen

Wenn der Hintergrundmodus nicht transparent ist, verwendet das System die Hintergrundfarbe, um die Lücken in formatierten Linien, die Lücken zwischen ausschlendeten Linien in Pinseln und den Hintergrund in Zeichen Zellen auszufüllen. Das System verwendet auch die Hintergrundfarbe beim Umrechnen von Bitmaps zwischen Farb-und Monochrom-Geräte Kontexten.

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>CDC:: getbkmode

Gibt den Hintergrundmodus zurück.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der aktuelle Hintergrundmodus, der transparent oder transparent sein kann.

### <a name="remarks"></a>Bemerkungen

Der Hintergrundmodus definiert, ob das System vorhandene Hintergrundfarben auf der Zeichnungs Oberfläche vor dem Zeichnen von Text, auslendeten Pinseln oder einem beliebigen Stift Stil entfernt, der keine durchgezogenen Linie ist.

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>CDC:: getboundsrect

Gibt das aktuelle akkumulierte umgebende Rechteck für den angegebenen Gerätekontext zurück.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parameter

*lprectbounds*<br/>
Verweist auf einen Puffer, der das aktuelle umgebende Rechteck empfängt. Das Rechteck wird in logischen Koordinaten zurückgegeben.

*flags*<br/>
Gibt an, ob das umschließende Rechteck gelöscht werden soll, nachdem es zurückgegeben wurde. Dieser Parameter muss NULL sein oder auf den folgenden Wert festgelegt werden:

- DCB_RESET erzwingt, dass das umschließende Rechteck gelöscht wird, nachdem es zurückgegeben wurde.

### <a name="return-value"></a>Rückgabewert

Gibt den aktuellen Zustand des umgebenden Rechtecks an, wenn die Funktion erfolgreich ist. Dabei kann es sich um eine Kombination der folgenden Werte handeln:

- DCB_ACCUMULATE umgebende Rechteck wird angezeigt.

- DCB_RESET umgebende Rechteck ist leer.

- DCB_SET umgebende Rechteck ist nicht leer.

- DCB_ENABLE Begrenzungs Ansammlung ist on.

- DCB_DISABLE Begrenzungs Ansammlung ist deaktiviert.

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>CDC:: getbrushorg

Ruft den Ursprung (in den Geräte Einheiten) des aktuell für den Gerätekontext ausgewählten Pinsels ab.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Rückgabewert

Der aktuelle Ursprung des Pinsels (in Geräte Einheiten) als [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) -Objekt.

### <a name="remarks"></a>Bemerkungen

Der ursprüngliche Pinsel Ursprung liegt bei (0,0) des Client Bereichs. Der Rückgabewert gibt diesen Punkt in den Geräte Einheiten relativ zum Ursprung des Desktop Fensters an.

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>CDC:: getcharakteriplacement

Ruft verschiedene Typen von Informationen zu einer Zeichenfolge ab.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parameter

*LpString*<br/>
Ein Zeiger auf die zu verarbeitende Zeichenfolge.

*nCount*<br/>
Gibt die Länge der Zeichenfolge an. Bei der ANSI-Version ist es eine Byteanzahl und bei der Unicode-Funktion ist es eine Wortanzahl. Weitere Informationen finden Sie unter [getcharakteriplacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw).

*nmaxblock*<br/>
Gibt der maximale Wertbereich (in logischen Einheiten) an, zu dem die Zeichenfolge verarbeitet wird. Zeichen, die diesen Wertbereich bei Verarbeitung überschreiten würden, werden ignoriert. Berechnungen für alle erforderlichen Reihenfolge- oder Glyphenarrays gelten nur für die enthaltenen Zeichen. Dieser Parameter wird nur verwendet, wenn der GCP_MAXEXTENT Wert im *dwFlags* -Parameter angegeben wird. Da die Funktion die Eingabezeichenfolge verarbeitet, wird jedes Zeichen und sein Wertebereich nur dann der Ausgabe, dem Wertebereich und anderen Arrays hinzugefügt, wenn der gesamte Wertebereich das Maximum noch nicht überschritten hat. Bei Erreichen des Limits wird die Verarbeitung beendet.

*lpResults*<br/>
Zeiger auf eine [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) -Struktur, die die Ergebnisse der Funktion empfängt.

*dwFlags*<br/>
Gibt das Verarbeiten der Zeichenfolge in die erforderlichen Arrays an. Bei diesem Parameter kann es sich um einen oder mehrere der Werte handeln, die im Abschnitt *dwFlags* des Themas [getcharakteriplacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw) aufgeführt sind.

*str*<br/>
Ein Zeiger auf ein zu verarbeitende [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt.

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, handelt es sich bei dem Rückgabewert um die Breite und Höhe der Zeichenfolge in logischen Einheiten.

Wenn die Funktion fehlerhaft ist, ist der Rückgabewert null.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion emuliert die Funktionalität der [getcharakteriplacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)-Funktion, wie im Windows SDK beschrieben.

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>CDC:: getcharabcbreiten

Ruft die Breite der aufeinander folgenden Zeichen in einem angegebenen Bereich von der aktuellen TrueType-Schriftart ab.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parameter

*nfirstchar*<br/>
Gibt das erste Zeichen im Bereich von Zeichen aus der aktuellen Schriftart an, für die Zeichen breiten zurückgegeben werden.

*nlastchar*<br/>
Gibt das letzte Zeichen in dem Bereich von Zeichen aus der aktuellen Schriftart an, für die Zeichen breiten zurückgegeben werden.

*lpabc*<br/>
Verweist auf ein Array von [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) -Strukturen, die die Zeichenbreite empfangen, wenn die Funktion zurückgibt. Dieses Array muss mindestens so viele Strukturen enthalten, `ABC` wie Zeichen in dem von den Parametern *nfirstchar* und *nlastchar* angegebenen Bereich vorhanden sind.

*lpabcf*<br/>
Verweist auf einen von der Anwendung bereitgestellten Puffer mit einem Array von [abcfloat](/windows/win32/api/wingdi/ns-wingdi-abcfloat) -Strukturen, um die Zeichenbreite zu erhalten, wenn die Funktion zurückgegeben wird. Die von dieser Funktion zurückgegebenen breiten liegen im IEEE-Gleit Komma Format vor.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die breiten werden in logischen Einheiten zurückgegeben. Diese Funktion ist nur mit TrueType-Schriftarten erfolgreich.

Der TrueType-Raster gibt den Zeichenabstand "ABC" an, nachdem eine bestimmte Punktgröße ausgewählt wurde. Der Abstand "A" ist der Abstand, der der aktuellen Position vor dem Platzieren des Symbols hinzugefügt wird. Der Abstand "B" ist die Breite des schwarzen Teils des Symbols. Der Abstand "C" wird der aktuellen Position hinzugefügt, um den Leerraum rechts neben dem Symbol zu berücksichtigen. Die gesamte erweiterte Breite wird von A + B + C angegeben.

Wenn die `GetCharABCWidths` Member-Funktion negative "A"-oder "C"-breiten für ein Zeichen abruft, umfasst dieses Zeichen unter hängen oder Überhängen.

Zum Konvertieren der ABC-Breite in Schriftart Entwurfs Einheiten sollte eine Anwendung eine Schriftart erstellen, deren Höhe (wie im- `lfHeight` Member der [LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw) -Struktur angegeben) gleich dem Wert ist, der im- `ntmSizeEM` Member der [newtextmetric](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) -Struktur gespeichert ist. (Der Wert des Members `ntmSizeEM` kann durch Aufrufen der Windows-Funktion " [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) " abgerufen werden.)

Die ABC-Breite des Standard Zeichens wird für Zeichen verwendet, die sich außerhalb des Bereichs der aktuell ausgewählten Schriftart befinden.

Zum Abrufen der breiten von Zeichen in nicht-TrueType-Schriftarten sollten Anwendungen die [getcharwidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) -Windows-Funktion verwenden.

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>CDC:: getcharabcwidthsi

Ruft die breiten in logischen Einheiten von aufeinander folgenden Glyphe-Indizes in einem angegebenen Bereich aus der aktuellen TrueType-Schriftart ab.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parameter

*gifirst*<br/>
Gibt den ersten Glyphe-Index in der Gruppe von aufeinander folgenden Glyphen-Indizes aus der aktuellen Schriftart an. Dieser Parameter wird nur verwendet, wenn der *PGI* -Parameter NULL ist.

*CGI*<br/>
Gibt die Anzahl der Glyphe-Indizes an.

*PGI*<br/>
Ein Zeiger auf ein Array, das Glyphe-Indizes enthält. Wenn der Wert NULL ist, wird stattdessen der *gifirst* -Parameter verwendet. Der *CGI* -Parameter gibt die Anzahl der Glyphe-Indizes in diesem Array an.

*lpabc*<br/>
Zeiger auf ein Array von [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) -Strukturen, die die Zeichenbreite empfangen. Dieses Array muss mindestens so viele Strukturen enthalten, `ABC` wie vom *CGI* -Parameter angegebene Glyphe-Indizes enthalten.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion emuliert die Funktionalität der [getcharabcwidthsi](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi)-Funktion, wie im Windows SDK beschrieben.

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>CDC:: getcharwidth

Ruft die Breite einzelner Zeichen in einer aufeinander folgenden Gruppe von Zeichen aus der aktuellen Schriftart ab, wobei `m_hAttribDC` der Eingabegeräte Kontext verwendet wird.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parameter

*nfirstchar*<br/>
Gibt das erste Zeichen in einer aufeinanderfolgenden Gruppe von Zeichen in der aktuellen Schriftart an.

*nlastchar*<br/>
Gibt das letzte Zeichen in einer aufeinander folgenden Gruppe von Zeichen in der aktuellen Schriftart an.

*lpBuffer*<br/>
Verweist auf einen Puffer, der die Breitenwerte für eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart empfängt.

*lpfloatbuffer*<br/>
Zeigt auf einen Puffer, um die Zeichenbreite zu erhalten. Die zurückgegebenen breiten liegen im 32-Bit-IEEE-Gleit Komma Format vor. (Die breiten werden entlang der Basis Zeile der Zeichen gemessen.)

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Wenn z. b. *nfirstchar* den Buchstaben "a" und *nlastchar* den Buchstaben "z" identifiziert, ruft die Funktion die Breite aller Kleinbuchstaben ab.

Die-Funktion speichert die Werte im Puffer, auf die von *lpBuffer*verwiesen wird. Dieser Puffer muss groß genug sein, um alle breiten zu halten. Das heißt, es müssen mindestens 26 Einträge im angegebenen Beispiel vorhanden sein.

Wenn in einer bestimmten Schriftart kein Zeichen in der aufeinander folgenden Zeichen Gruppe vorhanden ist, wird Ihr der Wert Width (Breite) des Standard Zeichens zugewiesen.

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>CDC:: getcharwidthi

Ruft die breiten in logischen Koordinaten von aufeinander folgenden Glyphe-Indizes in einem angegebenen Bereich aus der aktuellen Schriftart ab.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parameter

*gifirst*<br/>
Gibt den ersten Glyphe-Index in der Gruppe von aufeinander folgenden Glyphen-Indizes aus der aktuellen Schriftart an. Dieser Parameter wird nur verwendet, wenn der *PGI* -Parameter NULL ist.

*CGI*<br/>
Gibt die Anzahl der Glyphe-Indizes an.

*PGI*<br/>
Ein Zeiger auf ein Array, das Glyphe-Indizes enthält. Wenn der Wert NULL ist, wird stattdessen der *gifirst* -Parameter verwendet. Der *CGI* -Parameter gibt die Anzahl der Glyphe-Indizes in diesem Array an.

*lpBuffer*<br/>
Ein Zeiger auf einen Puffer, der die Breite empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion emuliert die Funktionalität der [getcharwidthi](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi)-Funktion, wie im Windows SDK beschrieben.

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>CDC:: getclipbox

Ruft die Dimensionen des Begrenzungs Rechtecks um die aktuelle clippinggrenze ab.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Verweist auf die [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur oder das [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das die Rechteck Abmessungen empfangen soll.

### <a name="return-value"></a>Rückgabewert

Der Typ des Clippingbereichs. Dabei kann es sich um einen der folgenden Werte handeln:

- Der complexregion-Ausschneide Bereich weist überlappende Rahmen auf.

- Fehler beim Gerätekontext.

- Der NULLREGION-Clippingbereich ist leer.

- Der simpleregion-Clippingbereich hat keine überlappenden Rahmen.

### <a name="remarks"></a>Bemerkungen

Die Dimensionen werden in den Puffer kopiert, auf den *lprect*zeigt.

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>CDC:: getcoloradjustment

Ruft die Farb Anpassungs Werte für den Gerätekontext ab.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parameter

*lpcoloradjust*<br/>
Verweist auf eine [coloradjustment](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) -Datenstruktur, um die Farb Anpassungs Werte zu erhalten.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>CDC:: getcurrentbitmap

Gibt einen Zeiger auf das aktuell ausgewählte `CBitmap` Objekt zurück.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf ein- `CBitmap` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion gibt möglicherweise temporäre Objekte zurück.

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>CDC:: getcurrentbrush

Gibt einen Zeiger auf das aktuell ausgewählte `CBrush` Objekt zurück.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf ein- `CBrush` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion gibt möglicherweise temporäre Objekte zurück.

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>CDC:: getcurrentfont

Gibt einen Zeiger auf das aktuell ausgewählte `CFont` Objekt zurück.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf ein- `CFont` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion gibt möglicherweise temporäre Objekte zurück.

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>CDC:: getcurrentpalette

Gibt einen Zeiger auf das aktuell ausgewählte `CPalette` Objekt zurück.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf ein- `CPalette` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion gibt möglicherweise temporäre Objekte zurück.

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>CDC:: getcurrentpen

Gibt einen Zeiger auf das aktuell ausgewählte `CPen` Objekt zurück.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf ein- `CPen` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion gibt möglicherweise temporäre Objekte zurück.

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>CDC:: GetCurrentPosition

Ruft die aktuelle Position (in logischen Koordinaten) ab.

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Rückgabewert

Die aktuelle Position als- `CPoint` Objekt.

### <a name="remarks"></a>Bemerkungen

Die aktuelle Position kann mit der Member-Funktion festgelegt werden `MoveTo` .

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>CDC:: getdcbrushcolor

Ruft die aktuelle Pinselfarbe ab.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ausgeführt wird, ist der Rückgabewert der [COLORREF](/windows/win32/gdi/colorref) -Wert für die aktuelle Pinsel Farbe.

Wenn die Funktion fehlerhaft ist, ist der Rückgabewert CLR_INVALID.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion emuliert die Funktionalität der [getdcbrushcolor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor)-Funktion, wie im Windows SDK beschrieben.

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>CDC:: getdcpcolor

Ruft die aktuelle Stiftfarbe ab.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ausgeführt wird, ist der Rückgabewert der [COLORREF](/windows/win32/gdi/colorref) -Wert für die aktuelle Stift Farbe.

Wenn die Funktion fehlerhaft ist, ist der Rückgabewert CLR_INVALID.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion verwendet die Win32-Funktion [getdcpcolor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor), wie im Windows SDK beschrieben.

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>CDC:: getde vicecaps

Ruft eine große Bandbreite an gerätespezifischen Informationen zum Anzeigegerät ab.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parameter

*nIndex*<br/>
Gibt den Typ der zurück zugebende Informationen an. Eine Liste der Werte finden Sie unter [getdebug](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) in der Windows SDK.

### <a name="return-value"></a>Rückgabewert

Der Wert der angeforderten Funktion, wenn die Funktion erfolgreich ausgeführt wurde.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CPrintDialog:: getdefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>CDC:: getfontdata

Ruft Schriftart metrikinformationen aus einer skalierbaren Schriftart Datei ab.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parameter

*dwtable*<br/>
Gibt den Namen der metriktabelle an, die zurückgegeben werden soll. Dieser Parameter kann eine der metriktabellen sein, die in der von der Microsoft Corporation veröffentlichten TrueType-Schriftart Datei Spezifikation dokumentiert ist. Wenn dieser Parameter 0 ist, werden die Informationen ab dem Anfang der Schriftart Datei abgerufen.

*dwOffset*<br/>
Gibt den Offset vom Anfang der Tabelle an, an dem mit dem Abrufen von Informationen begonnen werden soll. Wenn dieser Parameter 0 ist, werden die Informationen ab dem Anfang der Tabelle abgerufen, die durch den *dwtable* -Parameter angegeben wird. Wenn dieser Wert größer oder gleich der Größe der Tabelle ist, wird `GetFontData` 0 zurückgegeben.

*lpdata*<br/>
Verweist auf einen Puffer, der die Schriftart Informationen empfängt. Wenn dieser Wert NULL ist, gibt die Funktion die Größe des Puffers zurück, der für die im *dwtable* -Parameter angegebenen Schriftart Daten erforderlich ist.

*cbData*<br/>
Gibt die Länge der abzurufenden Informationen in Bytes an. Wenn dieser Parameter 0 ist, wird `GetFontData` die Größe der Daten zurückgegeben, die im *dwtable* -Parameter angegeben sind.

### <a name="return-value"></a>Rückgabewert

Gibt die Anzahl der Bytes an, die in dem Puffer zurückgegeben werden, auf den *lpdata* verweist, wenn die Funktion erfolgreich ist. andernfalls-1.

### <a name="remarks"></a>Bemerkungen

Die abzurufenden Informationen werden durch Angabe eines Offsets in der Schriftart Datei und der Länge der zurück zugebende Informationen identifiziert.

Eine Anwendung kann manchmal die `GetFontData` Member-Funktion verwenden, um eine TrueType-Schriftart mit einem Dokument zu speichern. Zu diesem Zweck bestimmt die Anwendung, ob die Schriftart eingebettet werden kann, und ruft dann die gesamte Schriftart Datei ab, wobei 0 für die Parameter *dwtable*, *dwOffset*und *cbData* angegeben wird.

Anwendungen können bestimmen, ob eine Schriftart eingebettet werden kann, indem Sie den `otmfsType` Member der [outlinetextmetric](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) -Struktur überprüfen. Wenn Bit 1 von `otmfsType` festgelegt ist, ist die Einbettung für die Schriftart nicht zulässig. Wenn Bit 1 eindeutig ist, kann die Schriftart eingebettet werden. Wenn Bit 2 festgelegt ist, ist die Einbettung schreibgeschützt.

Wenn eine Anwendung versucht, diese Funktion zum Abrufen von Informationen für eine nicht-TrueType-Schriftart zu verwenden, `GetFontData` gibt die Member-Funktion-1 zurück.

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>CDC:: getfontlanguageingefo

Gibt Informationen zur aktuell ausgewählten Schriftart für den angegebenen Anzeige Kontext zurück.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Rückgabewert

Der Rückgabewert identifiziert Merkmale der aktuell ausgewählten Schriftart. Eine vollständige Liste möglicher Werte finden Sie unter [getfontlanguageingefo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion emuliert die Funktionalität der [getfontlanguageingefo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo)-Funktion, wie im Windows SDK beschrieben.

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>CDC:: GetGlyphOutline

Ruft die Gliederungs Kurve oder Bitmap für ein Umriss Zeichen in der aktuellen Schriftart ab.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parameter

*NCHAR*<br/>
Gibt das Zeichen an, für das Informationen zurückgegeben werden sollen.

*nformat*<br/>
Gibt das Format an, in dem die Funktion Informationen zurückgeben soll. Die folgenden Werte sind möglich:

|Wert|Bedeutung|
|-----------|-------------|
|GGO_BITMAP|Gibt das Glyphe-Bitmap zurück. Wenn die Funktion zurückgegeben wird, enthält der Puffer, auf den von *lpBuffer* verwiesen wird, eine Bitmap mit 1 Bit pro Pixel, deren Zeilen an doppelten Wortgrenzen beginnen.|
|GGO_NATIVE|Gibt die Kurven Datenpunkte im nativen Format des Rasterizers mithilfe von Geräte Einheiten zurück. Wenn dieser Wert angegeben wird, wird jede in *lpmat2* angegebene Transformation ignoriert.|

Wenn der Wert von *nformat* 0 ist, füllt die Funktion eine [GlyphMetrics](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) -Struktur aus, gibt jedoch keine Glyphe-Gliederungs Daten zurück.

*lpgm*<br/>
Verweist auf eine GlyphMetrics-Struktur, die die Platzierung des Symbols in der Zeichen Zelle beschreibt.

*cbbuffer*<br/>
Gibt die Größe des Puffers an, in den die Funktion Informationen über das Umriss Zeichen kopiert. Wenn dieser Wert 0 ist und der *nformat* -Parameter entweder der GGO_BITMAP oder GGO_NATIVE Werte ist, gibt die Funktion die erforderliche Größe des Puffers zurück.

*lpBuffer*<br/>
Verweist auf einen Puffer, in den die-Funktion Informationen über das Umriss Zeichen kopiert. Wenn *nformat* den GGO_NATIVE Wert angibt, werden die Informationen in Form von ttpolygonheader-und ttpolycurve-Strukturen kopiert. Wenn dieser Wert NULL ist und *nformat* entweder der GGO_BITMAP oder GGO_NATIVE Wert ist, gibt die Funktion die erforderliche Größe des Puffers zurück.

*lpmat2*<br/>
Verweist auf eine [MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2) -Struktur, die eine Transformationsmatrix für das Zeichen enthält. Dieser Parameter darf nicht NULL sein, auch wenn der GGO_NATIVE Wert für *nformat*angegeben wird.

### <a name="return-value"></a>Rückgabewert

Die Größe (in Bytes) des Puffers, der für die abgerufenen Informationen erforderlich ist, wenn *cbbuffer* 0 ist oder *lpBuffer* NULL ist. Andernfalls ist es ein positiver Wert, wenn die Funktion erfolgreich ist, oder-1, wenn ein Fehler vorliegt.

### <a name="remarks"></a>Bemerkungen

Eine Anwendung kann im Bitmapformat abgerufene Zeichen drehen, indem Sie in der Struktur, auf die von *lpmat2*verwiesen wird, eine 2-by-2-Transformationsmatrix angibt.

Eine Symbol Gliederung wird als eine Reihe von Kontur zurückgegeben. Jede Kontur wird durch eine [ttpolygonheader](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) -Struktur gefolgt von so vielen `TTPOLYCURVE` Strukturen definiert, wie Sie Sie beschreiben müssen. Alle Punkte werden als [pointfx](/windows/win32/api/wingdi/ns-wingdi-pointfx) -Strukturen zurückgegeben und stellen absolute Positionen dar, nicht Relative Verschiebungen. Der Startpunkt, der vom- `pfxStart` Member der [ttpolygonheader](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) -Struktur angegeben wird, ist der Punkt, an dem der Umriss für eine Kontur beginnt. Die folgenden [ttpolycurve](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) -Strukturen können entweder Polylinie-Datensätze oder Spline-Datensätze sein. Polyliniendatensätze sind eine Reihe von Punkten. die Linien, die zwischen den Punkten gezeichnet werden, beschreiben den Umriss des Zeichens. Spline-Datensätze stellen die von TrueType verwendeten quadratischen Kurven dar (d. h. Quadratische b-Splines).

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>CDC:: getgraphicsmode

Ruft den aktuellen Grafikmodus für den angegebenen Gerätekontext ab.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Rückgabewert

Gibt den aktuellen Grafikmodus bei Erfolg zurück. Eine Liste der Werte, die von dieser Methode zurückgegeben werden können, finden Sie unter [getgraphicsmode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

Gibt bei einem Fehler 0 zurück.

Um erweiterte Fehlerinformationen abzurufen, nennen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Bemerkungen

Diese Methode umschließt die Windows-GDI-Funktion [getgraphicsmode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>CDC:: gethalftonebrush

Rufen Sie diese Member-Funktion auf, um einen halbftone-Pinsel abzurufen.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf ein- `CBrush` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Ein halbftone-Pinsel zeigt Pixel an, die abwechselnd Vordergrund-und Hintergrundfarben sind, um ein Dithering-Muster zu erstellen. Im folgenden finden Sie ein Beispiel für ein Dithering-Muster, das von einem Halbton-Pinsel erstellt wurde.

![Detail eines geditherten Stiftstrichs](../../mfc/reference/media/vc318s1.gif "Detail eines geditherten Stiftstrichs")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>CDC:: getkerningpairs

Ruft die Zeichen für die Zeichenauswahl für die Schriftart ab, die derzeit im angegebenen Gerätekontext ausgewählt ist.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parameter

*npaare*<br/>
Gibt die Anzahl der [kerningpair](/windows/win32/api/wingdi/ns-wingdi-kerningpair) -Strukturen an, auf die von *lpkrnpair*verwiesen wird. Die Funktion kopiert nicht mehr als durch *npaare*angegebene, nicht mehr.

*lpkrnpair*<br/>
Verweist auf ein Array von- `KERNINGPAIR` Strukturen, die bei Rückgabe der Funktion die kernungs Paare empfangen. Dieses Array muss mindestens so viele Strukturen enthalten, wie von *npairs*angegeben. Wenn dieser Parameter NULL ist, gibt die-Funktion die Gesamtzahl der abkerenden Paare für die Schriftart zurück.

### <a name="return-value"></a>Rückgabewert

Gibt die Anzahl der abgerufenen abgerufenen Paare bzw. die Gesamtanzahl der abgerufenen Paare in der Schriftart an, wenn die Funktion erfolgreich ausgeführt wurde. NULL wird zurückgegeben, wenn bei der Funktion ein Fehler auftritt oder keine kernungs Paare für die Schriftart vorhanden sind.

## <a name="cdcgetlayout"></a><a name="getlayout"></a>CDC:: getLayout

Mit dieser Member-Funktion können Sie das Layout von Text und Grafiken für einen Gerätekontext ermitteln, z. b. einen Drucker oder eine Metadatei.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn erfolgreich, die LayoutFlags für den aktuellen Gerätekontext. Andernfalls GDI_ERROR. Für erweiterte Fehlerinformationen aufrufen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror). Eine Liste der LayoutFlags finden Sie unter [CDC:: setLayout](#setlayout).

### <a name="remarks"></a>Bemerkungen

Das Standardlayout ist von links nach rechts.

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>CDC:: getmapmode

Ruft den aktuellen Mapping-Modus ab.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der Mapping-Modus.

### <a name="remarks"></a>Bemerkungen

Eine Beschreibung der Karten Modi finden Sie unter der- `SetMapMode` Member-Funktion.

> [!NOTE]
> Wenn Sie [setLayout](#setlayout) aufrufen, um den DC in das Layout von rechts nach Links zu ändern, wird `SetLayout` der Zuordnungsmodus von automatisch in MM_ISOTROPIC geändert. Folglich geben alle nachfolgenden Aufrufe von `GetMapMode` MM_ISOTROPIC zurück.

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>CDC:: getMiterLimit

Gibt das miterLimit für den Gerätekontext zurück.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Das Trennzeichen wird verwendet, wenn geometrische Linien gezeichnet werden, die über Gehrungs Joins verfügen.

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>CDC:: GetNearestColor

Gibt die voll Tonfarbe zurück, die mit einer angegebenen logischen Farbe am besten übereinstimmt.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parameter

*crcolor*<br/>
Gibt die Farbe an, die abgeglichen werden soll.

### <a name="return-value"></a>Rückgabewert

Ein RGB-Farbwert (rot, grün, blau), der die voll Tonfarbe definiert, die dem *crcolor* -Wert am nächsten liegt, den das Gerät darstellen kann.

### <a name="remarks"></a>Bemerkungen

Das angegebene Gerät muss diese Farbe darstellen können.

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>CDC:: getoutlinetextmetrics

Ruft metrikinformationen für TrueType-Schriftarten ab.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parameter

*lpotm*<br/>
Verweist auf ein Array von [outlinetextmetric](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) -Strukturen. Wenn dieser Parameter NULL ist, gibt die Funktion die Größe des Puffers zurück, der für die abgerufenen Metrikdaten erforderlich ist.

*cbData*<br/>
Gibt die Größe (in Bytes) des Puffers an, in den Informationen zurückgegeben werden.

*lpotm*<br/>
Verweist auf eine- `OUTLINETEXTMETRIC` Struktur. Wenn dieser Parameter NULL ist, gibt die Funktion die Größe des Puffers zurück, der für die abgerufenen metrikinformationen erforderlich ist.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die [outlinetextmetric](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) -Struktur enthält die meisten Schriftart metrikinformationen, die im TrueType-Format bereitgestellt werden, einschließlich einer [TextMetric](/windows/win32/api/wingdi/ns-wingdi-textmetricw) -Struktur. Die letzten vier Member der- `OUTLINETEXTMETRIC` Struktur sind Zeiger auf Zeichen folgen. Anwendungen sollten zusätzlich zu dem für die anderen Elemente erforderlichen Speicherplatz für diese Zeichen folgen Speicherplatz zuweisen. Da die Größe der Zeichen folgen nicht vom System festgelegt wird, ist die einfachste Methode zum belegen von Arbeitsspeicher das Abrufen der erforderlichen Größe durch Angeben von NULL für *lpotm* beim ersten Aufrufen der `GetOutlineTextMetrics` Funktion.

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>CDC:: getoutputcharwidth

Verwendet den Ausgabegeräte Kontext, `m_hDC` , und ruft die Breite einzelner Zeichen in einer aufeinander folgenden Gruppe von Zeichen aus der aktuellen Schriftart ab.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parameter

*nfirstchar*<br/>
Gibt das erste Zeichen in einer aufeinanderfolgenden Gruppe von Zeichen in der aktuellen Schriftart an.

*nlastchar*<br/>
Gibt das letzte Zeichen in einer aufeinander folgenden Gruppe von Zeichen in der aktuellen Schriftart an.

*lpBuffer*<br/>
Verweist auf einen Puffer, der die Breitenwerte für eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Wenn z. b. *nfirstchar* den Buchstaben "a" und *nlastchar* den Buchstaben "z" identifiziert, ruft die Funktion die Breite aller Kleinbuchstaben ab.

Die-Funktion speichert die Werte im Puffer, auf die von *lpBuffer*verwiesen wird. Dieser Puffer muss groß genug sein, um alle breiten zu halten. Das heißt, es müssen mindestens 26 Einträge im angegebenen Beispiel vorhanden sein.

Wenn in einer bestimmten Schriftart kein Zeichen in der aufeinander folgenden Zeichen Gruppe vorhanden ist, wird Ihr der Wert Width (Breite) des Standard Zeichens zugewiesen.

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>CDC:: getoutputtabbedtextextent

Mit dieser Member-Funktion können Sie die Breite und Höhe einer Zeichenfolge mit [m_hDC](#m_hdc), dem Ausgabegeräte Kontext, berechnen.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parameter

*lpszstring*<br/>
Verweist auf eine zu messende Zeichenfolge. Sie können auch ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt für diesen Parameter übergeben.

*nCount*<br/>
Gibt die [Länge der Zeichenfolge](/windows/win32/gdi/specifying-length-of-text-output-string) an, auf die von *lpszstring*verwiesen wird.

*ntabpositionen*<br/>
Gibt die Anzahl der Tabstopp Positionen im Array an, auf die von *lpntabstoppositions*verwiesen wird.

*lpntabstoppositions*<br/>
Verweist auf ein Array von ganzen Zahlen, das die Position der Tabstopps in logischen Einheiten enthält. Die Tabstopps müssen in steigender Reihenfolge sortiert werden. der kleinste x-Wert sollte das erste Element im Array sein. Zurück-Registerkarten sind nicht zulässig.

*str*<br/>
Ein- `CString` Objekt, das die angegebenen zu messenden Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Die Dimensionen der Zeichenfolge (in logischen Einheiten) in einem [CSize](../../atl-mfc-shared/reference/csize-class.md) -Objekt.

### <a name="remarks"></a>Bemerkungen

Wenn die Zeichenfolge ein oder mehrere Tabstopps enthält, basiert die Breite der Zeichenfolge auf den durch *lpntabstoppositions*angegebenen Tabstopps. Die-Funktion verwendet die aktuell ausgewählte Schriftart, um die Dimensionen der Zeichenfolge zu berechnen.

Der aktuelle Clippingbereich versetzt nicht die von der Funktion zurückgegebene Breite und Höhe `GetOutputTabbedTextExtent` .

Da einige Geräte keine Zeichen in regulären Zell Arrays platzieren (d. h., Sie setzen die Zeichen ein), ist die Summe der Werte Blöcke in einer Zeichenfolge möglicherweise nicht gleich dem Wertebereich der Zeichenfolge.

Wenn *ntabpositions* den Wert 0 hat und *lpntabstoppositions* den Wert NULL hat, werden die Registerkarten auf 8 durchschnittliche Zeichenbreite erweitert. Wenn *ntabpositions* den Wert 1 hat, wird die Tabstopps durch die Entfernung getrennt, die durch den ersten Wert im Array festgelegt wird, auf den *lpntabstoppositions* verweist. Wenn *lpntabstoppositions* auf mehr als einen einzelnen Wert zeigt, wird für jeden Wert im Array ein Tabstopp festgelegt, bis zu der von *ntabpositions*angegebenen Zahl.

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>CDC:: getoutputtextextent

Mit dieser Member-Funktion können Sie den Ausgabegeräte Kontext verwenden, [m_hDC](#m_hdc)und die Breite und Höhe einer Textzeile mithilfe der aktuellen Schriftart berechnen.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parameter

*lpszstring*<br/>
Verweist auf eine Zeichenfolge. Sie können auch ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt für diesen Parameter übergeben.

*nCount*<br/>
Gibt die [Länge der Zeichenfolge](/windows/win32/gdi/specifying-length-of-text-output-string) an, auf die von *lpszstring*verwiesen wird.

*str*<br/>
Ein- `CString` Objekt, das die angegebenen zu messenden Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Die Dimensionen der Zeichenfolge (in logischen Einheiten), die in einem [CSize](../../atl-mfc-shared/reference/csize-class.md) -Objekt zurückgegeben werden.

### <a name="remarks"></a>Bemerkungen

Der aktuelle Clippingbereich wirkt sich nicht auf die von zurückgegebene Breite und Höhe aus `GetOutputTextExtent` .

Da einige Geräte keine Zeichen in regulären Zell Arrays platzieren (d. h., Sie führen die kernung aus), ist die Summe der Werte Blöcke in einer Zeichenfolge möglicherweise nicht gleich dem Wertebereich der Zeichenfolge.

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>CDC:: getoutputtextmetrics

Ruft die Metriken für die aktuelle Schriftart mithilfe von `m_hDC` , dem Ausgabegeräte Kontext ab.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parameter

*lpmetrics*<br/>
Verweist auf die [textmetrikstruktur](/windows/win32/api/wingdi/ns-wingdi-textmetricw) , die die Metriken empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

## <a name="cdcgetpath"></a><a name="getpath"></a>CDC:: getpath

Ruft die Koordinaten ab, die die Endpunkte von Linien definieren, sowie die Steuerungs Punkte der Kurven, die sich in dem Pfad befinden, der im Gerätekontext ausgewählt wird.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von [Punkt](/windows/win32/api/windef/ns-windef-point) Datenstrukturen oder- `CPoint` Objekten, in denen die Zeilen Endpunkte und die Kurven Steuerungs Punkte platziert werden.

*lptypes*<br/>
Verweist auf ein Bytearray, in dem die Scheitelpunkt Typen platziert werden. Zu den Werten gehören die folgenden:

- PT_MOVETO gibt an, dass der entsprechende Punkt in *lppoints* eine nicht zusammenhängende Abbildung startet.

- PT_LINETO gibt an, dass der vorherige Punkt und der entsprechende Punkt in den *lppoints* die Endpunkte einer Zeile sind.

- PT_BEZIERTO gibt an, dass der entsprechende Punkt in *lppoints* ein Steuerungspunkt oder Endpunkt für eine Bzier-Kurve ist.

PT_BEZIERTO Typen treten immer in drei Sätzen auf. Der Punkt in dem Pfad, der unmittelbar vorangestellt ist, definiert den Startpunkt für die Bzier-Kurve. Die ersten beiden PT_BEZIERTO Punkte sind die Steuerungs Punkte, und der dritte PT_BEZIERTO Punkt ist der Endpunkt (sofern hart codiert).

   Ein PT_LINETO oder PT_BEZIERTO Typ kann mit dem folgenden Flag kombiniert werden (mithilfe des bitweisen Operators **oder**), um anzugeben, dass der entsprechende Punkt der letzte Punkt in einer Abbildung ist und dass die Abbildung geschlossen werden soll:

- PT_CLOSEFIGURE gibt an, dass die Abbildung automatisch geschlossen wird, nachdem die entsprechende Linie oder Kurve gezeichnet wurde. Die Abbildung wird geschlossen, indem eine Linie vom Zeilen-oder Kurven Endpunkt bis zu dem Punkt gezeichnet wird, der der letzten PT_MOVETO entspricht.

*nCount*<br/>
Gibt die Gesamtanzahl der [Punkt](/windows/win32/api/windef/ns-windef-point) Datenstrukturen an, die im *lppoints* -Array platziert werden können. Dieser Wert muss mit der Anzahl der Bytes identisch sein, die im *lptypes* -Array platziert werden können.

### <a name="return-value"></a>Rückgabewert

Wenn der *nCount* -Parameter ungleich 0 (null) ist, wird die Anzahl der aufgezählten Punkte angezeigt. Wenn *nCount* 0 (null) ist, wird die Gesamtzahl der Punkte im Pfad (und `GetPath` schreibt nichts in die Puffer). Wenn *nCount* ungleich 0 (null) und kleiner als die Anzahl der Punkte im Pfad ist, ist der Rückgabewert-1.

### <a name="remarks"></a>Bemerkungen

Der Gerätekontext muss einen geschlossenen Pfad enthalten. Die Punkte des Pfads werden in logischen Koordinaten zurückgegeben. Punkte werden in Geräte Koordinaten im Pfad gespeichert, sodass `GetPath` die Punkte von Geräte Koordinaten zu logischen Koordinaten mithilfe der Umkehrung der aktuellen Transformation geändert werden. Die `FlattenPath` Member-Funktion kann vor aufgerufen werden `GetPath` , um alle Kurven im Pfad in Liniensegmente zu konvertieren.

### <a name="example"></a>Beispiel

  Sehen Sie sich das Beispiel für [CDC:: beginpath](#beginpath)an.

## <a name="cdcgetpixel"></a><a name="getpixel"></a>CDC:: GetPixel

Ruft den RGB-Farbwert des Pixels an dem durch *x* und *y*angegebenen Punkt ab.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate des Punkts an, der überprüft werden soll.

*Teenie*<br/>
Gibt die logische y-Koordinate des Punkts an, der überprüft werden soll.

*Punkt*<br/>
Gibt die logischen x-und y-Koordinaten des Punkts an, der überprüft werden soll.

### <a name="return-value"></a>Rückgabewert

Für beide Versionen der Funktion ein RGB-Farbwert für die Farbe des angegebenen Punkts. Der Wert ist-1, wenn die Koordinaten keinen Punkt im Clippingbereich angeben.

### <a name="remarks"></a>Bemerkungen

Der Punkt muss sich im Clippingbereich befinden. Wenn sich der Punkt nicht im Clippingbereich befindet, hat die Funktion keine Auswirkung und gibt-1 zurück.

Nicht alle Geräte unterstützen die `GetPixel`-Funktion. Weitere Informationen finden Sie unter der RC_BITBLT Rasterfunktion unter der [GetDeviceCaps](#getdevicecaps) -Member-Funktion.

Die `GetPixel` Member-Funktion verfügt über zwei Formen. Der erste Wert erfordert zwei Koordinaten Werte. die zweite Komponente nimmt entweder eine [Punkt](/windows/win32/api/windef/ns-windef-point) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) -Objekt an.

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>CDC:: getpolyfillmode

Ruft den aktuellen Polygon Füll Modus ab.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der aktuelle, durch Polygon gefüllte Modus, alternativer oder auffüllender, wenn die Funktion erfolgreich ausgeführt wurde.

### <a name="remarks"></a>Bemerkungen

`SetPolyFillMode`Eine Beschreibung der Polygon Füll Modi finden Sie unter der Member-Funktion.

## <a name="cdcgetrop2"></a><a name="getrop2"></a>CDC:: GetROP2

Ruft den aktuellen Zeichnungsmodus ab.

```
int GetROP2() const;
```

### <a name="return-value"></a>Rückgabewert

Der Zeichnungsmodus. Eine Liste der zeichenmoduswerte finden Sie unter der- `SetROP2` Member-Funktion.

### <a name="remarks"></a>Bemerkungen

Der Zeichnungsmodus gibt an, wie die Farben des Stifts und das Innere von ausgefüllten Objekten mit der Farbe kombiniert werden, die sich bereits auf der Anzeige Oberfläche befindet.

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>CDC:: Geder afehdc

Mit dieser Member-Funktion können Sie [m_hDC](#m_hdc), den Ausgabegeräte Kontext abrufen.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Gerätekontext handle.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion funktioniert auch mit Null-Zeigern.

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>CDC:: getstretchbltmode

Ruft den aktuellen bitmapstreckungs Modus ab.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der Rückgabewert gibt den aktuellen Bitmap-stretchmodus an – STRETCH_ANDSCANS, STRETCH_DELETESCANS oder STRETCH_ORSCANS –, wenn die Funktion erfolgreich ausgeführt wurde.

### <a name="remarks"></a>Bemerkungen

Der Modus für die Bitmap-Streckung definiert, wie Informationen aus Bitmaps entfernt werden, die von der-Element Funktion gestreckt oder komprimiert werden `StretchBlt` .

Die STRETCH_ANDSCANS-und STRETCH_ORSCANS Modi werden in der Regel verwendet, um Vordergrund Pixel in Monochrom-Bitmaps beizubehalten. Der STRETCH_DELETESCANS Modus wird normalerweise verwendet, um die Farbe in Farb Bitmaps beizubehalten.

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>CDC:: gettabbedtextextent

Mit dieser Member-Funktion können Sie die Breite und Höhe einer Zeichenfolge mit [m_hAttribDC](#m_hattribdc), dem Attribut Gerätekontext, berechnen.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parameter

*lpszstring*<br/>
Verweist auf eine Zeichenfolge. Sie können auch ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt für diesen Parameter übergeben.

*nCount*<br/>
Gibt die [Länge der Zeichenfolge](/windows/win32/gdi/specifying-length-of-text-output-string) an, auf die von *lpszstring*verwiesen wird.

*ntabpositionen*<br/>
Gibt die Anzahl der Tabstopp Positionen im Array an, auf die von *lpntabstoppositions*verwiesen wird.

*lpntabstoppositions*<br/>
Verweist auf ein Array von ganzen Zahlen, das die Position der Tabstopps in logischen Einheiten enthält. Die Tabstopps müssen in steigender Reihenfolge sortiert werden. der kleinste x-Wert sollte das erste Element im Array sein. Zurück-Registerkarten sind nicht zulässig.

*str*<br/>
Ein- `CString` Objekt, das die angegebenen Zeichen enthält, die gezeichnet werden sollen.

### <a name="return-value"></a>Rückgabewert

Die Dimensionen der Zeichenfolge (in logischen Einheiten) in einem [CSize](../../atl-mfc-shared/reference/csize-class.md) -Objekt.

### <a name="remarks"></a>Bemerkungen

Wenn die Zeichenfolge ein oder mehrere Tabstopps enthält, basiert die Breite der Zeichenfolge auf den durch *lpntabstoppositions*angegebenen Tabstopps. Die-Funktion verwendet die aktuell ausgewählte Schriftart, um die Dimensionen der Zeichenfolge zu berechnen.

Der aktuelle Clippingbereich versetzt nicht die von der Funktion zurückgegebene Breite und Höhe `GetTabbedTextExtent` .

Da einige Geräte keine Zeichen in regulären Zell Arrays platzieren (d. h., Sie setzen die Zeichen ein), ist die Summe der Werte Blöcke in einer Zeichenfolge möglicherweise nicht gleich dem Wertebereich der Zeichenfolge.

Wenn *ntabpositions* den Wert 0 hat und *lpntabstoppositions* den Wert NULL hat, werden die Registerkarten auf das Achtfache der durchschnittlichen Zeichenbreite erweitert. Wenn *ntabpositions* den Wert 1 hat, wird die Tabstopps durch die Entfernung getrennt, die durch den ersten Wert im Array festgelegt wird, auf den *lpntabstoppositions* verweist. Wenn *lpntabstoppositions* auf mehr als einen einzelnen Wert zeigt, wird für jeden Wert im Array ein Tabstopp festgelegt, bis zu der von *ntabpositions*angegebenen Zahl.

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>CDC:: gettextalign

Ruft den Status der Flags für die Textausrichtung für den Gerätekontext ab.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Rückgabewert

Der Status der Flags für die Textausrichtung. Der Rückgabewert ist einer oder mehrere der folgenden Werte:

- TA_BASELINE gibt die Ausrichtung der x-Achse und die Baseline der ausgewählten Schriftart innerhalb des umgebenden Rechtecks an.

- TA_BOTTOM gibt die Ausrichtung der x-Achse und den unteren Rand des umgebenden Rechtecks an.

- TA_CENTER gibt die Ausrichtung der y-Achse und der Mitte des umgebenden Rechtecks an.

- TA_LEFT gibt die Ausrichtung der y-Achse und der linken Seite des umgebenden Rechtecks an.

- TA_NOUPDATECP gibt an, dass die aktuelle Position nicht aktualisiert wird.

- TA_RIGHT gibt die Ausrichtung der y-Achse und der rechten Seite des umgebenden Rechtecks an.

- TA_TOP gibt die Ausrichtung der x-Achse und des oberen Rands des umgebenden Rechtecks an.

- TA_UPDATECP gibt an, dass die aktuelle Position aktualisiert wird.

### <a name="remarks"></a>Bemerkungen

Die Flags für die Textausrichtung legen fest `TextOut` , wie die-und- `ExtTextOut` Member-Funktionen eine Text Zeichenfolge in Relation zum Anfangspunkt der Zeichenfolge ausrichten. Die Flags für die Textausrichtung sind nicht notwendigerweise Einzelbit-Flags und können gleich 0 sein. Um zu testen, ob ein Flag festgelegt ist, sollte eine Anwendung die folgenden Schritte ausführen:

1. Wenden Sie den bitweisen OR-Operator auf das Flag und seine zugehörigen Flags an, die wie folgt gruppiert werden:

   - TA_LEFT, TA_CENTER und TA_RIGHT

   - TA_BASELINE, TA_BOTTOM und TA_TOP

   - TA_NOUPDATECP und TA_UPDATECP

1. Wenden Sie den bitweisen AND-Operator auf das Ergebnis und den Rückgabewert von an `GetTextAlign` .

1. Testen Sie die Gleichheit dieses Ergebnisses und des-Flags.

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>CDC:: gettextcharakteriextra

Ruft die aktuelle Einstellung für die Menge der intercharacter-Abstände ab.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Rückgabewert

Die Menge des intercharacter-Abstands.

### <a name="remarks"></a>Bemerkungen

GDI fügt jedem Zeichen diesen Abstand hinzu, einschließlich der Break-Zeichen, wenn eine Textzeile in den Gerätekontext geschrieben wird.

Der Standardwert für die Menge der intercharacter-Abstände ist 0.

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>CDC:: gettextcolor

Ruft die aktuelle Textfarbe ab.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Rückgabewert

Die aktuelle Textfarbe als RGB-Farbwert.

### <a name="remarks"></a>Bemerkungen

Die Textfarbe ist die Vordergrundfarbe von Zeichen, die mithilfe der GDI-Textausgabe Element Funktionen " [TextOut](#textout)", " [exttextout](#exttextout)" und " [tabbedtextout](#tabbedtextout)" gezeichnet werden.

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>CDC:: GetTextExtent

Mit dieser Member-Funktion können Sie die Breite und Höhe einer Textzeile mithilfe der aktuellen Schriftart berechnen, um die Dimensionen zu bestimmen.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parameter

*lpszstring*<br/>
Verweist auf eine Zeichenfolge. Sie können auch ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt für diesen Parameter übergeben.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an.

*str*<br/>
Ein- `CString` Objekt, das die angegebenen Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Die Dimensionen der Zeichenfolge (in logischen Einheiten) in einem [CSize](../../atl-mfc-shared/reference/csize-class.md) -Objekt.

### <a name="remarks"></a>Bemerkungen

Die Informationen werden aus [m_hAttribDC](#m_hattribdc)abgerufen, dem Attribut Gerätekontext.

Standardmäßig `GetTextExtent` geht davon aus, dass der Text, für den die Dimension abgerufen wird, entlang einer horizontalen Linie festgelegt wird (d. h., das escapeselement ist 0). Wenn Sie eine Schriftart erstellen, die ein escapesfeld ungleich 0 (null) angibt, müssen Sie den Winkel des Texts explizit konvertieren, um die Dimensionen der Zeichenfolge zu erhalten.

Der aktuelle Clippingbereich wirkt sich nicht auf die von zurückgegebene Breite und Höhe aus `GetTextExtent` .

Da einige Geräte keine Zeichen in regulären Zell Arrays platzieren (d. h., Sie führen die kernung aus), ist die Summe der Werte Blöcke in einer Zeichenfolge möglicherweise nicht gleich dem Wertebereich der Zeichenfolge.

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>CDC:: gettextextentexpointi

Ruft die Anzahl der Zeichen in einer angegebenen Zeichenfolge ab, die in einen angegebenen Bereich passen und ein Array mit dem TextBlock für jedes dieser Zeichen füllt.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*pgiin*<br/>
Ein Zeiger auf ein Array von Symbol Indizes, für die Blöcke abgerufen werden sollen.

*CGI*<br/>
Gibt die Anzahl der Symbole im Array an, auf die durch *pgiin*verwiesen wird.

*nmaxblock*<br/>
Gibt die maximale zulässige Breite (in logischen Einheiten) der formatierten Zeichenfolge an.

*lpnfit*<br/>
Ein Zeiger auf eine ganze Zahl, die die Anzahl der Zeichen angibt, die in den durch *nmaxblock*angegebenen Bereich passen. Wenn *lpnfit* NULL ist, wird *nmaxblock* ignoriert.

*alpdx*<br/>
Ein Zeiger auf ein Array von ganzen Zahlen, das partielle Symbol Blöcke empfängt. Jedes Element im Array gibt den Abstand zwischen dem Anfang des Symbols für das Symbol Indizes und einem der Symbole, die in den durch *nmaxblock*angegebenen Raum passen, in logischen Einheiten an. Obwohl dieses Array mindestens so viele Elemente aufweisen muss wie die von *CGI*angegebenen Symbol Indizes, füllt die Funktion das Array nur für so viele Symbol Indizes, wie von *lpnfit*angegeben. Wenn *lpndx* den Wert NULL hat, berechnet die Funktion keine partiellen Zeichen folgen breiten.

*lpsize*<br/>
Ein Zeiger auf eine [Größen](/windows/win32/api/windef/ns-windef-size) Struktur, die die Dimensionen des Symbols für die Glyphe-Indizes in logischen Einheiten empfängt. Dieser Wert darf nicht NULL sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion emuliert die Funktionalität der [gettextextentexpointi](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi)-Funktion, wie im Windows SDK beschrieben.

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>CDC:: gettextextentpointi

Ruft die Breite und Höhe des angegebenen Arrays von Symbol Indizes ab.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*pgiin*<br/>
Ein Zeiger auf ein Array von Symbol Indizes, für die Blöcke abgerufen werden sollen.

*CGI*<br/>
Gibt die Anzahl der Symbole im Array an, auf die durch *pgiin*verwiesen wird.

*lpsize*<br/>
Ein Zeiger auf eine [Größen](/windows/win32/api/windef/ns-windef-size) Struktur, die die Dimensionen des Symbols für die Glyphe-Indizes in logischen Einheiten empfängt. Dieser Wert darf nicht NULL sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion emuliert die Funktionalität der [gettextextentpointi](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi)-Funktion, wie im Windows SDK beschrieben.

## <a name="cdcgettextface"></a><a name="gettextface"></a>CDC:: gettextface

Mit dieser Member-Funktion wird der Schriftart Name der aktuellen Schriftart in einen Puffer kopiert.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parameter

*nCount*<br/>
Gibt die Größe des Puffers an (in Bytes). Wenn der Schriftart Name länger ist als die Anzahl der Bytes, die durch diesen Parameter angegeben werden, wird der Name abgeschnitten.

*lpszfakename*<br/>
Zeigt auf den Puffer für den Schriftart Namen.

*RString*<br/>
Ein Verweis auf ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt.

### <a name="return-value"></a>Rückgabewert

Die Anzahl der Bytes, die in den Puffer kopiert werden, ohne das abschließende Null Zeichen. Der Wert ist 0, wenn ein Fehler auftritt.

### <a name="remarks"></a>Bemerkungen

Der Schriftart Name wird als NULL-terminierte Zeichenfolge kopiert.

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>CDC:: GetTextMetrics

Ruft die Metriken für die aktuelle Schriftart mithilfe des Attribut Geräte Kontexts ab.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parameter

*lpmetrics*<br/>
Verweist auf die [textmetrikstruktur](/windows/win32/api/wingdi/ns-wingdi-textmetricw) , die die Metriken empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>CDC:: getviewportext

Ruft die x-und y-Blöcke des Viewports des Geräte Kontexts ab.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Rückgabewert

Die x-und y-Blöcke (in Geräte Einheiten) als- `CSize` Objekt.

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>CDC:: getviewportor g

Ruft die x-und y-Koordinaten des Ursprungs des Viewports ab, der dem Gerätekontext zugeordnet ist.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Rückgabewert

Der Ursprung des Viewports (in Geräte Koordinaten) als- `CPoint` Objekt.

## <a name="cdcgetwindow"></a><a name="getwindow"></a>CDC:: GetWindow

Gibt das Fenster zurück, das dem Anzeigegeräte Kontext zugeordnet ist.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf ein- `CWnd` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Dies ist eine erweiterte Funktion. Diese Member-Funktion kann beispielsweise das Ansichts Fenster beim Drucken oder in der Seitenansicht nicht zurückgeben. Er gibt immer das Fenster zurück, das der Ausgabe zugeordnet ist. Ausgabefunktionen, die den angegebenen Domänen Controller verwenden, zeichnen in dieses Fenster.

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>CDC:: getwindowext

Ruft die x-und y-Blöcke des Fensters ab, das dem Gerätekontext zugeordnet ist.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Rückgabewert

Die x-und y-Blöcke (in logischen Einheiten) als- `CSize` Objekt.

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>CDC:: getwindoworg

Ruft die x-und y-Koordinaten des Ursprungs des Fensters ab, das dem Gerätekontext zugeordnet ist.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Rückgabewert

Der Ursprung des Fensters (in logischen Koordinaten) als- `CPoint` Objekt.

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>CDC:: getworldtransform

Ruft die aktuelle Transformation für Welt Raum zu Seiten Raum ab.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parameter

*rxform*<br/>
Verweis auf eine [XForm](/windows/win32/api/wingdi/ns-wingdi-xform) -Struktur, die die aktuelle Transformation für Welt Raum zu Seiten Raum empfängt.

### <a name="return-value"></a>Rückgabewert

Gibt bei Erfolg einen Wert ungleich 0 (null) zurück.

Gibt bei einem Fehler 0 zurück.

Um erweiterte Fehlerinformationen abzurufen, nennen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Bemerkungen

Diese Methode umschließt die Windows-GDI-Funktion [getworldtransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform).

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>CDC:: GradientFill

Mit dieser Member-Funktion können Sie Rechteck-und Dreieck Strukturen mit Farben auffüllen, die nahtlos von einer Seite zur anderen Seite ausgeblendet werden.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parameter

*pvertices*<br/>
Zeiger auf ein Array von [trivertex](/windows/win32/api/wingdi/ns-wingdi-trivertex) -Strukturen, die jeweils einen Dreiecks Scheitelpunkt definieren.

*nvertices*<br/>
Die Anzahl der Scheitel Punkte.

*pmesh*<br/>
Array von [GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) Strukturen im Dreiecks Modus oder ein Array von [GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) Strukturen im Rechteck Modus.

*nmeshelements*<br/>
Die Anzahl der Elemente (Dreiecke oder Rechtecke) im *pmesh*.

*dwmode*<br/>
Gibt den Füll Modus für den Verlauf an Eine Liste möglicher Werte finden [Sie unter GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) in der Windows SDK.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Bemerkungen

Weitere Informationen finden Sie unter `GradientFill` in der Windows SDK.

## <a name="cdcgraystring"></a><a name="graystring"></a>CDC:: graystring

Zeichnet abgeblendet (grauer) Text an der angegebenen Position, indem der Text in eine Speicher Bitmap geschrieben wird, das Bitmap abgeblendet und dann die Bitmap in die Anzeige kopiert wird.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*pbrush*<br/>
Gibt den Pinsel an, der zum Dimmen (Graying) verwendet werden soll.

*lpfnoutput*<br/>
Gibt die Prozedur-instanzadresse der von der Anwendung bereitgestellten Rückruffunktion an, mit der die Zeichenfolge gezeichnet wird. Weitere Informationen finden Sie in der Beschreibung der Windows- `OutputFunc` [Rückruffunktion](callback-functions-used-by-mfc.md#graystring). Wenn dieser Parameter NULL ist, verwendet das System die Windows `TextOut` -Funktion, um die Zeichenfolge zu zeichnen, und *lpdata* wird als Long-Zeiger auf die Zeichenfolge angenommen, die ausgegeben werden soll.

*lpdata*<br/>
Gibt einen entfernten Zeiger auf Daten an, die an die Output-Funktion weitergegeben werden sollen. Wenn *lpfnoutput* NULL ist, muss *lpdata* ein langer Zeiger auf die auszugabeende Zeichenfolge sein.

*nCount*<br/>
Gibt die Anzahl von Zeichen an, die ausgegeben werden sollen. Wenn dieser Parameter 0 ist, wird `GrayString` die Länge der Zeichenfolge berechnet (vorausgesetzt, dass *lpdata* ein Zeiger auf die Zeichenfolge ist). Wenn *nCount* 1 ist und die Funktion, auf die von *lpfnoutput* verwiesen wird, 0 zurückgibt, wird das Bild angezeigt, aber nicht abgeblendet.

*x*<br/>
Gibt die logische x-Koordinate der Anfangsposition des Rechtecks an, das die Zeichenfolge einschließt.

*Teenie*<br/>
Gibt die logische y-Koordinate der Anfangsposition des Rechtecks an, das die Zeichenfolge einschließt.

*nwidth*<br/>
Gibt die Breite (in logischen Einheiten) des Rechtecks an, das die Zeichenfolge einschließt. Wenn *nwidth* den Wert 0 hat, wird `GrayString` die Breite des Bereichs berechnet, vorausgesetzt, *lpdata* ist ein Zeiger auf die Zeichenfolge.

*nheight*<br/>
Gibt die Höhe (in logischen Einheiten) des Rechtecks an, das die Zeichenfolge einschließt. Wenn *nheight* den Wert 0 hat, wird `GrayString` die Höhe des Bereichs berechnet, vorausgesetzt, *lpdata* ist ein Zeiger auf die Zeichenfolge.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn die Zeichenfolge gezeichnet wird, oder 0 (null), wenn die `TextOut` Funktion oder die von der Anwendung bereitgestellte Ausgabefunktion 0 zurückgegeben hat, oder, wenn nicht genügend Arbeitsspeicher vorhanden ist, um eine Speicher Bitmap zum

### <a name="remarks"></a>Bemerkungen

Die-Funktion gibt den Text unabhängig vom ausgewählten Pinsel und Hintergrund aus. Die `GrayString` Member-Funktion verwendet die aktuell ausgewählte Schriftart. Der MM_TEXT Zuordnungs Modus muss vor der Verwendung dieser Funktion ausgewählt werden.

Eine Anwendung kann Abgebundene (abgefüllte) Zeichen folgen auf Geräten zeichnen, die eine voll tongraue Farbe unterstützen, ohne die Member-Funktion aufzurufende `GrayString` . Die System Farbe COLOR_GRAYTEXT ist die voll tongraue System Farbe, die zum Zeichnen von deaktiviertem Text verwendet wird. Die Anwendung kann die `GetSysColor` Windows-Funktion aufrufen, um den Farbwert COLOR_GRAYTEXT abzurufen. Wenn die Farbe nicht 0 (schwarz) ist, kann die Anwendung die `SetTextColor` Member-Funktion aufrufen, um die Textfarbe auf den Farbwert festzulegen, und die Zeichenfolge dann direkt zeichnen. Wenn die abgerufene Farbe schwarz ist, muss die Anwendung `GrayString` den Text Abblenden (grau).

Wenn *lpfnoutput* den Wert NULL hat, verwendet GDI die Windows- [TextOut](/windows/win32/api/wingdi/nf-wingdi-textoutw) -Funktion, und es wird davon ausgegangen, dass *lpdata* ein weitaus Zeiger auf das auszulegende Zeichen ist. Wenn die auszustellenden Zeichen nicht von der Element Funktion behandelt werden können (z. b. Wenn `TextOut` die Zeichenfolge als Bitmap gespeichert ist), muss die Anwendung eine eigene Ausgabefunktion bereitstellen.

Beachten Sie außerdem, dass alle Rückruf Funktionen Microsoft Foundation-Ausnahmen vor der Rückgabe an Windows abfangen müssen, da Ausnahmen nicht über Rückruf Grenzen hinweg ausgelöst werden können. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).

Die an übergebenen Rückruffunktion `GrayString` muss die **`__stdcall`** -Aufruf Konvention verwenden und muss mit exportiert werden **`__declspec`** .

Wenn sich das Framework im Vorschaumodus befindet, wird ein Aufruf der `GrayString` Member-Funktion in einen `TextOut` -Aufruf übersetzt, und die Rückruffunktion wird nicht aufgerufen.

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>CDC:: himetricdedp

Verwenden Sie diese Funktion, wenn Sie himetrikgrößen von OLE in Pixel konvertieren.

```cpp
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpsize*<br/>
Verweist auf eine [Größen](/windows/win32/api/windef/ns-windef-size) Struktur oder ein [CSize](../../atl-mfc-shared/reference/csize-class.md) -Objekt.

### <a name="remarks"></a>Bemerkungen

Wenn der Kartenmodus des Gerätekontext Objekts MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC oder MM_HIMETRIC ist, basiert die Konvertierung auf der Anzahl der Pixel im physischen Zoll. Wenn der Kartenmodus einem der anderen nicht eingeschränkten Modi entspricht (z. b. MM_TEXT), basiert die Konvertierung auf der Anzahl der Pixel im logischen Zoll.

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>CDC:: himetrictolp

Mit dieser Funktion können Sie HIMETRIC-Einheiten in logische Einheiten konvertieren.

```cpp
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpsize*<br/>
Verweist auf eine [Größen](/windows/win32/api/windef/ns-windef-size) Struktur oder ein [CSize](../../atl-mfc-shared/reference/csize-class.md) -Objekt.

### <a name="remarks"></a>Bemerkungen

Verwenden Sie diese Funktion, wenn Sie die himetrikgrößen von OLE erhalten und Sie in den natürlichen Zuordnungs Modus Ihrer Anwendung konvertieren möchten.

Die Konvertierung erfolgt durch das erste Konvertieren der HIMETRIC-Einheiten in Pixel und das anschließende Konvertieren dieser Einheiten in logische Einheiten mithilfe der aktuellen Mapping-Einheiten des Geräte Kontexts. Beachten Sie, dass sich die Blöcke für das Fenster und den Viewport des Geräts auf das Ergebnis auswirken.

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>CDC:: IntersectClipRect

Erstellt einen neuen Clippingbereich, indem die Schnittmenge des aktuellen Bereichs und des Rechtecks gebildet wird, das von *x1*, *Y1*, *x2*und *Y2*angegeben wird.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Rechtecks an.

*Y1*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks an.

*x2*<br/>
Gibt die logische x-Koordinate der unteren rechten Ecke des Rechtecks an.

*Y2*<br/>
Gibt die logische y-Koordinate der unteren rechten Ecke des Rechtecks an.

*lprect*<br/>
Gibt das Rechteck an. Sie können entweder ein- `CRect` Objekt oder einen-Zeiger an eine- `RECT` Struktur für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Der Typ des neuen Clippingbereichs. Es kann sich um einen der folgenden Werte handeln:

- Der neue Ausschneide Bereich von complexregion weist überlappende Rahmen auf.

- Fehler beim Gerätekontext.

- Der neue Clippingbereich der NULLREGION ist leer.

- Der neue Ausschneide Bereich der simpleregion weist keine überlappenden Rahmen auf.

### <a name="remarks"></a>Bemerkungen

GDI schneidet alle nachfolgenden Ausgaben an die neue Grenze an. Breite und Höhe dürfen nicht größer sein als 32.767.

## <a name="cdcinvertrect"></a><a name="invertrect"></a>CDC:: invertrect

Kehrt den Inhalt des angegebenen Rechtecks um.

```cpp
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Verweist auf eine `RECT` , die die logischen Koordinaten des Rechtecks enthält, das invertiert werden soll. Sie können auch ein- `CRect` Objekt für diesen Parameter übergeben.

### <a name="remarks"></a>Bemerkungen

Inversion ist eine logische NOT-Operation und kippt die Bits jedes Pixels. In monochrome zeigt die Funktion weiße Pixel schwarz und schwarz Pixel weiß an. Bei Farbanzeige hängt die Inversion davon ab, wie Farben für die Anzeige generiert werden. Wenn `InvertRect` Sie zweimal mit dem gleichen Rechteck aufrufen, wird die Anzeige in den vorherigen Farben wieder hergestellt.

Wenn das Rechteck leer ist, wird nichts gezeichnet.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>CDC:: invertrgn

Kehrt die Farben in dem durch *PRGN*angegebenen Bereich um.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parameter

*PRGN*<br/>
Identifiziert den Bereich, der invertiert werden soll. Die Koordinaten für den Bereich werden in logischen Einheiten angegeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

In monochrome zeigt die Funktion weiße Pixel schwarz und schwarz Pixel weiß an. Bei Farben zeigt die Inversion an, wie die Farben für die Anzeige generiert werden.

## <a name="cdcisprinting"></a><a name="isprinting"></a>CDC:: IsPrinting

Bestimmt, ob der Gerätekontext zum Drucken verwendet wird.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn das `CDC` Objekt ein Drucker-DC ist; andernfalls 0.

## <a name="cdclineto"></a><a name="lineto"></a>CDC:: LineTo

Zeichnet eine Linie von der aktuellen Position bis zum, jedoch nicht einschließlich, dem durch *x* und *y* (oder *Punkt*) angegebenen Punkt.

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate des Endpunkts für die Zeile an.

*Teenie*<br/>
Gibt die logische y-Koordinate des Endpunkts für die Zeile an.

*Punkt*<br/>
Gibt den Endpunkt für die Zeile an. Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn die Zeile gezeichnet wird. andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Die Zeile wird mit dem ausgewählten Stift gezeichnet. Die aktuelle Position ist auf " *x*", " *y* " oder " *Point*" festgelegt.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CRect:: Centerpoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdclptodp"></a><a name="lptodp"></a>CDC:: lptodp

Konvertiert logische Einheiten in Geräte Einheiten.

```cpp
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von Punkten. Jeder Punkt im Array ist eine [Punkt](/windows/win32/api/windef/ns-windef-point) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) -Objekt.

*nCount*<br/>
Die Anzahl der Punkte im Array.

*lprect*<br/>
Verweist auf eine [Rect](/windows/win32/api/windef/ns-windef-rect) -Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt. Dieser Parameter wird bei der Zuordnung eines Rechtecks zwischen logischen und Geräte Einheiten verwendet.

*lpsize*<br/>
Verweist auf eine [Größen](/windows/win32/api/windef/ns-windef-size) Struktur oder ein [CSize](../../atl-mfc-shared/reference/csize-class.md) -Objekt.

### <a name="remarks"></a>Bemerkungen

Die-Funktion ordnet die Koordinaten der einzelnen Punkte oder Dimensionen einer Größe vom logischen Koordinatensystem von GDI in ein Geräte Koordinatensystem zu. Die Konvertierung hängt vom aktuellen Mapping-Modus und den Einstellungen der Ursprünge und Blöcke des Geräte Fensters und des Viewports ab.

Die x-und y-Koordinaten von Punkten sind 2-Byte-Ganzzahlen mit Vorzeichen im Bereich von-32.768 bis 32.767. In Fällen, in denen der Zuordnungsmodus zu Werten führt, die diese Grenzwerte überschreiten, legt das System die Werte auf-32.768 bzw. 32.767 fest.

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>CDC:: lptohimetric

Mit dieser Funktion können Sie logische Einheiten in HIMETRIC-Einheiten konvertieren.

```cpp
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpsize*<br/>
Verweist auf eine- `SIZE` Struktur oder ein- `CSize` Objekt.

### <a name="remarks"></a>Bemerkungen

Verwenden Sie diese Funktion, wenn Sie die himetrikgrößen an OLE übergeben, indem Sie den natürlichen Mapping-Modus Ihrer Anwendung verwenden. Beachten Sie, dass sich die Blöcke für das Fenster und den Viewport des Geräts auf das Ergebnis auswirken.

Die Konvertierung erfolgt durch das erste Konvertieren der logischen Einheiten in Pixel mithilfe der aktuellen Mapping-Einheiten des Geräte Kontexts und das anschließende Konvertieren dieser Einheiten in HIMETRIC-Einheiten.

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>CDC:: m_hAttribDC

Der Attribut Gerätekontext für dieses- `CDC` Objekt.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Bemerkungen

Standardmäßig ist dieser Gerätekontext gleich `m_hDC` . Im allgemeinen `CDC` werden GDI-Aufrufe, die Informationen aus dem Gerätekontext anfordern, an weitergeleitet `m_hAttribDC` . Weitere Informationen zur Verwendung dieser beiden Geräte Kontexte finden Sie in der Beschreibung der [CDC](../../mfc/reference/cdc-class.md) -Klasse.

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>CDC:: m_hDC

Der Ausgabegeräte Kontext für dieses- `CDC` Objekt.

```
HDC m_hDC;
```

### <a name="remarks"></a>Bemerkungen

Standardmäßig `m_hDC` ist gleich `m_hAttribDC` , der andere Gerätekontext, der von umschließt wird `CDC` . Im allgemeinen wechseln `CDC` GDI-Aufrufe, die die Ausgabe erstellen, in den `m_hDC` Gerätekontext. Sie können auf verschiedene Geräte initialisieren und auf diese `m_hDC` `m_hAttribDC` verweisen. Weitere Informationen zur Verwendung dieser beiden Geräte Kontexte finden Sie in der Beschreibung der [CDC](../../mfc/reference/cdc-class.md) -Klasse.

## <a name="cdcmaskblt"></a><a name="maskblt"></a>CDC:: MaskBlt

Kombiniert die Farbdaten für die Quell-und Ziel Bitmaps mithilfe der angegebenen Maske und des Raster Vorgangs.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Ziel Rechtecks an.

*Teenie*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Ziel Rechtecks an.

*nwidth*<br/>
Gibt die Breite (in logischen Einheiten) des Ziel Rechtecks und der Quell Bitmap an.

*nheight*<br/>
Gibt die Höhe des Ziel Rechtecks und der Quell Bitmap in logischen Einheiten an.

*psrcdc*<br/>
Identifiziert den Gerätekontext, von dem aus die Bitmap kopiert werden soll. Der Wert muss 0 (null) lauten, wenn der *dwrop* -Parameter einen Raster Vorgang angibt, der keine Quelle enthält.

*xsrc*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke der Quell Bitmap an.

*ysrc*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke der Quell Bitmap an.

*maskbitmap*<br/>
Gibt die Monochrom-Masken Bitmap in Kombination mit der Farb Bitmap im Quell Gerätekontext an.

*xmask*<br/>
Gibt den horizontalen Pixel Offset für die Maske-Bitmap an, die durch den *maskbitmap* -Parameter angegeben wird.

*ymask*<br/>
Gibt den vertikalen Pixel Offset für die Maske-Bitmap an, die durch den *maskbitmap* -Parameter angegeben wird.

*dwRop*<br/>
Gibt sowohl Vordergrund-als auch im Hintergrund ternäre Raster Vorgangs Codes an, die die Funktion verwendet, um die Kombination von Quell-und Zieldaten zu steuern. Der Code für den Hintergrund Raster Vorgang wird im hohen Byte des hohen Worts dieses Werts gespeichert. der Code des Vordergrund-Raster Vorgangs wird im unteren Byte des hohen Worts dieses Werts gespeichert. das niedrige Wort dieses Werts wird ignoriert und sollte NULL sein. Mit dem Makro MAKEROP4 werden solche Kombinationen aus Vordergrund-und Hintergrund Raster-Vorgangs Codes erstellt. Im Abschnitt "Hinweise" finden Sie eine Erörterung von Vordergrund und Hintergrund im Kontext dieser Funktion. `BitBlt`Eine Liste der allgemeinen Raster Vorgangs Codes finden Sie unter der Member-Funktion.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Wert 1 in der durch *maskbitmap* angegebenen Maske gibt an, dass der von *dwrop* angegebene Vordergrund-Raster Vorgangs Code an dieser Stelle angewendet werden soll. Der Wert 0 in der Maske gibt an, dass der von *dwrop* angegebene Hintergrund Raster-Vorgangs Code an dieser Stelle angewendet werden soll. Wenn für die Raster Vorgänge eine Quelle erforderlich ist, muss das Masken Rechteck das Quell Rechteck abdecken. Wenn dies nicht der Fall ist, tritt bei der Funktion ein Fehler auf. Wenn für die Raster Vorgänge keine Quelle erforderlich ist, muss das Masken Rechteck das Ziel Rechteck abdecken. Wenn dies nicht der Fall ist, tritt bei der Funktion ein Fehler auf.

Wenn beim Aufrufen dieser Funktion eine Drehung oder eine scherungs Transformation für den Quell Gerätekontext wirksam ist, tritt ein Fehler auf. Andere Arten von Transformationen sind jedoch zulässig.

Wenn sich die Farb Formate der Quell-, Muster-und Ziel Bitmaps unterscheiden, konvertiert diese Funktion das Muster oder das Quellformat (oder beides), damit Sie dem Zielformat entspricht. Wenn es sich bei der Mask-Bitmap nicht um eine monochrome Bitmap handelt, tritt ein Fehler auf. Wenn eine erweiterte Metadatei aufgezeichnet wird, tritt ein Fehler auf (und die Funktion gibt 0 zurück), wenn der Quell Gerätekontext einen erweiterten Metadatei-Gerätekontext identifiziert. Nicht alle Geräte werden unterstützt `MaskBlt` . Eine Anwendung sollte anrufen `GetDeviceCaps` , um zu bestimmen, ob ein Gerät diese Funktion unterstützt. Wenn keine Maske-Bitmap angegeben wird, verhält sich diese Funktion wie bei `BitBlt` Verwendung des Vordergrund-Raster Vorgangs Codes. Die Pixel Offsets in der Mask-Bitmap werden dem Punkt (0,0) in der Bitmap des Quell Geräte Kontexts zugeordnet. Dies ist nützlich für Fälle, in denen eine Masken Bitmap eine Reihe von Masken enthält. eine Anwendung kann Sie problemlos auf eine Maskierungs Aufgabe anwenden, indem die Pixel Offsets und Rechteck Größen angepasst werden, die an gesendet werden `MaskBlt` .

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>CDC:: modifyworldtransform

Ändert die globale Transformation für einen Gerätekontext unter Verwendung des angegebenen Modus.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parameter

*rxform*<br/>
Verweis auf eine [XForm](/windows/win32/api/wingdi/ns-wingdi-xform) -Struktur, die verwendet wird, um die Welt Transformation für den angegebenen Gerätekontext zu ändern.

*iMode*<br/>
Gibt an, wie die Transformations Daten die aktuelle globale Transformation ändern. Eine Liste der Werte, die dieser Parameter annehmen kann, finden Sie unter [modifyworldtransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Rückgabewert

Gibt bei Erfolg einen Wert ungleich 0 (null) zurück.

Gibt bei einem Fehler 0 zurück.

Um erweiterte Fehlerinformationen abzurufen, nennen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Bemerkungen

Diese Methode umschließt die Windows-GDI-Funktion [modifyworldtransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

## <a name="cdcmoveto"></a><a name="moveto"></a>CDC:: muveto

Verschiebt die aktuelle Position an den durch *x* und *y* angegebenen Punkt (oder nach *Punkt*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate der neuen Position an.

*Teenie*<br/>
Gibt die logische y-Koordinate der neuen Position an.

*Punkt*<br/>
Gibt die neue Position an. Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Die x-und y-Koordinaten der vorherigen Position als- `CPoint` Objekt.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CRect:: Centerpoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>CDC:: offsetcliprgn

Verschiebt den Ausschneide Bereich des Geräte Kontexts um die angegebenen Offsets.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die Anzahl der logischen Einheiten an, nach links oder rechts verschoben werden soll.

*Teenie*<br/>
Gibt die Anzahl der logischen Einheiten an, die nach oben oder unten verschoben werden.

*size*<br/>
Gibt die zu Offset Bare Menge an.

### <a name="return-value"></a>Rückgabewert

Der Typ der neuen Region. Es kann sich um einen der folgenden Werte handeln:

- Der complexregion-Ausschneide Bereich weist überlappende Rahmen auf.

- Fehler beim Gerätekontext.

- Der NULLREGION-Clippingbereich ist leer.

- Der simpleregion-Clippingbereich hat keine überlappenden Rahmen.

### <a name="remarks"></a>Bemerkungen

Die-Funktion verschiebt die Einheiten *x* -Einheiten entlang der x-Achse und *y* -Einheiten entlang der y-Achse.

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>CDC:: offsetviewportor

Ändert die Koordinaten des viewportursprungs in Relation zu den Koordinaten des aktuellen viewportursprungs.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*nwidth*<br/>
Gibt die Anzahl der Geräte Einheiten an, die der x-Koordinate des aktuellen Ursprungs hinzugefügt werden sollen.

*nheight*<br/>
Gibt die Anzahl der Geräte Einheiten an, die der y-Koordinate des aktuellen Ursprungs hinzugefügt werden sollen.

### <a name="return-value"></a>Rückgabewert

Der vorherige Viewportursprung (in Geräte Koordinaten) als- `CPoint` Objekt.

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>CDC:: offsetwindoworg

Ändert die Koordinaten des Fenster Ursprungs in Relation zu den Koordinaten des aktuellen Fenster Ursprungs.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*nwidth*<br/>
Gibt die Anzahl der logischen Einheiten an, die der x-Koordinate des aktuellen Ursprungs hinzugefügt werden sollen.

*nheight*<br/>
Gibt die Anzahl der logischen Einheiten an, die der y-Koordinate des aktuellen Ursprungs hinzugefügt werden sollen.

### <a name="return-value"></a>Rückgabewert

Der vorherige Fenster Ursprung (in logischen Koordinaten) als- `CPoint` Objekt.

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>CDC:: Operator-HDC

Verwenden Sie diesen Operator, um das Gerätekontext Handle des- `CDC` Objekts abzurufen.

```
operator HDC() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn erfolgreich, das Handle des Gerätekontext Objekts. andernfalls NULL.

### <a name="remarks"></a>Bemerkungen

Sie können das Handle verwenden, um Windows-APIs direkt aufzurufen.

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>CDC::P aintrgn

Füllt den durch *PRGN* angegebenen Bereich mithilfe des aktuellen Pinsels.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parameter

*PRGN*<br/>
Identifiziert den Bereich, der ausgefüllt werden soll. Die Koordinaten für den angegebenen Bereich werden in logischen Einheiten angegeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

## <a name="cdcpatblt"></a><a name="patblt"></a>CDC::P atblt

Erstellt ein Bitmuster auf dem Gerät.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate der oberen linken Ecke des Rechtecks an, das das Muster empfangen soll.

*Teenie*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks an, das das Muster empfangen soll.

*nwidth*<br/>
Gibt die Breite (in logischen Einheiten) des Rechtecks an, das das Muster empfangen soll.

*nheight*<br/>
Gibt die Höhe (in logischen Einheiten) des Rechtecks an, das das Muster empfangen soll.

*dwRop*<br/>
Gibt den Code für den Raster Vorgang an. Raster-Operation Codes (ROPS) definieren, wie in GDI Farben in Ausgabe Vorgängen kombiniert werden, die einen aktuellen Pinsel, eine mögliche Quell Bitmap und eine Ziel Bitmap einschließen. Dieser Parameter kann einen der folgenden Werte aufweisen:

- Patcopy kopiert das Muster in die Ziel Bitmap.

- Patinvert kombiniert die Ziel Bitmap mit einem Muster mithilfe des booleschen XOR-Operators.

- Dstinvert kehrt die Ziel Bitmap um.

- Blackness schaltet alle Ausgaben schwarz.

- Mit der whitheit wird die Ausgabe weiß.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Das Muster ist eine Kombination aus dem ausgewählten Pinsel und dem Muster, das sich bereits auf dem Gerät befindet. Der von *dwrop* angegebene Raster Vorgangs Code definiert, wie die Muster kombiniert werden. Die für diese Funktion aufgelisteten Raster Vorgänge sind eine begrenzte Teilmenge der vollständigen 256 ternären Raster-Operation-Codes. ein Raster Vorgangs Code, der auf eine Quelle verweist, kann insbesondere nicht verwendet werden.

Die-Funktion wird nicht von allen Geräte Kontexten unterstützt `PatBlt` . Um zu ermitteln, ob ein Gerätekontext von unterstützt `PatBlt` wird, müssen Sie die Element `GetDeviceCaps` Funktion mit dem RasterCaps-Index aufrufen und den Rückgabewert für das RC_BITBLT-Flag überprüfen.

## <a name="cdcpie"></a><a name="pie"></a>CDC::P IE

Zeichnet einen kreisförmigen Keil durch Zeichnen eines elliptischen Bogens, dessen Mittelpunkt und zwei Endpunkte durch Linien verknüpft sind.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*Y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*Y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umgebenden Rechtecks an (in logischen Einheiten).

*x3*<br/>
Gibt die x-Koordinate des Anfangs Punkts des Bogens (in logischen Einheiten) an. Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*Y3*<br/>
Gibt die y-Koordinate des Anfangs Punkts des Bogens (in logischen Einheiten) an. Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*x4*<br/>
Gibt die x-Koordinate des Endpunkts des Bogens an (in logischen Einheiten). Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*Y4*<br/>
Gibt die y-Koordinate des Endpunkts des Bogens an (in logischen Einheiten). Dieser Punkt muss sich nicht genau auf dem Bogen befinden.

*lprect*<br/>
Gibt das umgebende Rechteck an. Sie können entweder ein- `CRect` Objekt oder einen-Zeiger an eine- `RECT` Struktur für diesen Parameter übergeben.

*ptstart*<br/>
Gibt den Anfangspunkt des Bogens an. Dieser Punkt muss sich nicht genau auf dem Bogen befinden. Sie können entweder eine [Punkt](/windows/win32/api/windef/ns-windef-point) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) -Objekt für diesen Parameter übergeben.

*ptend*<br/>
Gibt den Endpunkt des Bogens an. Dieser Punkt muss sich nicht genau auf dem Bogen befinden. Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Mittelpunkt des Bogens ist die Mitte des umgebenden Rechtecks, das von *x1*, *Y1*, *x2*und *Y2* (oder *lprect*) angegeben wird. Die Anfangs-und Endpunkte des Bogens werden von *X3*, *Y3*, *X4*und *Y4* (oder durch *ptstart* und *ptend*) angegeben.

Der Bogen wird mit dem ausgewählten Stift gezeichnet und wechselt in die Richtung gegen den Uhrzeigersinn. Zwei weitere Zeilen werden von jedem Endpunkt zum Mittelpunkt des Bogens gezeichnet. Der kreisförmige Bereich ist mit dem aktuellen Pinsel gefüllt. Wenn *X3* gleich *X4* und *Y3* gleich *Y4*ist, ist das Ergebnis eine Ellipse mit einer einzelnen Zeile von der Mitte der Ellipse bis zum Punkt ( *X3*, *Y3*) oder ( *X4*, *Y4*).

Die von dieser Funktion gezeichnete Abbildung erstreckt sich auf, aber schließt nicht die Rechte und unteren Koordinaten ein. Dies bedeutet, dass die Höhe der Abbildung *Y2*  -  *Y1* und die Breite der Abbildung *x2*  -  *x1*ist. Sowohl die Breite als auch die Höhe des umgebenden Rechtecks müssen größer als 2 Einheiten und kleiner als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>CDC::P laymetafile

Gibt den Inhalt der angegebenen Metadatendatei im Gerätekontext wieder.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parameter

*HMF*<br/>
Identifiziert die zu Wiedergabe Ende Metadatei.

*"HENHMETAFILE"*<br/>
Identifiziert die erweiterte Metadatei.

*lpbounds*<br/>
Verweist auf eine- `RECT` Struktur oder ein- `CRect` Objekt, das die Koordinaten des umgebenden Rechtecks enthält, das zum Anzeigen des Bilds verwendet wird. Die Koordinaten werden in logischen Einheiten angegeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Metadatei kann beliebig oft wiedergegeben werden.

Die zweite Version von `PlayMetaFile` zeigt das Bild an, das in der angegebenen Metadatei mit erweitertem Format gespeichert ist. Wenn eine Anwendung die zweite Version von aufruft `PlayMetaFile` , verwendet Windows den Bild Rahmen im Enhanced-Metafile-Header, um das Bild auf dem Rechteck zuzuordnen, auf das durch den *lpbounds* -Parameter verwiesen wird. (Dieses Bild kann durch Festlegen der Welt Transformation im Ausgabegerät vor dem Aufrufen von gereniert oder gedreht werden `PlayMetaFile` .) Punkte entlang der Kanten des Rechtecks sind im Bild enthalten. Ein erweitertes Metadateibild kann abgeschnitten werden, indem der Clippingbereich im Ausgabegerät definiert wird, bevor die erweiterte Metadatei wiedergegeben wird.

Wenn eine erweiterte Metadatei eine optionale Palette enthält, kann eine Anwendung konsistente Farben erreichen, indem eine Farbpalette auf dem Ausgabegerät eingerichtet wird, bevor die zweite Version von aufgerufen wird `PlayMetaFile` . Verwenden Sie die Windows-Funktion, um die optionale Palette abzurufen `GetEnhMetaFilePaletteEntries` . Eine erweiterte Metadatei kann in eine neu erstellte erweiterte Metadatendatei eingebettet werden, indem Sie die zweite Version von Aufrufen `PlayMetaFile` und die erweiterte Metadatentabelle für die erweiterte Metadatei in den Gerätekontext herunterspielt.

Die Zustände des Ausgabegeräte Kontexts werden von dieser Funktion beibehalten. Alle Objekte, die in der erweiterten Metadatei erstellt, aber nicht gelöscht werden, werden von dieser Funktion gelöscht. Um diese Funktion zu beenden, kann eine Anwendung die `CancelDC` Windows-Funktion von einem anderen Thread aus anrufen, um den Vorgang zu beenden. In diesem Fall gibt die Funktion 0 (null) zurück.

## <a name="cdcplgblt"></a><a name="plgblt"></a>CDC::P lgblt

Führt eine Bitblock Übertragung der Bits von Farbdaten aus dem angegebenen Rechteck im Quell Gerätekontext in das angegebene Parallelogramm im angegebenen Gerätekontext aus.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parameter

*lpPoint*<br/>
Verweist auf ein Array von drei Punkten im logischen Raum, das drei Ecken des Ziel-parallelograms identifiziert. Die linke obere Ecke des Quell Rechtecks wird dem ersten Punkt in diesem Array zugeordnet, der oberen rechten Ecke des zweiten Punkts in diesem Array und der unteren linken Ecke des dritten Punkts. Die untere rechte Ecke des Quell Rechtecks wird dem impliziten vierten Punkt im Parallelogram zugeordnet.

*psrcdc*<br/>
Identifiziert den Quell Gerätekontext.

*xsrc*<br/>
Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quell Rechtecks an.

*ysrc*<br/>
Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quell Rechtecks an.

*nwidth*<br/>
Gibt die Breite des Quell Rechtecks in logischen Einheiten an.

*nheight*<br/>
Gibt die Höhe des Quell Rechtecks in logischen Einheiten an.

*maskbitmap*<br/>
Gibt eine optionale monochrome Bitmap an, mit der die Farben des Quell Rechtecks maskiert werden.

*xmask*<br/>
Gibt die x-Koordinate der oberen linken Ecke der monochrome Bitmap an.

*ymask*<br/>
Gibt die y-Koordinate der oberen linken Ecke der monochrome Bitmap an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Wenn das angegebene Bitmasken-handle eine gültige monochrome Bitmap identifiziert, verwendet die-Funktion diese Bitmap, um die Bits der Farbdaten aus dem Quell Rechteck zu maskieren.

Der vierte Scheitelpunkt des parallelograms (D) wird definiert, indem die ersten drei Punkte (A, B und c) als Vektoren und Computing D = B + C-A behandelt werden.

Wenn die Bitmaske vorhanden ist, gibt der Wert 1 in der Maske an, dass die Quell Pixelfarbe in das Ziel kopiert werden soll. Der Wert 0 in der Maske gibt an, dass die Ziel Pixelfarbe nicht geändert werden soll.

Wenn das Masken Rechteck kleiner ist als die Quell-und Ziel Rechtecke, repliziert die Funktion das Masken Muster.

Skalierungs-, Übersetzungs-und reflektionstransformationen sind im Quell Gerätekontext zulässig. Allerdings sind Drehung und schscheren Transformationen nicht. Wenn es sich bei der Mask-Bitmap nicht um eine monochrome Bitmap handelt, tritt ein Fehler auf. Der streckungs Modus für den Zielgeräte Kontext wird verwendet, um zu bestimmen, wie die Pixel gestreckt oder komprimiert werden, falls dies erforderlich ist. Wenn eine erweiterte Metadatei aufgezeichnet wird, tritt ein Fehler auf, wenn der Quell Gerätekontext einen erweiterten Metadatei-Gerätekontext identifiziert.

Die Zielkoordinaten werden gemäß dem Zielgerätekontext transformiert. Die Quellkoordinaten werden gemäß dem Quellgerätekontext transformiert. Wenn die Quell Transformation über eine Drehung oder eine Schere verfügt, wird ein Fehler zurückgegeben. Wenn die Ziel-und Quell Rechtecke nicht das gleiche Farb Format aufweisen, `PlgBlt` konvertiert das Quell Rechteck so, dass es mit dem Ziel Rechteck übereinstimmt. Nicht alle Geräte werden unterstützt `PlgBlt` . Weitere Informationen finden Sie in der Beschreibung der RC_BITBLT Rasterfunktion in der `CDC::GetDeviceCaps` Member-Funktion.

Wenn die Quell-und Zielgeräte Kontexte nicht kompatible Geräte darstellen, `PlgBlt` gibt einen Fehler zurück.

## <a name="cdcpolybezier"></a><a name="polybezier"></a>CDC::P olybezier

Zeichnet eine oder mehrere Bzier-Splines.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von [Point](/windows/win32/api/windef/ns-windef-point) -Datenstrukturen, die die Endpunkte und Kontrollpunkte der Spline (n) enthalten.

*nCount*<br/>
Gibt die Anzahl der Punkte im *lppoints* -Array an. Dieser Wert muss ein Vielfaches der Anzahl der zu zeichnende Splines sein, da jede Bzier-Spline zwei Kontrollpunkte und einen Endpunkt erfordert, und für die anfängliche Spline ist ein zusätzlicher Ausgangspunkt erforderlich.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Funktion zeichnet kubische Bzier-Splines mithilfe der Endpunkte und Steuerungs Punkte, die durch den *lppoints* -Parameter angegeben werden. Der erste Spline wird vom ersten Punkt zum vierten Punkt gezeichnet, indem der zweite und dritte Punkt als Kontrollpunkte verwendet werden. Jeder nachfolgende Spline in der Sequenz benötigt genau drei weitere Punkte: der Endpunkt der vorherigen Spline wird als Ausgangspunkt verwendet, die nächsten zwei Punkte in der Sequenz sind Steuerungs Punkte, und der dritte ist der Endpunkt.

Die aktuelle Position wird nicht von der-Funktion verwendet oder aktualisiert `PolyBezier` . Die Abbildung ist nicht ausgefüllt. Diese Funktion zeichnet Zeilen mithilfe des aktuellen Stifts.

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>CDC::P olybezierto

Zeichnet eine oder mehrere Bzier-Splines.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von [Punkt](/windows/win32/api/windef/ns-windef-point) Datenstrukturen, das die Endpunkte und die Steuerungs Punkte enthält.

*nCount*<br/>
Gibt die Anzahl der Punkte im *lppoints* -Array an. Dieser Wert muss dreimal so oft wie die Anzahl der zu Zeichenden Splines sein, da jede Bzier-Spline zwei Steuerungs Punkte und einen Endpunkt erfordert.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Funktion zeichnet kubische Bzier-Splines mithilfe der durch den *lppoints* -Parameter angegebenen Steuerpunkte. Der erste Spline wird von der aktuellen Position bis zum dritten Punkt gezeichnet, indem die ersten beiden Punkte als Kontrollpunkte verwendet werden. Für jede nachfolgende Spline benötigt die Funktion genau drei weitere Punkte, und der Endpunkt der vorherigen Spline wird als Ausgangspunkt für die nächste verwendet. `PolyBezierTo`Verschiebt die aktuelle Position an den Endpunkt der letzten Bzier-Spline. Die Abbildung ist nicht ausgefüllt. Diese Funktion zeichnet Zeilen mithilfe des aktuellen Stifts.

### <a name="example"></a>Beispiel

  Sehen Sie sich das Beispiel für [CDC:: beginpath](#beginpath)an.

## <a name="cdcpolydraw"></a><a name="polydraw"></a>CDC::P olydraw

Zeichnet eine Reihe von Liniensegmenten und Bzier-Splines.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von [Punkt](/windows/win32/api/windef/ns-windef-point) Datenstrukturen, das die Endpunkte für jedes Liniensegment und die Endpunkte und Steuerungs Punkte für jede Bzier-Spline enthält.

*lptypes*<br/>
Verweist auf ein Array, das angibt, wie die einzelnen Punkte im *lppoints* -Array verwendet werden. Folgende Werte sind möglich:

- PT_MOVETO gibt an, dass dieser Punkt eine Zusammenhang lose Abbildung startet. Dieser Punkt wird zur neuen aktuellen Position.

- PT_LINETO gibt an, dass eine Linie von der aktuellen Position bis zu diesem Punkt gezeichnet werden soll, die dann zur neuen aktuellen Position wird.

- PT_BEZIERTO gibt an, dass dieser Punkt ein Steuerungspunkt oder Endpunkt für eine Bzier-Spline ist.

PT_BEZIERTO Typen treten immer in drei Sätzen auf. Die aktuelle Position definiert den Anfangspunkt für den Bzier-Spline. Die ersten beiden PT_BEZIERTO Punkte sind die Steuerungs Punkte, und der dritte PT_BEZIERTO Punkt ist der Endpunkt. Der Endpunkt wird zur neuen aktuellen Position. Wenn es nicht drei aufeinander folgende PT_BEZIERTO Punkte gibt, tritt ein Fehler auf.

   Ein PT_LINETO oder PT_BEZIERTO Typ kann mit der folgenden Konstante kombiniert werden, indem der bitweise Operator oder verwendet wird, um anzugeben, dass der entsprechende Punkt der letzte Punkt in einer Abbildung ist und die Abbildung geschlossen ist:

- PT_CLOSEFIGURE gibt an, dass die Abbildung automatisch geschlossen wird, nachdem der PT_LINETO oder PT_BEZIERTO Typ für diesen Punkt abgeschlossen wurde. Zwischen diesem Punkt und dem letzten PT_MOVETO oder Punkt wird eine Linie gezeichnet `MoveTo` .

   Dieses Flag wird mithilfe des bitweisen **or** -Operators mit dem PT_LINETO-Typ für eine Zeile oder mit dem PT_BEZIERTO Typ des Endpunkts für eine Bzier-Spline kombiniert. Die aktuelle Position wird auf den Endpunkt der schließenden Zeile festgelegt.

*nCount*<br/>
Gibt die Gesamtzahl der Punkte im *lppoints* -Array an, die mit der Anzahl der Bytes im *lptypes* -Array identisch sind.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Funktion kann verwendet werden, um nicht zusammenhängende Abbildungen anstelle von aufeinander folgenden Aufrufen `CDC::MoveTo` von `CDC::LineTo` -,-und-Member-Funktionen zu zeichnen `CDC::PolyBezierTo` . Die Linien und Splines werden mithilfe des aktuellen Stifts gezeichnet, und die Abbildungen werden nicht aufgefüllt. Wenn ein aktiver Pfad durch Aufrufen der Member-Funktion gestartet wird `CDC::BeginPath` , wird `PolyDraw` dem Pfad hinzugefügt. Die Punkte, die im *lppoints* -Array und in *lptypes* enthalten sind, geben an, ob jeder Punkt Teil eines- `CDC::MoveTo` ,-oder-Vorgangs ist `CDC::LineTo` `CDC::BezierTo` . Es ist auch möglich, die Abbildungen zu schließen. Diese Funktion aktualisiert die aktuelle Position.

### <a name="example"></a>Beispiel

  Sehen Sie sich das Beispiel für [CDC:: beginpath](#beginpath)an.

## <a name="cdcpolygon"></a><a name="polygon"></a>CDC::P olygon

Zeichnet mithilfe des aktuellen Stifts ein Polygon, das aus zwei oder mehr Punkten (Vertices) besteht, die durch Linien verbunden sind.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von Punkten, das die Scheitel Punkte des Polygons angibt. Jeder Punkt im Array ist eine `POINT` Struktur oder ein- `CPoint` Objekt.

*nCount*<br/>
Gibt die Anzahl der Scheitel Punkte im Array an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Das System schließt das Polygon ggf. automatisch, indem eine Linie vom letzten Scheitelpunkt zum ersten gezeichnet wird.

Der aktuelle Polygon-Füllungs Modus kann mithilfe der `GetPolyFillMode` -und-Member-Funktionen abgerufen oder festgelegt werden `SetPolyFillMode` .

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>CDC::P olyline

Zeichnet eine Reihe von Liniensegmenten, die die von *lppoints*angegebenen Punkte verbinden.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von `POINT` Strukturen oder `CPoint` Objekten, die verbunden werden sollen.

*nCount*<br/>
Gibt die Anzahl der Punkte im Array an. Dieser Wert muss mindestens 2 sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Zeilen werden vom ersten Punkt durch nachfolgende Punkte mithilfe des aktuellen Stifts gezeichnet. Anders als bei der `LineTo` Member-Funktion verwendet die- `Polyline` Funktion weder die aktuelle noch die aktuelle Position.

Weitere Informationen finden Sie unter [Polyline](/windows/win32/api/wingdi/nf-wingdi-polyline) in der Windows SDK.

## <a name="cdcpolylineto"></a><a name="polylineto"></a>CDC::P olylineto

Zeichnet eine oder mehrere gerade Linien.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von [Punkt](/windows/win32/api/windef/ns-windef-point) Datenstrukturen, das die Scheitel Punkte der Zeile enthält.

*nCount*<br/>
Gibt die Anzahl der Punkte im Array an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Eine Linie wird von der aktuellen Position bis zum ersten Punkt gezeichnet, der durch den *lppoints* -Parameter mithilfe des aktuellen Stifts angegeben wird. Für jede weitere Zeile zeichnet die Funktion vom Endpunkt der vorherigen Zeile bis zum nächsten Punkt, der von *lppoints*angegeben wird. `PolylineTo`Verschiebt die aktuelle Position an den Endpunkt der letzten Zeile. Wenn die von dieser Funktion gezeichneten Liniensegmente eine geschlossene Abbildung bilden, wird die Abbildung nicht ausgefüllt.

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>CDC::P olypolygon

Erstellt zwei oder mehr Polygone, die mit dem aktuellen Polygon Füll Modus gefüllt werden.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von- `POINT` Strukturen oder-Objekten, die die Scheitel Punkte `CPoint` der Polygone definieren.

*lppolycounts*<br/>
Verweist auf ein Array von ganzen Zahlen, von denen jedes die Anzahl der Punkte in einem der Polygone im *lppoints* -Array angibt.

*nCount*<br/>
Die Anzahl der Einträge im *lppolycounts* -Array. Diese Zahl gibt die Anzahl von Polygonen an, die gezeichnet werden sollen. Dieser Wert muss mindestens 2 sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Polygone können zusammen hanglos oder überlappend sein.

Jedes in einem Aufrufe der Funktion angegebene Polygon `PolyPolygon` muss geschlossen werden. Im Gegensatz zu Polygonen `Polygon` , die von der-Member-Funktion erstellt wurden, werden die von erstellten Polygone `PolyPolygon` nicht automatisch geschlossen.

Die-Funktion erstellt zwei oder mehr Polygone. Zum Erstellen eines einzelnen Polygons sollte eine Anwendung die `Polygon` Member-Funktion verwenden.

Der aktuelle Polygon-Füllungs Modus kann mithilfe der `GetPolyFillMode` -und-Member-Funktionen abgerufen oder festgelegt werden `SetPolyFillMode` .

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>CDC::P olypolyline

Zeichnet mehrere Reihe verbundener Liniensegmente.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lppoints*<br/>
Verweist auf ein Array von-Strukturen, das die Scheitel Punkte der Polylinien enthält. Die Polylinien werden nacheinander angegeben.

*lppolypoints*<br/>
Verweist auf ein Array von Variablen, die die Anzahl der Punkte im *lppoints* -Array für das entsprechende Polygon angeben. Jeder Eintrag muss größer oder gleich 2 sein.

*nCount*<br/>
Gibt die Gesamtanzahl der Anzahlen im *lppolypoints* -Array an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Liniensegmente werden mithilfe des aktuellen Stifts gezeichnet. Die von den Segmenten geformten Abbildungen werden nicht aufgefüllt. Die aktuelle Position wird von dieser Funktion weder verwendet noch aktualisiert.

## <a name="cdcptvisible"></a><a name="ptvisible"></a>CDC::P tvisible

Bestimmt, ob sich der angegebene Punkt innerhalb des Clippingbereichs des Geräte Kontexts befindet.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate des Punkts an.

*Teenie*<br/>
Gibt die logische y-Koordinate des Punkts an.

*Punkt*<br/>
Gibt den Punkt an, an dem logische Koordinaten eingecheckt werden sollen. Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn sich der angegebene Punkt innerhalb des Ausschneide Bereichs befindet. andernfalls 0.

## <a name="cdcqueryabort"></a><a name="queryabort"></a>CDC:: QueryAbort

Ruft die Abbruch Funktion auf, die von der [SETABORTPROC](#setabortproc) -Member-Funktion für eine Druckanwendung installiert wird, und fragt ab, ob der Druckvorgang beendet werden soll.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Rückgabewert

Der Rückgabewert ist ungleich 0 (null), wenn der Druckvorgang fortgesetzt werden soll, oder, wenn keine Abbruch Prozedur vorliegt. Der Wert ist 0, wenn der Druckauftrag beendet werden soll. Der Rückgabewert wird von der Abbruch-Funktion bereitgestellt.

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>CDC:: RealizePalette

Ordnet Einträge aus der aktuellen logischen Palette der Systempalette zu.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Rückgabewert

Gibt an, wie viele Einträge in der logischen Palette anderen Einträgen in der Systempalette zugeordnet wurden. Dies entspricht der Anzahl der Einträge, die von dieser Funktion neu zugeordnet wurden, um Änderungen an der Systempalette seit der letzten Realisierung der logischen Palette zu unterstützen.

### <a name="remarks"></a>Bemerkungen

Eine logische Farbpalette fungiert als Puffer zwischen farbintensiven Anwendungen und dem System, sodass eine Anwendung beliebig viele Farben verwenden kann, ohne die eigenen angezeigten Farben oder Farben zu beeinträchtigen, die von anderen Fenstern angezeigt werden.

Wenn ein Fenster den Eingabefokus besitzt und aufruft `RealizePalette` , stellt Windows sicher, dass im Fenster alle angeforderten Farben angezeigt werden, bis die maximale Anzahl gleichzeitig auf dem Bildschirm verfügbar ist. Windows zeigt außerdem Farben an, die nicht in der Palette des Fensters gefunden wurden, indem Sie Sie mit verfügbaren Farben vergleichen.

Außerdem stimmt Windows mit den von inaktiven Fenstern angeforderten Farben überein, die die Funktion so nah wie möglich an die verfügbaren Farben angleichen. Dadurch werden unerwünschte Änderungen in den in inaktiven Fenstern angezeigten Farben erheblich reduziert.

## <a name="cdcrectangle"></a><a name="rectangle"></a>CDC:: Rechteck

Zeichnet ein Rechteck mit dem aktuellen Stift.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des Rechtecks an (in logischen Einheiten).

*Y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des Rechtecks an (in logischen Einheiten).

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*Y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*lprect*<br/>
Gibt das Rechteck in logischen Einheiten an. Sie können entweder ein- `CRect` Objekt oder einen-Zeiger an eine- `RECT` Struktur für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Das Innere des Rechtecks wird mit dem aktuellen Pinsel gefüllt.

Das Rechteck erstreckt sich über die Rechte und die untere Koordinate, schließt diese jedoch nicht ein. Dies bedeutet, dass die Höhe des Rechtecks *Y2*ist  -  *Y1* und die Breite des Rechtecks ist *x2*  -  *x1*. Sowohl die Breite als auch die Höhe eines Rechtecks müssen größer als 2 Einheiten und kleiner als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>CDC:: rectvisible

Bestimmt, ob ein Teil des angegebenen Rechtecks innerhalb des Clippingbereichs des Anzeige Kontexts liegt.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parameter

*lprect*<br/>
Verweist auf eine- `RECT` Struktur oder ein- `CRect` Objekt, das die logischen Koordinaten des angegebenen Rechtecks enthält.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn ein Teil des angegebenen Rechtecks innerhalb des Ausschneide Bereichs liegt. andernfalls 0.

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>CDC:: releaseattribdc

Mit dieser Member-Funktion können `m_hAttribDC` Sie auf NULL festlegen.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Bemerkungen

Dies bewirkt nicht, dass ein `Detach` auftritt. Nur der Ausgabegeräte Kontext ist an das `CDC` -Objekt angefügt, und nur kann er getrennt werden.

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>CDC:: releaseoutputdc

Diese Member-Funktion wird aufgerufen, um den `m_hDC` Member auf NULL festzulegen.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion kann nicht aufgerufen werden, wenn der Ausgabegeräte Kontext an das-Objekt angefügt wird `CDC` . Verwenden `Detach` Sie die Member-Funktion, um den Ausgabegeräte Kontext zu trennen.

## <a name="cdcresetdc"></a><a name="resetdc"></a>CDC:: ResetDC

Mit dieser Member-Funktion können Sie den Gerätekontext aktualisieren, der vom-Objekt umschließt wird `CDC` .

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parameter

*lpdevmode*<br/>
Ein Zeiger auf eine Windows- `DEVMODE` Struktur.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Gerätekontext wird anhand der Informationen aktualisiert, die in der Windows-Struktur angegeben sind `DEVMODE` . Diese Member-Funktion setzt nur den Attribut Gerätekontext zurück.

Eine Anwendung verwendet in der Regel die `ResetDC` Member-Funktion, wenn ein Fenster eine `WM_DEVMODECHANGE` Nachricht verarbeitet. Sie können diese Member-Funktion auch verwenden, um die Papier Ausrichtung oder Papierbehälter beim Drucken eines Dokuments zu ändern.

Sie können diese Member-Funktion nicht verwenden, um den Treiber Namen, den Gerätenamen oder den Ausgabeport zu ändern. Wenn der Benutzer die Port Verbindung oder den Gerätenamen ändert, müssen Sie den ursprünglichen Gerätekontext löschen und einen neuen Gerätekontext mit den neuen Informationen erstellen.

Bevor Sie diese Member-Funktion aufgerufen haben, müssen Sie sicherstellen, dass alle Objekte (mit Ausnahme von Aktien Objekten), die im Gerätekontext ausgewählt wurden, ausgewählt wurden.

## <a name="cdcrestoredc"></a><a name="restoredc"></a>CDC:: restoredc

Stellt den Gerätekontext in dem vorherigen durch *nsaveddc*identifizierten Zustand wieder her.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parameter

*nsaveddc*<br/>
Gibt den Gerätekontext an, der wieder hergestellt werden soll. Dies kann ein Wert sein, der von einem vorherigen `SaveDC` Funktions Aufrufwert zurückgegeben wurde. Wenn *nsaveddc* den Wert-1 hat, wird der zuletzt gespeicherte Gerätekontext wieder hergestellt.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn der angegebene Kontext wieder hergestellt wurde. andernfalls 0.

### <a name="remarks"></a>Bemerkungen

`RestoreDC`stellt den Gerätekontext wieder her, indem Zustandsinformationen von einem Stapel abgelegt werden, der von früheren Aufrufen der Member-Funktion erstellt wurde `SaveDC` .

Der Stapel kann die Zustandsinformationen für mehrere Geräte Kontexte enthalten. Wenn sich der von *nsaveddc* angegebene Kontext nicht am Anfang des Stapels befindet, `RestoreDC` Löscht alle Zustandsinformationen zwischen dem durch *nsaveddc* angegebenen Gerätekontext und dem oberen Rand des Stapels. Die gelöschten Informationen gehen verloren.

## <a name="cdcroundrect"></a><a name="roundrect"></a>CDC:: roundRect

Zeichnet mithilfe des aktuellen Stifts ein Rechteck mit abgerundeten Ecken.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die x-Koordinate der oberen linken Ecke des Rechtecks an (in logischen Einheiten).

*Y1*<br/>
Gibt die y-Koordinate der oberen linken Ecke des Rechtecks an (in logischen Einheiten).

*x2*<br/>
Gibt die x-Koordinate der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*Y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*x3*<br/>
Gibt die Breite der Ellipse an, die zum Zeichnen der abgerundeten Ecken (in logischen Einheiten) verwendet wird.

*Y3*<br/>
Gibt die Höhe der Ellipse an, die zum Zeichnen der abgerundeten Ecken (in logischen Einheiten) verwendet wird.

*lprect*<br/>
Gibt das Begrenzungs Rechteck in logischen Einheiten an. Sie können entweder ein- `CRect` Objekt oder einen-Zeiger an eine- `RECT` Struktur für diesen Parameter übergeben.

*Punkt*<br/>
Die x-Koordinate des *Punkts* gibt die Breite der Ellipse zum Zeichnen der abgerundeten Ecken an (in logischen Einheiten). Die y-Koordinate des *Punkts* gibt die Höhe der Ellipse zum Zeichnen der abgerundeten Ecken an (in logischen Einheiten). Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Das Innere des Rechtecks wird mit dem aktuellen Pinsel gefüllt.

Die von dieser Funktion aufzurufende Abbildung erweitert sich, aber schließt nicht die Rechte und unteren Koordinaten ein. Dies bedeutet, dass die Höhe der Abbildung *Y2*  -  *Y1* und die Breite der Abbildung *x2*  -  *x1*ist. Die Höhe und Breite des umgebenden Rechtecks müssen größer als 2 Einheiten und kleiner als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>CDC:: savedc

Speichert den aktuellen Zustand des Geräte Kontexts, indem Zustandsinformationen (z. b. Clippingbereich, ausgewählte Objekte und Zustellungs Modus) in einen Kontext Stapel kopiert werden, der von Windows verwaltet wird.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Rückgabewert

Eine ganze Zahl, die den gespeicherten Gerätekontext identifiziert. Der Wert ist 0, wenn ein Fehler auftritt. Dieser Rückgabewert kann verwendet werden, um den Gerätekontext durch Aufrufen von wiederherzustellen `RestoreDC` .

### <a name="remarks"></a>Bemerkungen

Der gespeicherte Gerätekontext kann später mithilfe von wieder hergestellt werden `RestoreDC` .

`SaveDC`kann beliebig oft verwendet werden, um eine beliebige Anzahl von Gerätekontext Zuständen zu speichern.

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>CDC:: scaleviewportext

Ändert die Werte des Viewports in Bezug auf die aktuellen Werte.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parameter

*xNum*<br/>
Gibt den Betrag an, um den der aktuelle x-Block multipliziert werden soll.

*xdenom*<br/>
Gibt den Betrag an, um den das Ergebnis der Multiplikation des aktuellen x-Blocks mit dem Wert des *xNum* -Parameters dividiert werden soll.

*ynum*<br/>
Gibt den Betrag an, um den der aktuelle y-Block multipliziert werden soll.

*ydenom*<br/>
Gibt den Betrag an, um den das Ergebnis der Multiplikation des aktuellen y-Blocks mit dem Wert des *ynum* -Parameters dividiert werden soll.

### <a name="return-value"></a>Rückgabewert

Die vorherigen viewportblöcke (in Geräte Einheiten) als- `CSize` Objekt.

### <a name="remarks"></a>Bemerkungen

Die Formeln werden wie folgt geschrieben:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Die neuen viewportblöcke werden berechnet, indem die aktuellen Blöcke mit dem angegebenen Zähler multipliziert und dann durch den angegebenen Nenner dividiert werden.

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>CDC:: scalewindowext

Ändert die Fensterblöcke in Bezug auf die aktuellen Werte.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parameter

*xNum*<br/>
Gibt den Betrag an, um den der aktuelle x-Block multipliziert werden soll.

*xdenom*<br/>
Gibt den Betrag an, um den das Ergebnis der Multiplikation des aktuellen x-Blocks mit dem Wert des *xNum* -Parameters dividiert werden soll.

*ynum*<br/>
Gibt den Betrag an, um den der aktuelle y-Block multipliziert werden soll.

*ydenom*<br/>
Gibt den Betrag an, um den das Ergebnis der Multiplikation des aktuellen y-Blocks mit dem Wert des *ynum* -Parameters dividiert werden soll.

### <a name="return-value"></a>Rückgabewert

Das vorherige Fenster erweitert (in logischen Einheiten) als- `CSize` Objekt.

### <a name="remarks"></a>Bemerkungen

Die Formeln werden wie folgt geschrieben:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Die neuen Fensterblöcke werden berechnet, indem die aktuellen Blöcke mit dem angegebenen Zähler multipliziert und dann durch den angegebenen Nenner dividiert werden.

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>CDC:: scrolldc

Führt einen horizontalen und vertikalen Bildlauf für ein Rechteck von Bits aus.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parameter

*Market*<br/>
Gibt die Anzahl der horizontalen scrolleinheiten an.

*reiche*<br/>
Gibt die Anzahl der vertikalen scrolleinheiten an.

*lprectscroll*<br/>
Verweist auf die `RECT` Struktur oder das `CRect` Objekt, das die Koordinaten des scrollrechtecks enthält.

*lprectclip*<br/>
Verweist auf die `RECT` Struktur oder das `CRect` Objekt, das die Koordinaten des clippingrechtecks enthält. Wenn dieses Rechteck kleiner ist als das ursprüngliche Rechteck, auf das von *lprectscroll*verwiesen wird, erfolgt der Bildlauf nur im kleineren Rechteck.

*prgnupdate*<br/>
Identifiziert den Bereich, der durch den scrollprozess aufgedeckt wird. Die `ScrollDC` Funktion definiert diesen Bereich, nicht notwendigerweise ein Rechteck.

*lprectupdate*<br/>
Verweist auf die `RECT` Struktur oder das `CRect` Objekt, das die Koordinaten des Rechtecks empfängt, das den scrollaktualisierungs Bereich umschließt. Dies ist der größte rechteckige Bereich, der das Neuzeichnen erfordert. Die Werte in der Struktur oder im Objekt, wenn die Funktion zurückgibt, werden in Client Koordinaten angezeigt, unabhängig vom Kartenmodus für den angegebenen Gerätekontext.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn der Bildlauf ausgeführt wird. andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Wenn *lprectupdate* NULL ist, berechnet Windows das Aktualisierungs Rechteck nicht. Wenn sowohl *prgnupdate* als auch *lprectupdate* NULL sind, berechnet Windows den Update Bereich nicht. Wenn *prgnupdate* nicht NULL ist, geht Windows davon aus, dass es einen gültigen Zeiger auf den Bereich enthält, der durch den scrollprozess (definiert durch die `ScrollDC` Member-Funktion) aufgedeckt wird. Der in *lprectupdate* zurückgegebene Aktualisierungs Bereich kann bei Bedarf an übergeben werden `CWnd::InvalidateRgn` .

Eine Anwendung sollte die `ScrollWindow` Member-Funktion der-Klasse verwenden `CWnd` , wenn es erforderlich ist, einen Bildlauf für den gesamten Client Bereich eines Fensters durchführen zu müssen. Andernfalls sollte verwendet werden `ScrollDC` .

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>CDC:: selectclippath

Wählt den aktuellen Pfad als Clippingbereich für den Gerätekontext aus, wobei die neue Region mit einem beliebigen vorhandenen Clippingbereich unter Verwendung des angegebenen Modus kombiniert wird.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parameter

*nmode*<br/>
Gibt an, wie der Pfad verwendet werden soll. Folgende Werte sind zulässig:

- RGN_AND der neue Clippingbereich die Schnittmenge (überlappende Bereiche) des aktuellen Ausschneide Bereichs und des aktuellen Pfads enthält.

- RGN_COPY der neue Clippingbereich der aktuelle Pfad ist.

- RGN_DIFF der neue Clippingbereich die Bereiche des aktuellen Clippingbereichs einschließt und die des aktuellen Pfads ausgeschlossen werden.

- RGN_OR der neue Clippingbereich die Union (kombinierte Bereiche) des aktuellen Ausschneide Bereichs und des aktuellen Pfads enthält.

- RGN_XOR der neue Clippingbereich die Gesamtmenge des aktuellen Clippingbereichs und des aktuellen Pfads, aber ohne die überlappenden Bereiche einschließt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der identifizierte Gerätekontext muss einen geschlossenen Pfad enthalten.

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>CDC:: selectcliprgn

Wählt die angegebene Region als aktuellen Clippingbereich für den Gerätekontext aus.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parameter

*PRGN*<br/>
Identifiziert den Bereich, der ausgewählt werden soll.

- Wenn dieser Wert für die erste Version dieser Funktion NULL ist, wird der gesamte Client Bereich ausgewählt, und die Ausgabe wird weiterhin auf das Fenster zugeschnitten.

- Bei der zweiten Version dieser Funktion kann dieses Handle nur NULL sein, wenn der RGN_COPY Modus angegeben wird.

*nmode*<br/>
Gibt den auszuführenden Vorgang an. Es muss sich um einen der folgenden Werte handeln:

- RGN_AND der neue Clippingbereich die überlappenden Bereiche des aktuellen Clippingbereichs und die durch *PRGN*identifizierte Region kombiniert.

- RGN_COPY der neue Clippingbereich eine Kopie der durch *PRGN*identifizierten Region ist. Diese Funktionalität ist mit der ersten Version von identisch `SelectClipRgn` . Wenn der durch *PRGN* identifizierte Bereich NULL ist, wird der neue Clippingbereich zum Standard Clippingbereich (ein NULL-Bereich).

- RGN_DIFF der neue Clippingbereich die Bereiche des aktuellen Clippingbereichs mit den Bereichen kombiniert, die von der durch *PRGN*identifizierten Region ausgeschlossen sind.

- RGN_OR der neue Clippingbereich den aktuellen Clippingbereich und die durch *PRGN*identifizierte Region kombiniert.

- RGN_XOR der neue Clippingbereich den aktuellen Clippingbereich und die durch *PRGN* identifizierte Region kombiniert, aber alle überlappenden Bereiche ausschließen.

### <a name="return-value"></a>Rückgabewert

Der Typ der Region. Dabei kann es sich um einen der folgenden Werte handeln:

- Der neue Ausschneide Bereich von complexregion weist überlappende Rahmen auf.

- Der Fehler des Geräte Kontexts oder der Region ist ungültig.

- Der neue Clippingbereich der NULLREGION ist leer.

- Der neue Ausschneide Bereich der simpleregion weist keine überlappenden Rahmen auf.

### <a name="remarks"></a>Bemerkungen

Es wird nur eine Kopie des ausgewählten Bereichs verwendet. Die Region selbst kann für eine beliebige Anzahl von anderen Geräte Kontexten ausgewählt werden, oder Sie kann gelöscht werden.

Die-Funktion geht davon aus, dass die Koordinaten für den angegebenen Bereich in Geräte Einheiten angegeben werden. Einige Drucker Geräte unterstützen die Textausgabe bei einer höheren Auflösung als bei der Grafikausgabe, um die für das Ausdrücken von textmetriken erforderliche Genauigkeit beizubehalten. Diese Geräte melden Geräte Einheiten mit höherer Auflösung, d. h. in Text Einheiten. Diese Geräte skalieren dann Koordinaten für Grafiken, sodass mehrere gemeldete Geräte Einheiten nur einer Grafikeinheit zugeordnet werden. Die Funktion sollte immer `SelectClipRgn` mit Text Einheiten aufgerufen werden.

Anwendungen, die die Skalierung von Grafikobjekten im GDI durchführen müssen, können den getscalingfactor Printer-Escapezeichen verwenden, um den Skalierungsfaktor zu ermitteln. Dieser Skalierungsfaktor wirkt sich auf das Clipping aus. Wenn ein Bereich zum Ausschneiden von Grafiken verwendet wird, dividiert GDI die Koordinaten durch den Skalierungsfaktor. Wenn der Bereich zum Ausschneiden von Text verwendet wird, nimmt GDI keine Skalierungs Anpassung vor. Der Skalierungsfaktor 1 bewirkt, dass die Koordinaten durch 2 dividiert werden. der Skalierungsfaktor 2 bewirkt, dass die Koordinaten durch 4 dividiert werden. Und so weiter.

## <a name="cdcselectobject"></a><a name="selectobject"></a>CDC:: SelectObject

Wählt ein Objekt in den Gerätekontext aus.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parameter

*Bewerbungs*<br/>
Ein Zeiger auf ein zu ausgewähltes [CPen](../../mfc/reference/cpen-class.md) -Objekt.

*pbrush*<br/>
Ein Zeiger auf ein [CBrush](../../mfc/reference/cbrush-class.md) -Objekt, das ausgewählt werden soll.

*pfont*<br/>
Ein Zeiger auf ein zu ausgewähltes [CFont](../../mfc/reference/cfont-class.md) -Objekt.

*pbitmap*<br/>
Ein Zeiger auf ein zu ausgewähltes [CBitmap](../../mfc/reference/cbitmap-class.md) -Objekt.

*PRGN*<br/>
Ein Zeiger auf ein zu ausgewähltes [crgn](../../mfc/reference/crgn-class.md) -Objekt.

*pObject*<br/>
Ein Zeiger auf ein [CGdiObject](../../mfc/reference/cgdiobject-class.md) -Objekt, das ausgewählt werden soll.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf das Objekt, das ersetzt wird. Dies ist ein Zeiger auf ein Objekt einer der von abgeleiteten Klassen `CGdiObject` , z. b `CPen` ., je nachdem, welche Version der Funktion verwendet wird. Der Rückgabewert ist NULL, wenn ein Fehler vorliegt. Diese Funktion gibt möglicherweise einen Zeiger auf ein temporäres Objekt zurück. Dieses temporäre Objekt ist nur während der Verarbeitung einer Windows-Nachricht gültig. Weitere Informationen finden Sie unter `CGdiObject::FromHandle`.

Die Version der Member-Funktion, die einen regions Parameter annimmt, führt dieselbe Aufgabe aus wie die `SelectClipRgn` Member-Funktion. Der Rückgabewert kann eines der folgenden sein:

- Der neue Ausschneide Bereich von complexregion weist überlappende Rahmen auf.

- Der Fehler des Geräte Kontexts oder der Region ist ungültig.

- Der neue Clippingbereich der NULLREGION ist leer.

- Der neue Ausschneide Bereich der simpleregion weist keine überlappenden Rahmen auf.

### <a name="remarks"></a>Bemerkungen

Die-Klasse `CDC` bietet fünf Versionen, die für bestimmte Arten von GDI-Objekten spezialisiert sind, einschließlich Stifte, Pinsel, Schriftarten, Bitmaps und Regionen. Das neu ausgewählte Objekt ersetzt das vorherige Objekt desselben Typs. Wenn beispielsweise *pObject* der allgemeinen Version von `SelectObject` auf ein [CPen](../../mfc/reference/cpen-class.md) -Objekt verweist, ersetzt die Funktion den aktuellen Stift durch den durch *pObject*angegebenen Stift.

Eine Anwendung kann eine Bitmap nur in den Kontext des Speichergeräts und nur jeweils in jeweils einem Speichergeräte Kontext auswählen. Das Format der Bitmap muss entweder monochrom sein oder mit dem Gerätekontext kompatibel sein. Wenn dies nicht der Fall ist, wird von `SelectObject` ein Fehler zurückgegeben.

Bei Windows 3,1 und höher gibt die `SelectObject` Funktion denselben Wert zurück, unabhängig davon, ob Sie in einer Metadatei verwendet wird. In früheren Versionen von Windows wurde `SelectObject` ein Wert ungleich 0 (null) für Erfolg und 0 für Fehler bei der Verwendung in einer Metadatei zurückgegeben.

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>CDC:: SelectPalette

Wählt die logische Palette aus, die von *pPalette* als ausgewähltes Palettenobjekt des Geräte Kontexts angegeben wird.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parameter

*pPalette*<br/>
Identifiziert die auszuwählende logische Palette. Diese Palette muss bereits mit der `CPalette` Member-Funktion [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)erstellt worden sein.

*bForceBackground*<br/>
Gibt an, ob die logische Palette als Hintergrund Palette erzwungen werden soll. Wenn *bForceBackground* nicht NULL ist, ist die ausgewählte Palette immer eine Hintergrund Palette, unabhängig davon, ob das Fenster den Eingabefokus besitzt. Wenn *bForceBackground* den Wert 0 hat und der Gerätekontext an ein Fenster angefügt ist, ist die logische Palette eine Vordergrund Palette, wenn das Fenster den Eingabefokus besitzt.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf ein- `CPalette` Objekt, das die logische Palette identifiziert, die durch die durch *pPalette*angegebene Palette ersetzt wird. Der Wert ist NULL, wenn ein Fehler vorliegt.

### <a name="remarks"></a>Bemerkungen

Die neue Palette wird zum Palettenobjekt, das von GDI zum Steuern von Farben verwendet wird, die im Gerätekontext angezeigt werden, und ersetzt die vorherige Palette.

Eine Anwendung kann eine logische Palette in mehr als einem Gerätekontext auswählen. Änderungen an einer logischen Palette wirken sich jedoch auf alle Geräte Kontexte aus, für die Sie ausgewählt ist. Wenn eine Anwendung eine Palette in mehr als einen Gerätekontext auswählt, müssen die Geräte Kontexte alle zum selben physischen Gerät gehören.

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>CDC:: selectstockobject

Wählt ein [CGdiObject](../../mfc/reference/cgdiobject-class.md) -Objekt aus, das einem der vordefinierten Aktien Stifte, Pinsel oder Schriftarten entspricht.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parameter

*nIndex*<br/>
Gibt die Art des gewünschten Aktien Objekts an. Es kann sich um einen der folgenden Werte handeln:

- BLACK_BRUSH schwarze Pinsel.

- DKGRAY_BRUSH dunkelgrauen Pinsel.

- GRAY_BRUSH grauen Pinsel.

- HOLLOW_BRUSH-hohl Pinsel.

- LTGRAY_BRUSH hellgrauer Pinsel.

- NULL_BRUSH NULL-Pinsel.

- WHITE_BRUSH weißen Pinsel.

- BLACK_PEN schwarzer Stift.

- NULL_PEN NULL-Stift.

- WHITE_PEN weißen Stift.

- ANSI_FIXED_FONT ANSI-System Schriftart mit fester Größe.

- ANSI_VAR_FONT ANSI-Variable System Schriftart.

- DEVICE_DEFAULT_FONT Geräte abhängige Schriftart.

- OEM_FIXED_FONT OEM-abhängige, fixierte Schriftart.

- SYSTEM_FONT die System Schriftart. Standardmäßig verwendet Windows die System Schriftart, um Menüs, Dialogfeld-Steuerelemente und anderen Text zu zeichnen. Es ist jedoch am besten, sich nicht auf SYSTEM_FONT zu verlassen, um die von Dialogfeldern und Fenstern verwendete Schriftart zu erhalten. Verwenden Sie stattdessen die- `SystemParametersInfo` Funktion mit dem SPI_GETNONCLIENTMETRICS-Parameter, um die aktuelle Schriftart abzurufen. `SystemParametersInfo`berücksichtigt das aktuelle Design und stellt Schriftart Informationen für Beschriftungen, Menüs und Nachrichten Dialogfelder bereit.

- SYSTEM_FIXED_FONT die in Windows verwendete System Schriftart mit fester Breite vor Version 3,0. Dieses Objekt ist für die Kompatibilität mit früheren Versionen von Windows verfügbar.

- DEFAULT_PALETTE Standard Farb Palette. Diese Palette besteht aus den 20 statischen Farben in der Systempalette.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf das `CGdiObject` Objekt, das ersetzt wurde, wenn die Funktion erfolgreich ausgeführt wurde. Das tatsächliche Objekt, auf das verwiesen wird, ist ein [CPen](../../mfc/reference/cpen-class.md)-, [CBrush](../../mfc/reference/cbrush-class.md)-oder [CFont](../../mfc/reference/cfont-class.md) -Objekt. Wenn der-Befehl nicht erfolgreich ist, ist der Rückgabewert NULL.

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>CDC:: abtabortproc

Installiert die Abbruch Prozedur für den Druckauftrag.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parameter

*lpfn*<br/>
Ein Zeiger auf die Abbruch-Funktion, die als Abbruch Prozedur installiert werden soll. Weitere Informationen zur Rückruffunktion finden Sie unter [Rückruffunktion für CDC:: abtabortproc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Rückgabewert

Gibt das Ergebnis der `SetAbortProc` Funktion an. Einige der folgenden Werte sind wahrscheinlicher als andere, aber alle sind möglich.

- Allgemeiner Fehler SP_ERROR.

- SP_OUTOFDISK nicht genügend Speicherplatz zum Spoolvorgang verfügbar, und es wird kein Speicherplatz mehr verfügbar.

- SP_OUTOFMEMORY nicht genügend Arbeitsspeicher zum Spoolvorgang verfügbar.

- SP_USERABORT Benutzer den Auftrag über den Druck-Manager beendet hat.

### <a name="remarks"></a>Bemerkungen

Wenn eine Anwendung zulässt, dass der Druckauftrag während des Spoolvorgangs abgebrochen werden kann, muss die Abbruch-Funktion festgelegt werden, bevor der Druckauftrag mit der [StartDoc](#startdoc) -Member-Funktion gestartet wird. Der Druck-Manager ruft während des Spoolvorgangs die Abbruch Funktion auf, damit die Anwendung den Druckauftrag abbrechen oder nicht genügend Speicherplatz verarbeiten kann. Wenn keine Abbruch Funktion festgelegt ist, schlägt der Druckauftrag fehl, wenn nicht genügend Speicherplatz für das Spoolvorgang verfügbar ist.

Beachten Sie, dass die Funktionen von Microsoft Visual C++ das Erstellen der Rückruffunktion vereinfachen, die an übermittelt wird `SetAbortProc` . Die an die `EnumObjects` Member-Funktion übergebenen Adresse ist ein Zeiger auf eine Funktion, `__declspec(dllexport)` die mit und mit der- **`__stdcall`** Aufruf Konvention exportiert wird.

Sie müssen den Funktionsnamen auch nicht in eine **Exports** -Anweisung in der Modul Definitionsdatei Ihrer Anwendung exportieren. Stattdessen können Sie den **Export** funktionsmodifizierer wie in verwenden.

`BOOL CALLBACK EXPORT AFunction( HDC, int );`

, wenn der Compiler bewirkt, dass der richtige Exportdaten Satz für den Export nach Namen ohne Aliasing ausgegeben wird. Dies funktioniert für die meisten Anforderungen. Für einige Sonderfälle, z. b. das Exportieren einer Funktion durch Ordinalzahl oder Aliasing des Exports, müssen Sie dennoch eine **Exports** -Anweisung in einer Modul Definitionsdatei verwenden.

Rückruf Registrierungs Schnittstellen sind nun typsicher (Sie müssen einen Funktionszeiger übergeben, der auf die richtige Funktionsart für den jeweiligen Rückruf zeigt).

Beachten Sie außerdem, dass alle Rückruf Funktionen Microsoft Foundation-Ausnahmen vor der Rückgabe an Windows abfangen müssen, da Ausnahmen nicht über Rückruf Grenzen hinweg ausgelöst werden können. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>CDC:: tartarcdirection

Legt die Zeichnungs Richtung fest, die für Bogen-und Rechteck Funktionen verwendet werden soll.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parameter

*narcdirection*<br/>
Gibt die neue Bogen Richtung an. Dieser Parameter kann einen der folgenden Werte aufweisen:

- AD_COUNTERCLOCKWISE Abbildungen gegen den Uhrzeigersinn gezeichnet.

- AD_CLOCKWISE im Uhrzeigersinn gezeichnete Abbildungen.

### <a name="return-value"></a>Rückgabewert

Gibt die alte Bogen Richtung an, wenn erfolgreich. andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Die Standardrichtung ist gegen den Uhrzeigersinn. Die- `SetArcDirection` Funktion gibt die Richtung an, in der die folgenden Funktionen zeichnen:

|Arc|Kreisdiagramm|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>CDC:: ""

Mit dieser Funktion können Sie den Attribut Gerätekontext festlegen `m_hAttribDC` .

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parameter

*HDC*<br/>
Ein Windows-Gerätekontext.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion fügt den Gerätekontext nicht an das- `CDC` Objekt an. Nur der Ausgabegeräte Kontext ist an ein- `CDC` Objekt angefügt.

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>CDC:: SetBkColor

Legt die aktuelle Hintergrundfarbe auf die angegebene Farbe fest.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crcolor*<br/>
Gibt die neue Hintergrundfarbe an.

### <a name="return-value"></a>Rückgabewert

Die vorherige Hintergrundfarbe als RGB-Farbwert. Wenn ein Fehler auftritt, ist der Rückgabewert 0x80000000.

### <a name="remarks"></a>Bemerkungen

Wenn der Hintergrundmodus nicht transparent ist, verwendet das System die Hintergrundfarbe, um die Lücken in formatierten Linien, die Lücken zwischen ausschlendeten Linien in Pinseln und den Hintergrund in Zeichen Zellen auszufüllen. Das System verwendet auch die Hintergrundfarbe beim Umrechnen von Bitmaps zwischen Farb-und Monochrom-Geräte Kontexten.

Wenn das Gerät die angegebene Farbe nicht anzeigen kann, legt das System die Hintergrundfarbe auf die nächste physische Farbe fest.

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>CDC:: setbkmode

Legt den Hintergrundmodus fest.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parameter

*nbkmode*<br/>
Gibt den Modus an, der festgelegt werden soll. Dieser Parameter kann einen der folgenden Werte aufweisen:

- Nicht transparenter Hintergrund wird mit der aktuellen Hintergrundfarbe ausgefüllt, bevor der Text, der ausgelöste Pinsel oder der Stift gezeichnet wird. Dies ist der Standard Hintergrundmodus.

- Transparenter Hintergrund wird vor dem Zeichnen nicht geändert.

### <a name="return-value"></a>Rückgabewert

Der vorherige Hintergrundmodus.

### <a name="remarks"></a>Bemerkungen

Der Hintergrundmodus definiert, ob das System vorhandene Hintergrundfarben auf der Zeichnungs Oberfläche vor dem Zeichnen von Text, auslendeten Pinseln oder einem beliebigen Stift Stil entfernt, der keine durchgezogenen Linie ist.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CWnd:: onctlcolor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>CDC:: setboundsrect

Steuert die Ansammlung von umgebenden Rechteck Informationen für den angegebenen Gerätekontext.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parameter

*lprectbounds*<br/>
Verweist auf eine `RECT` Struktur oder ein `CRect` Objekt, das zum Festlegen des umgebenden Rechtecks verwendet wird. Rechteck Dimensionen sind in logischen Koordinaten angegeben. Dieser Parameter kann NULL sein.

*flags*<br/>
Gibt an, wie das neue Rechteck mit dem akkumulierten Rechteck kombiniert wird. Dieser Parameter kann eine Kombination der folgenden Werte sein:

- DCB_ACCUMULATE das durch *lprectbounds* angegebene Rechteck dem umschließenden Rechteck hinzuzufügen (mit einem Rechteck-Union-Vorgang).

- DCB_DISABLE die Begrenzungen-Akkumulation deaktivieren.

- DCB_ENABLE die Begrenzungen-Akkumulation aktivieren. (Die Standardeinstellung für die Begrenzungen-Akkumulation ist deaktiviert.)

### <a name="return-value"></a>Rückgabewert

Der aktuelle Zustand des umgebenden Rechtecks, wenn die Funktion erfolgreich ausgeführt wurde. Ebenso wie *Flags*kann der Rückgabewert eine Kombination aus **DCB_** Werten sein:

- DCB_ACCUMULATE das umgebende Rechteck nicht leer ist. Dieser Wert wird immer festgelegt.

- Die kumulierten DCB_DISABLE Begrenzungen ist deaktiviert.

- Die Akkumulation der DCB_ENABLE Begrenzungen ist on.

### <a name="remarks"></a>Bemerkungen

Windows kann ein Begrenzungs Rechteck für alle Zeichnungsvorgänge beibehalten. Dieses Rechteck kann abgefragt und von der Anwendung zurückgesetzt werden. Die Zeichnungs Grenzen sind nützlich, um bitmapcaches ungültig zu machen.

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>CDC:: setbrushorg

Gibt den Ursprung an, den GDI dem nächsten Pinsel zuweist, der von der Anwendung in den Gerätekontext ausgewählt wird.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die x-Koordinate (in Geräte Einheiten) des neuen Ursprungs an. Dieser Wert muss im Bereich 0-7 liegen.

*Teenie*<br/>
Gibt die y-Koordinate (in Geräte Einheiten) des neuen Ursprungs an. Dieser Wert muss im Bereich 0-7 liegen.

*Punkt*<br/>
Gibt die x-und y-Koordinaten des neuen Ursprungs an. Jeder Wert muss im Bereich 0-7 liegen. Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Der vorherige Ursprung des Pinsels in den Geräte Einheiten.

### <a name="remarks"></a>Bemerkungen

Die Standard Koordinaten für den Pinsel Ursprung sind (0,0). Um den Ursprung eines Pinsels zu ändern, wird die- `UnrealizeObject` Funktion für das- `CBrush` Objekt aufgerufen, `SetBrushOrg` und der-Member wird aufgerufen, `SelectObject` um den Pinsel in den Gerätekontext auszuwählen.

Verwenden Sie nicht `SetBrushOrg` mit Aktien `CBrush` Objekten.

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>CDC:: setcoloradjustment

Legt die Farb Anpassungs Werte für den Gerätekontext mithilfe der angegebenen Werte fest.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parameter

*lpcoloradjust*<br/>
Verweist auf eine [coloradjustment](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) -Datenstruktur, die die Farb Anpassungs Werte enthält.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Bemerkungen

Die Farb Anpassungs Werte werden verwendet, um die Eingabe Farbe der Quell Bitmap für Aufrufe der Member- `CDC::StretchBlt` Funktion anzupassen, wenn der Modus "halbftone" festgelegt ist.

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>CDC:: setdcbrushcolor

Legt die aktuelle Pinsel Farbe des Geräte Kontexts (DC) auf den angegebenen Farbwert fest.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crcolor*<br/>
Gibt die neue Pinsel Farbe an.

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ausgeführt wird, gibt der Rückgabewert die vorherige DC-Pinsel Farbe als COLORREF-Wert an.

Wenn die Funktion fehlerhaft ist, ist der Rückgabewert CLR_INVALID.

### <a name="remarks"></a>Bemerkungen

Diese Methode emuliert die Funktionalität der Funktion " [setdcbrushcolor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor)", wie im Windows SDK beschrieben.

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>CDC:: setdcpcolor

Legt die Stift Farbe des aktuellen Geräte Kontexts (DC) auf den angegebenen Farbwert fest.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crcolor*<br/>
Gibt die neue Stift Farbe an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion verwendet die Win32-Funktion [setdcpcolor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor), wie im Windows SDK beschrieben.

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>CDC:: setgraphicsmode

Legt den Grafikmodus für den angegebenen Gerätekontext fest.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parameter

*iMode*<br/>
Gibt den Grafikmodus an. Eine Liste der Werte, die dieser Parameter annehmen kann, finden Sie unter [setgraphicsmode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Rückgabewert

Gibt bei Erfolg den alten Grafikmodus zurück.

Gibt bei einem Fehler 0 zurück. Um erweiterte Fehlerinformationen abzurufen, nennen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Bemerkungen

Diese Methode umschließt die Windows-GDI-Funktion [setgraphicsmode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

## <a name="cdcsetlayout"></a><a name="setlayout"></a>CDC:: setLayout

Mit dieser Member-Funktion können Sie das Layout von Text und Grafiken für einen Gerätekontext von rechts nach Links ändern, das Standardlayout für Kulturen wie Arabisch und Hebräisch.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parameter

*dwlayout*<br/>
Gerätekontext Layout und Bitmap-Steuerungsflags. Dies kann eine Kombination der folgenden Werte sein.

|Wert|Bedeutung|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Deaktiviert jede Reflektion für Aufrufe von [CDC:: BitBLT](#bitblt) und [CDC:: StretchBlt](#stretchblt).|
|LAYOUT_RTL|Legt das horizontale Standardlayout von rechts nach links fest.|
|LAYOUT_LTR|Legt das Standardlayout von links nach rechts fest.|

### <a name="return-value"></a>Rückgabewert

Wenn erfolgreich, das vorherige Layout des Geräte Kontexts.

Wenn nicht erfolgreich, GDI_ERROR. Um erweiterte Fehlerinformationen abzurufen, nennen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Bemerkungen

Normalerweise würden Sie `SetLayout` für ein Fenster nicht aufzurufen. Stattdessen steuern Sie das Layout von rechts nach links in einem Fenster, indem Sie die [erweiterten Fenster Stile](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) wie WS_EX_RTLREADING festlegen. Ein Gerätekontext (z. b. ein Drucker oder eine Metadatei) erbt dieses Layout nicht. Die einzige Möglichkeit zum Festlegen des Geräte Kontexts für ein Layout von rechts nach links ist das Aufrufen von `SetLayout` .

Wenn Sie **setLayout (LAYOUT_RTL** ) aufrufen, wird `SetLayout` der Zuordnungsmodus von automatisch in MM_ISOTROPIC geändert. Folglich gibt ein nachfolgende [getmapmode](#getmapmode) -aufrufen MM_ISOTROPIC statt MM_TEXT zurück.

In einigen Fällen, z. b. bei vielen Bitmaps, empfiehlt es sich, das Layout von links nach rechts beizubehalten. In diesen Fällen müssen Sie das Image durch Aufrufen von `BitBlt` oder Rendering `StretchBlt` und dann das Bitmap-Steuerelement Flag für *dwlayout* auf LAYOUT_BITMAPORIENTATIONPRESERVED festlegen.

Nachdem Sie das Layout mit dem LAYOUT_RTL-Flag geändert haben, werden die Flags, die normalerweise nach rechts oder Links angeben, umgekehrt. Um Verwirrung zu vermeiden, können Sie alternative Namen für die Standardflags definieren. Eine Liste der vorgeschlagenen Alternativen flagnamen finden Sie unter [setLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) in der Windows SDK.

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>CDC:: setmapmode

Legt den Modus für die Zuordnung fest.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parameter

*nmapmode*<br/>
Gibt den neuen Mapping-Modus an. Es kann sich um einen der folgenden Werte handeln:

- MM_ANISOTROPIC logischen Einheiten werden in beliebige Einheiten mit beliebig skalierten Achsen konvertiert. Wenn der Kartenmodus auf MM_ANISOTROPIC festgelegt wird, werden die aktuellen Fenster-oder viewporteinstellungen nicht geändert. Um die Einheiten, die Ausrichtung und die Skalierung zu ändern, müssen Sie die Element Funktionen [setwindowext](#setwindowext) und [setviewportext](#setviewportext) aufrufen.

- MM_HIENGLISH jede logische Einheit in 0,001 Zoll konvertiert wird. Positives x steht auf der rechten Seite. positives y ist aktiv.

- MM_HIMETRIC jede logische Einheit in 0,01 Millimeter konvertiert wird. Positives x steht auf der rechten Seite. positives y ist aktiv.

- MM_ISOTROPIC logische Einheiten werden in beliebige Einheiten mit gleichmäßig skalierten Achsen konvertiert. Das heißt, 1 Einheit entlang der x-Achse ist gleich 1 Einheit entlang der y-Achse. Verwenden `SetWindowExt` Sie die-und- `SetViewportExt` Member-Funktionen, um die gewünschten Einheiten und die Ausrichtung der Achsen anzugeben. GDI nimmt bei Bedarf Anpassungen vor, um sicherzustellen, dass die x-und y-Einheiten die gleiche Größe haben.

- MM_LOENGLISH jede logische Einheit in 0,01 Zoll konvertiert wird. Positives x steht auf der rechten Seite. positives y ist aktiv.

- MM_LOMETRIC jede logische Einheit in 0,1 Millimeter konvertiert wird. Positives x steht auf der rechten Seite. positives y ist aktiv.

- MM_TEXT jede logische Einheit in 1 Geräte Pixel konvertiert wird. Positives x steht auf der rechten Seite. positives y ist nicht mehr.

- MM_TWIPS jede logische Einheit in 1/20 eines Punkts konvertiert wird. (Da es sich bei einem Punkt um 1/72 Zoll handelt, ist ein Twip 1/1440 Zoll.) Positives x steht auf der rechten Seite. positives y ist aktiv.

### <a name="return-value"></a>Rückgabewert

Der vorherige Mapping-Modus.

### <a name="remarks"></a>Bemerkungen

Der Zuordnungsmodus definiert die Maßeinheit, die verwendet wird, um logische Einheiten in Geräte Einheiten zu konvertieren. Außerdem wird die Ausrichtung der x-und y-Achsen des Geräts definiert. GDI verwendet den Zuordnungsmodus, um logische Koordinaten in die entsprechenden Geräte Koordinaten zu konvertieren. Mit dem MM_TEXT Modus können Anwendungen in Geräte Pixeln arbeiten, wobei 1 Einheit gleich 1 Pixel ist. Die physische Größe eines Pixels variiert von Gerät zu Gerät.

Die Modi MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC und MM_TWIPS sind für Anwendungen nützlich, die in physisch sinnvollen Einheiten (z. b. Zoll oder Millimeter) gezeichnet werden müssen. Der MM_ISOTROPIC Modus stellt ein 1:1-Seitenverhältnis sicher, was nützlich ist, wenn es wichtig ist, die exakte Form eines Bilds beizubehalten. Der MM_ANISOTROPIC Modus ermöglicht, dass die x-und y-Koordinaten unabhängig voneinander angepasst werden.

> [!NOTE]
> Wenn Sie [setLayout](#setlayout) aufrufen, um den DC (Gerätekontext) in das Layout von rechts nach Links zu ändern, wird `SetLayout` der Zuordnungsmodus von automatisch in MM_ISOTROPIC geändert.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>CDC:: setmapperflags

Ändert die Methode, die vom Schriftart Mapper verwendet wird, wenn eine logische Schriftart in eine physische Schriftart konvertiert wird.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parameter

*dwFlag*<br/>
Gibt an, ob der Schriftart Mapper versucht, die Seitenhöhe und-Breite einer Schriftart dem Gerät zuzuordnen. Wenn dieser Wert ASPECT_FILTERING ist, wählt der Mapper nur die Schriftarten aus, deren x-Aspekt und y-Aspekt exakt mit denen des angegebenen Geräts übereinstimmen.

### <a name="return-value"></a>Rückgabewert

Der vorherige Wert des Font-Mapper-Flags.

### <a name="remarks"></a>Bemerkungen

Eine Anwendung kann verwenden `SetMapperFlags` , damit der Schriftart-Mapper versucht, nur eine physische Schriftart auszuwählen, die exakt mit dem Seitenverhältnis des angegebenen Geräts übereinstimmt.

Eine Anwendung, die nur Raster Schriftarten verwendet, kann die `SetMapperFlags` -Funktion verwenden, um sicherzustellen, dass die von der Schriftart Zuordnung ausgewählte Schriftart auf dem angegebenen Gerät attraktiv und lesbar ist. Anwendungen, die skalierbare (TrueType) Schriftarten verwenden, verwenden in der Regel nicht `SetMapperFlags` .

Wenn keine physische Schriftart über ein Seitenverhältnis verfügt, das mit der Spezifikation in der logischen Schriftart übereinstimmt, wählt GDI ein neues Seitenverhältnis aus und wählt eine Schriftart aus, die mit diesem neuen Seitenverhältnis übereinstimmt.

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>CDC:: setmiterlimit

Legt den Grenzwert für die Länge von Gehrungs-Joins für den Gerätekontext fest.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parameter

*Limit für die Anzahl*<br/>
Gibt das neue Gehrungs-Limit für den Gerätekontext an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Gehrungs-Länge wird als Abstand zwischen der Schnittmenge der Linien Wände im Inneren des Joins und der Schnittmenge der Linien Wände auf der Außenseite des Joins definiert. Das miterLimit ist das maximal zulässige Verhältnis der Gehrungs-Länge zur Linienbreite. Der Standard Grenzwert für das Trennzeichen ist 10,0.

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>CDC:: setoutputdc

Mit dieser Member-Funktion können Sie den Ausgabegeräte Kontext festlegen `m_hDC` .

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parameter

*HDC*<br/>
Ein Windows-Gerätekontext.

### <a name="remarks"></a>Bemerkungen

Diese Member-Funktion kann nur aufgerufen werden, wenn ein Gerätekontext nicht an das-Objekt angefügt wurde `CDC` . Diese Member-Funktion legt `m_hDC` den Gerätekontext fest, fügt ihn aber nicht an das- `CDC` Objekt an.

## <a name="cdcsetpixel"></a><a name="setpixel"></a>CDC:: SetPixel

Legt das Pixel an der angegebenen Stelle auf die nächstgelegene Näherung der durch *crcolor*angegebenen Farbe fest.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate des festzulegenden Punkts an.

*Teenie*<br/>
Gibt die logische y-Koordinate des festzulegenden Punkts an.

*crcolor*<br/>
Ein COLORREF RGB-Wert, der die Farbe angibt, mit der der Punkt gezeichnet wird. Eine Beschreibung dieses Werts finden Sie unter [COLORREF](/windows/win32/gdi/colorref) im Windows SDK.

*Punkt*<br/>
Gibt die logischen x-und y-Koordinaten des festzulegenden Punkts an. Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ein RGB-Wert für die Farbe, in der der Punkt tatsächlich gezeichnet wird. Dieser Wert kann sich von dem Wert unterscheiden, der von *crcolor* festgelegt wird, wenn eine Näherung dieser Farbe verwendet wird. Wenn die Funktion fehlschlägt (wenn sich der Punkt außerhalb des Clippingbereichs befindet), ist der Rückgabewert-1.

### <a name="remarks"></a>Bemerkungen

Der Punkt muss sich im Clippingbereich befinden. Wenn sich der Punkt nicht im Clippingbereich befindet, führt die Funktion keine Aktion aus.

Nicht alle Geräte unterstützen die `SetPixel`-Funktion. Um zu ermitteln, ob ein Gerät unterstützt `SetPixel` , müssen `GetDeviceCaps` Sie die Member-Funktion mit dem RasterCaps-Index aufrufen und den Rückgabewert für das RC_BITBLT-Flag überprüfen.

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>CDC:: setpixelv

Legt das Pixel an den angegebenen Koordinaten auf die nächstgelegene Näherung der angegebenen Farbe fest.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die x-Koordinate (in logischen Einheiten) des festzulegenden Punkts an.

*Teenie*<br/>
Gibt die y-Koordinate (in logischen Einheiten) des festzulegenden Punkts an.

*crcolor*<br/>
Gibt die Farbe an, die zum Zeichnen des Punkts verwendet werden soll.

*Punkt*<br/>
Gibt die logischen x-und y-Koordinaten des festzulegenden Punkts an. Sie können entweder eine [Punkt](/windows/win32/api/windef/ns-windef-point) Datenstruktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) -Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Punkt muss sowohl im Clippingbereich als auch im sichtbaren Teil der Geräteoberfläche liegen. Die Member-Funktion wird nicht von allen Geräten unterstützt. Weitere Informationen finden Sie unter RC_BITBLT Funktion in der `CDC::GetDeviceCaps` Member-Funktion. `SetPixelV`ist schneller als `SetPixel` , weil der Farbwert des tatsächlich gezeichneten Punkts nicht zurückgegeben werden muss.

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>CDC:: setpolyfillmode

Legt den Polygon Füll Modus fest.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parameter

*npolyfillmode*<br/>
Gibt den neuen Füll Modus an. Bei diesem Wert kann es sich entweder um eine Alternative oder um eine " Der in Windows festgelegte Standardmodus ist "Alternative".

### <a name="return-value"></a>Rückgabewert

Der vorherige Füllmodus, wenn erfolgreich. andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Wenn der Polygon Füllmodus eine Alternative ist, füllt das System den Bereich zwischen ungeraden und sogar nummerierten Polygon Seiten für jede Scan Zeile aus. Das heißt, das System füllt den Bereich zwischen der ersten und der zweiten Seite, zwischen der dritten und vierten Seite und so weiter. Dies ist der Standardmodus.

Wenn sich der Polygon Füllmodus in der Größe befindet, verwendet das System die Richtung, in der eine Figur gezeichnet wurde, um zu bestimmen, ob ein Bereich ausgefüllt werden soll. Jedes Liniensegment in einem Polygon wird entweder im Uhrzeigersinn oder gegen den Uhrzeigersinn gezeichnet. Wenn eine imaginäre Linie, die von einem eingeschlossenen Bereich zum äußeren Rand einer Figur gezeichnet wird, ein Liniensegment im Uhrzeigersinn übergibt, wird eine Anzahl erhöht. Wenn die Linie ein Liniensegment gegen den Uhrzeigersinn übergibt, wird die Anzahl dekrementiert. Der Bereich wird aufgefüllt, wenn die Anzahl nicht 0 (null) ist, wenn die Zeile den äußeren Rand der Abbildung erreicht.

## <a name="cdcsetrop2"></a><a name="setrop2"></a>CDC:: SetROP2

Legt den aktuellen Zeichnungsmodus fest.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parameter

*ndrawmode*<br/>
Gibt den neuen Zeichnungsmodus an. Dabei kann es sich um einen der folgenden Werte handeln:

- R2_BLACK Pixel ist immer schwarz.

- R2_WHITE Pixel ist immer weiß.

- R2_NOP Pixel bleibt unverändert.

- R2_NOT Pixel ist die Umkehrung der Bildschirm Farbe.

- R2_COPYPEN Pixel ist die Stift Farbe.

- R2_NOTCOPYPEN Pixel ist die Umkehrung der Stift Farbe.

- R2_MERGEPENNOT Pixel ist eine Kombination aus Stift Farbe und umgekehrter Bildschirm Farbe (letztes Pixel = (nicht Bildschirm Pixel) oder Stift).

- R2_MASKPENNOT Pixel ist eine Kombination der Farben, die sowohl dem Stift als auch der Umkehrung des Bildschirms gemeinsam sind (letztes Pixel = (nicht Bildschirm Pixel) und Stift).

- R2_MERGENOTPEN Pixel ist eine Kombination der Bildschirm Farbe und der Umkehrung der Stift Farbe (letztes Pixel = (nicht Stift) oder Bildschirm Pixel).

- R2_MASKNOTPEN Pixel ist eine Kombination der Farben, die sowohl auf dem Bildschirm als auch auf der Umkehrung des Stifts (letztes Pixel = (nicht Stift) und Bildschirm Pixel) gemeinsam sind.

- R2_MERGEPEN Pixel ist eine Kombination aus Stift Farbe und Bildschirm Farbe (letztes Pixel = Stift oder Bildschirm Pixel).

- R2_NOTMERGEPEN Pixel ist die Umkehrung der R2_MERGEPEN Farbe (letztes Pixel = Not (Stift oder Bildschirm Pixel)).

- R2_MASKPEN Pixel ist eine Kombination der Farben, die sowohl für den Stift als auch für den Bildschirm (letztes Pixel = Stift und Bildschirm Pixel) gemeinsam sind.

- R2_NOTMASKPEN Pixel ist die Umkehrung der R2_MASKPEN Farbe (letztes Pixel = Not (Stift und Bildschirm Pixel)).

- R2_XORPEN Pixel ist eine Kombination der Farben im Stift oder im Bildschirm, jedoch nicht in beiden (letztes Pixel = Stift-Xor-Bildschirm Pixel).

- R2_NOTXORPEN Pixel ist die Umkehrung der R2_XORPEN Farbe (letztes Pixel = Not (Pen XOR Screen Pixel)).

### <a name="return-value"></a>Rückgabewert

Der vorherige Zeichnungsmodus.

Dabei kann es sich um einen beliebigen Wert handeln, der in der Windows SDK angegeben ist.

### <a name="remarks"></a>Bemerkungen

Der Zeichnungsmodus gibt an, wie die Farben des Stifts und das Innere von ausgefüllten Objekten mit der Farbe kombiniert werden, die sich bereits auf der Anzeige Oberfläche befindet.

Der Zeichnungsmodus ist nur für Raster Geräte vorgesehen. Dies gilt nicht für Vektor Geräte. Zeichnungs Modi sind binäre Raster-Vorgangs Codes, die alle möglichen booleschen Kombinationen von zwei Variablen darstellen. dabei werden die binären Operatoren und, oder, und XOR (exklusiv oder) und die unäre Operation nicht verwendet.

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>CDC:: setstretchbltmode

Legt den Modus für die Bitmap-Streckung für die `StretchBlt` Member-Funktion fest.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parameter

*nstretchmode*<br/>
Gibt den streckungs Modus an. Dabei kann es sich um einen der folgenden Werte handeln:

|Wert|BESCHREIBUNG|
|-----------|-----------------|
|Blackonwhite|Führt einen booleschen and-Vorgang mit den Farbwerten für die ausgelösten und vorhandenen Pixel aus. Wenn es sich bei der Bitmap um eine monochrome Bitmap handelt, behält dieser Modus schwarze Pixel auf Kosten von weißen Pixeln bei.|
|Coloroncolor|Löscht die Pixel. In diesem Modus werden alle Lösch Zeilen gelöscht, ohne zu versuchen, Ihre Informationen beizubehalten.|
|Halbton|Ordnet Pixel aus dem Quell Rechteck in Blöcke von Pixeln im Ziel Rechteck. Die durchschnittliche Farbe für den Zielblock von Pixel entspricht der Farbe der Quell Pixel.|
||Nach dem Festlegen des Halftone-streckungs Modus muss eine Anwendung die Win32-Funktion [setbrushorgex](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) aufrufen, um den Pinsel Ursprung festzulegen. Wenn dies nicht der Fall ist, erfolgt eine Fehlausrichtung des Pinsels.|
|STRETCH_ANDSCANS|**Windows 95/98**: identisch mit "blackonwhite"|
|STRETCH_DELETESCANS|**Windows 95/98**: identisch mit coloroncolor|
|STRETCH_HALFTONE|**Windows 95/98**: identisch mit "Halftone".|
|STRETCH_ORSCANS|**Windows 95/98**: identisch mit whiteonblack|
|Whiteonblack|Führt eine boolesche OR-Operation mit den Farbwerten für die eliminieren und vorhandene Pixel aus. Wenn es sich bei der Bitmap um eine monochrome Bitmap handelt, werden in diesem Modus weiße Pixel auf der Kosten der schwarzen Pixel beibehalten.|

### <a name="return-value"></a>Rückgabewert

Der vorherige streckungs Modus. Sie kann STRETCH_ANDSCANS, STRETCH_DELETESCANS oder STRETCH_ORSCANS sein.

### <a name="remarks"></a>Bemerkungen

Der Modus für die Bitmap-Streckung definiert, wie Informationen aus Bitmaps entfernt werden, die mit der-Funktion komprimiert werden.

Der Modus "blackonwhite (STRETCH_ANDSCANS)" und "whiteonblack" (STRETCH_ORSCANS) wird in der Regel verwendet, um Vordergrund Pixel in monochrome Bitmaps beizubehalten. Der coloroncolor (STRETCH_DELETESCANS)-Modus wird normalerweise verwendet, um die Farbe in Farb Bitmaps beizubehalten.

Der Modus "Halftone" erfordert mehr Verarbeitung des Quell Abbilds als die anderen drei Modi. Sie ist langsamer als die anderen, erzeugt jedoch qualitativ hochwertige Images. Beachten Sie auch, dass `SetBrushOrgEx` nach dem Festlegen des Halftone-Modus aufgerufen werden muss, um eine fehlerhafte Pinsel Ausrichtung zu vermeiden.

Abhängig von den Funktionen des Gerätetreibers können auch zusätzliche streckungs Modi verfügbar sein.

## <a name="cdcsettextalign"></a><a name="settextalign"></a>CDC:: setTextAlign

Legt die Flags für die Textausrichtung fest.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parameter

*nFlags*<br/>
Gibt Flags für die Textausrichtung an. Die-Flags geben die Beziehung zwischen einem Punkt und einem Rechteck an, das den Text umschließt. Der Punkt kann entweder die aktuelle Position oder die von einer Textausgabe Funktion angegebenen Koordinaten sein. Das Rechteck, das den Text umschließt, wird durch die angrenzenden Zeichen Zellen in der Text Zeichenfolge definiert. Der *nFlags* -Parameter kann ein oder mehrere Flags aus den folgenden drei Kategorien sein. Wählen Sie nur ein Flag aus jeder Kategorie aus. Die erste Kategorie wirkt sich auf die Ausrichtung von Text in der x-Richtung aus:

- TA_CENTER richtet den Punkt mit der horizontalen Mitte des umgebenden Rechtecks aus.

- TA_LEFT richtet den Punkt mit der linken Seite des umgebenden Rechtecks aus. Dies ist die Standardeinstellung.

- TA_RIGHT richtet den Punkt am rechten Rand des umgebenden Rechtecks aus.

Die zweite Kategorie wirkt sich auf die Ausrichtung von Text in y-Richtung aus:

- TA_BASELINE richtet den Punkt mit der Basislinie der ausgewählten Schriftart aus.

- TA_BOTTOM richtet den Punkt am unteren Rand des umgebenden Rechtecks aus.

- TA_TOP richtet den Punkt am oberen Rand des umgebenden Rechtecks aus. Dies ist die Standardeinstellung.

Die dritte Kategorie bestimmt, ob die aktuelle Position beim Schreiben von Text aktualisiert wird:

- TA_NOUPDATECP aktualisiert die aktuelle Position nicht nach jedem aufzurufenden Textausgabe Funktion. Dies ist die Standardeinstellung.

- TA_UPDATECP aktualisiert die aktuelle x-Position nach jedem aufzurufenden Textausgabe Funktion. Die neue Position befindet sich auf der rechten Seite des umgebenden Rechtecks für den Text. Wenn dieses Flag festgelegt ist, werden die in Aufrufen der Member-Funktion angegebenen Koordinaten `TextOut` ignoriert.

### <a name="return-value"></a>Rückgabewert

Die vorherige Text Ausrichtungs Einstellung, wenn erfolgreich. Das nieder wertige Byte enthält die horizontale Einstellung, und das hochwertige Byte enthält die vertikale Einstellung. andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Die `TextOut` -und- `ExtTextOut` Member-Funktionen verwenden diese Flags, wenn Sie eine Text Zeichenfolge auf einer Anzeige oder einem Gerät positionieren. Die-Flags geben die Beziehung zwischen einem bestimmten Punkt und einem Rechteck an, das den Text umschließt. Die Koordinaten dieses Punkts werden als Parameter an die Member- `TextOut` Funktion übermittelt. Das Rechteck, das den Text umschließt, wird durch die angrenzenden Zeichen Zellen in der Text Zeichenfolge gebildet.

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>CDC:: settextcharakteriextra

Legt den Abstand zwischen Leerzeichen fest.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parameter

*ncharextra*<br/>
Gibt die Menge des zusätzlichen Speicherplatzes (in logischen Einheiten) an, der jedem Zeichen hinzugefügt werden soll. Wenn der aktuelle Kartenmodus nicht ist `MM_TEXT` , wird *ncharextra* transformiert und auf das nächste Pixel gerundet.

### <a name="return-value"></a>Rückgabewert

Die Menge der vorherigen intercharacter-Abstände.

### <a name="remarks"></a>Bemerkungen

GDI fügt jedem Zeichen diesen Abstand hinzu, einschließlich der Break-Zeichen, wenn eine Textzeile in den Gerätekontext geschrieben wird. Der Standardwert für die Menge der intercharacter-Abstände ist 0.

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>CDC:: SetTextColor

Legt die Textfarbe auf die angegebene Farbe fest.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crcolor*<br/>
Gibt die Textfarbe als RGB-Farbwert an.

### <a name="return-value"></a>Rückgabewert

Ein RGB-Wert für die vorherige Textfarbe.

### <a name="remarks"></a>Bemerkungen

Das System verwendet diese Textfarbe beim Schreiben von Text in diesen Gerätekontext und auch beim Umrechnen von Bitmaps zwischen Farb-und Monochrome-Geräte Kontexten.

Wenn das Gerät die angegebene Farbe nicht darstellen kann, legt das System die Textfarbe auf die nächste physische Farbe fest. Die Hintergrundfarbe für ein Zeichen wird durch die `SetBkColor` -und- `SetBkMode` Member-Funktionen angegeben.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CWnd:: onctlcolor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>CDC:: settextbegrün dung

Fügt den Break-Zeichen in einer Zeichenfolge Leerzeichen hinzu.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parameter

*nbreakextra*<br/>
Gibt den insgesamt zusätzlichen Speicherplatz an, der der Textzeile (in logischen Einheiten) hinzugefügt werden soll. Wenn der aktuelle Zuordnungsmodus nicht ist `MM_TEXT` , wird der von diesem Parameter angegebene Wert in den aktuellen Zuordnungsmodus konvertiert und auf die nächste Geräteeinheit gerundet.

*nbreakcount*<br/>
Gibt die Anzahl der Break-Zeichen in der Zeile an.

### <a name="return-value"></a>Rückgabewert

Eine, wenn die Funktion erfolgreich ist. andernfalls 0.

### <a name="remarks"></a>Bemerkungen

Eine Anwendung kann die `GetTextMetrics` Member-Funktionen verwenden, um das Break-Zeichen einer Schriftart abzurufen.

Nachdem die `SetTextJustification` Member-Funktion aufgerufen wurde, verteilt ein Aufruf einer Textausgabe Funktion (z. b. `TextOut` ) den angegebenen zusätzlichen Leerraum gleichmäßig auf die angegebene Anzahl von Break-Zeichen. Das Break-Zeichen ist in der Regel das Leerzeichen (ASCII 32), kann jedoch durch eine Schriftart als ein anderes Zeichen definiert werden.

Die Member-Funktion `GetTextExtent` wird in der Regel mit verwendet `SetTextJustification` . `GetTextExtent`berechnet die Breite einer angegebenen Zeile vor der Ausrichtung. Eine Anwendung kann ermitteln, wie viel Speicherplatz im *nbreakextra* -Parameter angegeben werden soll, indem der von zurückgegebene Wert von `GetTextExtent` der Breite der Zeichenfolge nach der Ausrichtung subtrahieren wird.

Die- `SetTextJustification` Funktion kann verwendet werden, um eine Zeile auszurichten, die mehrere Ausführungen in unterschiedlichen Schriftarten enthält. In diesem Fall muss die Zeile schrittweise erstellt werden, indem die einzelnen Testlauf einzeln ausgerichtet und geschrieben werden.

Da während der Ausrichtung Rundungsfehler auftreten können, behält das System einen laufenden Fehler Begriff bei, der den aktuellen Fehler definiert. Beim Ausrichten einer Zeile, die mehrere Ausführungen enthält, wird `GetTextExtent` dieser Fehler Begriff von automatisch verwendet, wenn der Umfang der nächsten Ausführung berechnet wird. Dadurch kann die Textausgabe Funktion den Fehler in den neuen Testlauf einblenden.

Nachdem jede Zeile ausgerichtet wurde, muss diese Fehlerbedingung gelöscht werden, um zu verhindern, dass Sie in die nächste Zeile eingebunden wird. Der Begriff kann gelöscht werden, indem aufgerufen wird `SetTextJustification` , wobei *nbreakextra* auf 0 festgelegt ist.

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>CDC:: setviewportext

Legt die x-und y-Blöcke des Viewports des Geräte Kontexts fest.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parameter

*verschoben*<br/>
Gibt den x-Umfang des Viewports an (in Geräte Einheiten).

*CY*<br/>
Gibt den y-Umfang des Viewports an (in Geräte Einheiten).

*size*<br/>
Gibt die x-und y-Blöcke des Viewports an (in Geräte Einheiten).

### <a name="return-value"></a>Rückgabewert

Die vorherigen Blöcke des Viewports als [CSize](../../atl-mfc-shared/reference/csize-class.md) -Objekt. Wenn ein Fehler auftritt, werden die x-und y-Koordinaten des zurückgegebenen- `CSize` Objekts auf 0 festgelegt.

### <a name="remarks"></a>Bemerkungen

Der Viewport definiert zusammen mit dem Fenster "Gerätekontext", wie GDI Punkte im logischen Koordinatensystem den Punkten im Koordinatensystem des eigentlichen Geräts zuordnet. Anders ausgedrückt: Sie definieren, wie GDI logische Koordinaten in Geräte Koordinaten konvertiert.

Wenn die folgenden zuordnungsmodi festgelegt sind, werden Aufrufe von `SetWindowExt` und `SetViewportExt` ignoriert:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Wenn MM_ISOTROPIC Modus festgelegt ist, muss eine Anwendung die `SetWindowExt` Member-Funktion aufrufen, bevor aufgerufen wird `SetViewportExt` .

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>CDC:: setviewportor

Legt den Viewportursprung des Geräte Kontexts fest.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die x-Koordinate (in Geräte Einheiten) des Ursprungs des Viewports an. Der Wert muss innerhalb des Bereichs des Geräte Koordinatensystems liegen.

*Teenie*<br/>
Gibt die y-Koordinate (in Geräte Einheiten) des Ursprungs des Viewports an. Der Wert muss innerhalb des Bereichs des Geräte Koordinatensystems liegen.

*Punkt*<br/>
Gibt den Ursprung des Viewports an. Die Werte müssen innerhalb des Bereichs des Geräte Koordinatensystems liegen. Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Der vorherige Ursprung des Viewports (in Geräte Koordinaten) als- `CPoint` Objekt.

### <a name="remarks"></a>Bemerkungen

Der Viewport definiert zusammen mit dem Fenster "Gerätekontext", wie GDI Punkte im logischen Koordinatensystem den Punkten im Koordinatensystem des eigentlichen Geräts zuordnet. Anders ausgedrückt: Sie definieren, wie GDI logische Koordinaten in Geräte Koordinaten konvertiert.

Der Viewportursprung markiert den Punkt im Geräte Koordinatensystem, dem GDI den Fenster Ursprung zuordnet, einen Punkt im logischen Koordinatensystem, der durch die `SetWindowOrg` Member-Funktion angegeben wird. GDI ordnet alle anderen Punkte zu, indem der gleiche Prozess zum Zuordnen des Fenster Ursprungs zum Viewportursprung folgt. Beispielsweise befinden sich alle Punkte in einem Kreis um den Punkt am Fenster Ursprung in einem Kreis um den Punkt am Viewportursprung. Ebenso werden alle Punkte in einer Zeile, die den Fenster Ursprung durchläuft, in einer Zeile angezeigt, die den Viewportursprung übergibt.

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>CDC:: setwindowext

Legt die x-und y-Blöcke des Fensters fest, das dem Gerätekontext zugeordnet ist.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parameter

*verschoben*<br/>
Gibt den x-Block (in logischen Einheiten) des Fensters an.

*CY*<br/>
Gibt den y-Block (in logischen Einheiten) des Fensters an.

*size*<br/>
Gibt die x-und y-Blöcke (in logischen Einheiten) des Fensters an.

### <a name="return-value"></a>Rückgabewert

Die vorherigen Blöcke des Fensters (in logischen Einheiten) als- `CSize` Objekt. Wenn ein Fehler auftritt, werden die x-und y-Koordinaten des zurückgegebenen- `CSize` Objekts auf 0 festgelegt.

### <a name="remarks"></a>Bemerkungen

Das Fenster wird zusammen mit dem Device-Context-Viewport definiert, wie das GDI Punkte im logischen Koordinatensystem den Punkten im Geräte Koordinatensystem zuordnet.

Wenn die folgenden zuordnungsmodi festgelegt sind, werden Aufrufe der `SetWindowExt` -Funktion und der- `SetViewportExt` Funktion ignoriert:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Wenn MM_ISOTROPIC Modus festgelegt ist, muss eine Anwendung die `SetWindowExt` Member-Funktion aufrufen, bevor aufgerufen wird `SetViewportExt` .

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>CDC:: setwindoworg

Legt den Fenster Ursprung des Geräte Kontexts fest.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate des neuen Ursprungs des Fensters an.

*Teenie*<br/>
Gibt die logische y-Koordinate des neuen Ursprungs des Fensters an.

*Punkt*<br/>
Gibt die logischen Koordinaten des neuen Ursprungs des Fensters an. Sie können entweder eine `POINT` Struktur oder ein- `CPoint` Objekt für diesen Parameter übergeben.

### <a name="return-value"></a>Rückgabewert

Der vorherige Ursprung des Fensters als- `CPoint` Objekt.

### <a name="remarks"></a>Bemerkungen

Das Fenster wird zusammen mit dem Device-Context-Viewport definiert, wie das GDI Punkte im logischen Koordinatensystem den Punkten im Geräte Koordinatensystem zuordnet.

Der Fenster Ursprung markiert den Punkt im logischen Koordinatensystem, von dem GDI den Viewportursprung zuordnet, einen Punkt im Geräte Koordinatensystem, der durch die-Funktion angegeben wird `SetWindowOrg` . GDI ordnet alle anderen Punkte zu, indem der gleiche Prozess zum Zuordnen des Fenster Ursprungs zum Viewportursprung folgt. Beispielsweise befinden sich alle Punkte in einem Kreis um den Punkt am Fenster Ursprung in einem Kreis um den Punkt am Viewportursprung. Ebenso werden alle Punkte in einer Zeile, die den Fenster Ursprung durchläuft, in einer Zeile angezeigt, die den Viewportursprung übergibt.

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>CDC:: setworldtransform

Legt eine zweidimensionale lineare Transformation zwischen dem Welt Raum und dem Seiten Raum für den angegebenen Gerätekontext fest. Diese Transformation kann verwendet werden, um die Grafikausgabe zu skalieren, zu drehen, zu Scheren oder zu übersetzen.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parameter

*rxform*<br/>
Verweis auf eine [XForm](/windows/win32/api/wingdi/ns-wingdi-xform) -Struktur, die die Transformations Daten enthält.

### <a name="return-value"></a>Rückgabewert

Gibt bei Erfolg einen Wert ungleich 0 (null) zurück.

Gibt bei einem Fehler 0 zurück.

Um erweiterte Fehlerinformationen abzurufen, nennen Sie [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Bemerkungen

Diese Methode umschließt die Windows-GDI-Funktion [setworldtransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform).

## <a name="cdcstartdoc"></a><a name="startdoc"></a>CDC:: StartDoc

Informiert den Gerätetreiber, dass ein neuer Druckauftrag gestartet wird und dass alle nachfolgenden `StartPage` -und- `EndPage` Aufrufe unter demselben Auftrag gespoolte werden sollen, bis ein `EndDoc` Aufruf erfolgt.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parameter

*lpdocinfo*<br/>
Verweist auf eine [DocInfo](/windows/win32/api/wingdi/ns-wingdi-docinfow) -Struktur, die den Namen der Dokument Datei und den Namen der Ausgabedatei enthält.

*lpszdocname*<br/>
Zeiger auf eine Zeichenfolge, die den Namen der Dokument Datei enthält.

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ausgeführt wird, ist der Rückgabewert größer als 0 (null). Dieser Wert ist der Druckauftrags Bezeichner für das Dokument.

Wenn die Funktion fehlschlägt, ist der Rückgabewert kleiner oder gleich 0 (null).

### <a name="remarks"></a>Bemerkungen

Dadurch wird sichergestellt, dass Dokumente, die länger als eine Seite sind, nicht mit anderen Aufträgen vermischt werden.

Bei Windows-Versionen 3,1 und höher ersetzt diese Funktion den StartDoc-druckerescapezeichen. Durch die Verwendung dieser Funktion wird sichergestellt, dass Dokumente, die mehr als eine Seite enthalten, nicht mit anderen Druckaufträgen vermischt werden.

`StartDoc`sollte nicht innerhalb von Metafiles verwendet werden.

### <a name="example"></a>Beispiel

Dieses Code Fragment Ruft den Standarddrucker ab, öffnet einen Druckauftrag und Spool eine Seite mit "Hello, World!" darauf. Da der Text, der von diesem Code gedruckt wird, nicht auf die logischen Einheiten des Druckers skaliert wird, kann der Ausgabetext in so kleinen Buchstaben enthalten sein, dass das Ergebnis nicht lesbar ist. Die CDC-Skalierungs Funktionen (z. b. `SetMapMode` , `SetViewportOrg` und) `SetWindowExt` können verwendet werden, um die Skalierung zu beheben.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>CDC:: Startpage

Diese Member-Funktion wird aufgerufen, um den Druckertreiber für den Empfang von Daten vorzubereiten.

```
int StartPage();
```

### <a name="return-value"></a>Rückgabewert

Größer oder gleich 0 (null), wenn die Funktion erfolgreich ist, oder ein negativer Wert, wenn ein Fehler aufgetreten ist.

### <a name="remarks"></a>Bemerkungen

`StartPage`ersetzt die Escapesequenzen und Bandinfo-Escapezeichen.

Eine Übersicht über die Abfolge von Druck aufrufen finden Sie unter der [StartDoc](#startdoc) -Member-Funktion.

Das System deaktiviert die `ResetDC` Member-Funktion zwischen Aufrufen von `StartPage` und `EndPage` .

### <a name="example"></a>Beispiel

  Weitere Informationen finden Sie im Beispiel für [CDC:: StartDoc](#startdoc).

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>CDC:: StretchBlt

Kopiert eine Bitmap aus einem Quellrechteck in ein Zielrechteck, wobei das Bitmap gestreckt oder komprimiert wird, falls dies notwendig ist, um zu den Maßen des Zielrechtecks zu passen.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Zielrechtecks an.

*Teenie*<br/>
Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Zielrechtecks an.

*nwidth*<br/>
Gibt die Breite (in logischen Einheiten) des Zielrechtecks an.

*nheight*<br/>
Gibt die Höhe (in logischen Einheiten) des Zielrechtecks an.

*psrcdc*<br/>
Gibt den Quellgerätekontext an.

*xsrc*<br/>
Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quellrechtecks an.

*ysrc*<br/>
Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quellrechtecks an.

*nsrcwidth*<br/>
Gibt die Breite (in logischen Einheiten) des Quellrechtecks an.

*nsrcheight*<br/>
Gibt die Höhe (in logischen Einheiten) des Quellrechtecks an.

*dwRop*<br/>
Gibt das Raster des auszuführenden Vorgangs an. Rastervorgangscode definiert, wie GDI Farben in Ausgabevorgängen kombiniert, an denen ein aktueller Pinsel, eine mögliche Quellbitmap und eine Zielbitmap beteiligt sind. Dieser Parameter kann möglicherweise einen der folgenden Werte aufweisen:

- Blackness schaltet alle Ausgaben schwarz.

- Dstinvert kehrt die Ziel Bitmap um.

- Mergecopy kombiniert das Muster und die Quell Bitmap mithilfe des booleschen and-Operators.

- MergePaint kombiniert die invertierte Quell Bitmap mit der Ziel Bitmap mithilfe des booleschen OR-Operators.

- Nozrccopy kopiert die invertierte Quell Bitmap in das Ziel.

- Nozrcerase kehrt das Ergebnis der Kombination der Ziel-und Quell Bitmaps mithilfe des booleschen OR-Operators um.

- Patcopy kopiert das Muster in die Ziel Bitmap.

- Patinvert kombiniert die Ziel Bitmap mit dem Muster mithilfe des booleschen XOR-Operators.

- Patpaint kombiniert die invertierte Quell Bitmap mit dem Muster mithilfe des booleschen OR-Operators. Hierdurch wird das Ziel dieses Vorgangs mithilfe des booleschen OR-Operators mit dem Zielbitmap kombiniert.

- Srcand kombiniert Pixel der Ziel-und Quell Bitmaps mithilfe des booleschen and-Operators.

- Srccopy kopiert die Quell Bitmap in die Ziel Bitmap.

- Srcerase kehrt die Ziel Bitmap um und kombiniert das Ergebnis mit der Quell Bitmap mithilfe des booleschen and-Operators.

- Srcinvert kombiniert Pixel der Ziel-und Quell Bitmaps mithilfe des booleschen XOR-Operators.

- Srcpaint kombiniert Pixel der Ziel-und Quell Bitmaps mithilfe des booleschen OR-Operators.

- Mit der whitheit wird die Ausgabe weiß.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Bitmap gezeichnet wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Die Funktion verwendet den Streckmodus des Zielgerätkontexts (durch `SetStretchBltMode` festgelegt), um zu bestimmen, wie die Bitmap gestreckt oder komprimiert werden soll.

Die- `StretchBlt` Funktion verschiebt die Bitmap von dem von *psrcdc* angegebenen Quellgerät auf das Zielgerät, das durch das Gerätekontext Objekt dargestellt wird, dessen Member-Funktion aufgerufen wird. Mit den Parametern *xsrc*, *ysrc*, *nsrcwidth*und *nsrcheight* werden die linke obere Ecke und die Abmessungen des Quell Rechtecks definiert. Der Parameter " *x*", " *y*", " *nwidth*" und " *nheight* " gibt die obere linke Ecke und die Abmessungen des Ziel Rechtecks an. Der von *dwrop* angegebene Raster Vorgang definiert, wie die Quell Bitmap und die Bits, die sich bereits auf dem Zielgerät befinden, kombiniert werden.

Die- `StretchBlt` Funktion erstellt ein Spiegelbild einer Bitmap, wenn die Vorzeichen der Parameter " *nsrcwidth* " und " *nwidth* " oder " *nsrcheight* " und " *nheight* " unterschiedlich sind. Wenn " *nsrcwidth* " und " *nwidth* " andere Vorzeichen aufweisen, erstellt die Funktion ein Spiegelbild der Bitmap entlang der x-Achse. Wenn " *nsrcheight* " und " *nheight* " andere Vorzeichen aufweisen, erstellt die Funktion ein Spiegelbild der Bitmap entlang der y-Achse.

Die Funktion `StretchBlt` streckt oder komprimiert die Quellbitmap im Speicher und kopiert dann das Ergebnis in das Ziel. Wenn ein Muster mit dem Ergebnis zusammengeführt werden soll, wird es erst zusammengeführt, wenn die gestreckte Quellbitmap in das Ziel kopiert wurde. Wenn ein Pinsel verwendet wird, ist es der ausgewählte Pinsel im Zielgerätekontext. Die Zielkoordinaten werden gemäß dem Zielgerätekontext transformiert. Die Quellkoordinaten werden gemäß dem Quellgerätekontext transformiert.

Wenn das Ziel, die Quelle und die Musterbitmaps nicht dasselbe Farbformat haben, konvertiert `StretchBlt` die Quelle und die Musterbitmaps so, dass sie mit den Zielbitmaps übereinstimmen. Die Vordergrund- und Hintergrundfarben des Zielgerätekontexts werden bei der Konvertierung verwendet.

Wenn `StretchBlt` eine monochrome Bitmap in eine farbige konvertiere muss, legt sie weiße Bits (1) für die Hintergrundfarbe und schwarze Bits (0) für die Vordergrundfarbe fest. Um Farbe in monochrom zu verwandeln, legt sie Pixel, die mit der Hintergrundfarbe übereinstimmen, auf weiß (1) fest und legt alle anderen Pixel auf schwarz (0) fest. Die Vordergrund- und Hintergrundfarben des Gerätekontexts mit Farbe werden verwendet.

Nicht alle Geräte unterstützen die `StretchBlt`-Funktion. Um zu ermitteln, ob ein Gerät unterstützt `StretchBlt` , müssen `GetDeviceCaps` Sie die Member-Funktion mit dem RasterCaps-Index aufrufen und den Rückgabewert für das RC_STRETCHBLT-Flag überprüfen.

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>CDC:: strokeandfillpath

Schließt alle geöffneten Abbildungen in einem Pfad, streift die Gliederung des Pfads mithilfe des aktuellen Stifts und füllt das Innere mit dem aktuellen Pinsel.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Gerätekontext muss einen geschlossenen Pfad enthalten. Die `StrokeAndFillPath` Member-Funktion hat denselben Effekt wie das Schließen aller geöffneten Abbildungen im Pfad, wobei der Pfad separat gezeichnet und ausgefüllt wird, mit dem Unterschied, dass der ausgefüllte Bereich sich nicht überschneidet, auch wenn der Stift breit ist.

## <a name="cdcstrokepath"></a><a name="strokepath"></a>CDC:: strokePath

Rendert den angegebenen Pfad mit dem aktuellen Stift.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Der Gerätekontext muss einen geschlossenen Pfad enthalten.

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>CDC:: tabbedtextout

Mit dieser Member-Funktion können Sie eine Zeichenfolge an der angegebenen Position schreiben und die Registerkarten auf die Werte erweitern, die im Array der Tabstopp Positionen angegeben sind.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate des Anfangs Punkts der Zeichenfolge an.

*Teenie*<br/>
Gibt die logische y-Koordinate des Anfangs Punkts der Zeichenfolge an.

*lpszstring*<br/>
Verweist auf die Zeichenfolge, die gezeichnet werden soll. Sie können entweder einen Zeiger an ein Zeichen Array oder ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) -Objekt für diesen Parameter übergeben.

*nCount*<br/>
Gibt die [Länge der Zeichenfolge](/windows/win32/gdi/specifying-length-of-text-output-string) an, auf die von *lpszstring*verwiesen wird.

*ntabpositionen*<br/>
Gibt die Anzahl der Werte im Array der Tabstopp-Positions Positionen an.

*lpntabstoppositions*<br/>
Verweist auf ein Array, das die Position der Tabstopps (in logischen Einheiten) enthält. Die Tabstopps müssen in steigender Reihenfolge sortiert werden. der kleinste x-Wert sollte das erste Element im Array sein.

*ntaborigin*<br/>
Gibt die x-Koordinate der Anfangsposition an, von der Tabstopps (in logischen Einheiten) erweitert werden.

*str*<br/>
Ein- `CString` Objekt, das die angegebenen Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Die Dimensionen der Zeichenfolge (in logischen Einheiten) als- `CSize` Objekt.

### <a name="remarks"></a>Bemerkungen

Der Text wird in der aktuell ausgewählten Schriftart geschrieben. Wenn *ntabpositions* den Wert 0 hat und *lpntabstoppositions* den Wert NULL hat, werden die Registerkarten auf das Achtfache der durchschnittlichen Zeichenbreite erweitert.

Wenn *ntabpositions* den Wert 1 hat, werden die Tabstopps durch die Entfernung getrennt, die durch den ersten Wert im *lpntabstoppositions* -Array angegeben wird. Wenn das *lpntabstoppositions* -Array mehr als einen Wert enthält, wird für jeden Wert im Array ein Tabstopp festgelegt, bis zu der von *ntabpositions*angegebenen Zahl. Der *ntaborigin* -Parameter ermöglicht es einer Anwendung, die `TabbedTextOut` Funktion mehrmals für eine einzelne Zeile aufzurufen. Wenn die Anwendung die Funktion mehrmals aufruft, wobei *ntaborigin* immer auf denselben Wert festgelegt ist, erweitert die Funktion alle Registerkarten relativ zu der durch *ntaborigin*angegebenen Position.

Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert. Wenn eine Anwendung die aktuelle Position aktualisieren muss, wenn Sie die Funktion aufruft, kann die Anwendung die Member-Funktion [setTextAlign](#settextalign) mit *nFlags* aufrufen, die auf TA_UPDATECP festgelegt sind. Wenn dieses Flag festgelegt ist, ignoriert Windows die *x* -und *y* -Parameter bei nachfolgenden Aufrufen von und `TabbedTextOut` verwendet dabei die aktuelle Position.

## <a name="cdctextout"></a><a name="textout"></a>CDC:: TextOut

Schreibt mithilfe der aktuell ausgewählten Schriftart eine Zeichenfolge an dem angegebenen Speicherort.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parameter

*x*<br/>
Gibt die logische x-Koordinate des Anfangspunkts des Texts an.

*Teenie*<br/>
Gibt die logische y-Koordinate des Anfangspunkts des Texts an.

*lpszstring*<br/>
Zeigt auf die zu zeichnende Zeichenfolge.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an.

*str*<br/>
Ein `CString`-Objekt, das die zu zeichnenden Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Zeichenursprünge befindet sich in der oberen linken Ecke der Zeichenzelle. Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert.

Wenn eine Anwendung die aktuelle Position aktualisieren muss, wenn Sie aufruft `TextOut` , kann die Anwendung die `SetTextAlign` Member-Funktion mit *nFlags* aufrufen, die auf TA_UPDATECP festgelegt sind. Wenn dieses Flag festgelegt ist, ignoriert Windows die *x* -und *y* -Parameter bei nachfolgenden Aufrufen von und `TextOut` verwendet dabei die aktuelle Position.

### <a name="example"></a>Beispiel

  Sehen Sie sich das Beispiel für [CDC:: beginpath](#beginpath)an.

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>CDC:: TransparentBlt

Mit dieser Member-Funktion wird ein Bitblock der Farbdaten, der einem Rechteck aus Pixeln aus dem angegebenen Quell Gerätekontext entspricht, in einen Zielgeräte Kontext übertragen.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parameter

*xdest*<br/>
Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Ziel Rechtecks an.

*ydest*<br/>
Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Ziel Rechtecks an.

*ndestwidth*<br/>
Gibt die Breite (in logischen Einheiten) des Ziel Rechtecks an.

*ndestheight*<br/>
Gibt die Höhe (in logischen Einheiten) des Ziel Rechtecks an.

*psrcdc*<br/>
Zeiger auf den Quell Gerätekontext.

*xsrc*<br/>
Gibt die x-Koordinate (in logischen Einheiten) des Quell Rechtecks an.

*ysrc*<br/>
Gibt die y-Koordinate (in logischen Einheiten) des Quell Rechtecks an.

*nsrcwidth*<br/>
Gibt die Breite des Quell Rechtecks in logischen Einheiten an.

*nsrcheight*<br/>
Gibt die Höhe des Quell Rechtecks in logischen Einheiten an.

*clrtransparent*<br/>
Die RGB-Farbe in der Quell Bitmap, die als transparent behandelt werden soll.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Bemerkungen

`TransparentBlt`ermöglicht Transparenz; Das heißt, die RGB-Farbe, die *clrtransparent* angibt, wird für die Übertragung transparent gerendert.

Weitere Informationen finden Sie unter [TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) in der Windows SDK.

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>CDC:: updatecolors

Aktualisiert den Client Bereich des Geräte Kontexts, indem die aktuellen Farben im Client Bereich auf pixelweise mit der Systempalette übereinstimmen.

```cpp
void UpdateColors();
```

### <a name="remarks"></a>Bemerkungen

Ein inaktives Fenster mit einer erkannten logischen Palette kann `UpdateColors` als Alternative zum Neuzeichnen des Client Bereichs aufgerufen werden, wenn sich die Systempalette ändert.

Weitere Informationen zur Verwendung von Farbpaletten finden Sie unter [updatecolors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) in der Windows SDK.

Die `UpdateColors` Member-Funktion aktualisiert in der Regel einen Client Bereich schneller, als den Bereich neu zu zeichnen. Da die Funktion jedoch die Farb Übersetzung basierend auf der Farbe jedes Pixels vor der Änderung der Systempalette ausführt, führt jeder Rückruf dieser Funktion zu einem Verlust der Farbgenauigkeit.

## <a name="cdcwidenpath"></a><a name="widenpath"></a>CDC:: widenpath

Definiert den aktuellen Pfad neu als den Bereich, der gezeichnet werden würde, wenn der Pfad mithilfe des derzeit im Gerätekontext ausgewählten Stifts gezeichnet würde.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Bemerkungen

Diese Funktion ist nur erfolgreich, wenn der aktuelle Stift ein geometrischer Stift ist, der von der zweiten Version der Element `CreatePen` Funktion erstellt wurde, oder wenn der Stift mit der ersten Version von erstellt wird `CreatePen` und in Geräte Einheiten eine Breite von mehr als 1 aufweist. Der Gerätekontext muss einen geschlossenen Pfad enthalten. Alle Bzier-Kurven im Pfad werden in Sequenzen von geraden Zeilen konvertiert, die den erweiterten Kurven ähneln. Daher verbleiben keine Bzier-Kurven im Pfad, nachdem `WidenPath` aufgerufen wurde.

## <a name="see-also"></a>Weitere Informationen

[CObject-Klasse](../../mfc/reference/cobject-class.md)<br/>
[Hierarchie Diagramm](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC-Klasse](../../mfc/reference/cpaintdc-class.md)<br/>
[Cwindowdc-Klasse](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC-Klasse](../../mfc/reference/cclientdc-class.md)<br/>
[Cmetafiledc-Klasse](../../mfc/reference/cmetafiledc-class.md)
