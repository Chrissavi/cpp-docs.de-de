---
title: CDC-Klasse
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 06c68d02433ce53c2b27167a985fc5854ca49700
ms.sourcegitcommit: 9e891eb17b73d98f9086d9d4bfe9ca50415d9a37
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/20/2018
ms.locfileid: "52176912"
---
# <a name="cdc-class"></a>CDC-Klasse

Definiert eine Klasse von Gerätekontextobjekten.

## <a name="syntax"></a>Syntax

```
class CDC : public CObject
```

## <a name="members"></a>Member

### <a name="public-constructors"></a>Öffentliche Konstruktoren

|Name|Beschreibung|
|----------|-----------------|
|[CDC::CDC](#cdc)|Erstellt ein `CDC`-Objekt.|

### <a name="public-methods"></a>Öffentliche Methoden

|Name|Beschreibung|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Beendet den aktuellen Druckauftrag, löschen Alles, was die Anwendung an das Gerät, seit dem letzten Aufruf von geschrieben hat der `StartDoc` Member-Funktion.|
|[CDC::AbortPath](#abortpath)|Schließt ein, und verwirft alle Pfade in den Gerätekontext.|
|[CDC::AddMetaFileComment](#addmetafilecomment)|Kopiert den Kommentar aus einem Puffer in einen angegebenen EMF-Datei an.|
|[CDC::AlphaBlend](#alphablend)|Zeigt die Bitmaps, die transparent oder halbtransparent Pixel aufweisen.|
|[CDC::AngleArc](#anglearc)|Zeichnet ein Liniensegment und einen Bogen, und verschiebt die aktuelle Position, an den Endpunkt des Bogens.|
|[CDC::Arc](#arc)|Zeichnet einen elliptischen Bogen.|
|[CDC::ArcTo](#arcto)|Zeichnet einen elliptischen Bogen. Diese Funktion ist vergleichbar mit `Arc`, außer dass die aktuelle Position aktualisiert wird.|
|[CDC::Attach](#attach)|Fügt einen Windows-Gerätekontext zu diesem `CDC` Objekt.|
|[CDC::BeginPath](#beginpath)|Öffnet eine Klammer Pfad in den Gerätekontext.|
|[CDC::BitBlt](#bitblt)|Kopiert eine Bitmap aus einem angegebenen Gerätekontext.|
|[CDC::Chord](#chord)|Zeichnet eine Tastenkombination (eine geschlossene Form, durch die Schnittmenge einer Ellipse und ein Liniensegment begrenzt).|
|[CDC::CloseFigure](#closefigure)|Schließt eine offene Form in einem Pfad.|
|[CDC::CreateCompatibleDC](#createcompatibledc)|Erstellt einen Speicher-Gerätekontext, der mit einem anderen Gerätekontext kompatibel ist. Sie können es verwenden, zum Vorbereiten des Images im Arbeitsspeicher.|
|[CDC::CreateDC](#createdc)|Erstellt einen Gerätekontext für ein bestimmtes Gerät.|
|[CDC::CreateIC](#createic)|Erstellt einen Informationen über den Kontext für ein bestimmtes Gerät. Dies bietet eine schnelle Möglichkeit, um Informationen über das Gerät zu erhalten, ohne einen Gerätekontext zu erstellen.|
|[CDC::DeleteDC](#deletedc)|Löscht die zugeordnete Windows-Gerätekontext `CDC` Objekt.|
|[CDC::DeleteTempMap](#deletetempmap)|Wird aufgerufen, indem die `CWinApp` -leerlaufzeithandler So löschen Sie temporäre `CDC` von erstelltes Objekt `FromHandle`. Außerdem trennt den Gerätekontext.|
|[CDC::Detach](#detach)|Trennt den Windows-Gerätekontext aus diesem `CDC` Objekt.|
|[CDC::DPtoHIMETRIC](#dptohimetric)|Geräteeinheiten konvertiert in HIMETRIC-Einheiten.|
|[CDC::DPtoLP](#dptolp)|Konvertiert Geräteeinheiten in logischen Einheiten.|
|[CDC::Draw3dRect](#draw3drect)|Zeichnet einen dreidimensionalen Rechteck.|
|[CDC::DrawDragRect](#drawdragrect)|Löscht ein, und zeichnet ein Rechteck, wie es gezogen wird.|
|[CDC::DrawEdge](#drawedge)|Zeichnet die Ränder eines Rechtecks an.|
|[CDC::DrawEscape](#drawescape)|Greift auf Zeichnen die Funktionen einer Videoanzeige, die nicht direkt über die Graphics Device Interface (GDI) verfügbar sind.|
|[CDC::DrawFocusRect](#drawfocusrect)|Zeichnet ein Rechteck im Stil verwendet, um den Fokus anzugeben.|
|[CDC::DrawFrameControl](#drawframecontrol)|Ein Frame-Steuerelement zu zeichnen.|
|[CDC::DrawIcon](#drawicon)|Zeichnet ein Symbol an.|
|[CDC::DrawState](#drawstate)|Zeigt ein Bild aus, und wendet einen visuellen Effekt aus, um ein Zustand gekennzeichnet wird.|
|[CDC::DrawText](#drawtext)|Zeichnet formatierten Text im angegebenen Rechteck.|
|[CDC::DrawTextEx](#drawtextex)|Zeichnet formatierten Text in das angegebene Rechteck, das zusätzliche Formate verwenden.|
|[CDC::Ellipse](#ellipse)|Zeichnet eine Ellipse.|
|[CDC::EndDoc](#enddoc)|Beendet einen Druckauftrag gestartet, indem die `StartDoc` Member-Funktion.|
|[CDC::EndPage](#endpage)|Informiert den Gerätetreiber, den eine Seite beendet wird.|
|[CDC::EndPath](#endpath)|Schließt eine Klammer Pfad ein, und wählt den Pfad, der durch die Klammer definiert werden, in den Gerätekontext.|
|[CDC::EnumObjects](#enumobjects)|Listet die Stifte und Pinsel verfügbaren in einem Gerätekontext.|
|[CDC::Escape](#escape)|Ermöglicht es Anwendungen auf Einrichtungen, die nicht direkt von einem bestimmten Gerät über GDI verfügbar sind. Außerdem ermöglicht den Zugriff auf Windows-Escape-Funktionen. Escape-Aufrufe, die von einer Anwendung, die werden übersetzt und an den Treiber gesendet.|
|[CDC::ExcludeClipRect](#excludecliprect)|Erstellt einen neuen Ausschneidebereich, der den vorhandenen Ausschneidebereich abzüglich des angegebenen Rechtecks besteht.|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Verhindert, dass Zeichnung in ungültigen Bereiche eines Fensters durch einen aktualisierten Bereich im Fenster in einer zuschneideregion zu ausschließen.|
|[CDC::ExtFloodFill](#extfloodfill)|Füllt einen Bereich mit dem aktuellen Pinsel. Bietet mehr Flexibilität als die [CDC::FloodFill](#floodfill) Member-Funktion.|
|[CDC::ExtTextOut](#exttextout)|Schreibt eine Zeichenfolge in einen rechteckigen Bereich mit der aktuell ausgewählten Schriftart.|
|[CDC::FillPath](#fillpath)|Schließt alle geöffneten Figuren in den aktuellen Pfad aus, und füllt den Pfad des innere mithilfe des aktuellen Pinsel und Polygon-füllen-Modus.|
|[CDC::FillRect](#fillrect)|Füllt ein angegebenes Rechteck mit einem bestimmten Pinsel.|
|[CDC::FillRgn](#fillrgn)|Füllt eine bestimmte Region mit dem angegebenen Pinsel.|
|[CDC::FillSolidRect](#fillsolidrect)|Füllt ein Rechteck mit einer Volltonfarbe aus.|
|[CDC::FlattenPath](#flattenpath)|Transformiert jede Kurven in den der aktuelle Gerätekontext ausgewählten Pfad, und wandelt jede Kurve in einer Sequenz von Zeilen.|
|[CDC::FloodFill](#floodfill)|Füllt einen Bereich mit dem aktuellen Pinsel.|
|[CDC::FrameRect](#framerect)|Zeichnet einen Rahmen um ein Rechteck.|
|[CDC::FrameRgn](#framergn)|Zeichnet einen Rahmen um eine bestimmte Region Verwenden eines Pinsels an.|
|[CDC::FromHandle](#fromhandle)|Gibt einen Zeiger auf eine `CDC` Objekt, wenn ein Handle für einen Gerätekontext zu erhalten. Wenn ein `CDC`-Objekt nicht an das Handle angefügt ist, wird ein temporäres `CDC`-Objekt erstellt und angefügt.|
|[CDC::GetArcDirection](#getarcdirection)|Gibt die aktuelle Richtung der Bogen für den Gerätekontext zurück.|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Ruft die Einstellung für den aktuellen Seitenverhältnis Filter ab.|
|[CDC::GetBkColor](#getbkcolor)|Ruft die aktuelle Hintergrundfarbe ab.|
|[CDC::GetBkMode](#getbkmode)|Ruft den Hintergrundmodus ab.|
|[CDC::GetBoundsRect](#getboundsrect)|Gibt das aktuelle akkumulierte umschließende Rechteck für den angegebenen Gerätekontext zurück.|
|[CDC::GetBrushOrg](#getbrushorg)|Ruft den Ursprung des aktuellen Pinsels ab.|
|[CDC::GetCharABCWidths](#getcharabcwidths)|Ruft die Breite, in logischen Einheiten von aufeinander folgenden Zeichen in einem angegebenen Bereich aus der aktuellen Schriftart ab.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Ruft ab, das die Breiten in logischen Einheiten, der aufeinander folgenden Symbolindizes in einem angegebenen Bereich aus der aktuellen TrueType-Schriftart.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Ruft verschiedene Typen von Informationen zu einer Zeichenfolge ab.|
|[CDC::GetCharWidth](#getcharwidth)|Ruft das hohe Auflösung von aufeinander folgenden Zeichen in einem angegebenen Bereich aus der aktuellen Schriftart ab.|
|[CDC::GetCharWidthI](#getcharwidthi)|Ruft die Breite, in logischen Koordinaten von aufeinander folgenden Symbolindizes in einem angegebenen Bereich aus der aktuellen Schriftart ab.|
|[CDC::GetClipBox](#getclipbox)|Ruft die Abmessungen des tightest umschließenden Rechtecks um die aktuelle Grenze von Clipping ab.|
|[CDC::GetColorAdjustment](#getcoloradjustment)|Ruft die Farbwerte für die Anpassung für den Gerätekontext ab.|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Gibt einen Zeiger auf das derzeit ausgewählte `CBitmap` Objekt.|
|[CDC::GetCurrentBrush](#getcurrentbrush)|Gibt einen Zeiger auf das derzeit ausgewählte `CBrush` Objekt.|
|[CDC::GetCurrentFont](#getcurrentfont)|Gibt einen Zeiger auf das derzeit ausgewählte `CFont` Objekt.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Gibt einen Zeiger auf das derzeit ausgewählte `CPalette` Objekt.|
|[CDC::GetCurrentPen](#getcurrentpen)|Gibt einen Zeiger auf das derzeit ausgewählte `CPen` Objekt.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Ruft die aktuelle Position des Stifts (in logischen Koordinaten) ab.|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Ruft die aktuelle Pinselfarbe ab.|
|[CDC::GetDCPenColor](#getdcpencolor)|Ruft die aktuelle Stiftfarbe ab.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Ruft eine angegebene Art von Gerät-spezifische Informationen über Funktionen für ein angegebenes Anzeigegerät ab.|
|[CDC::GetFontData](#getfontdata)|Ruft die Metrik Schriftartinformationen aus einer Datei skalierbare Schriftart ab. Die Informationen abgerufen werden durch Angeben eines Offsets in die Schriftartdatei und die Länge der zurückzugebenden Informationen identifiziert.|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Gibt Informationen über die aktuell ausgewählten Schriftart für den angegebenen Anzeigekontext zurück.|
|[CDC::GetGlyphOutline](#getglyphoutline)|Ruft die Gliederung Kurve oder eine Bitmap für eine Gliederung Zeichen in der aktuellen Schriftart ab.|
|[CDC::GetGraphicsMode](#getgraphicsmode)|Ruft den aktuellen Grafikmodus für den angegebenen Gerätekontext ab.|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Ruft einen Pinsel Halbtonpalette ab.|
|[CDC::GetKerningPairs](#getkerningpairs)|Ruft das Zeichen, kerning-Paare für die Schriftart, die in den angegebenen Gerätekontext markiert ist.|
|[CDC::GetLayout](#getlayout)|Ruft das Layout des einen Gerätekontext (DC) ab. Das Layout kann werden entweder von links nach rechts (Standard) oder von rechts nach links (gespiegelt).|
|[CDC::GetMapMode](#getmapmode)|Ruft den aktuellen Zuordnungsmodus ab.|
|[CDC::GetMiterLimit](#getmiterlimit)|Gibt die Gehrungsgrenze für den Gerätekontext zurück.|
|[CDC::GetNearestColor](#getnearestcolor)|Ruft ab, die am nächsten logischen Farbe an einer angegebenen logischen Farbe, die das angegebene Gerät darstellen kann.|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Ruft die Metrik Schriftartinformationen für TrueType-Schriftarten ab.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Ruft die Breite der einzelnen Zeichen in eine aufeinander folgende Gruppe von Zeichen aus der aktuellen Schriftart, die mit den Ausgabe-Gerätekontext ab.|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Berechnet die Breite und Höhe einer Zeichenfolge auf den Ausgabe-Gerätekontext.|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Berechnet die Breite und Höhe einer Zeile des Texts in der Ausgabe-Gerätekontext, die anhand der aktuellen Schriftart bestimmt die Dimensionen.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Ruft die Metriken für die aktuelle Schriftart aus der Ausgabe-Gerätekontext ab.|
|[CDC::GetPath](#getpath)|Ruft die Koordinaten, die definieren, die Endpunkte der Zeilen und die Steuerpunkte der Kurven finden Sie in den Pfad, der in den Gerätekontext ausgewählt ist.|
|[CDC::GetPixel](#getpixel)|Ruft den RGB-Farbwert des Pixels am angegebenen Punkt ab.|
|[CDC::GetPolyFillMode](#getpolyfillmode)|Ruft den aktuellen Modus des Polygons füllenden ab.|
|[CDC::GetROP2](#getrop2)|Ruft den Zeichnungsmodus des aktuellen ab.|
|[CDC::GetSafeHdc](#getsafehdc)|Gibt [CDC::m_hDC](#m_hdc), den Ausgabe-Gerätekontext.|
|[CDC::GetStretchBltMode](#getstretchbltmode)|Ruft den aktuellen Strecken einer Bitmap-Modus ab.|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Berechnet die Breite und Höhe einer Zeichenfolge für den Gerätekontext Attribut.|
|[CDC::GetTextAlign](#gettextalign)|Ruft die textausrichtung Flags ab.|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Ruft die aktuelle Einstellung für die Menge an Zeichenabstands ab.|
|[CDC::GetTextColor](#gettextcolor)|Ruft die aktuelle Textfarbe ab.|
|[CDC::GetTextExtent](#gettextextent)|Berechnet die Breite und Höhe einer Textzeile im Gerätekontext Attribut anhand der aktuellen Schriftart bestimmt die Dimensionen an.|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Ruft die Anzahl der Zeichen in einer angegebenen Zeichenfolge, die in einem angegebenen Raum passt, und füllt ein Array mit der Größe von Text für jedes dieser Zeichen ab.|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Ruft die Breite und Höhe des angegebenen Arrays von glyphenindizes.|
|[CDC::GetTextFace](#gettextface)|Kopiert den Namen der aktuellen Schriftart in einen Puffer als Null-terminierte Zeichenfolge an.|
|[CDC::GetTextMetrics](#gettextmetrics)|Ruft die Metriken für die aktuelle Schriftart aus dem Gerätekontext Attribut ab.|
|[CDC::GetViewportExt](#getviewportext)|Ruft die x und y-Blöcke des Viewports ab.|
|[CDC::GetViewportOrg](#getviewportorg)|Ruft den x- und y-Koordinaten des Ursprungs Viewport ab.|
|[CDC::GetWindow](#getwindow)|Gibt zurück, das den Anzeigekontext für das Gerät zugeordnete Fenster.|
|[CDC::GetWindowExt](#getwindowext)|Ruft die x und y-Blöcke von das zugeordnete Fenster ab.|
|[CDC::GetWindowOrg](#getwindoworg)|Ruft den x- und y-Koordinaten des Ursprungs der das zugeordnete Fenster ab.|
|[CDC::GetWorldTransform](#getworldtransform)|Ruft den aktuellen Raum auf der Seite-Space-Transformation ab.|
|[CDC::GradientFill](#gradientfill)|Füllt mit einer Farbe gradating Rechteck und Dreieck Strukturen.|
|[CDC::GrayString](#graystring)|Zeichnet abgeblendet (grau) Text an der angegebenen Position.|
|[CDC::HIMETRICtoDP](#himetrictodp)|HIMETRIC-Einheiten konvertiert in Geräteeinheiten.|
|[CDC::HIMETRICtoLP](#himetrictolp)|HIMETRIC-Einheiten konvertiert in logischen Einheiten.|
|[CDC::IntersectClipRect](#intersectcliprect)|Erstellt einen neuen Ausschneidebereich durch Bildung der Schnittmenge der aktuellen Region und ein Rechteck.|
|[CDC::InvertRect](#invertrect)|Kehrt den Inhalt eines Rechtecks an.|
|[CDC::InvertRgn](#invertrgn)|Kehrt die Farben in einer Region an.|
|[CDC::IsPrinting](#isprinting)|Bestimmt, ob es sich bei der Gerätekontext für das Drucken verwendet wird.|
|[CDC::LineTo](#lineto)|Zeichnet eine Linie von der aktuellen Position bis zum, jedoch nicht einschließlich, einem Punkt.|
|[CDC::LPtoDP](#lptodp)|Logische Einheiten konvertiert in Geräteeinheiten.|
|[CDC::LPtoHIMETRIC](#lptohimetric)|Logische Einheiten konvertiert in HIMETRIC-Einheiten.|
|[CDC::MaskBlt](#maskblt)|Kombiniert die Farbdaten für die Quelle und Ziel-Bitmaps, die mithilfe der angegebenen Maske und rastervorgang an.|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Ändert die globale Transformation für einen Gerätekontext, die Verwendung des angegebenen Modus.|
|[CDC::MoveTo](#moveto)|Verschiebt die aktuelle Position.|
|[CDC::OffsetClipRgn](#offsetcliprgn)|Verschiebt den Ausschneidebereich des angegebenen Geräts an.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Ändert den Ursprung des Ausschnitts, relativ zu den Koordinaten des aktuellen Viewports Ursprungs.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Ändert den Fensterursprung relativ zu den Koordinaten des aktuellen Fensters Ursprungs.|
|[CDC::PaintRgn](#paintrgn)|Füllt einen Bereich mit den ausgewählten Pinsel.|
|[CDC::PatBlt](#patblt)|Erstellt ein Bitmuster.|
|[CDC::Pie](#pie)|Zeichnet einen kreisförmigen Keil an.|
|[CDC::PlayMetaFile](#playmetafile)|Gibt den Inhalt der angegebenen Metadatei auf das angegebene Gerät wieder. Die erweiterte Version des `PlayMetaFile` zeigt das Bild in der angegebenen EMF-Datei gespeichert. Die Metadatei kann oft wiedergegeben werden.|
|[CDC::PlgBlt](#plgblt)|Führt einen Bitblocktransfer der Farbdaten Bits auf das angegebene Rechteck, in dem Quellgerätekontext an der angegebenen Parallelogramm im angegebenen Gerätekontext aus.|
|[CDC::PolyBezier](#polybezier)|Zeichnet eine oder mehrere Bzier Splines an. Die aktuelle Position ist weder verwendet noch aktualisiert.|
|[CDC::PolyBezierTo](#polybezierto)|Zeichnet eine oder mehrere Bzier Splines, und verschiebt die aktuelle Position zum Endpunkt für den letzten Bzier Spline.|
|[CDC::PolyDraw](#polydraw)|Zeichnet eine Reihe von Liniensegmenten und Bzier Splines. Diese Funktion aktualisiert die aktuelle Position.|
|[CDC::Polygon](#polygon)|Zeichnet ein Vieleck, bestehend aus zwei oder mehr Punkten (Scheitelpunkte) durch Linien verbunden sind.|
|[CDC::Polyline](#polyline)|Zeichnet eine Reihe von Liniensegmenten, die zwischen den angegebenen Punkten.|
|[CDC::PolylineTo](#polylineto)|Zeichnet eine oder mehrere gerade Linien an, und verschiebt die aktuelle Position zum Endpunkt der letzten Zeile.|
|[CDC::PolyPolygon](#polypolygon)|Erstellt zwei oder mehreren Polygonen, die mit den aktuellen Modus des Polygons füllenden gefüllt sind. Die Polygone können nicht zusammenhängenden oder Überlappung zu können.|
|[CDC::PolyPolyline](#polypolyline)|Zeichnet mehrere Reihe verbundener Liniensegmente. Die aktuelle Position ist weder verwendet noch von dieser Funktion aktualisiert.|
|[CDC::PtVisible](#ptvisible)|Gibt an, ob der angegebene Punkt innerhalb des Clippingbereichs ist.|
|[CDC::RealizePalette](#realizepalette)|Der Systempalette Paletteneinträge in der aktuellen logischen Palette zugeordnet.|
|[CDC::Rectangle](#rectangle)|Zeichnet ein Rechteck mit dem aktuellen Stift und füllt sie mit dem aktuellen Pinsel.|
|[CDC::RectVisible](#rectvisible)|Bestimmt, ob ein Teil im angegebenen Rechteck innerhalb des Clippingbereichs liegt.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Releases `m_hAttribDC`, den Gerätekontext Attribut.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Releases `m_hDC`, den Ausgabe-Gerätekontext.|
|[CDC::ResetDC](#resetdc)|Updates der `m_hAttribDC` Gerätekontext.|
|[CDC::RestoreDC](#restoredc)|Stellt den Gerätekontext in einem vorherigen Zustand gespeichert, die mit `SaveDC`.|
|[CDC::RoundRect](#roundrect)|Zeichnet ein Rechteck mit abgerundeten Ecken den aktuellen Stift verwenden und unter Verwendung des aktuellen Pinsels gefüllt.|
|[CDC::SaveDC](#savedc)|Speichert den aktuellen Zustand des Gerätekontexts.|
|[CDC::ScaleViewportExt](#scaleviewportext)|Ändert das Ausmaß der Viewport relativ zu den aktuellen Werten.|
|[CDC::ScaleWindowExt](#scalewindowext)|Ändert die Fenster-Blöcken Bezug auf die aktuellen Werte.|
|[CDC::ScrollDC](#scrolldc)|Führt einen Bildlauf um ein Rechteck von Bits, horizontal und vertikal.|
|[CDC::SelectClipPath](#selectclippath)|Wählt den aktuellen Pfad als einen Ausschneidebereich für den Gerätekontext, kombinieren die neue Region mit der alle vorhandenen Ausschneidebereich unter Verwendung des angegebenen Modus.|
|[CDC::SelectClipRgn](#selectcliprgn)|Kombiniert den angegebenen Bereich mit den aktuellen Ausschneidebereich unter Verwendung des angegebenen Modus.|
|[CDC::SelectObject](#selectobject)|Markiert ein zeichnen GDI-Objekt, z. B. einen Stift.|
|[CDC::SelectPalette](#selectpalette)|Wählt die logische Palette an.|
|[CDC::SelectStockObject](#selectstockobject)|Wählt eine der vordefinierten vordefinierten Stifte, Pinsel oder Schriftarten, die von Windows bereitgestellt.|
|[CDC::SetAbortProc](#setabortproc)|Legt fest, eine vom Programmierer bereitgestellte Rückruffunktion, die Windows aufruft, wenn ein Druckauftrag abgebrochen werden muss.|
|[CDC::SetArcDirection](#setarcdirection)|Richtung für das Zeichnen für Bogen und Rechteck Funktionen verwendet werden.|
|[CDC::SetAttribDC](#setattribdc)|Legt `m_hAttribDC`, den Gerätekontext Attribut.|
|[CDC::SetBkColor](#setbkcolor)|Legt die aktuelle Hintergrundfarbe fest.|
|[CDC::SetBkMode](#setbkmode)|Legt den Hintergrundmodus fest.|
|[CDC::SetBoundsRect](#setboundsrect)|Steuert die Ansammlung von umgebenden Rechteck-Informationen für den angegebenen Gerätekontext.|
|[CDC::SetBrushOrg](#setbrushorg)|Gibt den Ursprung für den nächsten Pinsel ausgewählt wird, einen Gerätekontext.|
|[CDC::SetColorAdjustment](#setcoloradjustment)|Legt die Farbe Anpassungswerte für den Gerätekontext, die mit den angegebenen Werten.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Legt fest, die aktuelle Pinselfarbe.|
|[CDC::SetDCPenColor](#setdcpencolor)|Legt fest, die aktuelle Stiftfarbe.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Legt den aktuellen Graphics-Modus für den angegebenen Gerätekontext.|
|[CDC::SetLayout](#setlayout)|Ändert das Layout einem Gerätekontext (DC).|
|[CDC::SetMapMode](#setmapmode)|Legt den aktuellen Zuordnungsmodus fest.|
|[CDC::SetMapperFlags](#setmapperflags)|Ändert den Algorithmus, den die Schriftartenmapper verwendet werden soll, wenn es logische Schriftarten physischen Schriftarten zugeordnet.|
|[CDC::SetMiterLimit](#setmiterlimit)|Legt das Limit für die Dauer der Gehrungslänge Joins für den Gerätekontext.|
|[CDC::SetOutputDC](#setoutputdc)|Legt `m_hDC`, den Ausgabe-Gerätekontext.|
|[CDC::SetPixel](#setpixel)|Das Pixel festgelegt auf den angegebenen Punkt in diesem am ehesten der angegebenen Farbe.|
|[CDC::SetPixelV](#setpixelv)|Das Pixel festgelegt auf den angegebenen Koordinaten auf diesem am ehesten der angegebenen Farbe. `SetPixelV` ist schneller als `SetPixel` , da sie nicht den Farbwert der der Punkt tatsächlich gezeichnet zurückgeben muss.|
|[CDC::SetPolyFillMode](#setpolyfillmode)|Legt den Modus für die Polygon-füllen.|
|[CDC::SetROP2](#setrop2)|Legt den aktuellen Zeichnungsmodus fest.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Legt den Modus zum Strecken einer Bitmap.|
|[CDC::SetTextAlign](#settextalign)|Legt die textausrichtung Flags.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Legt die Menge des Zeichenabstands fest.|
|[CDC::SetTextColor](#settextcolor)|Legt die Textfarbe fest.|
|[CDC::SetTextJustification](#settextjustification)|Das Zeilenumbruchzeichen in einer Zeichenfolge werden Leerzeichen hinzugefügt.|
|[CDC::SetViewportExt](#setviewportext)|Legt fest, die x und y-Blöcke des Viewports.|
|[CDC::SetViewportOrg](#setviewportorg)|Legt den Ursprung des Viewports an.|
|[CDC::SetWindowExt](#setwindowext)|Legt fest, die x und y-Blöcke von das zugeordnete Fenster.|
|[CDC::SetWindowOrg](#setwindoworg)|Legt den Fensterursprung im des Gerätekontexts fest.|
|[CDC::SetWorldTransform](#setworldtransform)|Legt den aktuellen Raum auf Seite-Space-Transformation fest.|
|[CDC::StartDoc](#startdoc)|Informiert den Gerätetreiber, den ein neuer Druckauftrag gestartet wird.|
|[CDC::StartPage](#startpage)|Informiert den Gerätetreiber, den eine neue Seite gestartet wird.|
|[CDC::StretchBlt](#stretchblt)|Verschiebt eine Bitmap aus einem Quellrechteck und das Gerät in ein Zielrechteck, gestreckt oder komprimiert die Bitmap wird bei Bedarf die Maße des Zielrechtecks anpassen.|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Schließt alle geöffneten Figuren in einen Pfad, den Umriss des Pfads mithilfe des aktuellen Stifts eintritt und füllt mit der aktuellen Pinsel inneren.|
|[CDC::StrokePath](#strokepath)|Rendert den angegebenen Pfad mit der aktuelle Stift.|
|[CDC::TabbedTextOut](#tabbedtextout)|Schreibt eine Zeichenfolge an einer angegebenen Position, und Erweitern von Registerkarten auf die Werte in einem Array von Tabstopp Positionen angegeben.|
|[CDC::TextOut](#textout)|Schreibt eine Zeichenfolge an einer angegebenen Position mit der aktuell ausgewählten Schriftart.|
|[CDC::TransparentBlt](#transparentblt)|Überträgt einen Bit-Datenblock Farbe aus dem Gerätekontext für die angegebene Quelle in ein Ziel-Gerätekontext, Rendern einer angegebenen Farbe transparent in die Übertragung an.|
|[CDC::UpdateColors](#updatecolors)|Updates des Clientbereichs der Systempalette auf Pixel-für-Pixel-Basis der Clientbereich des Gerätekontexts durch Vergleich der aktuellen Farben.|
|[CDC::WidenPath](#widenpath)|Definiert den aktuellen Pfad als der Bereich, der gezeichnet werden sollen, wenn der Pfad mit Strichen gezeichnet wurden mit dem Stift in den Gerätekontext derzeit ausgewählt.|

### <a name="public-operators"></a>Öffentliche Operatoren

|Name|Beschreibung|
|----------|-----------------|
|[CDC::Operator HDC](#operator_hdc)|Ruft das Handle des Gerätekontexts ab.|

### <a name="public-data-members"></a>Öffentliche Datenmember

|Name|Beschreibung|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|Das verwendete Attribut-Gerätekontext `CDC` Objekt.|
|[CDC::m_hDC](#m_hdc)|Die Ausgabe-Gerätekontext verwendete `CDC` Objekt.|

## <a name="remarks"></a>Hinweise

Die `CDC` Objekt stellt Memberfunktionen zum Arbeiten mit einem Gerätekontext, z. B. eine Anzeige oder Drucker als auch Mitglieder für die Arbeit mit einen Anzeigekontext, das den Clientbereich eines Fensters zugeordnet.

Führen Sie alle Zeichnungen über den Member-Funktionen eine `CDC` Objekt. Die Klasse stellt Memberfunktionen zum Arbeiten mit Zeichnen typsicheren Graphics Device Interface (GDI)-Objektauswahl-Tools und Arbeiten mit Farben und Paletten Gerätekontext Vorgänge. Es enthält auch Member-Funktionen zum Abrufen und festlegen, die Zeichnungsattribute, Zuordnung, arbeiten mit dem Viewport sind, arbeiten mit Fenster soweit, Konvertieren von Koordinaten, arbeiten mit Regionen, Clipping: Zeichnen von Linien und einfache Formen zeichnen, Ellipsen, und Polygone. Member-Funktionen werden auch für das Zeichnen von Text, arbeiten mit Schriftarten, mit Escapezeichen des Druckers, Durchführen eines Bildlaufs und Wiedergabe von Metadateien bereitgestellt.

Verwenden einer `CDC` Objekt, erstellen Sie sie, und klicken Sie dann seine Memberfunktionen aufrufen, die Windows-Funktionen entsprechen, die Gerätekontexte zu verwenden.

> [!NOTE]
>  Unter Windows 95/98 sind alle Bildschirmkoordinaten 16 Bits beschränkt. Aus diesem Grund eine **Int** , die an eine `CDC` Memberfunktion muss im Bereich von-32768 bis 32767 liegen.

Für einen bestimmten Verwendungszweck, bietet die Microsoft Foundation Class-Bibliothek mehrere Klassen, die von `CDC` . `CPaintDC` Aufrufe kapselt `BeginPaint` und `EndPaint`. `CClientDC` verwaltet einen Anzeigekontext Clientbereich eines Fensters zugeordnet. `CWindowDC` verwaltet einen Anzeigekontext eines Fensters, einschließlich der Rahmen und -Steuerelementen zugeordnet. `CMetaFileDC` Ordnet einer Metadatei zu einen Gerätekontext.

`CDC` stellt zwei Memberfunktionen, [GetLayout](#getlayout) und [SetLayout](#setlayout), für die Umkehrung des Layouts eines Gerätekontexts, die nicht das Layout in einem Fenster erbt. Diese Ausrichtung rechts-nach-links ist für Anwendungen für die Kulturen, z. B. Arabisch oder Hebräisch, wenn das Layout Zeichen nicht der Europäischen Standard ist erforderlich.

`CDC` enthält zwei Gerätekontexte, [M_hDC](#m_hdc) und [M_hAttribDC](#m_hattribdc), das bei der Erstellung einer `CDC` Objekt, das gleiche Gerät finden Sie unter. `CDC` leitet alle Ausgabe GDI-Aufrufe an `m_hDC` und die meisten Attribut GDI-Aufrufe von `m_hAttribDC`. (Ein Beispiel für ein Attributaufruf ist `GetTextColor`, während `SetTextColor` ist ein Aufruf der Ausgabe.)

Das Framework verwendet beispielsweise diese beiden Kontexte zum Implementieren einer `CMetaFileDC` Objekt an, die Ausgabe an eine Metadatei beim Lesen der Attribute von einem physischen Gerät sendet. Seitenansicht wird in das Framework auf ähnliche Weise implementiert. Sie können auch die beiden Kontexte in Ihrem Code anwendungsspezifische auf ähnliche Weise verwenden.

Es gibt Situationen, wenn benötigen Sie möglicherweise Text-Metrik-Informationen aus, der `m_hDC` und `m_hAttribDC` Gerätekontexte. Die folgenden Paare von Funktionen bieten diese Funktion:

|M_hAttribDC verwendet|M_hDC verwendet|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Weitere Informationen zu `CDC`, finden Sie unter [Gerätekontexte](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Vererbungshierarchie

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Anforderungen

**Header:** afxwin.h

##  <a name="abortdoc"></a>  CDC::AbortDoc

Beendet den aktuellen Druckauftrag neu und löscht Sie alles, was die Anwendung an das Gerät, seit dem letzten Aufruf von geschrieben wurde der [StartDoc](#startdoc) Member-Funktion.

```
int AbortDoc();
```

### <a name="return-value"></a>Rückgabewert

Ein Wert größer als oder gleich 0, wenn erfolgreich, oder einen negativen Wert, wenn ein Fehler aufgetreten ist. Die folgende Liste zeigt häufig verwendete Fehlerwerte und ihre Bedeutung:

- SP_ERROR allgemeiner Fehler.

- SP_OUTOFDISK nicht genügend Speicherplatz auf dem Datenträger steht zurzeit zum Spoolen und keinen Speicherplatz mehr zur Verfügung stehen.

- SP_OUTOFMEMORY nicht genügend Arbeitsspeicher zum Spoolen verfügbar ist.

- SP_USERABORT Benutzer beendet den Auftrag über die Druck-Manager.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion ersetzt die ABORTDOC Druckerescape.

`AbortDoc` sollte verwendet werden, um Folgendes zu beenden:

- Drucken-Vorgänge, die keine Abort-Funktion mit angeben [SetAbortProc](#setabortproc).

- Drucken-Vorgänge, die ihre erste NEWFRAME oder NEXTBAND noch nicht erreicht haben Aufruf mit Escapezeichen versehen.

Wenn eine Anwendung eines Druckfehlers oder einen Druck abgebrochenen Vorgang auftritt, müssen sie nicht versuchen, den Vorgang zu beenden, indem Sie entweder die [EndDoc](#enddoc) oder `AbortDoc` Memberfunktionen der Klasse `CDC`. GDI wird automatisch beendet den Vorgang, bevor der Wert des Fehlercodes zurückgeben.

Wenn ein Dialogfeld, damit der Benutzer den Druckvorgang abbrechen kann von die Anwendung angezeigt wird, muss er Aufrufen `AbortDoc` vor dem Zerstören des Dialogfelds.

Wenn der Druck-Manager verwendet wurde, um den Auftrag zu starten, wird beim Aufrufen `AbortDoc` löscht den gesamten Spool-Auftrag, erhält der Drucker "nothing". Wenn der Druck-Manager nicht verwendet wurde, um den Auftrag zu starten, die Daten möglicherweise gesendet wurden an den Drucker vor dem `AbortDoc` aufgerufen wurde. In diesem Fall der Druckertreiber den Drucker (wenn möglich) zurückgesetzt haben und den Druckauftrag geschlossen.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CDC::StartDoc](#startdoc).

##  <a name="abortpath"></a>  CDC::AbortPath

Schließt ein, und verwirft alle Pfade in den Gerätekontext.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Wenn in den Gerätekontext eine Klammer offenen Pfad vorhanden ist, wird die Pfad-Klammer wird geschlossen, und der Pfad wird verworfen. In den Gerätekontext ein geschlossener Pfad vorhanden ist, wird der Pfad verworfen.

##  <a name="addmetafilecomment"></a>  CDC::AddMetaFileComment

Kopiert den Kommentar aus einem Puffer in einen angegebenen EMF-Datei an.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parameter

*nDataSize*<br/>
Gibt die Länge des Puffers Kommentar, in Bytes an.

*pCommentData*<br/>
Verweist auf den Puffer, der den Kommentar enthält.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Ein Kommentar kann private Informationen enthalten, z. B. die Quelle des Bilds und das Datum es erstellt wurde. Ein Kommentar sollte eine Anwendung Signatur, gefolgt von den Daten beginnen. Kommentare darf keine Position-spezifische Daten enthalten. Position-spezifische Daten gibt den Speicherort eines Datensatzes, und es sollte nicht angegeben werden, da eine Metadatei in einem anderen Metadatei eingebettet werden kann. Diese Funktion kann nur mit erweiterten Metadateien verwendet werden.

##  <a name="alphablend"></a>  CDC::AlphaBlend

Rufen Sie diese Memberfunktion zum Anzeigen von Bitmaps, die transparent oder halbtransparent Pixel aufweisen.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parameter

*xDest*<br/>
Gibt die X-Koordinate, in logischen Einheiten, der die linke obere Ecke des Zielrechtecks an.

*yDest*<br/>
Gibt die y-Koordinate, in logischen Einheiten, der die linke obere Ecke des Zielrechtecks an.

*nDestWidth*<br/>
Gibt die Breite in logischen Einheiten des Zielrechtecks an.

*nDestHeight*<br/>
Gibt die Höhe in logischen Einheiten des Zielrechtecks an.

*pSrcDC*<br/>
Ein Zeiger auf den Quellgerätekontext.

*xSrc*<br/>
Gibt die X-Koordinate, in logischen Einheiten, der die linke obere Ecke des Quellrechtecks an.

*ySrc*<br/>
Gibt die y-Koordinate, in logischen Einheiten, der die linke obere Ecke des Quellrechtecks an.

*nSrcWidth*<br/>
Gibt die Breite in logischen Einheiten des Quellrechtecks an.

*nSrcHeight*<br/>
Gibt die Höhe in logischen Einheiten des Quellrechtecks an.

*blend*<br/>
Gibt an, eine [BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-_blendfunction) Struktur.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Hinweise

Finden Sie unter [AlphaBlend](/windows/desktop/api/wingdi/nf-wingdi-alphablend) im Windows SDK für Weitere Informationen.

##  <a name="anglearc"></a>  CDC::AngleArc

Zeichnet ein Liniensegment und einen Bogen.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate für den Mittelpunkt des Kreises an.

*y*<br/>
Gibt die logische y-Koordinate für den Mittelpunkt des Kreises an.

*nRadius*<br/>
Gibt den Radius des Kreises in logischen Einheiten. Dieser Wert muss positiv sein.

*fStartAngle*<br/>
Gibt den Anfangswinkel in Grad relativ zu der x-Achse an.

*fSweepAngle*<br/>
Der mittelpunktswinkel wird in Grad relativ zu den Anfangswinkel angibt.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Hinweise

Zeilensegments wird von der aktuellen Position am Anfang des Bogens gezeichnet. Der Bogen gezeichnet wird entlang der Umkreis eines Kreises mit der angegebenen Radius und Center. Die Länge des Bogens wird durch den angegebenen Start- und Sweep Winkeln definiert.

`AngleArc` Verschiebt die aktuelle Position zum Endpunkt des Bogens. Der Bogen gezeichnet, die von dieser Funktion kann scheinbar elliptischen, abhängig von der aktuellen Transformation und Zuordnung sein. Vor dem Zeichnen des Winkels, zeichnet diese Funktion von der aktuellen Position Zeilensegments auf den Anfang des Bogens an. Der Bogen gezeichnet wird, durch das Erstellen eines imaginären Kreis mit den angegebenen Radius angegebenen Mittelpunkt. Der Anfangspunkt des Bogens wird durch die von der x-Achse des Kreises gegen den Uhrzeigersinn gemessen wird, um die Anzahl von Grad in der Startwinkel bestimmt. Der Endpunkt befindet sich auf ähnliche Weise durch die Messung der gegen den Uhrzeigersinn vom Ausgangspunkt durch die Anzahl von Grad in der mittelpunktswinkel.

Wenn der mittelpunktswinkel von 360 Grad übersteigt ist der Bogen mehrmals überflüssig. Diese Funktion zeichnet Zeilen mithilfe des aktuellen Stifts. In der Abbildung ist nicht ausgefüllt.

##  <a name="arc"></a>  CDC::ARC

Zeichnet einen elliptischen Bogen.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die X-Koordinate von der linken oberen Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate von der linken oberen Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die X-Koordinate der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*Y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*x3*<br/>
Gibt an, dass die X-Koordinate des Punkts, der den Bogen definiert Point (in logischen Einheiten) beginnt der. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*Y3*<br/>
Gibt an, der die y-Koordinate des Punkts, der den Bogen definiert (in logischen Einheiten) Anfangspunkt des. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*X4*<br/>
Gibt die X-Koordinate des Punkts, der Endpunkt des Bogens, (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*Y4*<br/>
Gibt die y-Koordinate des Punkts, der Endpunkt des Bogens, (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*lpRect*<br/>
Gibt das umschließende Rechteck (in logischen Einheiten) an. Sie können entweder eine LPRECT übergeben oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.

*ptStart*<br/>
Gibt an, dass die x- und y-Koordinaten des Punkts, der den Bogen definiert Point (in logischen Einheiten) beginnt der. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen. Sie können entweder übergeben eine [Punkt](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.

*ptEnd*<br/>
Gibt an, die x- und y-Koordinaten des Punkts, der Endpunkt des Bogens, (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Der Bogen gezeichnet wird, mithilfe der Funktion ist ein Segment der Ellipse definiert, die durch das angegebene umschließende Rechteck.

Die tatsächliche Anfangspunkt des Bogens ist der Punkt, an dem ein Strahl, der von der Mitte des umschließenden Rechtecks über den angegebenen Anfangspunkt die Ellipse überschneidet. Der tatsächlichen Endpunkt des Bogens ist der Punkt, an dem ein Strahl, der von der Mitte des umschließenden Rechtecks über den angegebenen Endpunkt auf die Ellipse schneidet. Der Bogen gezeichnet wird gegen den Uhrzeigersinn. Da ein Bogen nicht um eine geschlossene Form ist, wird er nicht ausgefüllt. Sowohl die Breite und Höhe des Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

##  <a name="arcto"></a>  CDC::ArcTo

Zeichnet einen elliptischen Bogen.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die X-Koordinate von der linken oberen Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate von der linken oberen Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die X-Koordinate der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*Y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*x3*<br/>
Gibt an, dass die X-Koordinate des Punkts, der den Bogen definiert Point (in logischen Einheiten) beginnt der. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*Y3*<br/>
Gibt an, der die y-Koordinate des Punkts, der den Bogen definiert (in logischen Einheiten) Anfangspunkt des. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*X4*<br/>
Gibt die X-Koordinate des Punkts, der Endpunkt des Bogens, (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*Y4*<br/>
Gibt die y-Koordinate des Punkts, der Endpunkt des Bogens, (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*lpRect*<br/>
Gibt das umschließende Rechteck (in logischen Einheiten) an. Sie können entweder einen Zeiger zu übergeben, eine [RECT](../../mfc/reference/rect-structure1.md) Datenstruktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.

*ptStart*<br/>
Gibt an, dass die x- und y-Koordinaten des Punkts, der den Bogen definiert Point (in logischen Einheiten) beginnt der. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen. Sie können entweder übergeben eine [Punkt](../../mfc/reference/point-structure1.md) Datenstruktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.

*ptEnd*<br/>
Gibt an, die x- und y-Koordinaten des Punkts, der Endpunkt des Bogens, (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen. Sie können entweder übergeben eine `POINT` Datenstruktur oder `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Diese Funktion ist vergleichbar mit `CDC::Arc`, außer dass die aktuelle Position aktualisiert wird. Die Punkte ( *X1*, *y1*) und ( *X2*, *y2*) des umschließenden Rechtecks angeben. Eine Ellipse gebildet, indem das angegebene umschließende Rechteck definiert die Kurve des Bogens. Der Bogen erweitert (die Richtung der Standard-Bogen) gegen den Uhrzeigersinn ab dem Punkt, an dem sie die radiale Linie von der Mitte des umschließenden Rechtecks, schneidet ( *X3*, *y3*). Den Bogen enden, an dem sie die radiale Linie von der Mitte des umschließenden Rechtecks, schneidet ( *X4*, *y4*). Wenn Sie den Startpunkt und Endpunkt identisch sind, wird eine vollständige Ellipse gezeichnet.

Den Anfangspunkt des Bogens wird von der aktuellen Position eine Zeile positioniert. Wenn kein Fehler auftritt, wird die aktuelle Position auf den Endpunkt des Bogens festgelegt. Der Bogen gezeichnet wird, mit dem aktuellen Stift; Es wird nicht ausgefüllt.

##  <a name="attach"></a>  CDC::Attach

Verwenden Sie diese Memberfunktion zum Anfügen einer *hDC* auf die `CDC` Objekt.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parameter

*hDC*<br/>
Einen Windows-Gerätekontext.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die *hDC* befindet sich in beiden `m_hDC`, dem Ausgabe-Gerätekontext, und klicken Sie in `m_hAttribDC`, den Gerätekontext Attribut.

##  <a name="beginpath"></a>  CDC:: beginpath

Öffnet eine Klammer Pfad in den Gerätekontext.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Nachdem eine Klammer Pfad geöffnet ist, kann eine Anwendung Aufrufen der GDI-Zeichenbefehle Funktionen zum definieren die Punkte, die sich im Pfad beginnen. Eine Anwendung kann eine offenen Pfad eckige Klammer schließen, durch Aufrufen der `EndPath` Member-Funktion. Wenn eine Anwendung ruft `BeginPath`, alle vorherigen Pfade werden verworfen.

Finden Sie unter [BeginPath](/windows/desktop/api/wingdi/nf-wingdi-beginpath) im Windows SDK für eine Liste mit den Funktionen zum Zeichnen, die Punkte in einem Pfad zu definieren.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

##  <a name="bitblt"></a>  CDC:: BitBlt

Kopiert eine Bitmap aus dem Quellgerätekontext für diese aktuelle Gerätekontext.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des Zielrechtecks an.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Zielrechtecks an.

*nWidth*<br/>
Gibt die Breite (in logischen Einheiten) der Bitmap für die Ziel-Rechteck und Quelle.

*nHeight*<br/>
Gibt die Höhe (in logischen Einheiten) der Bitmap für die Ziel-Rechteck und Quelle.

*pSrcDC*<br/>
Zeiger auf eine `CDC` Objekt, das den Gerätekontext identifiziert, von dem die Bitmap kopiert werden. Es muss NULL sein, wenn *DwRop* gibt an, ein rastervorgang, der nicht in eine Quelle enthalten ist.

*xSrc*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des Quellbitmaps an.

*ySrc*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Quellbitmaps an.

*dwRop*<br/>
Gibt das Raster des auszuführenden Vorgangs an. Raster-Operationscodes definieren, wie GDI Farben in Ausgabevorgängen kombiniert, an denen ein aktueller Pinsel, eine mögliche Quellbitmap und eine Zielbitmap beteiligt sind. Finden Sie unter [BitBlt](/windows/desktop/api/wingdi/nf-wingdi-bitblt) im Windows SDK für eine Liste der rastervorgang Codes für *DwRop* und deren Beschreibungen

Eine vollständige Liste der Raster-Operationscodes, finden Sie unter [zu Rastervorgangscode](/windows/desktop/gdi/raster-operation-codes) im Windows SDK.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die Anwendung ausrichten kann, Windows- oder Client-Bereichen auf Byte-Begrenzungen, um sicherzustellen, dass die `BitBlt` erfolgen auf Rechtecke Bytes ausgerichtet. (Legen Sie die Flags CS_BYTEALIGNWINDOW oder CS_BYTEALIGNCLIENT beim Registrieren der Klassen.)

`BitBlt` Vorgänge auf Rechtecke Bytes ausgerichtet sind wesentlich schneller als `BitBlt` Vorgänge auf Rechtecke, die nicht-Byte-ausgerichtet sind. Wenn Sie Klassenstile wie z. B. Byte-Ausrichtung für Ihre eigenen Gerätekontext angeben möchten, müssen Sie eine Fensterklasse registrieren statt auf der Microsoft Foundation Classes, damit es für Sie erledigt. Verwenden Sie die globale Funktion [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

GDI transformiert *nWidth* und *nHeight*, durch das Verwenden des Zielgerätekontexts und einmal mit dem Quellgerätekontext. Wenn die resultierende Blöcke nicht übereinstimmen, GDI verwendet die Windows `StretchBlt` Funktion komprimiert oder nach Bedarf die Quell-Bitmap gestreckt.

Wenn das Ziel, die Quelle und die musterbitmaps nicht dasselbe Farbformat, verfügen die `BitBlt` -Funktion konvertiert die Quelle und die musterbitmaps entsprechend das Ziel. Die Vordergrund- und Hintergrundfarben von die Zielbitmap werden bei der Konvertierung verwendet.

Wenn die `BitBlt` -Funktion konvertiert eine monochrome Bitmap in Farbe, legt Sie weiße Bits (1), die die Hintergrundfarbe und schwarze Bits (0), die die Vordergrundfarbe darstellt. Die Vordergrund- und Hintergrundfarben des Zielgerätekontexts werden verwendet. Farbe in Monochrom, konvertieren `BitBlt` legt Pixel, die Farbe des Hintergrunds weiß übereinstimmen und alle anderen Pixel auf Schwarz fest. `BitBlt` verwendet die Vordergrund- und Hintergrundfarben des Gerätekontexts Farbe, die um von Farbe in Monochrom zu verwandeln.

Beachten Sie, die nicht alle Gerätekontexte unterstützen `BitBlt`. Zu überprüfen, ob ein bestimmtes Gerätekontext unterstützt `BitBlt`, verwenden Sie die `GetDeviceCaps` Member Funktion, und geben Sie den indes RASTERCAPS.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CDC::CreateCompatibleDC](#createcompatibledc).

##  <a name="cdc"></a>  CDC::CDC

Erstellt ein `CDC`-Objekt.

```
CDC();
```

##  <a name="chord"></a>  CDC::Chord

Zeichnet eine Tastenkombination (eine geschlossene Form, durch die Schnittmenge einer Ellipse und ein Liniensegment begrenzt).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt an, dass die X-Koordinate der oberen linken Ecke des Bandes umschließende Rechteck (in logischen Einheiten).

*y1*<br/>
Gibt an, der die y-Koordinate der oberen linken Ecke des Bandes umschließende Rechteck (in logischen Einheiten).

*x2*<br/>
Gibt an, dass die X-Koordinate der unteren rechten Ecke des Bandes umschließende Rechteck (in logischen Einheiten).

*Y2*<br/>
Gibt an, der die y-Koordinate der unteren rechten Ecke des Bandes umschließende Rechteck (in logischen Einheiten).

*x3*<br/>
Gibt an, dass die X-Koordinate des Punkts, der die Tastenkombination definiert Point (in logischen Einheiten) beginnt der.

*Y3*<br/>
Gibt an, der die y-Koordinate des Punkts, der die Tastenkombination definiert (in logischen Einheiten) Anfangspunkt des.

*X4*<br/>
Gibt die X-Koordinate des Punkts, der die Tastenkombination für den Endpunkt (in logischen Einheiten) definiert.

*Y4*<br/>
Gibt die y-Koordinate des Punkts, der die Tastenkombination für den Endpunkt (in logischen Einheiten) definiert.

*lpRect*<br/>
Gibt das umschließende Rechteck (in logischen Einheiten) an. Sie können entweder eine LPRECT übergeben oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.

*ptStart*<br/>
Gibt an, dass die x- und y-Koordinaten des Punkts, der die Tastenkombination definiert Point (in logischen Einheiten) beginnt der. Dieser Punkt muss nicht genau an die Tastenkombination liegen. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

*ptEnd*<br/>
Gibt an, die x- und y-Koordinaten des Punkts, der die Tastenkombination für den Endpunkt (in logischen Einheiten) definiert. Dieser Punkt muss nicht genau an die Tastenkombination liegen. Sie können entweder übergeben eine [Punkt](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die ( *X1*, *y1*) und ( *X2*, *y2*) Parameter angeben, die oberen linken und rechten unteren Ecken eines Rechtecks die Ellipse, die Teil des Bandes des Begrenzungsrahmens. Die ( *X3*, *y3*) und ( *X4*, *y4*) Parameter geben die Endpunkte einer Zeile, die sich die Ellipse überschneidet. Die Tastenkombination ist mit dem ausgewählten Stift gezeichnet und mit den ausgewählten Pinsel gefüllt.

In der Abbildung, die gezeichnet wird, durch die `Chord` Funktion bis zu erweitert, jedoch keine die rechten und unteren Koordinaten. Dies bedeutet, dass die Höhe der Abbildung *y2* - *y1* und die Breite der Abbildung ist *X2* - *X1*.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

##  <a name="closefigure"></a>  CDC::CloseFigure

Schließt eine offene Form in einem Pfad.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die Funktion schließt in der Abbildung, indem eine Linie von der aktuellen Position bis zum ersten Punkt in der Abbildung (in der Regel auf den Punkt, angegeben durch den letzten Aufruf der `MoveTo` Member-Funktion) und die Zeilen mithilfe der Linienverbindungsstil verbindet. Wenn eine Figur, mithilfe geschlossen wird der `LineTo` Memberfunktion anstelle der `CloseFigure`, Linienenden verwendet, um die Ecke, statt eine Verknüpfung zu erstellen. `CloseFigure` sollte nur aufgerufen werden, wenn eine Klammer offenen Pfad in den Gerätekontext vorhanden ist.

Eine Abbildung in einem Pfad ist geöffnet, es sei denn, es explizit geschlossen wird, durch die Verwendung dieser Funktion. (Eine Abbildung kann geöffnet sein, selbst wenn dem aktuellen Punkt und den Startpunkt der Figur identisch sind.) Alle Linien- oder Kurvensegmente, die hinzugefügt werden, auf den Pfad nach `CloseFigure` startet eine neue Figur.

##  <a name="createcompatibledc"></a>  CDC::CreateCompatibleDC

Erstellt einen Gerätekontext für Arbeitsspeicher, die kompatibel mit dem Gerät gemäß *pDC*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parameter

*pDC*<br/>
Ein Zeiger zu einem Gerätekontext. Wenn *pDC* NULL ist, erstellt die Funktion einen Speichergerätekontext, die mit der Systemanzeige kompatibel ist.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Ein Arbeitsspeicher-Gerätekontext handelt es sich um einen Speicherblock, der eine Anzeigeoberfläche darstellt. Es kann verwendet werden, zum Vorbereiten von Images im Arbeitsspeicher, bevor sie in der tatsächlichen Geräteoberfläche das kompatible Gerät kopiert.

Wenn ein Arbeitsspeicher-Gerätekontext erstellt wird, wählt GDI automatisch eine monochrome vordefinierte 1-von-1-Bitmap für sie. GDI-Ausgabe-Funktionen können mit einem Gerätekontext Arbeitsspeicher verwendet werden, nur dann, wenn eine Bitmap erstellt und in diesem Kontext ausgewählt wurde.

Diese Funktion kann nur verwendet werden, kompatible Gerätekontexte für Geräte zu erstellen, die Raster-Vorgänge zu unterstützen. Finden Sie unter den [CDC:: BitBlt](#bitblt) Member-Funktion Informationen zu Bit-Block-Übertragungen zwischen Gerätekontexte. Um zu bestimmen, ob für ein Gerätekontext Rasteroperationen unterstützt, finden Sie unter der RC_BITBLT Raster-Funktion die Memberfunktion `CDC::GetDeviceCaps`.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

##  <a name="createdc"></a>  CDC::CreateDC

Erstellt einen Gerätekontext für das angegebene Gerät.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parameter

*lpszDriverName*<br/>
Verweist auf eine auf Null endende Zeichenfolge, die den Dateinamen (ohne Erweiterung) für den Gerätetreiber (z. B. "EPSON") angibt. Sie können auch übergeben eine `CString` Objekt für diesen Parameter.

*lpszDeviceName*<br/>
Verweist auf eine auf Null endende Zeichenfolge, die den Namen des speziellen Geräts unterstützt werden müssen (z. B. "EPSON FX-80") angibt. Die *LpszDeviceName* Parameter wird verwendet, wenn das Modul über mehrere Geräte unterstützt. Sie können auch übergeben eine `CString` Objekt für diesen Parameter.

*lpszOutput*<br/>
Verweist auf eine auf Null endende Zeichenfolge, die Datei bzw. das Gerät den Namen für das physische Ausgabemedium (oder im Ausgabefenster-Port) angibt. Sie können auch übergeben eine `CString` Objekt für diesen Parameter.

*lpInitData*<br/>
Verweist auf eine `DEVMODE` Struktur, die von gerätespezifischen Initialisierungsdaten für den Gerätetreiber enthält. Die Windows `DocumentProperties` Funktion ruft diese Struktur, die für ein bestimmtes Gerät ausgefüllt. Die *LpInitData* Parameter darf NULL sein, wenn der Gerätetreiber verwendet die standardinitialisierung (sofern vorhanden), der vom Benutzer über die Systemsteuerung angegeben ist.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Das Drucken. H-Headerdatei ist erforderlich, wenn die [DEVMODE](/windows/desktop/api/wingdi/ns-wingdi-_devicemodea) Struktur verwendet wird.

Gerätenamen diesen Konventionen: eine abschließende Doppelpunkt (:) wird empfohlen, ist aber optional. Windows entfernt den abschließenden Doppelpunkt, damit Sie ein Gerätenamen mit einem Doppelpunkt endet, auf den gleichen Port mit demselben Namen ohne Doppelpunkt zugeordnet ist. Die Treiber und Anschluss Namen darf keine führende oder nachgestellte Leerzeichen enthalten. Funktionen für die Ausgabe von GDI können nicht mit Informationen Kontexten verwendet werden.

##  <a name="createic"></a>  CDC::CreateIC

Erstellt einen Informationen über den Kontext für das angegebene Gerät.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parameter

*lpszDriverName*<br/>
Verweist auf eine auf Null endende Zeichenfolge, die den Dateinamen (ohne Erweiterung) für den Gerätetreiber (z. B. "EPSON") angibt. Sie können übergeben eine `CString` Objekt für diesen Parameter.

*lpszDeviceName*<br/>
Verweist auf eine auf Null endende Zeichenfolge, die den Namen des speziellen Geräts unterstützt werden müssen (z. B. "EPSON FX-80") angibt. Die *LpszDeviceName* Parameter wird verwendet, wenn das Modul über mehrere Geräte unterstützt. Sie können übergeben eine `CString` Objekt für diesen Parameter.

*lpszOutput*<br/>
Verweist auf eine auf Null endende Zeichenfolge, die Datei bzw. das Gerät den Namen für das physische Ausgabemedium ("Datei" oder "Port") angibt. Sie können übergeben eine `CString` Objekt für diesen Parameter.

*lpInitData*<br/>
Verweist auf die gerätespezifische Initialisierungsdaten für den Gerätetreiber. Die *LpInitData* Parameter darf NULL sein, wenn der Gerätetreiber verwendet die standardinitialisierung (sofern vorhanden), der vom Benutzer über die Systemsteuerung angegeben ist. Finden Sie unter `CreateDC` für das Datenformat für die gerätespezifischen-Initialisierung.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Hinweise

Die Informationen über den Kontext bietet eine schnelle Möglichkeit, um Informationen über das Gerät zu erhalten, ohne einen Gerätekontext zu erstellen.

Gerätenamen diesen Konventionen: eine abschließende Doppelpunkt (:) wird empfohlen, ist aber optional. Windows entfernt den abschließenden Doppelpunkt, damit Sie ein Gerätenamen mit einem Doppelpunkt endet, auf den gleichen Port mit demselben Namen ohne Doppelpunkt zugeordnet ist. Die Treiber und Anschluss Namen darf keine führende oder nachgestellte Leerzeichen enthalten. Funktionen für die Ausgabe von GDI können nicht mit Informationen Kontexten verwendet werden.

##  <a name="deletedc"></a>  CDC::DeleteDC

Im Allgemeinen werden diese Funktion nicht aufgerufen Sie werden. der Destruktor wird es für Sie übernimmt.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Rückgabewert

Ungleich NULL ist, wenn die Funktion erfolgreich abgeschlossen wurde; andernfalls 0.

### <a name="remarks"></a>Hinweise

Die `DeleteDC` Memberfunktion löscht die Kontexte der Windows-Gerät, die zugeordnet werden `m_hDC` in der aktuellen `CDC` Objekt. Wenn diese `CDC` Objekt ist, den letzten aktiven Gerätekontext für ein bestimmtes Gerät, das Gerät wird benachrichtigt, und alle vom Gerät verwendete Speicher und Systemressourcen freigegeben werden.

Eine Anwendung sollte nicht aufrufen `DeleteDC` Wenn Objekte im Gerätekontext ausgewählt wurden. Objekte müssen zuerst im Gerätekontext ausgewählt werden, bevor er gelöscht wird.

Löschen einer Anwendung muss keinen Gerätekontext, dessen Handle, durch den Aufruf abgerufen wurde [CWnd:: GetDC](../../mfc/reference/cwnd-class.md#getdc). Sie müssen stattdessen Aufrufen [CWnd:: ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) auf den Gerätekontext frei. Die [CClientDC](../../mfc/reference/cclientdc-class.md) und [CWindowDC](../../mfc/reference/cwindowdc-class.md) Klassen werden bereitgestellt, um diese Funktionalität zu umschließen.

Die `DeleteDC` Funktion dient in der Regel mit erstellt Gerätekontexte löschen [CreateDC](#createdc), [CreateIC](#createic), oder [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="deletetempmap"></a>  CDC::DeleteTempMap

Wird automatisch aufgerufen, die `CWinApp` -leerlaufzeithandler, `DeleteTempMap` löscht temporäre `CDC` Objekten von erstellt `FromHandle`, jedoch nicht die gerätehandles Kontext zerstört wird ( `hDC`s) vorübergehend die zugeordnet`CDC` Objekte.

```
static void PASCAL DeleteTempMap();
```

##  <a name="detach"></a>  CDC::Detach

Mit dieser Funktion wird beim Trennen `m_hDC` (die Ausgabe-Gerätekontext) aus der `CDC` Objekt aus, und legen Sie die `m_hDC` und `m_hAttribDC` auf NULL.

```
HDC Detach();
```

### <a name="return-value"></a>Rückgabewert

Einen Windows-Gerätekontext.

##  <a name="dptohimetric"></a>  CDC::DPtoHIMETRIC

Verwenden Sie diese Funktion, wenn Sie HIMETRIC-Größen auf OLE, gestatten Pixel in HIMETRIC konvertiert.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpSize*<br/>
Verweist auf eine [Größe](https://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur oder [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.

### <a name="remarks"></a>Hinweise

Wenn der Zuordnungsmodus, der das Gerätekontextobjekt MM_LOENGLISH MM_HIENGLISH, MM_LOMETRIC oder MM_HIMETRIC ist, basiert klicken Sie dann die Konvertierung auf die Anzahl der Pixel in der physischen Zoll. Wenn der Zuordnungsmodus einen der anderen nicht eingeschränkte Modi (z. B. MM_TEXT) ist, basiert klicken Sie dann die Konvertierung auf die Anzahl der Pixel in der logischen Zoll.

##  <a name="dptolp"></a>  CDC::DPtoLP

Konvertiert Geräteeinheiten in logischen Einheiten.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) Strukturen oder [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekte.

*nCount*<br/>
Die Anzahl der Punkte im Array.

*lpRect*<br/>
Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt. Dieser Parameter wird für einfache Fälle der Konvertierung von einem Rechteck aus geräteverwaltungspunkte in logische Punkte verwendet.

*lpSize*<br/>
Verweist auf eine [Größe](https://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur oder [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.

### <a name="remarks"></a>Hinweise

Die Funktion ordnet die Koordinaten jedes Punkts oder Dimension mit einer Größe, aus das Koordinatensystem des Geräts in GDIs-logischen Koordinatensystem. Die Konvertierung hängt von den aktuellen Zuordnungsmodus und die Einstellungen von dem Ursprung und der Blöcke, die für Fenster und der Viewport des Geräts ab.

##  <a name="draw3drect"></a>  CDC::Draw3dRect

Rufen Sie diese Memberfunktion, um ein dreidimensionales Rechteck zu zeichnen.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Gibt das umschließende Rechteck (in logischen Einheiten) an. Sie können entweder einen Zeiger zu übergeben, eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.

*clrTopLeft*<br/>
Gibt die Farbe von der oberen und linken Rand des Rechtecks dreidimensionalen.

*clrBottomRight*<br/>
Gibt an, die Farbe des unteren und rechten Seite des dreidimensionalen Rechtecks.

*w*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des dreidimensionalen Rechtecks an.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des dreidimensionalen Rechtecks an.

*CX*<br/>
Gibt die Breite des Rechtecks dreidimensionalen.

*CY*<br/>
Gibt die Höhe des Rechtecks dreidimensionalen.

### <a name="remarks"></a>Hinweise

Mit den oberen und linken Rand in der Farbe anhand des Rechtecks gezeichnet *ClrTopLeft* und die unteren und rechten Seite in der Farbe anhand des *ClrBottomRight*.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

##  <a name="drawdragrect"></a>  CDC::DrawDragRect

Rufen Sie diese Memberfunktion auf, um einem Rechteck neu gezeichnet werden.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt, das die logischen Koordinaten eines Rechtecks angibt, in diesem Fall die Endposition des Rechtecks gezeichnet.

*size*<br/>
Gibt an, die Verschiebung von der linken oberen Ecke des äußeren Rahmens in die linke obere Ecke von den inneren Rahmen (d. h. die Stärke des Rahmens) ein Rechteck.

*lpRectLast*<br/>
Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt, das die logischen Koordinaten der Position eines Rechtecks angibt, in diesem Fall ist die ursprüngliche Position des Rechtecks gezeichnet.

*sizeLast*<br/>
Gibt an, die Verschiebung von der linken oberen Ecke des äußeren Rahmens in die linke obere Ecke der den inneren Rahmen (d. h. die Stärke des Rahmens) das ursprüngliche Rechteck gezeichnet.

*pBrush*<br/>
Zeiger auf ein Brush-Objekt. Verwenden Sie den Standardpinsel für Halbton auf NULL festgelegt.

*pBrushLast*<br/>
Zeiger auf das letzte Brush-Objekt verwendet. Verwenden Sie den Standardpinsel für Halbton auf NULL festgelegt.

### <a name="remarks"></a>Hinweise

Rufen Sie es in einer Schleife, wie Sie die Position des Mauszeigers, Stichproben, um visuelles Feedback anzuzeigen. Beim Aufruf `DrawDragRect`des vorherigen Rechtecks wird gelöscht, und eine neue gezeichnet wird. Wie der Benutzer zieht Sie z. B. ein Rechteck über den Bildschirm `DrawDragRect` wird das ursprüngliche Rechteck zu löschen und neu gezeichnet werden ein neues Abonnement in seiner neuen Position. In der Standardeinstellung `DrawDragRect` zeichnet das Rechteck mithilfe eines Pinsels Halbton Flimmern zu eliminieren und die Darstellung eines Rechtecks reibungslos verschieben zu erstellen.

Das erste Mal aufrufen `DrawDragRect`, *LpRectLast* Parameter muss NULL sein.

##  <a name="drawedge"></a>  CDC::DrawEdge

Rufen Sie diese Memberfunktion zum Zeichnen der Ränder eines Rechtecks, der dem angegebenen Typ und den Stil an.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Ein Zeiger auf eine `RECT` Struktur, die die logischen Koordinaten des Rechtecks enthält.

*nEdge*<br/>
Gibt den Typ des inneren und äußeren Rand zeichnen. Dieser Parameter muss eine Kombination aus einem inneren Rahmen-Flag und einen Außenlinie Flag sein. Finden Sie unter [DrawEdge](/windows/desktop/api/winuser/nf-winuser-drawedge) im Windows SDK für eine Tabelle mit den Parametertypen des.

*nFlags*<br/>
Die Flags, die angeben, den Typ des Rahmens, gezeichnet werden soll. Finden Sie unter `DrawEdge` im Windows SDK für eine Tabelle mit die Werte des Parameters. Für die diagonale Linien geben die BF_RECT Flags den Endpunkt des Vektors begrenzt durch die Rechteckparameter.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

##  <a name="drawescape"></a>  CDC::DrawEscape

Greift auf Zeichnen die Funktionen einer Videoanzeige, die nicht direkt über die Graphics Device Interface (GDI) verfügbar sind.

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parameter

*nEscape*<br/>
Gibt die Escape-Funktion ausgeführt werden.

*nInputSize*<br/>
Gibt die Anzahl der Datenbytes, verweist der *LpszInputData* Parameter.

*lpszInputData*<br/>
Zeigt auf der Eingabestruktur, die für die Escapezeichen erforderlich sind.

### <a name="return-value"></a>Rückgabewert

Gibt das Ergebnis der Funktion an. Größer als 0 (null), wenn erfolgreich, mit Ausnahme der QUERYESCSUPPORT Draw-Escapesequenz, die für die Implementierung nur überprüft werden soll; oder 0 (null), wenn das Escapezeichen nicht implementiert wird; oder kleiner als NULL, wenn ein Fehler aufgetreten.

### <a name="remarks"></a>Hinweise

Wenn eine Anwendung ruft `DrawEscape`, die Daten, die identifizierte *nInputSize* und *LpszInputData* wird direkt an den angegebenen Anzeigetreiber übergeben.

##  <a name="drawfocusrect"></a>  CDC::DrawFocusRect

Zeichnet ein Rechteck im Stil verwendet, um anzugeben, dass das Rechteck um den Fokus besitzt.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das gibt an, die logischen Koordinaten des Rechtecks gezeichnet werden soll.

### <a name="remarks"></a>Hinweise

Da dies eine booleschen XOR-Funktion ist, wird das Aufrufen dieser Funktion eines zweiten Mal mit dem gleichen Rechteck das Rechteck aus der Anzeige entfernt. Das Rechteck gezeichnet, die von dieser Funktion kann nicht gescrollt werden. Rufen Sie zuerst einen Bereich, die ein Rechteck gezeichnet, die von dieser Funktion enthält einen Bildlauf durchführen, `DrawFocusRect` um das Rechteck aus der Anzeige zu entfernen, führen Sie den Bereich einen Bildlauf aus, und rufen Sie anschließend `DrawFocusRect` erneut aus, um das Rechteck in die neue Position zu zeichnen.

> [!CAUTION]
> `DrawFocusRect` funktioniert nur im Modus für MM_TEXT. In anderen Modi diese Funktion zeichnet das Fokusrechteck keine ordnungsgemäß, aber es werden keine Fehlerwerte zurückgegeben.

##  <a name="drawframecontrol"></a>  CDC::DrawFrameControl

Rufen Sie diese Memberfunktion zum Zeichnen eines Steuerelements Frame, der dem angegebenen Typ und den Stil an.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Ein Zeiger auf eine `RECT` Struktur, die die logischen Koordinaten des Rechtecks enthält.

*nType*<br/>
Gibt den Typ der Frame-Steuerelement zu zeichnen. Finden Sie unter den *uType* Parameter im [DrawFrameControl](/windows/desktop/api/winuser/nf-winuser-drawframecontrol) im Windows SDK für eine Liste der möglichen Werte dieses Parameters.

*nState*<br/>
Gibt den Ausgangszustand der Frame-Steuerelement an. Einer oder mehrere der Werte beschrieben, für das die *uState* Parameter im `DrawFrameControl` im Windows SDK. Verwenden der *nState* Wert DFCS_ADJUSTRECT, um das umschließende Rechteck zum Ausschließen von des umgebenden Randes der Schaltfläche anzupassen.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Hinweise

In vielen Fällen *nState* hängt von der *nType* Parameter. Die folgende Liste zeigt die Beziehung zwischen den vier *nType* Werte und *nState*:

- DFC_BUTTON

    - DFCS_BUTTON3STATE drei-Status-Schaltfläche

    - Das DFCS_BUTTONCHECK überprüfen

    - Schaltfläche DFCS_BUTTONPUSH mithilfe von Push übertragen

    - DFCS_BUTTONRADIO Optionsfeld

    - DFCS_BUTTONRADIOIMAGE-Image für das Optionsfeld (nicht quadratische erforderlich Image)

    - DFCS_BUTTONRADIOMASK Maske für Optionsfeld (nicht quadratische erforderlich Maske)

- DFC_CAPTION

    - Schaltfläche "DFCS_CAPTIONCLOSE schließen"

    - Schaltfläche Hilfe DFCS_CAPTIONHELP

    - Schaltfläche "DFCS_CAPTIONMAX zu maximieren."

    - Schaltfläche DFCS_CAPTIONMIN zu minimieren.

    - Schaltfläche DFCS_CAPTIONRESTORE wiederherstellen

- DFC_MENU

    - DFCS_MENUARROW Untermenü Pfeil

    - DFCS_MENUBULLET Aufzählungszeichen

    - DFCS_MENUCHECK Häkchen

- DFC_SCROLL

    - DFCS_SCROLLCOMBOBOX Combo Box-Bildlaufleiste

    - DFCS_SCROLLDOWN nach-unten-Pfeil der scrollleiste

    - Bildlaufleiste nach DFCS_SCROLLLEFT-links

    - DFCS_SCROLLRIGHT rechts-Pfeil der Bildlaufleiste.

    - DFCS_SCROLLSIZEGRIP Größenziehpunkts in der unteren rechten Ecke des Fensters

    - DFCS_SCROLLUP nach-oben Bildlaufleiste.

### <a name="example"></a>Beispiel

Dieser Code zeichnet ziehelements Größe in der unteren rechten Ecke des Fensters. Es eignet sich für die `OnPaint` Handler eines Dialogfelds, die keine Formatvorlagen und enthalten andere Steuerelemente (z. B. einer Statusleiste), mit denen sie ein ziehelements Größe können normalerweise nicht.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

##  <a name="drawicon"></a>  CDC::DrawIcon

Zeichnet ein Symbol auf dem Gerät, das vom aktuellen `CDC` Objekt.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des Symbols an.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Symbols an.

*hIcon*<br/>
Gibt das Handle des Symbols, das gezeichnet werden soll.

*Zeigen Sie*<br/>
Gibt die logische X - und y-Koordinaten von der linken oberen Ecke des Symbols an. Können Sie übergeben eine [Punkt](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL ist, wenn die Funktion erfolgreich abgeschlossen wurde; andernfalls 0.

### <a name="remarks"></a>Hinweise

Die Funktion wird das Symbol in der oberen linken Ecke an die vom angegebenen Speicherort *x* und *y*. Der Speicherort ist gemäß der aktuellen Zuordnungsmodus des Gerätekontexts.

Die Symbolressource muss wurden zuvor geladen mithilfe der Funktionen `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`, oder `CWinApp::LoadOEMIcon`. Die `MM_TEXT` Zuordnungsmodus muss ausgewählt sein, bevor Sie diese Funktion verwenden.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

##  <a name="drawstate"></a>  CDC::DrawState

Rufen Sie diese Memberfunktion, um ein Bild anzeigen und Anwenden eines visuellen Effekts, um einen Status, beispielsweise einen deaktivierten oder Standardzustand anzugeben.

> [!NOTE]
>  Für alle *nFlag* außer DSS_NORMAL, gibt das Bild wird in Monochrom zu umgewandelt, bevor der visuelle Effekt angewendet wird.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parameter

*pt*<br/>
Gibt den Speicherort des Bilds.

*size*<br/>
Gibt die Größe des Bilds.

*hBitmap*<br/>
Ein Handle für eine Bitmap.

*nFlags*<br/>
Flags, die den Bildtyp und Zustand angeben. Finden Sie unter [DrawState](/windows/desktop/api/winuser/nf-winuser-drawstatea) im Windows SDK für die möglichen *nFlags* Typen und Status.

*hBrush*<br/>
Ein Handle für einen Pinsel.

*pBitmap*<br/>
Ein Zeiger auf ein CBitmap-Objekt.

*pBrush*<br/>
Ein Zeiger auf ein CBrush-Objekt.

*hIcon*<br/>
Ein Handle für ein Symbol.

*lpszText*<br/>
Ein Zeiger auf Text.

*bPrefixText*<br/>
Text, der möglicherweise eine Zugriffstaste mnemonisches Zeichen enthalten. Die *lData* Parameter gibt die Adresse der Zeichenfolge ist, und die *nTextLen* Parameter gibt die Länge. Wenn *nTextLen* gleich 0 ist, wird angenommen, dass die Zeichenfolge Null-terminiert sein.

*nTextLen*<br/>
Länge der Textzeichenfolge verweist *LpszText*. Wenn *nTextLen* gleich 0 ist, wird angenommen, dass die Zeichenfolge Null-terminiert sein.

*lpDrawProc*<br/>
Ein Zeiger auf eine Callback-Funktion verwendet, um ein Bild zu rendern. Dieser Parameter ist erforderlich, wenn das Bild in eingeben *nFlags* DST_COMPLEX ist. Es ist optional und kann NULL sein, wenn der Bildtyp DST_TEXT ist. Für alle anderen Bildtypen wird dieser Parameter ignoriert. Weitere Informationen zu der Callback-Funktion, finden Sie unter den [DrawStateProc](/windows/desktop/api/winuser/nc-winuser-drawstateproc) -Funktion in das Windows SDK.

*lData*<br/>
Gibt Informationen zu dem Bild. Die Bedeutung dieses Parameters hängt von den Bildtyp ab.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

##  <a name="drawtext"></a>  CDC:: DrawText

Rufen Sie diese Memberfunktion zum Formatieren von Text in einem angegebenen Rechteck. Verwenden Sie zum Angeben zusätzlicher Formatierungsoptionen [CDC::DrawTextEx](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Verweist auf die Zeichenfolge, die gezeichnet werden soll. Wenn *nCount* ist-1. die Zeichenfolge muss Null-terminiert sein.

*nCount*<br/>
Gibt die Anzahl der Zeichen in der Zeichenfolge an. Wenn *nCount* -1 ist, klicken Sie dann *LpszString* wird als ein long-Zeiger auf eine Null-terminierte Zeichenfolge und `DrawText` berechnet die Anzahl der Zeichen automatisch.

*lpRect*<br/>
Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das das Rechteck (in logischen Koordinaten) enthält, in dem der Text formatiert werden.

*str*<br/>
Ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt mit der angegebenen Zeichen, gezeichnet werden soll.

*nFormat*<br/>
Gibt die Methode der Formatierung des Texts. Es kann sein, eine beliebige Kombination der Werte beschrieben, für die *uFormat* Parameter im [DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) im Windows SDK. (kombinieren Sie, mit dem bitweisen OR-Operator):

> [!NOTE]
>  Einige *uFormat* Flagkombinationen können dazu führen, dass die übergebene Zeichenfolge, die geändert werden. Mithilfe von DT_MODIFYSTRING DT_END_ELLIPSIS oder DT_PATH_ELLIPSIS kann dazu führen, dass die Zeichenfolge, die geändert werden, verursacht eine Assertion in dem `CString` außer Kraft setzen. Die Werte DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP und DT_NOPREFIX können nicht mit dem Wert DT_TABSTOP verwendet werden.

### <a name="return-value"></a>Rückgabewert

Die Höhe des Texts, wenn die Funktion erfolgreich ist.

### <a name="remarks"></a>Hinweise

Es formatiert Text durch Erweitern von Registerkarten in entsprechende Leerzeichen, Ausrichten von Text auf der linken, rechten, oder der Mitte des angegebenen Rechtecks und Aufteilen von Text in Zeilen, die in einem angegebenen Rechteck zu passen. Die Art der Formatierung wird durch angegeben *nFormat*.

Diese Memberfunktion verwendet des Gerätekontexts ausgewählten Schriftart, Textfarbe und Hintergrundfarbe zum Zeichnen des Texts an. Es sei denn, das DT_NOCLIP-Format verwendet wird, `DrawText` Text schneidet, sodass der Text nicht außerhalb des angegebenen Rechtecks angezeigt wird. Gesamte Formatierung wird angenommen, um mehrere Zeilen zu erhalten, es sei denn, das DT_SINGLELINE-Format angegeben wird.

Wenn die ausgewählte Schriftart zu groß für das angegebene Rechteck, das `DrawText` Memberfunktion wird nicht versucht, eine kleinere Schriftart zu ersetzen.

Wenn die DT_CALCRECT-Flag angegeben ist, das Rechteck angegeben *LpRect* wird aktualisiert, um die Breite und Höhe, die zum Zeichnen des Texts entsprechen.

Wenn das TA_UPDATECP textausrichtung Flag festgelegt wurde (finden Sie unter [CDC::SetTextAlign](#settextalign)), `DrawText` zeigt Text ab, an der aktuellen Position und nicht auf der linken Seite des angegebenen Rechtecks an. `DrawText` Text wird nicht umbrochen werden, wenn das TA_UPDATECP-Flag festgelegt wurde (d. h. das Flag DT_WORDBREAK hat keine Auswirkungen).

Die Textfarbe kann festgelegt werden, indem [CDC::SetTextColor](#settextcolor).

##  <a name="drawtextex"></a>  CDC::DrawTextEx

Formatiert den Text im angegebenen Rechteck.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Verweist auf die Zeichenfolge, die gezeichnet werden soll. Wenn *nCount* ist-1. die Zeichenfolge muss Null-terminiert sein.

*nCount*<br/>
Gibt die Anzahl der Zeichen in der Zeichenfolge an. Wenn *nCount* -1 ist, klicken Sie dann *LpszString* wird als ein long-Zeiger auf eine Null-terminierte Zeichenfolge und `DrawText` berechnet die Anzahl der Zeichen automatisch.

*lpRect*<br/>
Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das das Rechteck (in logischen Koordinaten) enthält, in dem der Text formatiert werden.

*str*<br/>
Ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt mit der angegebenen Zeichen, gezeichnet werden soll.

*nFormat*<br/>
Gibt die Methode der Formatierung des Texts. Es kann sein, eine beliebige Kombination der Werte beschrieben, für die *uFormat* Parameter im [DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) im Windows SDK. (Kombinieren, mit dem bitweisen **oder** Operator):

> [!NOTE]
>  Einige *uFormat* Flagkombinationen können dazu führen, dass die übergebene Zeichenfolge, die geändert werden. Mithilfe von DT_MODIFYSTRING DT_END_ELLIPSIS oder DT_PATH_ELLIPSIS kann dazu führen, dass die Zeichenfolge, die geändert werden, verursacht eine Assertion in dem `CString` außer Kraft setzen. Die Werte DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP und DT_NOPREFIX können nicht mit dem Wert DT_TABSTOP verwendet werden.

*lpDTParams*<br/>
Zeiger auf eine [DRAWTEXTPARAMS](/windows/desktop/api/winuser/ns-winuser-tagdrawtextparams) "Optionen" Struktur, die zusätzliche Formatierungen angibt. Dieser Parameter kann NULL sein.

### <a name="remarks"></a>Hinweise

Es formatiert Text durch Erweitern von Registerkarten in entsprechende Leerzeichen, Ausrichten von Text auf der linken, rechten, oder der Mitte des angegebenen Rechtecks und Aufteilen von Text in Zeilen, die in einem angegebenen Rechteck zu passen. Die Art der Formatierung wird durch angegeben *nFormat* und *LpDTParams*. Weitere Informationen finden Sie unter [CDC:: DrawText](#drawtext) und [DrawTextEx](/windows/desktop/api/winuser/nf-winuser-drawtextexa) im Windows SDK.

Die Textfarbe kann festgelegt werden, indem [CDC::SetTextColor](#settextcolor).

##  <a name="ellipse"></a>  CDC::Ellipse

Zeichnet eine Ellipse.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des umschließenden Rechtecks der Ellipse an.

*y1*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des umschließenden Rechtecks der Ellipse an.

*x2*<br/>
Gibt die logische X-Koordinate der unteren rechten Ecke des umschließenden Rechtecks der Ellipse an.

*Y2*<br/>
Gibt die logische y-Koordinate der unteren rechten Ecke des umschließenden Rechtecks der Ellipse an.

*lpRect*<br/>
Gibt an, das die Ellipse umschließenden Rechtecks. Sie können auch übergeben eine [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Der Mittelpunkt der Ellipse liegt im Zentrum des umschließenden Rechtecks gemäß *X1*, *y1*, *X2*, und *y2*, oder  *LpRect*. Die Ellipse wird gezeichnet, mit dem aktuellen Stift und inneren mit der aktuellen Pinsel gefüllt ist.

In der Abbildung, die von dieser Funktion gezeichnet bis erweitert, aber keine, die rechten und unteren Koordinaten. Dies bedeutet, dass die Höhe der Abbildung *y2* - *y1* und die Breite der Abbildung ist *X2* - *X1*.

Wenn die Breite oder die Höhe des umschließenden Rechtecks 0 ist, wird keine Ellipse gezeichnet.

##  <a name="enddoc"></a>  CDC::EndDoc

Beendet einen Druckauftrag gestartet, die durch einen Aufruf der [StartDoc](#startdoc) Member-Funktion.

```
int EndDoc();
```

### <a name="return-value"></a>Rückgabewert

Größer als oder gleich 0, wenn die Funktion erfolgreich ist oder ein negativer Wert, wenn ein Fehler aufgetreten.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion ersetzt die ENDDOC Druckerescape und unmittelbar nach Abschluss eines erfolgreichen Druckauftrags aufgerufen werden soll.

Wenn eine Anwendung eines Druckfehlers oder einen Druck abgebrochenen Vorgang auftritt, müssen sie nicht versuchen, den Vorgang zu beenden, indem Sie entweder `EndDoc` oder [AbortDoc](#abortdoc). GDI wird automatisch beendet den Vorgang, bevor der Wert des Fehlercodes zurückgeben.

Diese Funktion sollte nicht innerhalb von Metadateien verwendet werden.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CDC::StartDoc](#startdoc).

##  <a name="endpage"></a>  CDC::EndPage

Informiert dem Gerät, dass die Anwendung beim Schreiben in eine Seite abgeschlossen ist.

```
int EndPage();
```

### <a name="return-value"></a>Rückgabewert

Größer als oder gleich 0, wenn die Funktion erfolgreich ist oder ein negativer Wert, wenn ein Fehler aufgetreten.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion wird normalerweise verwendet, um den Gerätetreiber aus, um auf eine neue Seite leiten.

Diese Memberfunktion ersetzt die NEWFRAME Druckerescape. Im Gegensatz zu NEWFRAME wird diese Funktion immer nach dem Drucken einer Seite aufgerufen.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CDC::StartDoc](#startdoc).

##  <a name="endpath"></a>  CDC::EndPath

Schließt eine Klammer Pfad ein, und wählt den Pfad, der durch die Klammer definiert werden, in den Gerätekontext.

```
BOOL EndPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CDC:: beginpath](#beginpath).

##  <a name="enumobjects"></a>  CDC:: EnumObjects

Listet die Stifte und Pinsel verfügbaren in einem Gerätekontext.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parameter

*nObjectType*<br/>
Gibt den Objekttyp an. Sie haben die Werte OBJ_BRUSH oder OBJ_PEN.

*lpfn*<br/>
Ist die Adresse der Prozedur Instanzen der Anwendung bereitgestellten Rückruffunktion. Finden Sie im Abschnitt "Hinweise".

*lpData*<br/>
Verweist auf die von der Anwendung bereitgestellten Daten. Die Daten werden an die Callback-Funktion zusammen mit den Objektinformationen übergeben.

### <a name="return-value"></a>Rückgabewert

Gibt an, den letzten Rückgabewert, der von der [Rückruffunktion](callback-functions-used-by-mfc.md#enum_objects). Die Bedeutung wird vom Benutzer festgelegt.

### <a name="remarks"></a>Hinweise

Für jedes Objekt eines angegebenen Typs ist die Callback-Funktion, die Sie übergeben die Informationen für dieses Objekt aufgerufen. Das System Ruft die Callback-Funktion auf, bis keine weitere Objekte vorhanden sind oder die Callback-Funktion gibt 0 zurück.

Beachten Sie, dass die neuen Features von Microsoft Visual C++ können Sie eine gewöhnliche Funktion zu verwenden, die Funktion übergebenen `EnumObjects`. Die Adresse übergeben, um `EnumObjects` ist ein Zeiger auf eine Funktion, die mit exportierten **EXPORTIEREN** und mit der Pascal-Aufrufkonvention. In Anwendungen zu schützen-Modus müssen Sie nicht diese Funktion mit der Windows-MakeProcInstance-Funktion erstellen, oder geben Sie die Funktion nach der Verwendung mit der Funktion FreeProcInstance Windows frei.

Keine Sie auch den Funktionsnamen im Exportieren einer **EXPORTE** -Anweisung in DEF-Datei von Ihrer Anwendung. Sie können stattdessen verwenden die **EXPORTIEREN** Modifizierer funktionieren, wie in

**Int-RÜCKRUF EXPORTIEREN** AFunction **(LPSTR**, **LPSTR);**

den Compiler den ordnungsgemäßen Export-Datensatz für den Export nach Namen ohne Aliasing ausgeben zu verursachen. Dies funktioniert für die häufigsten Anforderungen. Für einige Sonderfälle, z. B. eine Funktion nach Ordnungszahl oder Aliasing exportieren exportieren, Sie weiterhin verwenden müssen eine **EXPORTE** -Anweisung in eine DEF-Datei.

Zum Kompilieren von Microsoft Foundation-Programme, werden Sie normalerweise die/GA und Compileroptionen /GEs verwenden. Die Compileroption "/ GW" ist nicht mit der Microsoft Foundation Classes verwendet. (Wenn Sie die Windows-Funktion verwenden `MakeProcInstance`, Sie müssen explizit von FARPROC in den Typ in dieser API benötigt den zurückgegebenen Funktionszeiger umgewandelt.) Registrierung von Rückrufschnittstellen sind jetzt als typsicherer (Sie müssen in einen Funktionszeiger, der auf die richtige Art von Funktion, die für den bestimmten Rückruf zeigt übergeben).

Beachten Sie außerdem, dass alle Rückruffunktionen vor der Rückgabe auf Windows, da Ausnahmen hinweg Rückruf ausgelöst werden, können nicht Microsoft Foundation Ausnahmen abfangen müssen. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

##  <a name="escape"></a>  CDC::Escape

Diese Memberfunktion ist praktisch für Win32-Programmierung veraltet.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parameter

*nEscape*<br/>
Gibt die Escape-Funktion ausgeführt werden.

Eine vollständige Liste der Escape-Funktionen, finden Sie unter [Escape](/windows/desktop/api/wingdi/nf-wingdi-escape) im Windows SDK.

*nCount*<br/>
Gibt die Anzahl der Datenbytes, die auf zeigt *LpszInData*.

*lpszInData*<br/>
Verweist auf die Eingabedaten-Struktur, die für diese Escapezeichen erforderlich sind.

*lpOutData*<br/>
Verweist auf die Struktur, die Ausgabe aus diesem Escapezeichen zu empfangen. Die *LpOutData* Parameter NULL ist, wenn keine Daten zurückgegeben werden.

*nInputSize*<br/>
Gibt die Anzahl der Datenbytes, verweist der *LpszInputData* Parameter.

*lpszInputData*<br/>
Zeigt auf der Eingabestruktur, die für die Escapezeichen erforderlich sind.

*nOutputSize*<br/>
Gibt die Anzahl der Datenbytes, verweist der *LpszOutputData* Parameter.

*lpszOutputData*<br/>
Verweist auf die Struktur, die von diesem Escape Ausgabe empfängt. Dieser Parameter sollte NULL sein, wenn keine Daten zurückgegeben werden.

### <a name="return-value"></a>Rückgabewert

Ein positiver Wert wird zurückgegeben, wenn die Funktion erfolgreich ist, mit Ausnahme der QUERYESCSUPPORT-Escapesequenz, die nur für die Implementierung überprüft. 0 (null) wird zurückgegeben, wenn das Escapezeichen nicht implementiert wird. Ein negativer Wert wird zurückgegeben, wenn ein Fehler aufgetreten. Es folgen allgemeine Fehlerwerte:

- SP_ERROR allgemeiner Fehler.

- SP_OUTOFDISK nicht genügend Speicherplatz auf dem Datenträger steht zurzeit zum Spoolen und keinen Speicherplatz mehr zur Verfügung stehen.

- SP_OUTOFMEMORY nicht genügend Arbeitsspeicher zum Spoolen verfügbar ist.

- SP_USERABORT Benutzer beendet den Auftrag über die Druck-Manager.

### <a name="remarks"></a>Hinweise

Von der ursprünglichen Printer-Escapesequenzen wird nur QUERYESCSUPPORT für Win32-Anwendungen unterstützt. Alle anderen Drucker Escapesequenzen sind veraltet und werden nur für Kompatibilität mit 16-Bit-Anwendungen unterstützt.

Für die Win32-Programmierung `CDC` bietet jetzt sechs Memberfunktionen, die ihre entsprechenden Drucker Escapezeichen abgelöst:

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

Darüber hinaus [GetDeviceCaps](#getdevicecaps) unterstützt Win32-Indizes, die andere Drucker Escapezeichen ablösen. Finden Sie unter [GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) im Windows SDK für Weitere Informationen.

Diese Memberfunktion ermöglicht Anwendungen die Funktionen eines bestimmten Geräts zuzugreifen, die nicht direkt über GDI verfügbar sind.

Verwenden Sie die erste Version, wenn die Anwendung vordefinierte Escape-Werte verwendet. Verwenden Sie die zweite Version aus, wenn Ihre Anwendung privat Escape-Werte definiert. Finden Sie unter [ExtEscape](/windows/desktop/api/wingdi/nf-wingdi-extescape) im Windows SDK für Weitere Informationen zu der zweiten Version.

##  <a name="excludecliprect"></a>  CDC::ExcludeClipRect

Erstellt einen neuen Ausschneidebereich, der den vorhandenen Ausschneidebereich abzüglich des angegebenen Rechtecks besteht.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des Rechtecks an.

*y1*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks an.

*x2*<br/>
Gibt die logische X-Koordinate der unteren rechten Ecke des Rechtecks an.

*Y2*<br/>
Gibt die logische y-Koordinate der unteren rechten Ecke des Rechtecks an.

*lpRect*<br/>
Gibt das Rechteck. Kann auch sein, eine `CRect` Objekt.

### <a name="return-value"></a>Rückgabewert

Gibt den neuen Ausschneidebereich-Typ. Eines der folgenden Werte sind möglich:

- COMPLEXREGION der Region hat überlappende Grenzen.

- Fehler wurde keine Region erstellt.

- NULLREGION der Region ist leer.

- SIMPLEREGION der Region verfügt über keine überlappenden Rahmen.

### <a name="remarks"></a>Hinweise

Die Breite des Rechtecks, durch den absoluten Wert des angegebenen *X2* - *X1*, 32.767 Einheiten nicht überschreiten. Dieser Grenzwert gilt für die Höhe des Rechtecks ebenfalls.

##  <a name="excludeupdatergn"></a>  CDC::ExcludeUpdateRgn

Verhindert, dass Zeichnung in ungültigen Bereiche eines Fensters durch einen aktualisierten Bereich im Fenster aus den zugeordneten Ausschneidebereich Ausschließen der `CDC` Objekt.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parameter

*Aufnehmen*<br/>
Verweist auf das Window-Objekt, dessen Fenster aktualisiert wird.

### <a name="return-value"></a>Rückgabewert

Der Typ, der ausgeschlossen werden soll. Eine der folgenden Werte sind möglich:

- COMPLEXREGION der Region hat überlappende Grenzen.

- Fehler wurde keine Region erstellt.

- NULLREGION der Region ist leer.

- SIMPLEREGION der Region verfügt über keine überlappenden Rahmen.

##  <a name="extfloodfill"></a>  CDC::ExtFloodFill

Füllt einen Bereich der Anzeigeoberfläche mit dem aktuellen Pinsel.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate des Punkts, an dem Füllen beginnt.

*y*<br/>
Gibt die logische y-Koordinate des Punkts, an dem Füllen beginnt.

*crColor*<br/>
Gibt die Farbe der Grenze oder den Bereich gefüllt werden soll. Die Interpretation der *CrColor* hängt vom Wert der *nFillType*.

*nFillType*<br/>
Gibt den Typ der Flut Füllung ausgeführt werden. Sie müssen die folgenden Werte sein:

- Bereich ausfüllen, wird durch die Farbe gemäß begrenzt FLOODFILLBORDER *CrColor*. Dieser Stil ist identisch mit der Füllen von ausgeführten `FloodFill`.

- FLOODFILLSURFACE Füllbereichs, durch die Farbe gemäß definiert wird *CrColor*. Füllen wird nach außen in alle Richtungen fortgesetzt, solange die Farbe gefunden wird. Dieses Format eignet sich für das Füllen von Bereichen mit mehrfarbigen Grenzen.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn die Funktion erfolgreich ist; Wenn das Ausfüllen nicht abgeschlossen werden konnte, wenn der angegebene Punkt die Grenze ist, andernfalls wird 0 Farbe anhand des *CrColor* (wenn es sich um eine FLOODFILLBORDER angefordert wurde), wenn der angegebene Punkt keinen die Farbe gemäß *CrColor* (wenn es sich um eine FLOODFILLSURFACE angefordert wurde), oder wenn der Punkt außerhalb des Clippingbereichs ist.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion bietet mehr Flexibilität als `FloodFill` , da Sie einen Typ in angeben können *nFillType*.

Wenn *nFillType* festgelegt ist, FLOODFILLBORDER, der Bereich wird angenommen, dass durch die Farbe gemäß vollständig umschlossen werden *CrColor*. Startet die Funktion, die zum Zeitpunkt der gemäß *x* und *y* und in alle Richtungen und der Farbe gefüllt.

Wenn *nFillType* festgelegt ist, FLOODFILLSURFACE, startet die Funktion an dem vom angegebenen *x* und *y* und in alle Richtungen ausgestrahlt, füllen alle verwandten Bereichen wird fortgesetzt mit der Farbe anhand des *CrColor*.

Nur Arbeitsspeicher-Gerätekontexte und Geräte, die Unterstützung der Raster-Anzeige-Technologie unterstützen `ExtFloodFill`. Weitere Informationen finden Sie unter den [GetDeviceCaps](#getdevicecaps) Member-Funktion.

##  <a name="exttextout"></a>  CDC::ExtTextOut

Rufen Sie diese Memberfunktion zum Schreiben einer Zeichenfolge in einen rechteckigen Bereich mit der aktuell ausgewählten Schriftart.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate der Zeichenzelle für das erste Zeichen in der angegebenen Zeichenfolge an.

*y*<br/>
Gibt die logische y-Koordinate für den oberen Rand der Zeichenzelle für das erste Zeichen in der angegebenen Zeichenfolge an.

*nOptions*<br/>
Gibt den Typ des Rechtecks. Dieser Parameter kann einen, beide oder keines von beiden der folgenden Werte sein:

- ETO_CLIPPED gibt an, dass Text in das Rechteck abgeschnitten wird.

- ETO_OPAQUE gibt an füllt, dass die aktuelle Hintergrundfarbe das Rechteck. (Sie können festlegen, und Abfragen mit die aktuellen Hintergrundfarbe der [SetBkColor](#setbkcolor) und [GetBkColor](#getbkcolor) Member-Funktionen.)

*lpRect*<br/>
Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur, die die Abmessungen des Rechtecks bestimmt. Dieser Parameter kann NULL sein. Sie können auch übergeben eine [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.

*lpszString*<br/>
Verweist auf die angegebene Zeichenfolge, die gezeichnet werden soll. Sie können auch übergeben eine [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an.

*lpDxWidths*<br/>
Zeigt auf ein Array von Werten, die den Abstand zwischen dem Ursprung von angrenzenden Zeichenzellen angeben. Z. B. *LpDxWidths*[ *ich*] logische Einheiten trennt die Ursprünge der Zeichenzelle *ich* und Zeichenzelle *ich* + 1. Wenn *LpDxWidths* NULL ist, `ExtTextOut` verwendet den Standardabstand zwischen Zeichen lang sein.

*str*<br/>
Ein `CString` Objekt mit der angegebenen Zeichen, gezeichnet werden soll.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Der rechteckige Bereich kann nicht transparente (ausgefüllt mit der aktuellen Hintergrundfarbe), und kann es einer zuschneideregion zu sein.

Wenn *nOptions* ist 0 und *LpRect* NULL ist, die Funktion schreibt Text in den Gerätekontext, ohne einen rechteckigen Bereich. Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert. Wenn eine Anwendung muss die aktuelle Position Aktualisieren beim Aufruf `ExtTextOut`, kann die Anwendung aufrufen, die `CDC` Memberfunktion [SetTextAlign](#settextalign) mit *nFlags* TA_UPDATECP festgelegt. Wenn dieses Flag festgelegt ist, ignoriert Windows *x* und *y* bei nachfolgenden Aufrufen `ExtTextOut` und verwendet Sie stattdessen die aktuelle Position. Wenn eine Anwendung TA_UPDATECP verwendet, um die aktuelle Position aktualisieren `ExtTextOut` setzt die aktuelle Position am Ende der vorherigen Zeile des Texts oder die Position angegeben wird, durch das letzte Element des Arrays zeigt *LpDxWidths*, welcher Wert größer ist.

##  <a name="fillpath"></a>  CDC::FillPath

Schließt alle geöffneten Figuren in den aktuellen Pfad aus, und füllt den Pfad des innere mithilfe des aktuellen Pinsel und Polygon-füllen-Modus.

```
BOOL FillPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Nach dem inneren gefüllt ist, wird der Pfad aus dem Gerätekontext verworfen.

##  <a name="fillrect"></a>  CDC::fillRect

Rufen Sie diese Memberfunktion, um ein angegebenes Rechteck, das mit dem angegebenen Pinsel zu füllen.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) -Struktur mit den logischen Koordinaten des Rechtecks gefüllt werden soll. Sie können auch übergeben eine [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt für diesen Parameter.

*pBrush*<br/>
Identifiziert den Pinsel ab, die zum Ausfüllen des Rechtecks.

### <a name="remarks"></a>Hinweise

Die Funktion füllt, das vollständige Rechteck, einschließlich der linken und oberen Rahmens, aber nicht den rechten und unteren Rahmen aufgefüllt wird.

Der Pinsel muss entweder erstellt werden, mit der [CBrush](../../mfc/reference/cbrush-class.md) Memberfunktionen [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush), und [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), oder abgerufen, indem die `GetStockObject` Windows-Funktion.

Wenn das angegebene Rechteck, ausfüllen `FillRect` enthält keine rechten und unteren-Seiten des Rechtecks. GDI ist füllt bis zu ein Rechteck jedoch nicht enthalten, die richtige Spalte und der unteren Zeile unabhängig von der aktuellen Zuordnungsmodus. `FillRect` Vergleicht die Werte der `top`, `bottom`, `left`, und `right` Member des angegebenen Rechtecks. Wenn `bottom` ist kleiner als oder gleich `top`, oder wenn `right` ist kleiner als oder gleich `left`, nicht das Rechteck gezeichnet wird.

`FillRect` ist vergleichbar mit [CDC::FillSolidRect](#fillsolidrect)jedoch `FillRect` ein Pinsels verwendet und kann daher verwendet werden, um ein Rechteck mit einer Volltonfarbe, einem Ditheringfarbe, schraffierten Pinsel oder ein Muster zu füllen. `FillSolidRect` verwendet nur Volltonfarben (angezeigt durch ein COLORREF-Parameter). `FillRect` in der Regel ist langsamer als `FillSolidRect`.

##  <a name="fillrgn"></a>  CDC::FillRgn

Füllt den Bereich, der anhand des *PRNG* mit dem Pinsel gemäß *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parameter

*PRNG*<br/>
Ein Zeiger auf die Region gefüllt werden soll. Die Koordinaten für den angegebenen Bereich sind in logischen Einheiten angegeben.

*pBrush*<br/>
Identifiziert den Pinsel verwendet werden soll, geben Sie die Region an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Der Pinsel muss entweder mit erstellt werden die `CBrush` Memberfunktionen `CreateHatchBrush`, `CreatePatternBrush`, `CreateSolidBrush`, oder abgerufen werden, indem `GetStockObject`.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

##  <a name="fillsolidrect"></a>  CDC::FillSolidRect

Rufen Sie diese Memberfunktion, um das angegebene Rechteck mit der angegebenen Volltonfarbe zu füllen.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Gibt das umschließende Rechteck (in logischen Einheiten) an. Sie können entweder einen Zeiger zu übergeben, eine [RECT](../../mfc/reference/rect-structure1.md) Datenstruktur oder ein `CRect` Objekt für diesen Parameter.

*CLR* gibt die Farbe, die zum Ausfüllen des Rechtecks verwendet werden.

*w*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des Rechtecks an.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Zielrechtecks an.

*CX*<br/>
Gibt die Breite des Rechtecks.

*CY*<br/>
Gibt die Höhe des Rechtecks.

### <a name="remarks"></a>Hinweise

`FillSolidRect` ist sehr ähnlich [CDC::FillRect](#fillrect)jedoch `FillSolidRect` verwendet nur Volltonfarben (angegeben durch den COLORREF-Parameter), während `FillRect` nimmt einen Pinsel und aus diesem Grund werden kann, geben Sie ein Rechteck mit einer Volltonfarbe, einem mit Dithering Farbe, schraffierten Pinsel oder ein Muster. `FillSolidRect` in der Regel ist schneller als `FillRect`.

> [!NOTE]
>  Beim Aufruf `FillSolidRect`, die Farbe des Hintergrunds, der zuvor festgelegt wurde, mithilfe von [SetBkColor](#setbkcolor), festgelegt ist, die durch Farbe *Clr*.

##  <a name="flattenpath"></a>  CDC::FlattenPath

Transformiert jede Kurven in den der aktuelle Gerätekontext ausgewählten Pfad, und wandelt jede Kurve in einer Sequenz von Zeilen.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

##  <a name="floodfill"></a>  CDC::FloodFill

Füllt einen Bereich der Anzeigeoberfläche mit dem aktuellen Pinsel.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate des Punkts, an dem Füllen beginnt.

*y*<br/>
Gibt die logische y-Koordinate des Punkts, an dem Füllen beginnt.

*crColor*<br/>
Gibt die Farbe der Grenze.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn die Funktion erfolgreich ist; andernfalls 0 wird zurückgegeben, wenn das Ausfüllen nicht abgeschlossen werden konnte, wurde der angegebene Punkt gemäß Mittelpunktfarbe *CrColor*, oder der Punkt befindet sich außerhalb des Clippingbereichs.

### <a name="remarks"></a>Hinweise

Der Bereich wird davon ausgegangen, die als umschlossen werden anhand des *CrColor*. Die `FloodFill` Funktion beginnt, an dem vom angegebenen *x* und *y* und in alle Richtungen ausgestrahlt, auf die Begrenzung des Farbe wird fortgesetzt.

Nur Arbeitsspeicher-Gerätekontexte und Geräte, die Unterstützung der Raster-Anzeige-Technologie unterstützen die `FloodFill` Member-Funktion. Informationen zu RC_BITBLT-Funktion finden Sie unter den `GetDeviceCaps` Member-Funktion.

Die `ExtFloodFill` Funktion bietet ähnliche Funktionalität jedoch größere Flexibilität.

##  <a name="framerect"></a>  CDC:: FrameRect

Zeichnet einen Rahmen um das Rechteck, das vom angegebenen *LpRect*.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt, das die logischen Koordinaten der oberen linken und rechten unteren Ecke des Rechtecks enthält. Sie können auch übergeben eine `CRect` Objekt für diesen Parameter.

*pBrush*<br/>
Identifiziert den Pinsel für die Darstellung des Rechtecks verwendet werden soll.

### <a name="remarks"></a>Hinweise

Die Funktion verwendet den angegebenen Pinsel zum Zeichnen des Rahmens an. Die Breite und Höhe des Rahmens ist immer 1 logische Einheit.

Wenn des Rechtecks des `bottom` Koordinate ist kleiner als oder gleich `top`, oder wenn `right` ist kleiner als oder gleich `left`, das Rechteck wird nicht gezeichnet.

Der Rahmen gezeichnet werden, indem `FrameRect` befindet sich in der gleichen Position wie ein Rahmen gezeichnet werden, indem die `Rectangle` Member-Funktion, die mit den Koordinaten (Wenn `Rectangle` verwendet einen Stift, der die logische Einheit Breite 1 ist). Das Innere des Rechtecks wird nicht durch gefüllt `FrameRect`.

##  <a name="framergn"></a>  CDC::FrameRgn

Zeichnet einen Rahmen um den Bereich, der anhand des *PRNG* mit dem Pinsel gemäß *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*PRNG*<br/>
Verweist auf die `CRgn` -Objekt, identifiziert die Region, in einem Rahmen eingeschlossen werden. Die Koordinaten für den angegebenen Bereich sind in logischen Einheiten angegeben.

*pBrush*<br/>
Verweist auf die `CBrush` Objekt, das den Pinsel zum Zeichnen des Rahmens zu verwendende identifiziert.

*nWidth*<br/>
Gibt die Breite des Rahmens in vertikalen Striche in Geräteeinheiten an.

*nHeight*<br/>
Gibt die Höhe des Rahmens in horizontale Striche in Geräteeinheiten an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

##  <a name="fromhandle"></a>  CDC::FromHandle

Gibt einen Zeiger auf eine `CDC` Objekt, wenn ein Handle für einen Gerätekontext zu erhalten.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parameter

*hDC*<br/>
Enthält ein Handle für einen Windows-Gerätekontext.

### <a name="return-value"></a>Rückgabewert

Der Zeiger kann temporär sein und sollten nicht über unmittelbare Verwendung gespeichert werden.

### <a name="remarks"></a>Hinweise

Wenn ein `CDC`-Objekt nicht an das Handle angefügt ist, wird ein temporäres `CDC`-Objekt erstellt und angefügt.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="getarcdirection"></a>  CDC::GetArcDirection

Gibt die aktuelle Richtung der Bogen für den Gerätekontext zurück.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Rückgabewert

Gibt die aktuelle Richtung der Bogen, bei erfolgreicher Ausführung an. Es folgen die gültige Rückgabewerte:

- AD_COUNTERCLOCKWISE Bögen und Rechtecke, die gegen den Uhrzeigersinn gezeichnet.

- AD_CLOCKWISE Bögen und Rechtecke zeichnen im Uhrzeigersinn.

Wenn ein Fehler auftritt, ist der Rückgabewert 0 (null).

### <a name="remarks"></a>Hinweise

ARC und Rechteck Funktionen verwenden, die Richtung der Bogen wird.

##  <a name="getaspectratiofilter"></a>  CDC::GetAspectRatioFilter

Ruft die Einstellung für den aktuellen Seitenverhältnis Filter ab.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Rückgabewert

Ein `CSize` Objekt, das darstellt, die von den aktuellen Seitenverhältnis Filter verwendet des Seitenverhältnis wird beibehalten.

### <a name="remarks"></a>Hinweise

Das Seitenverhältnis wird das Verhältnis zwischen gebildet, indem die Höhe und Breite in Pixel des Geräts. Informationen über das Seitenverhältnis des Geräts wird in die Erstellung, Auswahl und Anzeige von Schriftarten verwendet. Windows bietet einen speziellen Filter, den Filter Seitenverhältnis Schriftarten für ein bestimmtes Seitenverhältnis aus allen verfügbaren Schriftarten auswählen. Der Filter verwendet das Seitenverhältnis beibehalten, die gemäß der `SetMapperFlags` Member-Funktion.

##  <a name="getbkcolor"></a>  CDC::GetBkColor

Gibt die aktuelle Hintergrundfarbe zurück.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Rückgabewert

Ein RGB-Farbwert.

### <a name="remarks"></a>Hinweise

Wenn der Hintergrundmodus DECKEND ist, verwendet das System die Hintergrundfarbe zum Füllen der Lücken in formatierte Zeilen, die Lücken zwischen schraffierten Linien in Pinsel und den Hintergrund des Zeichenzellen an. Das System verwendet außerdem die Farbe des Hintergrunds beim Konvertieren von Bitmaps zwischen Farbe und monochromen Gerätekontexte.

##  <a name="getbkmode"></a>  CDC::GetBkMode

Gibt den Hintergrundmodus zurück.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der aktuelle Hintergrundmodus, der UNDURCHSICHTIG oder TRANSPARENT sein kann.

### <a name="remarks"></a>Hinweise

Der Hintergrundmodus definiert, ob das System vorhandene Hintergrundfarben auf die Zeichenoberfläche entfernt vor dem Zeichnen von Text, schraffierten Pinsel oder jede Pen-Formatvorlage, die keine durchgehende Linie ist.

##  <a name="getboundsrect"></a>  CDC::GetBoundsRect

Gibt das aktuelle akkumulierte umschließende Rechteck für den angegebenen Gerätekontext zurück.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parameter

*lpRectBounds*<br/>
Verweist auf einen Puffer, der den aktuellen umschließenden Rechtecks erhält. Das Rechteck in logischen Koordinaten zurückgegeben.

*flags*<br/>
Gibt an, ob das umschließende Rechteck gelöscht werden, nachdem er zurückgegeben wird. Dieser Parameter sollte 0 (null) oder auf die folgenden Werte festgelegt:

- DCB_RESET erzwingt, dass das umschließende Rechteck gelöscht werden sollen, nachdem er zurückgegeben wird.

### <a name="return-value"></a>Rückgabewert

Gibt den aktuellen Status des umschließenden Rechtecks an, wenn die Funktion erfolgreich ist. Sie können eine Kombination der folgenden Werte sein:

- DCB_ACCUMULATE umschließenden Rechteck Ansammlung stattfindet.

- DCB_RESET umschließenden Rechteck ist leer.

- DCB_SET umschließenden Rechteck ist nicht leer.

- DCB_ENABLE umgebenden Accumulation / ist.

- DCB_DISABLE umgebenden Accumulation / ist deaktiviert.

##  <a name="getbrushorg"></a>  CDC::GetBrushOrg

Ruft den Ursprung (in Geräteeinheiten), der derzeit für den Gerätekontext ausgewählten Pinsels ab.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Rückgabewert

Den aktuellen Ursprung des Pinsels (in Geräteeinheiten) als eine [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt.

### <a name="remarks"></a>Hinweise

Der Ursprung des ersten Pinsels wird bei (0,0) des Clientbereichs. Der Rückgabewert gibt dieser Punkt in Geräteeinheiten relativ zum Ursprung des Fensters auf dem desktop an.

##  <a name="getcharacterplacement"></a>  CDC::GetCharacterPlacement

Ruft verschiedene Typen von Informationen zu einer Zeichenfolge ab.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parameter

*lpString*<br/>
Ein Zeiger auf die zu verarbeitende Zeichenfolge.

*nCount*<br/>
Gibt die Länge der Zeichenfolge an. Bei der ANSI-Version ist es eine Byteanzahl und bei der Unicode-Funktion ist es eine Wortanzahl. Weitere Informationen finden Sie unter [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa).

*nMaxExtent*<br/>
Gibt der maximale Wertbereich (in logischen Einheiten) an, zu dem die Zeichenfolge verarbeitet wird. Zeichen, die diesen Wertbereich bei Verarbeitung überschreiten würden, werden ignoriert. Berechnungen für alle erforderlichen Reihenfolge- oder Glyphenarrays gelten nur für die enthaltenen Zeichen. Dieser Parameter wird verwendet, nur, wenn der GCP_MAXEXTENT-Wert, in angegeben ist der *DwFlags* Parameter. Da die Funktion die Eingabezeichenfolge verarbeitet, wird jedes Zeichen und sein Wertebereich nur dann der Ausgabe, dem Wertebereich und anderen Arrays hinzugefügt, wenn der gesamte Wertebereich das Maximum noch nicht überschritten hat. Bei Erreichen des Limits wird die Verarbeitung beendet.

*lpResults*<br/>
Zeiger auf eine [GCP_Results](/windows/desktop/api/wingdi/ns-wingdi-taggcp_resultsa) Struktur, die die Ergebnisse der Funktion empfängt.

*dwFlags*<br/>
Gibt das Verarbeiten der Zeichenfolge in die erforderlichen Arrays an. Dieser Parameter kann eine oder mehrere der Werte in der *DwFlags* Teil der [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa) Thema.

*str*<br/>
Ein Zeiger auf eine [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt zu verarbeiten.

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, handelt es sich bei dem Rückgabewert um die Breite und Höhe der Zeichenfolge in logischen Einheiten.

Wenn die Funktion fehlerhaft ist, ist der Rückgabewert null.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion emuliert die Funktionen der [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa), wie im Windows SDK beschrieben.

##  <a name="getcharabcwidths"></a>  CDC::GetCharABCWidths

Ruft die Breite der aufeinander folgenden Zeichen in einem angegebenen Bereich aus der aktuellen TrueType-Schriftart ab.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parameter

*nFirstChar*<br/>
Gibt das erste Zeichen im Bereich von Zeichen aus der aktuellen Schriftart für die Breite der Zeichen zurückgegeben werden.

*nLastChar*<br/>
Gibt das letzte Zeichen im Bereich von Zeichen aus der aktuellen Schriftart für die Breite der Zeichen zurückgegeben werden.

*lpabc*<br/>
Verweist auf ein Array von [ABC](../../mfc/reference/abc-structure.md) Strukturen, die die Breite Zeichen zu erhalten, wenn die Funktion gibt. Dieses Array muss mindestens so viele `ABC` Strukturen als Zeichen vorhanden, im Bereich gemäß sind der *nFirstChar* und *nLastChar* Parameter.

*lpABCF*<br/>
Verweist auf ein von der Anwendung bereitgestellten Puffer mit einem Array von [ABCFLOAT](../../mfc/reference/abcfloat-structure.md) Strukturen, um die Breite Zeichen zu erhalten, wenn die Funktion gibt. Die Breite von dieser Funktion zurückgegebenen befinden sich in der IEEE-Gleitkomma-Format.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die Breite werden in logischen Einheiten zurückgegeben. Diese Funktion erfolgreich ausgeführt wurde, nur mit TrueType-Schriftarten.

Die TrueType des rasterizers bietet Zeichenabstand "ABC" nach eine bestimmten Größe ausgewählt wurde. "A" Abstand, entspricht dem Abstand, der an der aktuellen Position hinzugefügt wird, vor dem Speichern des Symbols. Abstand für "B" ist die Breite des schwarzen Teils des Symbols. "C" Abstand, wird die aktuelle Position, die für den Leerraum auf der rechten Seite des Symbols für das Konto hinzugefügt. Die Gesamtsumme, die erweiterte Breite erhält von A + B + C.

Wenn die `GetCharABCWidths` Memberfunktion ruft negativ "A" oder "C" Breite für ein Zeichen, die dieses Zeichen enthält, Underhangs oder Überhängen.

Um die Breite ABC in Schriftentwurfseinheiten zu konvertieren, Erstellen einer Anwendung sollte eine Schriftart, deren Höhe (gemäß den Angaben in der `lfHeight` Mitglied der ["LogFont"](/windows/desktop/api/wingdi/ns-wingdi-taglogfonta) Struktur) ist gleich dem Wert, der in gespeicherten der `ntmSizeEM` Mitglied der [ NEWTEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagnewtextmetrica) Struktur. (Der Wert des der `ntmSizeEM` Member abgerufen werden kann, durch den Aufruf der [EnumFontFamilies](/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesa) Windows-Funktion.)

Die Breite ABC das Standardzeichen dienen für Zeichen, die außerhalb des Bereichs des derzeit ausgewählten Schriftart.

Die Breite der Zeichen in nicht-TrueType-Schriftarten Anwendungen sollten verwenden Sie zum Abrufen der [GetCharWidth](/windows/desktop/api/wingdi/nf-wingdi-getcharwidtha) Windows-Funktion.

##  <a name="getcharabcwidthsi"></a>  CDC::GetCharABCWidthsI

Ruft ab, das die Breiten in logischen Einheiten, der aufeinander folgenden Symbolindizes in einem angegebenen Bereich aus der aktuellen TrueType-Schriftart.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parameter

*giFirst*<br/>
Gibt den ersten Glyphen Index in der Gruppe der aufeinander folgenden Symbolindizes aus der aktuellen Schriftart an. Dieser Parameter wird nur verwendet, wenn die *Pgi* Parameter NULL ist.

*CGI*<br/>
Gibt die Anzahl von glyphenindizes.

*PGI*<br/>
Ein Zeiger auf ein Array, die Symbolindizes enthält. Wenn der Wert NULL aufweist, ist die *GiFirst* Parameter wird stattdessen verwendet. Die *Cgi* Parameter gibt die Anzahl von glyphenindizes, die in diesem Array.

*lpabc*<br/>
Zeiger auf ein Array von [ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc) Strukturen, die die Breite der Zeichen empfangen. Dieses Array muss mindestens so viele `ABC` Strukturen wie stehen die Symbolindizes gemäß der *Cgi* Parameter.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Diese Memberfunktion emuliert die Funktionen der [GetCharABCWidthsI](/windows/desktop/api/wingdi/nf-wingdi-getcharabcwidthsi), wie im Windows SDK beschrieben.

##  <a name="getcharwidth"></a>  CDC::GetCharWidth

Ruft die Breite der einzelnen Zeichen in eine aufeinander folgende Gruppe von Zeichen aus der aktuellen Schriftart mit `m_hAttribDC`, den Kontext Eingabegerät.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parameter

*nFirstChar*<br/>
Gibt das erste Zeichen in eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart an.

*nLastChar*<br/>
Gibt das letzte Zeichen in eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart an.

*lpBuffer*<br/>
Verweist auf einen Puffer, der die Werte für die Breite für eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart erhält.

*lpFloatBuffer*<br/>
Verweist auf einen Puffer zur Aufnahme der breiten Zeichen. Die zurückgegebene breiten befinden sich in der 32-Bit-IEEE-Gleitkomma-Format. (Die Breite werden auf der Basis-Linie Zeichen gemessen.)

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Z. B. wenn *nFirstChar* identifiziert den Buchstaben "a" und *nLastChar* identifiziert dem Buchstaben "Z", die die Funktion ruft die Breite der alle Kleinbuchstaben.

Die Funktion speichert die Werte in den Puffer, der auf *LpBuffer*. Dieser Puffer muss groß genug für alle der breiten sein. D. h. muss vorhanden sein mindestens 26 Einträge im Beispiel angegeben.

Wenn ein Zeichen in dem aufeinander folgende Gruppe von Zeichen in einer bestimmten Schriftart nicht vorhanden ist, wird es den Width-Wert, der das Standardzeichen zugewiesen.

##  <a name="getcharwidthi"></a>  CDC::GetCharWidthI

Ruft die Breite, in logischen Koordinaten von aufeinander folgenden Symbolindizes in einem angegebenen Bereich aus der aktuellen Schriftart ab.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parameter

*giFirst*<br/>
Gibt den ersten Glyphen Index in der Gruppe der aufeinander folgenden Symbolindizes aus der aktuellen Schriftart an. Dieser Parameter wird nur verwendet, wenn die *Pgi* Parameter NULL ist.

*CGI*<br/>
Gibt die Anzahl von glyphenindizes.

*PGI*<br/>
Ein Zeiger auf ein Array, die Symbolindizes enthält. Wenn der Wert NULL aufweist, ist die *GiFirst* Parameter wird stattdessen verwendet. Die *Cgi* Parameter gibt die Anzahl von glyphenindizes, die in diesem Array.

*lpBuffer*<br/>
Ein Zeiger auf einen Puffer, der die Breiten empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Diese Memberfunktion emuliert die Funktionen der [GetCharWidthI](/windows/desktop/api/wingdi/nf-wingdi-getcharwidthi), wie im Windows SDK beschrieben.

##  <a name="getclipbox"></a>  CDC::GetClipBox

Ruft die Abmessungen des tightest umschließenden Rechtecks um die aktuelle Grenze von Clipping ab.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Verweist auf die [RECT](../../mfc/reference/rect-structure1.md) Struktur oder [CRect](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das die Abmessungen des Rechtecks zu empfangen.

### <a name="return-value"></a>Rückgabewert

Der Ausschneidebereich-Typ. Eines der folgenden Werte sind möglich:

- Region COMPLEXREGION Clipping hat überlappende Grenzen.

- Fehler-Gerätekontext ist ungültig.

- Clipping NULLREGION Region ist leer.

- Clipping SIMPLEREGION Region verfügt über keine überlappenden Rahmen.

### <a name="remarks"></a>Hinweise

Die Dimensionen werden in den Puffer, der auf kopiert *LpRect*.

##  <a name="getcoloradjustment"></a>  CDC::GetColorAdjustment

Ruft die Farbwerte für die Anpassung für den Gerätekontext ab.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parameter

*lpColorAdjust*<br/>
Verweist auf eine [COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md) Datenstruktur die Farbwerte für die Anpassung zu erhalten.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

##  <a name="getcurrentbitmap"></a>  CDC::GetCurrentBitmap

Gibt einen Zeiger auf das derzeit ausgewählte `CBitmap` Objekt.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf eine `CBitmap` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion kann temporäre Objekte zurück.

##  <a name="getcurrentbrush"></a>  CDC::GetCurrentBrush

Gibt einen Zeiger auf das derzeit ausgewählte `CBrush` Objekt.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf eine `CBrush` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion kann temporäre Objekte zurück.

##  <a name="getcurrentfont"></a>  CDC::GetCurrentFont

Gibt einen Zeiger auf das derzeit ausgewählte `CFont` Objekt.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf eine `CFont` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion kann temporäre Objekte zurück.

##  <a name="getcurrentpalette"></a>  CDC::GetCurrentPalette

Gibt einen Zeiger auf das derzeit ausgewählte `CPalette` Objekt.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf eine `CPalette` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion kann temporäre Objekte zurück.

##  <a name="getcurrentpen"></a>  CDC::GetCurrentPen

Gibt einen Zeiger auf das derzeit ausgewählte `CPen` Objekt.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf eine `CPen` Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion kann temporäre Objekte zurück.

##  <a name="getcurrentposition"></a>  CDC::GetCurrentPosition

Ruft die aktuelle Position (in logischen Koordinaten) ab.

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Rückgabewert

Der aktuellen Position als einen `CPoint` Objekt.

### <a name="remarks"></a>Hinweise

Die aktuelle Position festgelegt werden kann, mit der `MoveTo` Member-Funktion.

##  <a name="getdcbrushcolor"></a>  CDC::GetDCBrushColor

Ruft die aktuelle Pinselfarbe ab.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, wird der Rückgabewert ist der [COLORREF](/windows/desktop/gdi/colorref) Wert für die aktuelle Pinselfarbe.

Wenn die Funktion fehlschlägt, ist der Rückgabewert CLR_INVALID an.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion emuliert die Funktionen der [GetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-getdcbrushcolor), wie im Windows SDK beschrieben.

##  <a name="getdcpencolor"></a>  CDC::GetDCPenColor

Ruft die aktuelle Stiftfarbe ab.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, wird der Rückgabewert ist der [COLORREF](/windows/desktop/gdi/colorref) Wert für die aktuelle Stiftfarbe.

Wenn die Funktion fehlschlägt, ist der Rückgabewert CLR_INVALID an.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion verwendet die Win32-Funktion [GetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-getdcpencolor), wie im Windows SDK beschrieben.

##  <a name="getdevicecaps"></a>  GetDeviceCaps

Ruft eine Vielzahl von gerätespezifischen Informationen über das Anzeigegerät ab.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parameter

*nIndex*<br/>
Gibt den Typ der zurückzugebenden Informationen. Finden Sie unter [GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) im Windows SDK für eine Liste von Werten.

### <a name="return-value"></a>Rückgabewert

Der Wert, der die erforderlichen Funktionen, wenn die Funktion erfolgreich ist.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

##  <a name="getfontdata"></a>  CDC::GetFontData

Ruft die Schriftarteigenschaft Informationen aus einer Datei skalierbare Schriftart ab.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parameter

*dwTable*<br/>
Gibt den Namen der Metrik Tabelle zurückgegeben werden. Dieser Parameter kann eine der Metrik Tabellen finden Sie unter der TrueType-Schriftartdateien-Spezifikation, die von der Microsoft Corporation veröffentlicht sein. Wenn dieser Parameter 0 ist, wird die Informationen abgerufen am Anfang der Schriftartdatei ab.

*dwOffset*<br/>
Gibt den Offset vom Anfang der Tabelle auf dem Informationen abgerufen werden soll. Wenn dieser Parameter 0 ist, die Informationen abgerufen wobei am Anfang der Tabelle, angegeben durch die *DwTable* Parameter. Wenn dieser Wert größer als oder gleich der Größe der Tabelle `GetFontData` gibt 0 zurück.

*lpData*<br/>
Verweist auf einen Puffer, der die Schriftartinformationen erhält. Wenn dieser Wert NULL ist, gibt die Funktion zurück, die Größe des Puffers für die Schriftartdaten im angegebenen erforderlich die *DwTable* Parameter.

*cbData*<br/>
Gibt die Länge in Bytes, die Informationen abgerufen werden sollen. Wenn dieser Parameter 0 (null) ist `GetFontData` gibt die Größe der die Daten in die *DwTable* Parameter.

### <a name="return-value"></a>Rückgabewert

Gibt die Anzahl der Bytes in den Puffer, der auf zurückgegeben *LpData* ist die Funktion erfolgreich ist; andernfalls -1.

### <a name="remarks"></a>Hinweise

Die Informationen abgerufen werden durch Angeben eines Offsets in die Schriftartdatei und die Länge der zurückzugebenden Informationen identifiziert.

Eine Anwendung kann in einigen Fällen verwenden die `GetFontData` Memberfunktion, um eine TrueType-Schriftart mit einem Dokument zu speichern. Zu diesem Zweck wird die Anwendung bestimmt, ob die Schriftart eingebettet werden kann, und dann die gesamte Schriftartdatei Ruft, durch den Wert 0 für die *DwTable*, *DwOffset*, und *CbData* Parameter.

Anwendungen können bestimmen, ob eine Schriftart kann, indem Sie überprüfen eingebettet werden die `otmfsType` Mitglied der [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) Struktur. Wenn bit 1 des `otmfsType` festgelegt ist, Einbetten von ist für die Schriftart nicht zulässig. Wenn ein Bit 1 ist, kann die Schriftart eingebettet werden. Wenn das Bit 2 festgelegt ist, ist das Einbetten schreibgeschützt.

Wenn eine Anwendung versucht, diese Funktion zu verwenden, zum Abrufen von Informationen für eine nicht-TrueType-Schriftart der `GetFontData` Member-Funktion gibt-1 zurück.

##  <a name="getfontlanguageinfo"></a>  CDC::GetFontLanguageInfo

Gibt Informationen über die aktuell ausgewählten Schriftart für den angegebenen Anzeigekontext zurück.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Rückgabewert

Der Rückgabewert gibt die Merkmale der derzeit ausgewählten Schriftart. Eine vollständige Liste der möglichen Werte, finden Sie unter [GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Hinweise

Diese Memberfunktion emuliert die Funktionen der [GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo), wie im Windows SDK beschrieben.

##  <a name="getglyphoutline"></a>  CDC::GetGlyphOutline

Ruft die Gliederung Kurve oder eine Bitmap für eine Gliederung Zeichen in der aktuellen Schriftart ab.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parameter

*NChar*<br/>
Gibt das Zeichen, die für das Informationen zurückgegeben werden.

*nFormat*<br/>
Gibt das Format, in dem die Funktion, die zum Zurückgeben von Informationen ist. Die folgenden Werte, oder 0 sind möglich:

|Wert|Bedeutung|
|-----------|-------------|
|GGO_BITMAP|Gibt die Symbolbitmap zurück. Wenn die Funktion zurückgibt, werden die Puffer, der auf *LpBuffer* enthält eine 1-Bit-pro-Pixel-Bitmap, deren Zeilen auf zeigt Doppelwort Grenzen zu starten.|
|GGO_NATIVE|Gibt die Kurve Datenpunkte in der rasterizers des systemeigenen Format mit Geräteeinheiten zurück. Wenn dieser Wert angegeben wird, wird eine Transformation in angegebenen *lpmat2* wird ignoriert.|

Wenn der Wert des *nFormat* gleich 0 ist, füllt die Funktion eine [GLYPHMETRICS](/windows/desktop/api/wingdi/ns-wingdi-_glyphmetrics) Struktur, jedoch keine Glyphe-Gliedern von Daten zurückgibt.

*lpgm*<br/>
Verweist auf eine GLYPHMETRICS-Struktur, die Platzierung des Symbols im Zeichenzelle beschreibt.

*CbBuffer die*<br/>
Gibt die Größe des Puffers in die die Funktion Informationen über die Gliederung Zeichen kopiert. Wenn dieser Wert 0 ist und die *nFormat* -Parameter ist entweder der GGO_BITMAP oder GGO_NATIVE-Werte, die Funktion gibt die erforderliche Größe des Puffers zurück.

*lpBuffer*<br/>
Verweist auf einen Puffer, in dem die Funktion Informationen über die Gliederung Zeichen kopiert, werden soll. Wenn *nFormat* gibt den Wert GGO_NATIVE kopiert die Informationen in Form von TTPOLYGONHEADER und TTPOLYCURVE Strukturen. Wenn dieser Wert NULL ist und *nFormat* der GGO_BITMAP oder GGO_NATIVE Wert ist, die Funktion gibt die erforderliche Größe des Puffers zurück.

*lpmat2*<br/>
Verweist auf eine [MAT2](/windows/desktop/api/wingdi/ns-wingdi-_mat2) Struktur, die eine Transformationsmatrix für das Zeichen enthält. Dieser Parameter darf nicht NULL sein, selbst wenn der GGO_NATIVE für angegebene Wert ist *nFormat*.

### <a name="return-value"></a>Rückgabewert

Die Größe in Byte des Puffers für die abgerufenen Informationen erforderlich, wenn *CbBuffer* ist 0 oder *LpBuffer* ist NULL. Andernfalls wird ein positiver Wert ist die Funktion erfolgreich ist, oder -1, wenn ein Fehler auftritt.

### <a name="remarks"></a>Hinweise

Eine Anwendung kann im Bitmapformat durch Angabe einer Transformationsmatrix 2 x 2-in der Struktur verweist abgerufene Zeichen drehen *lpmat2*.

Ein über das Symbol wird als eine Reihe von Konturen zurückgegeben. Jede Kontur wird definiert, indem eine [TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader) Struktur so viele gefolgt `TTPOLYCURVE` Strukturen wie erforderlich sind, um es zu beschreiben. Alle Punkte werden zurückgegeben, als [POINTFX](/windows/desktop/api/wingdi/ns-wingdi-tagpointfx) -Strukturen und absolute Positionen, keinen relativen verschiebt darstellen. Der Ausgangspunkt angegeben durch die `pfxStart` Mitglied der [TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader) Struktur ist der Punkt, an dem die Gliederung für eine Kontur beginnt. Die [TTPOLYCURVE](/windows/desktop/api/wingdi/ns-wingdi-tagttpolycurve) Strukturen, die folgen können Polylinie Datensätze oder Spline-Datensätze sein. Polyline-Datensätze sind eine Reihe von Punkten. zwischen den Punkten gezeichnete Linien beschreiben die Gliederung des Zeichens. Spline-Datensätze dar, die quadratischen Kurven von TrueType (d. h. quadratischen b-Splines) verwendet wird.

##  <a name="getgraphicsmode"></a>  CDC::GetGraphicsMode

Ruft den aktuellen Grafikmodus für den angegebenen Gerätekontext ab.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Rückgabewert

Gibt den aktuellen Grafikmodus bei Erfolg zurück. Eine Liste der Werte, die diese Methode zurückgeben können, finden Sie unter [GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode).

Gibt 0 bei einem Fehler zurück.

Um erweiterte Fehlerinformationen abzurufen, rufen Sie [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Hinweise

Diese Methode dient als Wrapper für die Windows-GDI-Funktion [GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode).

##  <a name="gethalftonebrush"></a>  CDC::GetHalftoneBrush

Rufen Sie diese Memberfunktion zum Abrufen eines Pinsels Halbton.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf eine `CBrush` -Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Hinweise

Ein Rasterbild Pinsel zeigt Pixel, die Vordergrund- und Hintergrundfarben, erstellen Sie ein Muster mit Dithering Alternativ sind. Folgendes ist ein Beispiel für eine Dithering Muster, das von einem Pinsel Halbton.

![Detail eines geditherten Stiftstrichs](../../mfc/reference/media/vc318s1.gif "Detail eines geditherten Stiftstrichs")

##  <a name="getkerningpairs"></a>  CDC::GetKerningPairs

Ruft das Zeichen, kerning-Paare für die Schriftart, die in den angegebenen Gerätekontext markiert ist.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parameter

*nPairs*<br/>
Gibt die Anzahl der [KERNINGPAIR](/windows/desktop/api/wingdi/ns-wingdi-tagkerningpair) Strukturen verweist *Lpkrnpair*. Die Funktion kopiert nicht mehr kerning Paare als *nPairs*.

*lpkrnpair*<br/>
Verweist auf ein Array von `KERNINGPAIR` Strukturen, die das kerning empfangen-Paaren bei Rückgabe der Funktion. Dieses Array muss mindestens so viele Strukturen laut enthalten *nPairs*. Wenn dieser Parameter NULL ist, gibt die Funktion die Gesamtzahl der kerning-Paare für die Schriftart an.

### <a name="return-value"></a>Rückgabewert

Gibt die Anzahl der abgerufenen Paare kerning oder die Gesamtanzahl der kerning-Paare in die Schriftart an, wenn die Funktion erfolgreich ist. 0 (null) wird zurückgegeben, wenn die Funktion fehlerhaft ist oder es keine Tabellenpaare kerning, für die Schriftart sind.

##  <a name="getlayout"></a>  CDC::GetLayout

Rufen Sie diese Memberfunktion, um das Layout von Text und Grafiken für einen Gerätekontext, z. B. ein Drucker oder einer Metadatei zu bestimmen.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn erfolgreich, kennzeichnet das Layout, für den aktuellen Gerätekontext. Andernfalls GDI_ERROR. Rufen Sie für erweiterte Fehlerinformationen [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360). Eine Liste der Flags, Layout, finden Sie unter [CDC::SetLayout](#setlayout).

### <a name="remarks"></a>Hinweise

Das Standardlayout ist von links nach rechts.

##  <a name="getmapmode"></a>  CDC::GetMapMode

Ruft den aktuellen Zuordnungsmodus ab.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der Mappingmodus.

### <a name="remarks"></a>Hinweise

Eine Beschreibung der die Zuordnungsmodi, finden Sie unter den `SetMapMode` Member-Funktion.

> [!NOTE]
>  Wenn Sie aufrufen [SetLayout](#setlayout) so ändern Sie den DC in rechts-nach-links-Layout, `SetLayout` automatisch den Zuordnungsmodus in MM_ISOTROPIC geändert. Folglich jeder nachfolgende Aufruf von `GetMapMode` MM_ISOTROPIC zurück.

##  <a name="getmiterlimit"></a>  CDC::GetMiterLimit

Gibt die Gehrungsgrenze für den Gerätekontext zurück.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Zeichnen von geometrische Linien, die Joins Linienverbindungsstile wird die Gehrungsgrenze verwendet.

##  <a name="getnearestcolor"></a>  CDC::GetNearestColor

Gibt zurück, die der Volltonfarbe entspricht, die eine angegebene logische Farbe am ehesten entspricht.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parameter

*crColor*<br/>
Gibt die Farbe, die abgeglichen werden.

### <a name="return-value"></a>Rückgabewert

Farbe, die ein Farbwert für RGB (Rot, Grün, Blau), die dem stabilen definiert, die am nächsten der *CrColor* -Wert, der das Gerät darstellen kann.

### <a name="remarks"></a>Hinweise

Das angegebene Gerät muss diese Farbe darstellen können.

##  <a name="getoutlinetextmetrics"></a>  CDC::GetOutlineTextMetrics

Ruft ab die metrikinformationen für TrueType-Schriftarten.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parameter

*lpotm*<br/>
Verweist auf ein Array von [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) Strukturen. Wenn dieser Parameter NULL ist, gibt die Funktion der Größe des Puffers für die abgerufenen metrischen Daten erforderlich sind.

*cbData*<br/>
Gibt die Größe in Byte des Puffers, der Informationen zurückgegeben werden.

*lpotm*<br/>
Verweist auf eine `OUTLINETEXTMETRIC` Struktur. Wenn dieser Parameter NULL ist, gibt die Funktion der Größe des Puffers für die abgerufenen Metriken Informationen erforderlich sind.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) Struktur enthält die meisten bereitgestellt, mit dem Format TrueType-Schriftart Metrik Informationen einschließlich einer [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) Struktur. Die letzten vier Member, der die `OUTLINETEXTMETRIC` Struktur sind Zeiger auf Zeichenfolgen. Anwendungen sollten diese Zeichenfolgen zusätzlich zu den erforderlichen Speicherplatz für die anderen Mitglieder Speicherplatz zuweisen. Da unbegrenzt System auferlegt, auf die Größe der Zeichenfolgen ist, ist die einfachste Methode zum Zuweisen von Arbeitsspeicher auf die erforderliche Größe zu abzurufen, indem Sie NULL für *Lpotm* in der erste Aufruf der `GetOutlineTextMetrics` Funktion.

##  <a name="getoutputcharwidth"></a>  CDC::GetOutputCharWidth

Der Gerätekontext, die Ausgabe verwendet `m_hDC`, und ruft die Breite der einzelnen Zeichen in eine aufeinander folgende Gruppe von Zeichen aus der aktuellen Schriftart ab.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parameter

*nFirstChar*<br/>
Gibt das erste Zeichen in eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart an.

*nLastChar*<br/>
Gibt das letzte Zeichen in eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart an.

*lpBuffer*<br/>
Verweist auf einen Puffer, der die Werte für die Breite für eine aufeinander folgende Gruppe von Zeichen in der aktuellen Schriftart erhält.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Z. B. wenn *nFirstChar* identifiziert den Buchstaben "a" und *nLastChar* identifiziert dem Buchstaben "Z", die die Funktion ruft die Breite der alle Kleinbuchstaben.

Die Funktion speichert die Werte in den Puffer, der auf *LpBuffer*. Dieser Puffer muss groß genug für alle der breiten werden; d. h. muss vorhanden sein mindestens 26 Einträge im Beispiel angegeben.

Wenn ein Zeichen in dem aufeinander folgende Gruppe von Zeichen in einer bestimmten Schriftart nicht vorhanden ist, wird es den Width-Wert, der das Standardzeichen zugewiesen.

##  <a name="getoutputtabbedtextextent"></a>  CDC::GetOutputTabbedTextExtent

Rufen Sie diese Memberfunktion zum Berechnen die Breite und Höhe einer Zeichenfolge mit Zeichen [M_hDC](#m_hdc), den Ausgabe-Gerätekontext.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Verweist auf eine Zeichenfolge, die gemessen werden. Sie können auch übergeben eine [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an. Wenn *nCount* -1 ist, wird die Länge berechnet.

*nTabPositions*<br/>
Gibt die Anzahl der Tabstopp Positionen im Array verweist *LpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Zeigt auf ein Array von Ganzzahlen, die Tabstopp Positionen in logischen Einheiten. Die Tabstopps müssen in aufsteigender Reihenfolge sortiert werden; der kleinste X-Wert sollte das erste Element im Array. Back-Registerkarten sind nicht zulässig.

*str*<br/>
Ein `CString` Objekt mit der angegebenen Zeichen gemessen wird.

### <a name="return-value"></a>Rückgabewert

Die Abmessungen der Zeichenfolge (in logischen Einheiten) in einem [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.

### <a name="remarks"></a>Hinweise

Wenn die Zeichenfolge eine oder mehrere Tabulatorzeichen enthält, die Breite der Zeichenfolge basiert die Tabstopps gemäß *LpnTabStopPositions*. Die Funktion verwendet die ausgewählte Schriftart, um die Abmessungen der Zeichenfolge zu berechnen.

Die Breite und Höhe, die vom des aktuellen Ausschneidebereichs kein versetzen der `GetOutputTabbedTextExtent` Funktion.

Da einige Geräte kein Zeichen in der regulären Zelle Arrays setzen (d.h., sie Unterschneiden von Zeichen), die Summe der Blöcke der Zeichen in einer Zeichenfolge in den Umfang der Zeichenfolge entspricht möglicherweise nicht.

Wenn *nTabPositions* ist 0 und *LpnTabStopPositions* NULL ist, Registerkarten auf acht Zeichen der durchschnittlichen breiten erweitert werden. Wenn *nTabPositions* 1 ist, werden die Tabstopps getrennt werden, mit dem durch den ersten Wert im Array, an dem angegebenen Abstand *LpnTabStopPositions* Punkte. Wenn *LpnTabStopPositions* auf mehr als einen einzelnen Wert verweist, ein Tabstopp festgelegt ist für jeden Wert im Array bis zu der Zahl von *nTabPositions*.

##  <a name="getoutputtextextent"></a>  CDC::GetOutputTextExtent

Rufen Sie diese Memberfunktion zum Verwenden der Ausgabe-Gerätekontext, [M_hDC](#m_hdc), und berechnen Sie die Breite und Höhe einer Zeile des Texts an, mit der aktuellen Schriftart.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Zeigt auf eine Zeichenfolge von Zeichen. Sie können auch übergeben eine [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an. Wenn *nCount* -1 ist, wird die Länge berechnet.

*str*<br/>
Ein `CString` Objekt mit der angegebenen Zeichen gemessen wird.

### <a name="return-value"></a>Rückgabewert

Die Abmessungen der Zeichenfolge (in logischen Einheiten) zurückgegeben, die einem [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.

### <a name="remarks"></a>Hinweise

Der aktuelle Ausschneidebereich hat keine Auswirkungen auf die Breite und Höhe, die vom `GetOutputTextExtent`.

Da einige Geräte kein Zeichen in der regulären Zelle Arrays setzen (d.h., sie durchzuführen, kerning), die Summe der Blöcke der Zeichen in einer Zeichenfolge in den Umfang der Zeichenfolge entspricht möglicherweise nicht.

##  <a name="getoutputtextmetrics"></a>  CDC::GetOutputTextMetrics

Ruft ab, der die Metriken für die aktuelle Schriftart mit `m_hDC`, den Ausgabe-Gerätekontext.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parameter

*lpMetrics*<br/>
Verweist auf die [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) -Struktur, die Metriken empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

##  <a name="getpath"></a>  CDC::getPath

Ruft die Koordinaten, die definieren, die Endpunkte der Zeilen und die Steuerpunkte der Kurven finden Sie in den Pfad, der in den Gerätekontext ausgewählt ist.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) Datenstrukturen oder `CPoint` Objekte, die die Endpunkte und die Kurve Kontrollpunkte, platziert werden.

*lpTypes*<br/>
Zeigt auf ein Array von Bytes, die dem Vertex-Typen platziert werden. Werte sind eine der folgenden:

- PT_MOVETO gibt an, die an den entsprechenden *LpPoints* startet eine separaten Abbildung.

- PT_LINETO gibt an, die im vorherigen Punkt und dem entsprechenden zeigen *LpPoints* sind die Endpunkte einer Zeile.

- PT_BEZIERTO gibt an, die an den entsprechenden *LpPoints* ist ein Steuerungspunkts für das oder der Endpunkt für eine Bzier-Kurve.

PT_BEZIERTO Typen an, die immer in Sätze von drei auftreten. Die Punkte im Pfad unmittelbar vor deren definiert des Anfangspunkt der Kurve Bzier. Die ersten beiden PT_BEZIERTO Punkte sind die Steuerpunkte, und der dritte PT_BEZIERTO Punkt ist der Endpunkt (wenn hartcodiert).

   Ein PT_LINETO oder PT_BEZIERTO Typ kann mit dem folgenden-Flag kombiniert werden (mit dem bitweisen Operator **OR**), um anzugeben, dass der entsprechende Punkt der letzte Punkt in einer Abbildung und die Abbildung geschlossen werden soll:

- PT_CLOSEFIGURE gibt an, die in der Abbildung wird automatisch geschlossen, nachdem die entsprechende Zeile oder die Kurve gezeichnet wird. In der Abbildung wird durch eine Linie vom Endpunkt Linien- oder Kurvensegmente zu dem Punkt entspricht dem letzten PT_MOVETO geschlossen.

*nCount*<br/>
Gibt die Gesamtanzahl der [Punkt](../../mfc/reference/point-structure1.md) -Datenstrukturen, die in platziert werden, können die *LpPoints* Array. Dieser Wert muss identisch mit die Anzahl der Bytes, die in platziert werden, kann die *LpTypes* Array.

### <a name="return-value"></a>Rückgabewert

Wenn die *nCount* Parameter ungleich NULL ist, die Anzahl der Punkte aufgelistet. Wenn *nCount* ist 0, der die Gesamtzahl der Punkte im Pfad (und `GetPath` "nothing" in den Puffer geschrieben). Wenn *nCount* ungleich NULL ist und kleiner als die Anzahl der Punkte im Pfad verwenden, ist der Rückgabewert-1.

### <a name="remarks"></a>Hinweise

Der Gerätekontext muss es sich um einen geschlossenen Pfad enthalten. Der Pfad der Punkte werden in logischen Koordinaten zurückgegeben. Punkte werden in den Pfad in Gerätekoordinaten, gespeichert, daher `GetPath` ändert sich der Punkt von Gerätekoordinaten in logische Koordinaten mithilfe der Umkehrung der aktuellen Transformation. Die `FlattenPath` Member-Funktion kann aufgerufen werden, bevor `GetPath`, um alle Kurven in den Pfad in Liniensegmente konvertieren.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CDC:: beginpath](#beginpath).

##  <a name="getpixel"></a>  CDC::getPixel

Ruft den RGB-Farbwert des Pixels an dem vom angegebenen *x* und *y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate des Punkts, der untersucht werden.

*y*<br/>
Gibt die logische y-Koordinate des Punkts, der untersucht werden.

*Zeigen Sie*<br/>
Gibt die logische X - und y-Koordinaten des Punkts, der untersucht werden.

### <a name="return-value"></a>Rückgabewert

Bei jeder Version der Funktion, einen RGB-Farbwert für die Farbe des dem angegebenen Punkt. Es ist-1, wenn die Koordinaten in den Ausschneidebereich keinen Punkt angeben.

### <a name="remarks"></a>Hinweise

Der Punkt muss in den Ausschneidebereich sein. Ist der Punkt nicht in den Ausschneidebereich, wird die Funktion hat keine Auswirkungen, und gibt-1 zurück.

Nicht alle Geräte unterstützen die `GetPixel`-Funktion. Weitere Informationen finden Sie unter der RC_BITBLT Raster-Funktion unter den [GetDeviceCaps](#getdevicecaps) Member-Funktion.

Die `GetPixel` Member-Funktion weist zwei Formen. Der erste erfordert zwei Koordinatenwerte; die zweite akzeptiert eine [Punkt](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt.

##  <a name="getpolyfillmode"></a>  CDC::GetPolyFillMode

Ruft den aktuellen Modus des Polygons füllenden ab.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der aktuelle Polygon gefüllten Modus, alternative oder WICKELN, wenn die Funktion erfolgreich ist.

### <a name="remarks"></a>Hinweise

Finden Sie unter den `SetPolyFillMode` Member-Funktion, eine Beschreibung der Polygon-füllen-Modi.

##  <a name="getrop2"></a>  CDC::GetROP2

Ruft den Zeichnungsmodus des aktuellen ab.

```
int GetROP2() const;
```

### <a name="return-value"></a>Rückgabewert

Den Zeichnungsmodus des. Eine Liste der Werte für den zeichnen, finden Sie unter den `SetROP2` Member-Funktion.

### <a name="remarks"></a>Hinweise

Zeichnungsmodus des gibt an, wie die Farben des Stifts und das Innere des ausgefüllten Objekte mit der Farbe bereits auf der Anzeigeoberfläche kombiniert werden.

##  <a name="getsafehdc"></a>  CDC::GetSafeHdc

Rufen Sie diese Memberfunktion abzurufenden [M_hDC](#m_hdc), den Ausgabe-Gerätekontext.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Rückgabewert

Handle für einen Gerätekontext.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion funktioniert auch mit null-Zeiger.

##  <a name="getstretchbltmode"></a>  CDC::GetStretchBltMode

Ruft den aktuellen Strecken einer Bitmap-Modus ab.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Rückgabewert

Der Rückgabewert gibt den aktuellen Strecken einer Bitmap-Modus – STRETCH_ANDSCANS STRETCH_DELETESCANS oder STRETCH_ORSCANS – Wenn die Funktion erfolgreich ist.

### <a name="remarks"></a>Hinweise

Der Modus zum Strecken einer Bitmap definiert, wie Informationen aus Bitmaps entfernt werden, die gestreckt oder komprimiert die `StretchBlt` Member-Funktion.

Die Modi STRETCH_ANDSCANS und STRETCH_ORSCANS werden normalerweise verwendet, Vordergrund Pixel monochrome Bitmaps beibehalten. Der Modus STRETCH_DELETESCANS wird normalerweise verwendet, um Farbe in Farbe Bitmaps zu erhalten.

##  <a name="gettabbedtextextent"></a>  CDC::GetTabbedTextExtent

Rufen Sie diese Memberfunktion zum Berechnen die Breite und Höhe einer Zeichenfolge mit Zeichen [M_hAttribDC](#m_hattribdc), den Gerätekontext Attribut.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Verweist auf eine Zeichenfolge. Sie können auch übergeben eine [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an. Wenn *nCount* -1 ist, wird die Länge berechnet.

*nTabPositions*<br/>
Gibt die Anzahl der Tabstopp Positionen im Array verweist *LpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Zeigt auf ein Array von Ganzzahlen, die Tabstopp Positionen in logischen Einheiten. Die Tabstopps müssen in aufsteigender Reihenfolge sortiert werden; der kleinste X-Wert sollte das erste Element im Array. Back-Registerkarten sind nicht zulässig.

*str*<br/>
Ein `CString` Objekt mit der angegebenen Zeichen, gezeichnet werden soll.

### <a name="return-value"></a>Rückgabewert

Die Abmessungen der Zeichenfolge (in logischen Einheiten) in einem [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.

### <a name="remarks"></a>Hinweise

Wenn die Zeichenfolge eine oder mehrere Tabulatorzeichen enthält, die Breite der Zeichenfolge basiert die Tabstopps gemäß *LpnTabStopPositions*. Die Funktion verwendet die ausgewählte Schriftart, um die Abmessungen der Zeichenfolge zu berechnen.

Die Breite und Höhe, die vom des aktuellen Ausschneidebereichs kein versetzen der `GetTabbedTextExtent` Funktion.

Da einige Geräte kein Zeichen in der regulären Zelle Arrays setzen (d.h., sie Unterschneiden von Zeichen), die Summe der Blöcke der Zeichen in einer Zeichenfolge in den Umfang der Zeichenfolge entspricht möglicherweise nicht.

Wenn *nTabPositions* ist 0 und *LpnTabStopPositions* NULL ist, Registerkarten auf acht Mal die durchschnittliche Zeichenbreite erweitert werden. Wenn *nTabPositions* 1 ist, werden die Tabstopps getrennt werden, mit dem durch den ersten Wert im Array, an dem angegebenen Abstand *LpnTabStopPositions* Punkte. Wenn *LpnTabStopPositions* auf mehr als einen einzelnen Wert verweist, ein Tabstopp festgelegt ist für jeden Wert im Array bis zu der Zahl von *nTabPositions*.

##  <a name="gettextalign"></a>  CDC::GetTextAlign

Ruft den Status der textausrichtung Flags für den Gerätekontext ab.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Rückgabewert

Der Status der textausrichtung Flags. Der Rückgabewert ist eine oder mehrere der folgenden Werte:

- Gibt an, TA_BASELINE Ausrichtung des der x-Achse und der Baseline der ausgewählten Schriftart innerhalb des umschließenden Rechtecks.

- Ausrichtung TA_BOTTOM gibt an, von der x-Achse und dem unteren Rand des umschließenden Rechtecks.

- Gibt an, TA_CENTER Ausrichtung des der y-Achse und dem Mittelpunkt des umschließenden Rechtecks.

- Gibt an, TA_LEFT Ausrichtung des der y-Achse und dem linken Rand des umschließenden Rechtecks.

- TA_NOUPDATECP gibt an, dass die aktuelle Position nicht aktualisiert wird.

- Gibt an, TA_RIGHT Ausrichtung des der y-Achse und der rechten Seite des umschließenden Rechtecks.

- Ausrichtung TA_TOP gibt an, von der x-Achse und dem oberen Rand des umschließenden Rechtecks.

- TA_UPDATECP gibt an, dass die aktuelle Position aktualisiert wird.

### <a name="remarks"></a>Hinweise

Die textausrichtung Flags legen fest, wie die `TextOut` und `ExtTextOut` Memberfunktionen ausrichten eine Textzeichenfolge in Bezug auf den Ausgangspunkt der Zeichenfolge. Die textausrichtung Flags sind nicht unbedingt ein Einzelbit-Flags und möglicherweise gleich 0. Um zu testen, ob ein Flag festgelegt ist, sollte eine Anwendung die folgenden Schritte ausführen:

1. Gelten Sie die bitweisen OR-Operator das Flag und ihre zugehörigen Flags, die wie folgt zusammengefasst werden:

    - TA_LEFT TA_CENTER und TA_RIGHT

    - TA_BASELINE TA_BOTTOM und TA_TOP

    - TA_NOUPDATECP und TA_UPDATECP

1. Anwenden der bitweise- und Operator, um das Ergebnis und der Rückgabewert von `GetTextAlign`.

1. Testen der Gleichheit dieses Ergebnis und das Flag.

##  <a name="gettextcharacterextra"></a>  CDC::GetTextCharacterExtra

Ruft die aktuelle Einstellung für die Menge an Zeichenabstands ab.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Rückgabewert

Die Menge der der Zeichenabstands.

### <a name="remarks"></a>Hinweise

GDI hinzugefügt jedes Zeichen, einschließlich der Zeilenumbruchzeichen, wenn sie eine Zeile mit Text in den Gerätekontext schreibt diese Leerzeichen.

Der Standardwert für die Menge an Zeichenabstands ist 0.

##  <a name="gettextcolor"></a>  CDC::GetTextColor

Ruft die aktuelle Textfarbe ab.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Rückgabewert

Die aktuelle Textfarbe als ein RGB-Farbwert.

### <a name="remarks"></a>Hinweise

Die Farbe des Textes ist die Vordergrundfarbe von Zeichen, die die GDI-Ausgabe von Text-Memberfunktionen mit gezeichnet [TextOut](#textout), [ExtTextOut](#exttextout), und [TabbedTextOut](#tabbedtextout).

##  <a name="gettextextent"></a>  CDC::getTextExtent

Rufen Sie diese Memberfunktion, um die Breite und Höhe einer Textzeile, die anhand der aktuellen Schriftart bestimmt die Dimensionen zu berechnen.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parameter

*lpszString*<br/>
Zeigt auf eine Zeichenfolge von Zeichen. Sie können auch übergeben eine [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an.

*str*<br/>
Ein `CString` Objekt, das die angegebenen Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Die Abmessungen der Zeichenfolge (in logischen Einheiten) in einem [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.

### <a name="remarks"></a>Hinweise

Die Informationen werden abgerufen, von [M_hAttribDC](#m_hattribdc), den Gerätekontext Attribut.

In der Standardeinstellung `GetTextExtent` geht davon aus, der Text für die die Dimension abgerufen entlang einer horizontalen Linie festgelegt ist (d. h. die "Escapement" ist 0). Wenn Sie eine Schriftart angeben einer nicht-NULL "Escapement" erstellen, müssen Sie den Winkel des Texts explizit, um die Abmessungen der Zeichenfolge zu erhalten konvertieren.

Der aktuelle Ausschneidebereich hat keine Auswirkungen auf die Breite und Höhe, die vom `GetTextExtent`.

Da einige Geräte kein Zeichen in der regulären Zelle Arrays setzen (d.h., sie durchzuführen, kerning), die Summe der Blöcke der Zeichen in einer Zeichenfolge in den Umfang der Zeichenfolge entspricht möglicherweise nicht.

##  <a name="gettextextentexpointi"></a>  CDC::GetTextExtentExPointI

Ruft die Anzahl der Zeichen in einer angegebenen Zeichenfolge, die in einem angegebenen Raum passt, und füllt ein Array mit der Größe von Text für jedes dieser Zeichen ab.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*pgiIn*<br/>
Ein Zeiger auf ein Array von glyphenindizes, die für die Blöcke sind, abgerufen werden sollen.

*CGI*<br/>
Gibt die Anzahl der Symbole in das Array verweist *PgiIn*.

*nMaxExtent*<br/>
Gibt die maximale zulässige Breite in logischen Einheiten, der die formatierte Zeichenfolge an.

*lpnFit*<br/>
Ein Zeiger auf eine ganze Zahl, die Anzahl der die maximale Anzahl von Zeichen empfängt, die im Bereich gemäß passen *nMaxExtent*. Wenn *LpnFit* NULL ist, *nMaxExtent* wird ignoriert.

*alpDx*<br/>
Ein Zeiger auf ein Array von Ganzzahlen, die teilweise Glyphe Blöcke empfängt. Jedes Element im Array gibt den Abstand in logischen Einheiten zwischen dem Anfang des Arrays Indizes Glyphe und eines der Symbole, die im Bereich gemäß entspricht *nMaxExtent*. Obwohl dieses Array Symbolindizes anhand mindestens so viele Elemente verfügen soll *Cgi*, die Funktion füllt das Array mit den Wertebereichen nur für so viele Symbolindizes wie vom angegebenen *LpnFit*. Wenn *LpnDx* NULL ist, berechnet die Funktion nicht Teil der Zeichenfolge Breite.

*lpSize*<br/>
Zeiger auf eine [Größe](https://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur, die die Abmessungen des Symbols Indices-Array, in logischen Einheiten empfängt. Dieser Wert darf nicht NULL sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Diese Memberfunktion emuliert die Funktionen der [GetTextExtentExPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentexpointi), wie im Windows SDK beschrieben.

##  <a name="gettextextentpointi"></a>  CDC::GetTextExtentPointI

Ruft die Breite und Höhe des angegebenen Arrays von glyphenindizes.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*pgiIn*<br/>
Ein Zeiger auf ein Array von glyphenindizes, die für die Blöcke sind, abgerufen werden sollen.

*CGI*<br/>
Gibt die Anzahl der Symbole in das Array verweist *PgiIn*.

*lpSize*<br/>
Zeiger auf eine [Größe](https://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur, die die Abmessungen des Symbols Indices-Array, in logischen Einheiten empfängt. Dieser Wert darf nicht NULL sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Diese Memberfunktion emuliert die Funktionen der [GetTextExtentPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentpointi), wie im Windows SDK beschrieben.

##  <a name="gettextface"></a>  CDC::GetTextFace

Rufen Sie diese Memberfunktion um den Namen der aktuellen Schriftart in einen Puffer zu kopieren.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parameter

*nCount*<br/>
Gibt die Größe des Puffers (in Byte). Wenn der Schriftartnamen länger als die Anzahl der Bytes, die durch diesen Parameter angegeben ist, wird der Name verkürzt.

*lpszFacename*<br/>
Verweist auf den Puffer für den Schriftartnamen.

*rString*<br/>
Ein Verweis auf eine [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt.

### <a name="return-value"></a>Rückgabewert

Die Anzahl der Bytes, die kopiert werden, in den Puffer, der das abschließende Nullzeichen nicht eingeschlossen. Es ist 0, wenn ein Fehler auftritt.

### <a name="remarks"></a>Hinweise

Der Schriftartname wird als eine Null-terminierte Zeichenfolge kopiert.

##  <a name="gettextmetrics"></a>  CDC::GetTextMetrics

Ruft die Metriken für die aktuelle Schriftart, die mit den Gerätekontext Attribut ab.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parameter

*lpMetrics*<br/>
Verweist auf die [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) -Struktur, die Metriken empfängt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

##  <a name="getviewportext"></a>  CDC::GetViewportExt

Ruft die x und y-Blöcke des Viewports für den Gerätekontext ab.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Rückgabewert

Die X - und y-Blöcke (in Geräteeinheiten) als eine `CSize` Objekt.

##  <a name="getviewportorg"></a>  CDC::GetViewportOrg

Ruft ab, der x- und y-Koordinaten des Ursprungs des Viewports im Gerätekontext zugeordnet.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Rückgabewert

Der Ursprung des Viewports (in Gerätekoordinaten) als eine `CPoint` Objekt.

##  <a name="getwindow"></a>  CDC::GetWindow

Gibt zurück, das den Anzeigekontext für das Gerät zugeordnete Fenster.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf eine `CWnd` -Objekt, wenn erfolgreich; andernfalls NULL.

### <a name="remarks"></a>Hinweise

Dies ist eine erweiterte Funktion. Beispielsweise kann diese Memberfunktion das Ansichtsfenster nicht beim Drucken oder in der Seitenansicht zurückgeben. Es gibt immer das Fenster Ausgabe zugeordnet. Ausgabefunktionen, die den angegebenen DC verwenden in diesem Fenster zeichnen.

##  <a name="getwindowext"></a>  CDC::GetWindowExt

Ruft die x und y-Blöcke im Zusammenhang mit den Gerätekontext Fenster ab.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Rückgabewert

Die X - und y-Blöcke (in logischen Einheiten) als eine `CSize` Objekt.

##  <a name="getwindoworg"></a>  CDC::GetWindowOrg

Ruft die x- und y-Koordinaten des Ursprungs im Zusammenhang mit den Gerätekontext Fenster ab.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Rückgabewert

Der Ursprung des Fensters (in logischen Koordinaten) als eine `CPoint` Objekt.

##  <a name="getworldtransform"></a>  CDC::GetWorldTransform

Ruft den aktuellen Raum auf der Seite-Space-Transformation ab.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parameter

*rXform*<br/>
Ein Verweis auf ein [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) Struktur, die die aktuelle Raum auf der Seite-Space-Transformation empfängt.

### <a name="return-value"></a>Rückgabewert

Gibt einen Wert ungleich NULL bei Erfolg zurück.

Gibt 0 bei einem Fehler zurück.

Um erweiterte Fehlerinformationen abzurufen, rufen Sie [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Hinweise

Diese Methode dient als Wrapper für die Windows-GDI-Funktion [GetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-getworldtransform).

##  <a name="gradientfill"></a>  CDC::GradientFill

Rufen Sie diese Memberfunktion zum Rechteck und Dreieck Strukturen mit Farbe zu füllen, die in den anderen reibungslos auf einer Seite eingeblendet.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parameter

*pVertices*<br/>
Zeiger auf ein Array von [TRIVERTEX](/windows/desktop/api/wingdi/ns-wingdi-_trivertex) Strukturen, die jeweils einen Dreieck Vertex definieren.

*nVertices*<br/>
Die Anzahl der Scheitelpunkte.

*pMesh*<br/>
Array von [GRADIENT_TRIANGLE](/windows/desktop/api/wingdi/ns-wingdi-_gradient_triangle) Strukturen im Modus für Dreieck oder ein Array von [GRADIENT_RECT](/windows/desktop/api/wingdi/ns-wingdi-_gradient_rect) Strukturen im Rechteck-Modus.

*nMeshElements*<br/>
Die Anzahl von Elementen (Dreiecke oder Rechtecke) in *pMesh*.

*dwMode*<br/>
Gibt die Farbverlauf-Modus an. Eine Liste der möglichen Werte, finden Sie unter [GradientFill](/windows/desktop/api/wingdi/nf-wingdi-gradientfill) im Windows SDK.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Hinweise

Weitere Informationen finden Sie unter `GradientFill` im Windows SDK.

##  <a name="graystring"></a>  CDC:: graystring

Zeichnet abgeblendet (grau) Text an der angegebenen Position durch Schreiben von Text in eine Bitmap Arbeitsspeicher, abblendet Bitmap und dann die Bitmap auf dem Bildschirm kopieren.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*pBrush*<br/>
Identifiziert den Pinsel für die (das abblendet abblendet) verwendet werden soll.

*lpfnOutput*<br/>
Gibt die Adresse der Prozedur Instanzen der Anwendung bereitgestellten Rückruffunktion, die die Zeichenfolge gezeichnet wird. Weitere Informationen finden Sie unter der Beschreibung der Windows `OutputFunc` [Rückruffunktion](callback-functions-used-by-mfc.md#graystring). Wenn dieser Parameter NULL ist, wird das System verwendet die Windows `TextOut` Funktion zum Zeichnen der Zeichenfolge ein, und *LpData* wird davon ausgegangen, dass ein long-Zeiger auf die Zeichenfolge ausgegeben werden.

*lpData*<br/>
Gibt an, ein ferner Zeiger auf Daten in der Ausgabe-Funktion übergeben werden. Wenn *LpfnOutput* NULL ist, *LpData* muss ein long-Zeiger auf die Zeichenfolge, die ausgegeben werden.

*nCount*<br/>
Gibt die Anzahl der Zeichen, die ausgegeben werden. Wenn dieser Parameter 0 (null) ist `GrayString` berechnet die Länge der Zeichenfolge (vorausgesetzt, dass *LpData* ist ein Zeiger auf Zeichenfolge). Wenn *nCount* ist-1 und die Funktion verweist *LpfnOutput* 0 zurückgibt, ist das Bild wird angezeigt, jedoch nicht abgeblendet.

*w*<br/>
Gibt die logische X-Koordinate der Startposition des Rechtecks, das Sie die Zeichenfolge enthält.

*y*<br/>
Gibt die logische y-Koordinate der Startposition des Rechtecks, das Sie die Zeichenfolge enthält.

*nWidth*<br/>
Gibt die Breite (in logischen Einheiten) des Rechtecks, das Sie die Zeichenfolge enthält. Wenn *nWidth* ist 0 (null) `GrayString` berechnet die Breite des Bereichs, sofern *LpData* ist ein Zeiger auf die Zeichenfolge.

*nHeight*<br/>
Gibt die Höhe (in logischen Einheiten) des Rechtecks, das Sie die Zeichenfolge enthält. Wenn *nHeight* ist 0 (null) `GrayString` berechnet die Höhe des Bereichs, sofern *LpData* ist ein Zeiger auf die Zeichenfolge.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn die Zeichenfolge gezeichnet wird, oder 0, wenn entweder die `TextOut` Funktion oder die der Anwendung bereitgestellten Ausgabefunktion zurückgegebenen 0 (null) oder wenn nicht genügend Arbeitsspeicher, um eine Bitmap im Arbeitsspeicher für die abblendet zu erstellen.

### <a name="remarks"></a>Hinweise

Die Funktion wird den Text unabhängig von der ausgewählten Pinsels und Hintergrund abgeblendet. Die `GrayString` Member-Funktion verwendet, die aktuell ausgewählte Schriftart. Der Zuordnungsmodus MM_TEXT muss ausgewählt werden, bevor Sie diese Funktion verwenden.

Eine Anwendung kann abgeblendete (grau) Zeichenfolgen auf Geräten, graue als Volltonfarbe ohne unterstützen, zeichnen die `GrayString` Member-Funktion. Die Systemfarbe COLOR_GRAYTEXT ist die einfarbig grau Systemfarbe für deaktivierten Text gezeichnet werden soll. Rufen Sie die Anwendung kann die `GetSysColor` Windows-Funktion, um den Farbwert der COLOR_GRAYTEXT abzurufen. Die Anwendung kann aufrufen, ist die Farbe als 0 (Schwarz), die `SetTextColor` Memberfunktion versucht, die Farbe des Textes auf den Color-Wert festgelegt, und zeichnen Sie die Zeichenfolge direkt. Wenn die abgerufene Farbe auf Schwarz festgelegt ist, muss die Anwendung aufrufen `GrayString` , abgeblendet (grau) den Text.

Wenn *LpfnOutput* NULL ist, GDI verwendet die Windows [TextOut](/windows/desktop/api/wingdi/nf-wingdi-textouta) -Funktion und *LpData* wird davon ausgegangen, dass ein ferner Zeiger auf das Zeichen ausgegeben werden. Wenn die Zeichen, die Ausgabe von behandelt werden können die `TextOut` Member-Funktion (z. B. die Zeichenfolge als Bitmap gespeichert ist), die Anwendung muss eine eigene Ausgabefunktion angeben.

Beachten Sie außerdem, dass alle Rückruffunktionen vor der Rückgabe auf Windows, da Ausnahmen hinweg Rückruf ausgelöst werden, können nicht Microsoft Foundation Ausnahmen abfangen müssen. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).

Die Rückruffunktion übergeben `GrayString` verwenden, muss die `__stdcall` -Aufrufkonvention verwendet und muss exportiert werden, mit `__declspec`.

Wenn das Framework ist im Vorschaumodus, einen Aufruf der `GrayString` Memberfunktion in übersetzt eine `TextOut` Aufruf und der Callback-Funktion wird nicht aufgerufen.

##  <a name="himetrictodp"></a>  CDC::HIMETRICtoDP

Verwenden Sie diese Funktion, wenn Sie auf Pixel HIMETRIC-Größen aus OLE konvertieren.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpSize*<br/>
Verweist auf eine [Größe](https://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur oder [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.

### <a name="remarks"></a>Hinweise

Wenn der Zuordnungsmodus, der das Gerätekontextobjekt MM_LOENGLISH MM_HIENGLISH, MM_LOMETRIC oder MM_HIMETRIC ist, basiert klicken Sie dann die Konvertierung auf die Anzahl der Pixel in der physischen Zoll. Wenn der Zuordnungsmodus einen der anderen nicht eingeschränkte Modi (z. B. MM_TEXT) ist, basiert klicken Sie dann die Konvertierung auf die Anzahl der Pixel in der logischen Zoll.

##  <a name="himetrictolp"></a>  CDC::HIMETRICtoLP

Rufen Sie diese Funktion zum Konvertieren von HIMETRIC-Einheiten in logischen Einheiten.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpSize*<br/>
Verweist auf eine [Größe](https://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur oder [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.

### <a name="remarks"></a>Hinweise

Verwenden Sie diese Funktion, wenn Sie HIMETRIC-Größen aus OLE und diese in Ihrer Anwendung natürliche Zuordnungsmodus konvertieren möchten.

Die Konvertierung wird erreicht, indem zunächst die HIMETRIC-Einheiten in Pixel konvertiert, und klicken Sie dann diese Einheiten in logischen Einheiten, die den Gerätekontext aktuelle Zuordnung Einheiten konvertiert wird. Beachten Sie, dass die Blöcke des Fensters und der Viewport des Geräts, das Ergebnis ausgewirkt hat.

##  <a name="intersectcliprect"></a>  CDC::IntersectClipRect

Erstellt einen neuen Ausschneidebereich durch Bildung der Schnittmenge der aktuellen Region und anhand des Rechtecks *X1*, *y1*, *X2*, und *y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des Rechtecks an.

*y1*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks an.

*x2*<br/>
Gibt die logische X-Koordinate der unteren rechten Ecke des Rechtecks an.

*Y2*<br/>
Gibt die logische y-Koordinate der unteren rechten Ecke des Rechtecks an.

*lpRect*<br/>
Gibt das Rechteck. Sie können entweder übergeben eine `CRect` Objekt oder ein Zeiger auf eine `RECT` Struktur für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Der neue Ausschneidebereich-Typ. Eine der folgenden Werte sind möglich:

- Neue COMPLEXREGION Ausschneidebereich hat überlappende Grenzen.

- Fehler-Gerätekontext ist ungültig.

- Neue NULLREGION Ausschneidebereich ist leer.

- Neue SIMPLEREGION Ausschneidebereich verfügt über keine überlappenden Rahmen.

### <a name="remarks"></a>Hinweise

GDI Schneidet alle nachfolgenden Ausgabe an die neue Grenze an. Die Breite und Höhe müssen nicht 32.767 überschreitet.

##  <a name="invertrect"></a>  CDC::InvertRect

Hierdurch wird der Inhalt des angegebenen Rechtecks.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Verweist auf eine `RECT` , enthält die logischen Koordinaten des Rechtecks umgekehrt werden soll. Sie können auch übergeben eine `CRect` Objekt für diesen Parameter.

### <a name="remarks"></a>Hinweise

Inversion ist eine logische nicht Vorgang und spiegelt die Bits der einzelnen Pixel. Auf die monochrome Anzeige Funktion, dass weißen Pixel schwarz und schwarzen Pixel weiß. Die Umkehrung hängt auf Farbe angezeigt das, zum Generieren von Farben für die Anzeige. Aufrufen von `InvertRect` zweimal mit dem gleichen Rechteck setzt Sie die Anzeige auf seine vorherige Farben.

Wenn das Rechteck leer ist, wird nichts gezeichnet.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

##  <a name="invertrgn"></a>  CDC::InvertRgn

Invertiert die Farben in der Region, die anhand des *PRNG*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parameter

*PRNG*<br/>
Identifiziert die Region, die umgekehrt werden soll. Die Koordinaten für die Region werden in logischen Einheiten angegeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Auf die monochrome Anzeige Funktion, dass weißen Pixel schwarz und schwarzen Pixel weiß. Die Umkehrung hängt mit Farben wie die Farben für die Anzeige generiert werden.

##  <a name="isprinting"></a>  CDC::IsPrinting

Bestimmt, ob es sich bei der Gerätekontext für das Drucken verwendet wird.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Rückgabewert

Einen Wert ungleich null der `CDC` Objekt ist ein Drucker DC, andernfalls 0.

##  <a name="lineto"></a>  CDC::LineTo

Zeichnet eine Linie von der aktuellen Position bis zum, jedoch nicht einschließlich, die vom angegebenen Punkt *x* und *y* (oder *zeigen*).

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate des Endpunkts für die Zeile an.

*y*<br/>
Gibt die logische y-Koordinate des Endpunkts für die Zeile an.

*Zeigen Sie*<br/>
Gibt den Endpunkt für die Zeile. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn die Linie gezeichnet wird; andernfalls 0.

### <a name="remarks"></a>Hinweise

Die Linie wird mit dem ausgewählten Stift gezeichnet. Die aktuelle Position nastaven NA hodnotu *x*, *y* oder *zeigen*.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="lptodp"></a>  CDC::LPtoDP

Logische Einheiten konvertiert in Geräteeinheiten.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein Array von Punkten. Jeder Punkt im Array ist ein [zeigen](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt.

*nCount*<br/>
Die Anzahl der Punkte im Array.

*lpRect*<br/>
Verweist auf eine [RECT](../../mfc/reference/rect-structure1.md) Struktur oder ein [CRect](../../atl-mfc-shared/reference/crect-class.md) Objekt. Dieser Parameter wird für den Regelfall der Zuordnung ein Rechteck vom logischen in Geräteeinheiten verwendet.

*lpSize*<br/>
Verweist auf eine [Größe](https://msdn.microsoft.com/library/windows/desktop/dd145106) Struktur oder ein [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt.

### <a name="remarks"></a>Hinweise

Die Funktion ordnet die Koordinaten jedes Punkts oder Dimensionen mit einer Größe, von GDI logischen Koordinatensystem in einem Gerät-Koordinatensystem. Die Konvertierung hängt davon ab, der aktuelle Zuordnungsmodus und die Einstellungen des Ursprünge und Blöcke von Fenster und der Viewport des Geräts.

Die x- und y-Koordinaten der Punkte sind 2-Byte-Ganzzahlen mit Vorzeichen im Bereich von -32.768 bis 32.767. In Fällen, in dem der Zuordnungsmodus Werte größer als diese Grenzwerte führen würde, setzt das System die Werte -32.768 und 32.767.

##  <a name="lptohimetric"></a>  CDC::LPtoHIMETRIC

Rufen Sie diese Funktion zum Konvertieren von logischer Einheiten in HIMETRIC-Einheiten.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parameter

*lpSize*<br/>
Verweist auf eine `SIZE` Struktur oder ein `CSize` Objekt.

### <a name="remarks"></a>Hinweise

Verwenden Sie diese Funktion, wenn Sie HIMETRIC-Größen an OLE, Erteilen von Ihrer Anwendung natürliche Zuordnungsmodus konvertieren. Beachten Sie, dass die Blöcke des Fensters und der Viewport des Geräts, das Ergebnis ausgewirkt hat.

Die Konvertierung wird erreicht, indem zunächst die logischen Einheiten in Pixel, die den Gerätekontext aktuelle Zuordnung Einheiten, und klicken Sie dann diese Einheiten in HIMETRIC-Einheiten konvertiert wird.

##  <a name="m_hattribdc"></a>  CDC::m_hAttribDC

Die Attribut-Gerätekontext für diesen `CDC` Objekt.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Hinweise

Standardmäßig ist dieser Gerätekontext gleich `m_hDC`. Im allgemeinen `CDC` GDI-Aufrufe, die Informationen aus dem Gerätekontext anfordern geleitet `m_hAttribDC`. Finden Sie unter den [CDC](../../mfc/reference/cdc-class.md) klassenbeschreibung Weitere Informationen zur Verwendung der folgenden beiden Kontexten.

##  <a name="m_hdc"></a>  CDC::m_hDC

Die Ausgabe-Gerätekontext für diesen `CDC` Objekt.

```
HDC m_hDC;
```

### <a name="remarks"></a>Hinweise

In der Standardeinstellung `m_hDC` gleich `m_hAttribDC`, den andere eingebundenes Gerätekontext `CDC`. Im allgemeinen `CDC` GDI-Aufrufe, die Ausgabe zu erstellen, wechseln Sie zu der `m_hDC` Gerätekontext. Sie können initialisieren `m_hDC` und `m_hAttribDC` auf verschiedenen Geräten zu verweisen. Finden Sie unter den [CDC](../../mfc/reference/cdc-class.md) klassenbeschreibung Weitere Informationen zur Verwendung der folgenden beiden Kontexten.

##  <a name="maskblt"></a>  CDC::MaskBlt

Kombiniert die Farbdaten für die Quelle und Ziel-Bitmaps, die mithilfe der angegebenen Maske und rastervorgang an.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des Zielrechtecks an.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Zielrechtecks an.

*nWidth*<br/>
Gibt die Breite in logischen Einheiten, der die Zielbitmap Rechteck und die Quelle an.

*nHeight*<br/>
Gibt die Höhe in logischen Einheiten, der die Zielbitmap Rechteck und die Quelle an.

*pSrcDC*<br/>
Gibt den Gerätekontext aus dem die Bitmap ist, kopiert werden soll. Es muss NULL, wenn die *DwRop* Parameter gibt an, ein rastervorgang, der nicht in eine Quelle enthalten ist.

*xSrc*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des Quellbitmaps an.

*ySrc*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Quellbitmaps an.

*maskBitmap*<br/>
Identifiziert die monochrome Maske-Bitmap, die in Kombination mit der Farbbitmap in den Quellgerätekontext an.

*xMask*<br/>
Gibt die horizontale Pixel des Offsets für die Maskenbitmap, die gemäß der *MaskBitmap* Parameter.

*yMask*<br/>
Gibt den Offset der vertikalen Pixel für die Maskenbitmap, die gemäß der *MaskBitmap* Parameter.

*dwRop*<br/>
Gibt an, Vordergrund und Hintergrund ternäre rastervorgangscode, die die Funktion verwendet, um die Kombination aus Quell-und Zieldaten zu steuern. Der Hintergrund Raster Vorgangscode wird in das hohe Word der dieser Wert das höherwertige Byte gespeichert. der Vordergrund Raster Vorgangscode wird in das hohe Word der dieser Wert das niedrige Byte gespeichert. das niedrige Word der dieser Wert wird ignoriert, und sollte Null sein. Das Makro MAKEROP4 erstellt diese Kombination aus Vordergrund- und Hintergrundfarbe rastervorgangscode. Finden Sie im Abschnitt "Hinweise" eine Beschreibung der Vordergrund- und Hintergrundfarbe im Kontext dieser Funktion. Finden Sie unter den `BitBlt` Member-Funktion eine Liste der allgemeinen rastervorgangscode.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Der Wert 1 in der Maske gemäß *MaskBitmap* gibt an, dass von der Vordergrund Raster Vorgangscode angegeben *DwRop* an diesem Speicherort angewendet werden soll. Der Wert 0 in der Maske gibt an, dass der Hintergrund Raster Vorgangscode durch angegeben *DwRop* an diesem Speicherort angewendet werden soll. Wenn die Raster-Vorgänge mit eine Datenquelle erforderlich ist, muss der Mask-Rechteck das Quellrechteck behandelt. Wenn dies nicht der Fall ist, schlägt die Funktion fehl. Wenn die Rasteroperationen nicht mit eine Datenquelle benötigen, muss das Rechteck Maske das Zielrechteck abdecken. Wenn dies nicht der Fall ist, schlägt die Funktion fehl.

Wenn eine Transformation Drehung oder reduzierungen für den Quellgerätekontext gilt, wenn diese Funktion aufgerufen wird, tritt ein Fehler auf. Andere Arten von Transformationen sind jedoch zulässig.

Wenn sich die Farbenformate, der die Quelle, Muster und Zielbitmaps unterscheiden, konvertiert diese Funktion des Musters oder Quellformat oder beidem unterzogen, um mit dem Zielformat überein. Wenn die Maskenbitmap nicht um eine monochrome Bitmap ist, tritt ein Fehler auf. Wenn eine erweiterte Metadatei aufgezeichnet werden wird, ein Fehler auftritt (und die Funktion gibt 0 zurück) Wenn der Quellgerätekontext eine EMF-Gerätekontext identifiziert. Nicht alle Geräte unterstützen `MaskBlt`. Es sollte eine Anwendung aufrufen `GetDeviceCaps` zu bestimmen, ob ein Gerät mit dieser Funktion unterstützt. Wenn keine Maskenbitmap angegeben wird, diese Funktion verhält sich genau so wie `BitBlt`, mit dem Vordergrund Raster Vorgangscode. Das Pixel, die in den Quellgerätekontext Bitmap in der Maske Bitmap-Zuordnung zu dem Punkt (0,0) versetzt werden. Dies ist nützlich für Fälle, in denen eine Maskenbitmap für eine Reihe von Masken enthält. eine Anwendung kann ganz einfach Anwenden eines von ihnen mit einer Maske-Blitting Aufgabe durch die Pixel-Offsets anpassen und Rechteck Größen gesendet wird, um `MaskBlt`.

##  <a name="modifyworldtransform"></a>  CDC::ModifyWorldTransform

Ändert die globale Transformation für einen Gerätekontext, die Verwendung des angegebenen Modus.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parameter

*rXform*<br/>
Ein Verweis auf ein [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) Struktur verwendet, um die globale Transformation für den angegebenen Gerätekontext zu ändern.

*iMode*<br/>
Gibt an, wie die Transformationsdaten die aktuellen globalen Transformation ändert. Eine Liste der Werte, die für diesen Parameter, finden Sie unter [ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Rückgabewert

Gibt einen Wert ungleich NULL bei Erfolg zurück.

Gibt 0 bei einem Fehler zurück.

Um erweiterte Fehlerinformationen abzurufen, rufen Sie [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Hinweise

Diese Methode dient als Wrapper für die Windows-GDI-Funktion [ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform).

##  <a name="moveto"></a>  CDC::MoveTo

Verschiebt die aktuelle Position, an der vom angegebenen *x* und *y* (oder durch *zeigen*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate der neuen Position an.

*y*<br/>
Gibt die logische y-Koordinate der neuen Position an.

*Zeigen Sie*<br/>
Gibt die neue Position. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Die x- und y-Koordinaten der vorherigen Position als einen `CPoint` Objekt.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="offsetcliprgn"></a>  CDC::OffsetClipRgn

Verschiebt den Ausschneidebereich des Gerätekontexts durch die angegebenen Offsets an.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die Anzahl der logischen Einheiten zum Verschieben von links oder rechts.

*y*<br/>
Gibt die Anzahl der logischen Einheiten nach oben oder unten zu verschieben.

*size*<br/>
Gibt den Betrag für den offset an.

### <a name="return-value"></a>Rückgabewert

Die neue Region-Typ. Eine der folgenden Werte sind möglich:

- Region COMPLEXREGION Clipping hat überlappende Grenzen.

- Fehler-Gerätekontext ist ungültig.

- Clipping NULLREGION Region ist leer.

- Clipping SIMPLEREGION Region verfügt über keine überlappenden Rahmen.

### <a name="remarks"></a>Hinweise

Die Funktion wird die Region verschoben *x* Einheiten entlang der x-Achse und *y* Einheiten entlang der y-Achse.

##  <a name="offsetviewportorg"></a>  CDC::OffsetViewportOrg

Ändert die Koordinaten des Ursprungs Viewport relativ zu den Koordinaten des aktuellen Viewports Ursprungs.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*nWidth*<br/>
Gibt die Anzahl der Geräteeinheiten X-Koordinate für den aktuellen Ursprung hinzu.

*nHeight*<br/>
Gibt die Anzahl der Geräteeinheiten y-Koordinate für den aktuellen Ursprung hinzu.

### <a name="return-value"></a>Rückgabewert

Der vorherige Viewport Ursprung (in Gerätekoordinaten) als eine `CPoint` Objekt.

##  <a name="offsetwindoworg"></a>  CDC::OffsetWindowOrg

Ändert die Koordinaten des Ursprungs Fenster relativ zu den Koordinaten des aktuellen Fensters Ursprungs.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parameter

*nWidth*<br/>
Gibt die Anzahl der logischen Einheiten X-Koordinate für den aktuellen Ursprung hinzu.

*nHeight*<br/>
Gibt die Anzahl der logischen Einheiten y-Koordinate für den aktuellen Ursprung hinzu.

### <a name="return-value"></a>Rückgabewert

Den vorherigen Fensterursprung (in logischen Koordinaten) als eine `CPoint` Objekt.

##  <a name="operator_hdc"></a>  CDC::Operator HDC

Verwenden Sie diesen Operator zum Abrufen von des Gerätehandle Kontext, der die `CDC` Objekt.

```
operator HDC() const;
```

### <a name="return-value"></a>Rückgabewert

Wenn erfolgreich, das Handle des Device Context-Objekts; andernfalls NULL.

### <a name="remarks"></a>Hinweise

Sie können das Handle verwenden, um Windows-APIs direkt aufrufen.

##  <a name="paintrgn"></a>  CDC::PaintRgn

Füllt den Bereich, der anhand des *PRNG* mit dem aktuellen Pinsel.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parameter

*PRNG*<br/>
Identifiziert die Region gefüllt werden soll. Die Koordinaten für den angegebenen Bereich sind in logischen Einheiten angegeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

##  <a name="patblt"></a>  CDC::PatBlt

Erstellt ein Bitmuster auf dem Gerät.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate der oberen linken Ecke des Rechtecks, das das Muster zu erhalten.

*y*<br/>
Gibt die logische y-Koordinate der oberen linken Ecke des Rechtecks, das das Muster zu erhalten.

*nWidth*<br/>
Gibt die Breite (in logischen Einheiten) des Rechtecks, das das Muster zu erhalten.

*nHeight*<br/>
Gibt die Höhe (in logischen Einheiten) des Rechtecks, das das Muster zu erhalten.

*dwRop*<br/>
Gibt den rastervorgang Code. Rastervorgang Codes (-RPC-Vorgänge) definieren, wie GDI Farben in Ausgabevorgängen kombiniert, an denen ein aktueller Pinsel, eine mögliche Quellbitmap und eine Zielbitmap beteiligt sind. Dieser Parameter kann einen der folgenden Werte sein:

- PATCOPY Kopien-Muster, das Zielbitmap.

- PATINVERT kombiniert Zielbitmap mithilfe des booleschen XOR-Operators mit Muster.

- DSTINVERT kehrt die Zielbitmap.

- BLACKNESS aktiviert, die Ausgabe Schwarz.

- WHITENESS aktiviert, die Ausgabe weiß.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Das Muster ist eine Kombination aus den ausgewählten Pinsel und das Muster bereits auf dem Gerät. Der rastervorgang Code anhand des *DwRop* definieren, wie die Muster kombiniert werden. Die Raster-Vorgänge aufgeführt, die für diese Funktion sind eine begrenzte Teilmenge der vollständigen 256 ternäre rastervorgang-Codes. Insbesondere kann kein rastervorgang Code, der mit einer Datenquelle verweist, verwendet werden.

Nicht alle Gerätekontexte unterstützen die `PatBlt` Funktion. Bestimmt, ob für ein Gerätekontext unterstützt `PatBlt`, rufen Sie die `GetDeviceCaps` Member mit dem Index RASTERCAPS Funktion und den Rückgabewert für das Flag RC_BITBLT überprüfen.

##  <a name="pie"></a>  CDC::PIE

Zeichnet einen kreisförmigen Keil durch Zeichnen eines elliptischen Bogens, dessen Mittelpunkt und zwei Endpunkte durch Linien miteinander verknüpft sind.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die X-Koordinate von der linken oberen Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate von der linken oberen Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die X-Koordinate der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*Y2*<br/>
Gibt die y-Koordinate der unteren rechten Ecke des umschließenden Rechtecks (in logischen Einheiten) an.

*x3*<br/>
Gibt die X-Koordinate des Startpunkts des Bogens, (in logischen Einheiten) an. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*Y3*<br/>
Gibt die y-Koordinate des Startpunkts des Bogens, (in logischen Einheiten) an. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*X4*<br/>
Gibt die X-Koordinate des Endpunkts des Bogens (in logischen Einheiten) an. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*Y4*<br/>
Gibt die y-Koordinate des Endpunkts des Bogens (in logischen Einheiten) an. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen.

*lpRect*<br/>
Gibt das umschließende Rechteck. Sie können entweder übergeben eine `CRect` Objekt oder ein Zeiger auf eine `RECT` Struktur für diesen Parameter.

*ptStart*<br/>
Gibt den Anfangspunkt des Bogens. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen. Sie können entweder übergeben eine [Punkt](../../mfc/reference/point-structure1.md) Struktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.

*ptEnd*<br/>
Gibt den Endpunkt des Bogens. Dieser Punkt muss nicht genau an den Bogen mit Strichen liegen. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die Mitte des Bogens steht im Mittelpunkt des umschließenden Rechtecks gemäß *X1*, *y1*, *X2*, und *y2* (oder durch *LpRect* ). Die Anfangs- und Endpunkt des Bogens angegebenen *X3*, *y3*, *X4*, und *y4* (oder durch *PtStart*und *PtEnd*).

Der Bogen gezeichnet wird mit dem ausgewählten Stift, gegen den Uhrzeigersinn verschieben. Zwei zusätzliche Codezeilen stammen aus jedem Endpunkt des Bogens Center. Der Bereich kreisförmigen ist mit dem aktuellen Pinsel gefüllt. Wenn *X3* gleich *X4* und *y3* gleich *y4*, das Ergebnis ist eine Ellipse mit einer einzelnen Zeile der Mittelpunkt der Ellipse auf den Zeitpunkt ( *X3*, *y3*) oder ( *X4*, *y4*).

In der Abbildung gezeichnet, die von dieser Funktion bis zu erweitert, aber es umfasst nicht die rechten und unteren Koordinaten. Dies bedeutet, dass die Höhe der Abbildung *y2* - *y1* und die Breite der Abbildung ist *X2* - *X1*. Sowohl die Breite und die Höhe des umschließenden Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

##  <a name="playmetafile"></a>  CDC::PlayMetaFile

Gibt den Inhalt der angegebenen Metadatei auf den Gerätekontext wieder.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parameter

*hMF*<br/>
Identifiziert die Metadatei wiedergegeben werden soll.

*hEnhMetaFile*<br/>
Identifiziert die erweiterte Metadatei an.

*lpBounds*<br/>
Verweist auf eine `RECT` Struktur oder ein `CRect` -Objekt, die Koordinaten des umgebenden Rechtecks verwendet enthält, um das Bild anzuzeigen. Die Koordinaten werden in logischen Einheiten angegeben.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die Metadatei kann oft wiedergegeben werden.

Die zweite Version der `PlayMetaFile` zeigt das Bild in der angegebenen EMF-Datei gespeichert. Wenn eine Anwendung ruft die zweite Version der `PlayMetaFile`, Windows verwendet den Bild-Frame im EMF-Header an, um das Bild auf die verweist Rectangle Zuordnen der *LpBounds* Parameter. (Dieses Bild ist möglicherweise verbogen oder gedreht werden, indem Sie die globale Transformation in das Ausgabegerät vor dem Aufruf festlegen `PlayMetaFile`.) In der Abbildung sind die Punkte, an den Rändern des Rechtecks enthalten. Ein Bild EMF-kann abgeschnitten werden, durch die Definition des Clippingbereichs in das Ausgabegerät vor der Wiedergabe von der erweiterten Metadatei.

Wenn eine erweiterte Metadatei eine optionale Palette enthält, erzielen eine Anwendung konsistente Farben durch Einrichten einer Farbpalette auf dem Ausgabegerät vor dem Aufrufen der zweiten Version der `PlayMetaFile`. Verwenden Sie zum Abrufen der optionalen Palette der `GetEnhMetaFilePaletteEntries` Windows-Funktion. Eine erweiterte Metadatei kann in eine neu erstellte erweiterte Metadatei eingebettet werden, durch den Aufruf der zweiten Version `PlayMetaFile` und Wiedergabe von der Quelle, die erweiterte Metadatei in den Gerätekontext für das neue erweiterte Metadatei.

Der Status des Gerätekontexts Ausgabe werden von dieser Funktion beibehalten. Ein Objekt erstellt, aber nicht in der erweiterten Metadatei gelöscht wird von dieser Funktion gelöscht. Um diese Funktion zu beenden, kann eine Anwendung Aufrufen der `CancelDC` Windows-Funktion von einem anderen Thread aus, um den Vorgang zu beenden. In diesem Fall gibt die Funktion 0 (null) zurück.

##  <a name="plgblt"></a>  CDC::PlgBlt

Führt einen Bitblocktransfer der Farbdaten Bits auf das angegebene Rechteck, in dem Quellgerätekontext an der angegebenen Parallelogramm im angegebenen Gerätekontext aus.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parameter

*lpPoint*<br/>
Zeigt auf ein Array von drei Punkten in logischer Speicherplatz, der drei Ecken des Zielparallelogramms identifiziert. Der erste Punkt in dieses Array ab, der oberen rechten Ecke zum zweiten Punkt in diesem Array und dem dritten Punkt der unteren linken Ecke wird der linke obere Ecke des Quellrechtecks zugeordnet. Der unteren rechten Ecke des Quellrechtecks wird bis zum vierten implizite Punkt in der Parallelogramm zugeordnet.

*pSrcDC*<br/>
Gibt den Quellgerätekontext an.

*xSrc*<br/>
Gibt die X-Koordinate, in logischen Einheiten, der die linke obere Ecke des Quellrechtecks an.

*ySrc*<br/>
Gibt die y-Koordinate, in logischen Einheiten, der die linke obere Ecke des Quellrechtecks an.

*nWidth*<br/>
Gibt die Breite in logischen Einheiten des Quellrechtecks an.

*nHeight*<br/>
Gibt die Höhe in logischen Einheiten des Quellrechtecks an.

*maskBitmap*<br/>
Gibt eine optionale monochrome Bitmap, die verwendet wird, um die Farben des Quellrechtecks zu maskieren.

*xMask*<br/>
Gibt die X-Koordinate der oberen linken Ecke der monochrome Bitmap an.

*yMask*<br/>
Gibt die y-Koordinate der oberen linken Ecke der monochrome Bitmap an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Wenn das Handle der angegebenen Bitmaske gültige monochrome Bitmap bezeichnet, verwendet die Funktion diese Bitmap zum Maskieren die Bits der Farbdaten vom Quellrechtecks an.

Des vierte Vertex eines Parallelogramms (D) wird definiert, indem Sie behandeln die ersten drei Punkte (A, B und C) als Vektoren und computing D = B + C – A.

Wenn die Bitmaske vorhanden ist, gibt einen Wert 1 in der Maske an, dass die Pixelfarbe Quelle zum Ziel kopiert werden sollen. Der Wert 0 in der Maske gibt an, dass die Pixelfarbe Ziel nicht geändert werden.

Ist das Rechteck Maske kleiner als die Quelle und Ziel Rechtecke, repliziert die Funktion der Maskenmuster.

Skalierung, Verschiebung und Reflektion Transformationen in den Quellgerätekontext zulässig. Allerdings sind Drehungs- und reduzierungen Transformationen nicht. Wenn die Maskenbitmap nicht um eine monochrome Bitmap ist, tritt ein Fehler auf. Der streckmodus für Zielgerätekontext wird verwendet, um zu bestimmen, wie gestreckt oder komprimiert der Pixel, wenn dies erforderlich ist. Wenn eine erweiterte Metadatei aufgezeichnet wird, tritt ein Fehler auf, wenn der Quellgerätekontext eine EMF-Gerätekontext identifiziert.

Die Zielkoordinaten werden gemäß dem Zielgerätekontext umgewandelt. Die Quellkoordinaten werden gemäß dem Quellgerätekontext umgewandelt. Verfügt die Quelle Transformation eine Drehung oder Schub, wird ein Fehler zurückgegeben. Wenn die Rechtecke Ziel- und Quellserver nicht dasselbe Farbformat verfügen `PlgBlt` Quellrechtecks Zielrechtecks entsprechend konvertiert. Nicht alle Geräte unterstützen `PlgBlt`. Weitere Informationen finden Sie unter der Beschreibung der Funktion Raster RC_BITBLT in die `CDC::GetDeviceCaps` Member-Funktion.

Wenn die Quelle und Ziel-Gerätekontexte nicht kompatible Geräte darstellen `PlgBlt` gibt einen Fehler zurück.

##  <a name="polybezier"></a>  CDC::PolyBezier

Zeichnet eine oder mehrere Bzier Splines an.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) -Datenstrukturen, enthalten die Endpunkte und die Punkte der Spline(s) steuern.

*nCount*<br/>
Gibt die Anzahl der Punkte in der *LpPoints* Array. Dieser Wert muss eine mehr als drei Mal die Anzahl der Splines gezeichnet werden, da für jeden Bzier Spline erforderlich ist, zwei Kontrollpunkten und ein Endpunkt und den anfänglichen Spline erfordert einen zusätzlichen Ausgangspunkt.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Diese Funktion zeichnet kubische Bzier Splines mithilfe der Endpunkte und die Control-Punkte, die gemäß der *LpPoints* Parameter. Der erste Spline wird vom ersten Punkt bis zum vierten Punkt mithilfe der zweite und dritte Punkt als Kontrollpunkte gezeichnet. Jede nachfolgende Spline in der Sequenz benötigt genau drei weitere Punkte: den Endpunkt des vorherigen Splines dient als Ausgangspunkt für die nächsten beiden Punkte in der Sequenz sind Kontrollpunkte und die dritte ist der Endpunkt.

Die aktuelle Position ist weder verwendet noch aktualisiert, indem die `PolyBezier` Funktion. In der Abbildung ist nicht ausgefüllt. Diese Funktion zeichnet Zeilen mithilfe des aktuellen Stifts.

##  <a name="polybezierto"></a>  CDC::PolyBezierTo

Zeichnet eine oder mehrere Bzier Splines an.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) verweist-Datenstrukturen, die die Endpunkte und das Steuerelement enthält.

*nCount*<br/>
Gibt die Anzahl der Punkte in der *LpPoints* Array. Dieser Wert muss drei Mal die Anzahl der Splines gezeichnet werden soll, sein, da für jeden Bzier Spline zwei Kontrollpunkten und ein Endpunkt erforderlich ist.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Diese Funktion zeichnet kubische Bzier Splines unter Verwendung von der Control-Punkte, die gemäß der *LpPoints* Parameter. Der erste Spline wird von der aktuellen Position dem dritten Punkt mit die ersten beiden Punkte als Kontrollpunkte gezeichnet. Für jeden nachfolgenden Spline die Funktion benötigt genau drei weitere Punkte, und verwendet den Endpunkt des vorherigen Splines als Ausgangspunkt für die nächsten. `PolyBezierTo` Verschiebt die aktuelle Position zum Endpunkt für den letzten Bzier Spline. In der Abbildung ist nicht ausgefüllt. Diese Funktion zeichnet Zeilen mithilfe des aktuellen Stifts.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CDC:: beginpath](#beginpath).

##  <a name="polydraw"></a>  CDC::PolyDraw

Zeichnet eine Reihe von Liniensegmenten und Bzier Splines.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) -Datenstrukturen, die für die einzelnen Endpunkte enthält, die Zeile Segment und die Endpunkte und die Kontrollpunkte für jeden Bzier Spline.

*lpTypes*<br/>
Zeigt auf ein Array, der angibt, wie jeder Punkt in der *LpPoints* Array verwendet wird. Die folgenden Werte sind möglich:

- PT_MOVETO gibt an, dass es sich bei diesem Zeitpunkt nicht zusammenhängende Abbildung beginnt. Dieser Punkt wird die neue Position.

- PT_LINETO gibt an, die eine Zeile ist, von der aktuellen Position an diesem Punkt ist gezeichnet werden soll, klicken Sie dann die neue Position wird.

- PT_BEZIERTO gibt an, dass es sich bei dieser Punkt einer Steuerungspunkts für das oder der Endpunkt für ein Spline Bzier ist.

PT_BEZIERTO Typen an, die immer in Sätze von drei auftreten. Die aktuelle Position definiert den Ausgangspunkt für die Bzier Spline. Die ersten beiden PT_BEZIERTO Punkte sind die Steuerpunkte, und der dritte PT_BEZIERTO-Punkt ist den Endpunkt. Der Endpunkt wird die neue Position. Wenn keine drei aufeinander folgende PT_BEZIERTO Punkte sind, tritt ein Fehler auf.

   Ein PT_LINETO oder PT_BEZIERTO Typ mit der folgenden Konstanten mit dem bitweisen Operator kombiniert werden kann, oder um anzugeben, dass es sich bei der entsprechende Punkt der letzte Punkt in der Abbildung und in der Abbildung ist geschlossen werden:

- PT_CLOSEFIGURE gibt an, die in der Abbildung wird automatisch geschlossen, nachdem die PT_LINETO oder PT_BEZIERTO-Typ für diesen Punkt erfolgt. An diesem Punkt ist eine Linie gezeichnet, um die neuesten PT_MOVETO oder `MoveTo` zeigen.

   Dieses Flag ist kombiniert mit dem PT_LINETO-Typ für eine Zeile oder mit dem PT_BEZIERTO Endpunkt für eine Splinekurve Bzier unter Verwendung des bitweisen **OR** Operator. Die aktuelle Position ist auf den Endpunkt, der die abschließende Zeile festgelegt.

*nCount*<br/>
Gibt die Gesamtanzahl der Punkte in der *LpPoints* identisch mit der Anzahl der Bytes im array der *LpTypes* Array.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Diese Funktion kann verwendet werden, zum Zeichnen von nicht zusammenhängenden Zahlen anstelle von aufeinander folgende Aufrufe von `CDC::MoveTo`, `CDC::LineTo`, und `CDC::PolyBezierTo` Memberfunktionen. Der Linien und Splines unter Verwendung des aktuellen Stifts gezeichnet werden, und Zahlen werden nicht aufgefüllt. Es ist der aktive Pfad durch den Aufruf gestartet der `CDC::BeginPath` Memberfunktion `PolyDraw` fügt dem Pfad hinzu. Die Punkte, die in enthaltenen der *LpPoints* Array und im *LpTypes* gibt an, ob jeder Punkt gehört eine `CDC::MoveTo`, `CDC::LineTo`, oder ein `CDC::BezierTo` Vorgang. Es ist auch möglich, Formen zu schließen. Diese Funktion aktualisiert die aktuelle Position.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CDC:: beginpath](#beginpath).

##  <a name="polygon"></a>  CDC::Polygon

Zeichnet ein Vieleck, bestehend aus zwei oder mehr Punkten (Scheitelpunkte) von Zeilen, die mit dem aktuellen Stift verbunden.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein Array von Punkten, die die Eckpunkte des Vielecks angibt. Jeder Punkt im Array ist ein `POINT` Struktur oder ein `CPoint` Objekt.

*nCount*<br/>
Gibt die Anzahl der Scheitelpunkte im Array an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Das System des Polygons wird automatisch geschlossen, falls erforderlich, durch eine Linie zwischen dem letzten Scheitelpunkt mit dem ersten.

Der aktuelle Polygon-füllen-Modus kann abgerufen oder festgelegt werden, mithilfe der `GetPolyFillMode` und `SetPolyFillMode` Memberfunktionen.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

##  <a name="polyline"></a>  CDC::Polyline

Zeichnet eine Reihe von Liniensegmenten, die zwischen den Punkten, die anhand des *LpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Verweist auf ein Array von `POINT` Strukturen oder `CPoint` Objekten verbunden werden.

*nCount*<br/>
Gibt die Anzahl der Punkte im Array an. Dieser Wert muss mindestens 2 sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die Zeilen stammen aus den ersten Punkt über die nachfolgenden Punkte, die mit dem aktuellen Stift. Im Gegensatz zu den `LineTo` Member-Funktion, die `Polyline` Funktion weder verwendet noch aktualisiert die aktuelle Position.

Weitere Informationen finden Sie unter [Polylinie](/windows/desktop/api/wingdi/nf-wingdi-polyline) im Windows SDK.

##  <a name="polylineto"></a>  CDC::PolylineTo

Zeichnet eine oder mehrere gerade Linien an.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Verweist auf ein Array von [Punkt](../../mfc/reference/point-structure1.md) -Datenstrukturen, die den Vertices für die Zeile enthält.

*nCount*<br/>
Gibt die Anzahl der Punkte im Array an.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Wird eine Linie von der aktuellen Position und dem ersten Punkt, der gemäß der *LpPoints* Parameter, indem der aktuelle Stift. Für jede zusätzliche Zeile zeichnet die Funktion aus den Endpunkt der vorherigen Zeile zum nächsten Punkt gemäß *LpPoints*. `PolylineTo` Verschiebt die aktuelle Position zum Endpunkt der letzten Zeile an. Wenn die Liniensegmente gezeichnet, die von dieser Funktion eine geschlossene Form bilden, wird in der Abbildung nicht ausgefüllt.

##  <a name="polypolygon"></a>  CDC::PolyPolygon

Erstellt zwei oder mehreren Polygonen, die mit den aktuellen Modus des Polygons füllenden gefüllt sind.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Verweist auf ein Array von `POINT` Strukturen oder `CPoint` Objekte, die den Vertices für die Polygone definieren.

*lpPolyCounts*<br/>
Zeigt auf ein Array von ganzen Zahlen, von denen jeder gibt an, die Anzahl der Punkte in einem der Polygone in der *LpPoints* Array.

*nCount*<br/>
Die Anzahl der Einträge in der *LpPolyCounts* Array. Diese Zahl gibt die Anzahl von Polygonen, gezeichnet werden soll. Dieser Wert muss mindestens 2 sein.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die Polygone können zusammenhanglos oder überlappende sein.

Jedes Polygon angegeben, die in einem Aufruf der `PolyPolygon` Funktion muss geschlossen werden. Im Gegensatz zu Polygonen erstellt die `Polygon` Member-Funktion, die Polygone, die von erstellten `PolyPolygon` werden nicht automatisch geschlossen.

Die Funktion erstellt zwei oder mehreren Polygonen. Um ein einzelnes Polygon zu erstellen, eine Anwendung verwenden, sollten die `Polygon` Member-Funktion.

Der aktuelle Polygon-füllen-Modus kann abgerufen oder festgelegt werden, mithilfe der `GetPolyFillMode` und `SetPolyFillMode` Memberfunktionen.

##  <a name="polypolyline"></a>  CDC::PolyPolyline

Zeichnet mehrere Reihe verbundener Liniensegmente.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parameter

*lpPoints*<br/>
Zeigt auf ein Array von Strukturen, die den Vertices für die Polylinien enthält. Die Polylinien werden nacheinander angegeben.

*lpPolyPoints*<br/>
Verweist auf ein Array von Variablen gibt die Anzahl der Punkte in der *LpPoints* Array für das entsprechende Polygon. Jeder Eintrag muss größer als oder gleich 2 sein.

*nCount*<br/>
Gibt die Gesamtanzahl der Zahlen in der *LpPolyPoints* Array.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die Liniensegmente werden mit dem aktuellen Stift gezeichnet. Die Abbildungen, die durch die Segmente gebildet werden nicht aufgefüllt. Die aktuelle Position ist weder verwendet noch von dieser Funktion aktualisiert.

##  <a name="ptvisible"></a>  CDC::PtVisible

Bestimmt, ob der angegebene Punkt innerhalb der Ausschneidebereich des Gerätekontexts befindet.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate des Punkts an.

*y*<br/>
Gibt die logische y-Koordinate des Punkts an.

*Zeigen Sie*<br/>
Legt den Punkt in logischen Koordinaten zu überprüfen. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn der angegebene Punkt befindet sich innerhalb des Clippingbereichs; andernfalls 0.

##  <a name="queryabort"></a>  CDC::QueryAbort

Ruft die Abort-Funktion installiert, indem Sie die [SetAbortProc](#setabortproc) Memberfunktion für eine Anwendung zum Drucken und Abfragen, ob das Drucken beendet werden soll.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Rückgabewert

Der zurückgegebene Wert ist ungleich NULL, wenn Drucken fortgesetzt werden soll oder wenn kein Abbruch Prozedur vorhanden ist. Es ist 0, wenn der Druckauftrag beendet werden sollen. Der zurückgegebene Wert wird durch die Abort-Funktion bereitgestellt.

##  <a name="realizepalette"></a>  CDC::RealizePalette

Ordnet Einträge aus der aktuellen logischen Palette der Systempalette an.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Rückgabewert

Gibt an, wie viele Einträge in der logischen Palette auf andere Einträge in der Systempalette zugeordnet wurden. Dies stellt die Anzahl von Einträgen, die diese Funktion neu zugeordnet, um Änderungen in der Systempalette aufzunehmen, seit Sie zuletzt die logische Palette realisiert wurde.

### <a name="remarks"></a>Hinweise

Eine logische Farbpalette fungiert als Puffer zwischen Farbe-Intensive Anwendungen und das System, dem eine Anwendung verwenden, wie viele Farben je nach Bedarf, ohne Beeinträchtigung durch einen eigenen Farben angezeigt oder mit Farben, die von anderen Fenstern angezeigt.

Wenn ein Fenster hat, den Eingabefokus und ruft `RealizePalette`, Windows wird sichergestellt, dass das Fenster alle angeforderten Farben, bis die maximale Anzahl gleichzeitig zur Verfügung gestellt, auf dem Bildschirm angezeigt werden. Windows zeigt auch die Farben des Fensters Palette vom Abgleich mit der verfügbaren Farben nicht gefunden.

Darüber hinaus entspricht Windows die Farben von inaktiven Fenstern, die die Funktion so weit wie möglich auf die verfügbaren Farben aufrufen angefordert. Dies reduziert wesentlich unerwünschte Änderungen an der Farben in inaktiven Fenstern angezeigt.

##  <a name="rectangle"></a>  CDC::Rectangle

Zeichnet ein Rechteck mit dem aktuellen Stift.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die X-Koordinate von der linken oberen Ecke des Rechtecks (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate von der linken oberen Ecke des Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die X-Koordinate von der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*Y2*<br/>
Gibt die y-Koordinate von der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*lpRect*<br/>
Gibt das Rechteck in logischen Einheiten. Sie können entweder übergeben eine `CRect` Objekt oder ein Zeiger auf eine `RECT` Struktur für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Das Innere des Rechtecks wird mit dem aktuellen Pinsel gefüllt.

Das Rechteck ist erweitert, bis zu jedoch nicht enthalten, die rechten und unteren Koordinaten. Dies bedeutet, dass die Höhe des Rechtecks *y2* - *y1* und die Breite des Rechtecks ist *X2* - *X1*. Sowohl die Breite und die Höhe eines Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

##  <a name="rectvisible"></a>  CDC::RectVisible

Bestimmt, ob ein Teil im angegebenen Rechteck innerhalb der Ausschneidebereich den Anzeigekontext liegt.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parameter

*lpRect*<br/>
Verweist auf eine `RECT` Struktur oder ein `CRect` Objekt, das die logischen Koordinaten des angegebenen Rechtecks enthält.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn alle Teil des angegebenen Rechtecks liegt innerhalb des Clippingbereichs; andernfalls 0.

##  <a name="releaseattribdc"></a>  CDC::ReleaseAttribDC

Rufen Sie diese Memberfunktion festzulegende `m_hAttribDC` auf NULL.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Hinweise

Dies führt nicht dazu, dass eine `Detach` auftreten. Nur die Ausgabe-Gerätekontext angefügt ist die `CDC` und nur getrennt werden können.

##  <a name="releaseoutputdc"></a>  CDC::ReleaseOutputDC

Rufen Sie diese Memberfunktion Festlegen der `m_hDC` Datenmember auf NULL.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Hinweise

Diese Memberfunktion kann nicht aufgerufen werden, wenn die Ausgabe-Gerätekontext an angefügt ist die `CDC` Objekt. Verwenden der `Detach` Memberfunktion versucht, den Ausgabe-Gerätekontext zu trennen.

##  <a name="resetdc"></a>  CDC::ResetDC

Rufen Sie diese Memberfunktion um den Gerätekontext, die vom Aktualisieren der `CDC` Objekt.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parameter

*lpDevMode*<br/>
Ein Zeiger auf ein Windows `DEVMODE` Struktur.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Der Gerätekontext wird aktualisiert, aus den Informationen in der Windows `DEVMODE` Struktur. Diese Memberfunktion setzt nur die Attribut-Gerätekontext zurück.

Eine Anwendung wird in der Regel verwenden Sie die `ResetDC` Member-Funktion, die bei der Verarbeitung eines Fensters ein `WM_DEVMODECHANGE` Nachricht. Sie können diese Memberfunktion auch verwenden, um, papierausrichtung oder Papier Klassen beim Drucken eines Dokuments zu ändern.

Sie können nicht diese Memberfunktion verwenden, ändern den Namen, der Gerätename oder Ausgabeport. Wenn der Benutzer die anschlussverbindung oder den Gerätenamen ändert, müssen Sie den ursprünglichen Gerätekontext zu löschen und erstellen einen neuen Gerätekontext mit den neuen Informationen.

Bevor Sie diese Memberfunktion aufrufen, müssen Sie sicherstellen, dass alle Objekte (mit Ausnahme von vordefinierten Objekten), die in den Gerätekontext ausgewählt wurde, ausgewählt wurden.

##  <a name="restoredc"></a>  CDC::RestoreDC

Stellt den Gerätekontext in den vorherigen Zustand identifizierte *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parameter

*nSavedDC*<br/>
Gibt den Gerätekontext, die wiederhergestellt werden. Es kann ein Wert, der von einem vorherigen zurückgegebene sein `SaveDC` Funktionsaufruf. Wenn *nSavedDC* ist-1, die zuletzt gespeicherte Gerätekontext wird wiederhergestellt.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL, wenn der angegebene Kontext wiederhergestellt wurde; andernfalls 0.

### <a name="remarks"></a>Hinweise

`RestoreDC` Stellt den Gerätekontext durch Anzeige von Statusinformationen aus einem Stapel erstellt, die von früheren aufrufen, um die `SaveDC` Member-Funktion.

Der Stapel kann die Statusinformationen für mehrere Gerätekontexte enthalten. Wenn der Kontext angegeben *nSavedDC* ist nicht am Anfang des Stapels `RestoreDC` löscht alle Zustandsinformationen zwischen den Gerätekontext, die anhand des *nSavedDC* und dem oberen Rand des Stapels. Die gelöschte Informationen geht verloren.

##  <a name="roundrect"></a>  CDC::RoundRect

Zeichnet ein Rechteck mit abgerundeten Ecken, die mit dem aktuellen Stift.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parameter

*x1*<br/>
Gibt die X-Koordinate von der linken oberen Ecke des Rechtecks (in logischen Einheiten) an.

*y1*<br/>
Gibt die y-Koordinate von der linken oberen Ecke des Rechtecks (in logischen Einheiten) an.

*x2*<br/>
Gibt die X-Koordinate von der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*Y2*<br/>
Gibt die y-Koordinate von der unteren rechten Ecke des Rechtecks (in logischen Einheiten) an.

*x3*<br/>
Gibt die Breite der Ellipse, die zum Zeichnen der abgerundeten Ecken (in logischen Einheiten) verwendet.

*Y3*<br/>
Gibt die Höhe der Ellipse, die zum Zeichnen der abgerundeten Ecken (in logischen Einheiten) verwendet.

*lpRect*<br/>
Gibt das umschließende Rechteck in logischen Einheiten. Sie können entweder übergeben eine `CRect` Objekt oder ein Zeiger auf eine `RECT` Struktur für diesen Parameter.

*Zeigen Sie*<br/>
Die X-Koordinate der *zeigen* gibt die Breite der Ellipse zum Zeichnen der abgerundeten Ecken (in logischen Einheiten). Die y-Koordinate der *zeigen* gibt die Höhe der Ellipse zum Zeichnen der abgerundeten Ecken (in logischen Einheiten) an. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Das Innere des Rechtecks wird mit dem aktuellen Pinsel gefüllt.

In der Abbildung, die diese Funktion zeichnet bis erweitert, aber es umfasst nicht die rechten und unteren Koordinaten. Dies bedeutet, dass die Höhe der Abbildung *y2* - *y1* und die Breite der Abbildung ist *X2* - *X1*. Sowohl die Höhe und die Breite des umschließenden Rechtecks müssen größer als 2 Einheiten und weniger als 32.767 Einheiten sein.

### <a name="example"></a>Beispiel

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

##  <a name="savedc"></a>  CDC::SaveDC

Speichert den aktuellen Status des Gerätekontexts durch Kopieren von Informationen (z. B. Ausschneidebereich, ausgewählte Objekte und Zuordnungsmodus) ein Kontextstapel von Windows verwaltet wird.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Rückgabewert

Eine ganze Zahl, die gespeicherten Gerätekontext angibt. Es ist 0, wenn ein Fehler auftritt. Dadurch zurückgegeben Wert kann verwendet werden, um den Gerätekontext durch Aufrufen von wiederherstellen `RestoreDC`.

### <a name="remarks"></a>Hinweise

Der gespeicherten Gerätekontext kann später wiederhergestellt werden, indem Sie mithilfe von `RestoreDC`.

`SaveDC` kann eine beliebige Anzahl an, wie oft verwendet, um eine beliebige Anzahl von Gerätekontext Status speichern.

##  <a name="scaleviewportext"></a>  CDC::ScaleViewportExt

Ändert die Viewport-Blöcken Bezug auf die aktuellen Werte.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parameter

*xNum*<br/>
Gibt die Menge mit dem das aktuelle X-Ausmaß multipliziert.

*xDenom*<br/>
Gibt an, wie durch die dividiert des Ergebnis der Multiplikation der aktuelle X-Block den Wert des der *xNum* Parameter.

*yNum*<br/>
Gibt die Menge, mit der aktuellen y-Block multipliziert.

*yDenom*<br/>
Gibt an, wie durch die dividiert des Ergebnis der Multiplikation der aktuellen y-Block den Wert des der *yNum* Parameter.

### <a name="return-value"></a>Rückgabewert

Die vorherigen Viewport-Blöcke (in Geräteeinheiten) als eine `CSize` Objekt.

### <a name="remarks"></a>Hinweise

Die Formeln werden wie folgt geschrieben:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Die neue Viewport-Blöcke werden berechnet, indem die aktuellen Blöcke mit den angegebenen Zähler multipliziert, und klicken Sie dann durch den angegebenen Nenner dividiert.

##  <a name="scalewindowext"></a>  CDC::ScaleWindowExt

Ändert die Fenster-Blöcken Bezug auf die aktuellen Werte.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parameter

*xNum*<br/>
Gibt die Menge mit dem das aktuelle X-Ausmaß multipliziert.

*xDenom*<br/>
Gibt an, wie durch die dividiert des Ergebnis der Multiplikation der aktuelle X-Block den Wert des der *xNum* Parameter.

*yNum*<br/>
Gibt die Menge, mit der aktuellen y-Block multipliziert.

*yDenom*<br/>
Gibt an, wie durch die dividiert des Ergebnis der Multiplikation der aktuellen y-Block den Wert des der *yNum* Parameter.

### <a name="return-value"></a>Rückgabewert

Die vorherigen Fenster Blöcke (in logischen Einheiten) als eine `CSize` Objekt.

### <a name="remarks"></a>Hinweise

Die Formeln werden wie folgt geschrieben:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Das neue Fenster Wertebereiche werden berechnet, indem die aktuellen Blöcke mit den angegebenen Zähler multipliziert, und klicken Sie dann durch den angegebenen Nenner dividiert.

##  <a name="scrolldc"></a>  CDC::ScrollDC

Führt einen Bildlauf um ein Rechteck von Bits, horizontal und vertikal.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parameter

*DX*<br/>
Gibt die Anzahl der Einheiten der horizontalen Bildlaufleiste an.

*dy*<br/>
Gibt die Anzahl der Einheiten für vertikale Bildlaufleiste an.

*lpRectScroll*<br/>
Verweist auf die `RECT` Struktur oder `CRect` -Objekt, das die Koordinaten des Rechtecks Bildlauf enthält.

*lpRectClip*<br/>
Verweist auf die `RECT` Struktur oder `CRect` -Objekt, das die Koordinaten des Rechtecks Clipping enthält. Wenn dieses Rechteck ist kleiner als das Original einer verweist *LpRectScroll*, Durchführen eines Bildlaufs tritt nur in kleinere Rechtecks.

*pRgnUpdate*<br/>
Die Region, die durch den fortlaufenden Prozess im Detail angibt. Die `ScrollDC` Funktion dieser Bereich definiert; er bezeichnet nicht unbedingt ein Rechteck.

*lpRectUpdate*<br/>
Verweist auf die `RECT` Struktur oder `CRect` Objekt, das die Koordinaten des Rechtecks empfängt, das Update Bildlaufbereich umschließt. Dies ist die größte rechteckigen Bereichs, der neu gezeichnet ist erforderlich. Die Werte in der Struktur oder das Objekt bei Rückgabe der Funktion sind in Clientkoordinaten, unabhängig von der Zuordnungsmodus für den angegebenen Gerätekontext.

### <a name="return-value"></a>Rückgabewert

Ungleich NULL ist, wenn ein Bildlauf ausgeführt wird; andernfalls 0.

### <a name="remarks"></a>Hinweise

Wenn *LpRectUpdate* NULL ist, berechnet Windows nicht das Update-Rechteck. Wenn beide *pRgnUpdate* und *LpRectUpdate* NULL sind, berechnet Windows nicht dem Aktualisierungsbereich. Wenn *pRgnUpdate* ist nicht NULL, Windows wird davon ausgegangen, dass es sich um einen gültigen Zeiger auf die Region, die durch den fortlaufenden Prozess im Detail enthält (definiert durch die `ScrollDC` Member-Funktion). Im zurückgegebenen Aktualisierungsbereich *LpRectUpdate* übergeben werden kann, um `CWnd::InvalidateRgn` bei Bedarf.

Eine Anwendung verwenden, sollten die `ScrollWindow` Memberfunktion der Klasse `CWnd` wann ist den gesamte Clientbereich eines Fensters einen Bildlauf durchführen. Andernfalls muss bei Verwendung `ScrollDC`.

##  <a name="selectclippath"></a>  CDC::SelectClipPath

Wählt den aktuellen Pfad als einen Ausschneidebereich für den Gerätekontext, kombinieren die neue Region mit der alle vorhandenen Ausschneidebereich unter Verwendung des angegebenen Modus.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parameter

*nMode*<br/>
Gibt an, wie den Pfad zu verwenden. Die folgenden Werte sind zulässig:

- RGN_AND den neuen Ausschneidebereich umfasst die Schnittmenge (überlappenden Bereichen) des aktuellen Ausschneidebereichs und der aktuelle Pfad.

- RGN_COPY den neuen Ausschneidebereich ist der aktuelle Pfad.

- RGN_DIFF den neuen Ausschneidebereich enthält die Bereiche des aktuellen Ausschneidebereichs und denen des aktuellen Pfads werden ausgeschlossen.

- RGN_OR den neuen Ausschneidebereich umfasst die Kombination (kombinierten Flächen) des aktuellen Ausschneidebereichs und der aktuelle Pfad.

- RGN_XOR den neuen Ausschneidebereich umfasst die Gesamtmenge des aktuellen Ausschneidebereichs und der aktuelle Pfad, jedoch ohne die überlappenden Bereiche.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Identifiziert den Gerätekontext muss es sich um einen geschlossenen Pfad enthalten.

##  <a name="selectcliprgn"></a>  CDC::SelectClipRgn

Wählt aus den angegebenen Region als aktuelle Ausschneidebereich für den Gerätekontext.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parameter

*PRNG*<br/>
Identifiziert die Region ausgewählt werden.

- Für die erste Version dieser Funktion Wenn dieser Wert NULL ist, der gesamten Clientbereich aktiviert ist und Ausgabe wird an das Fenster immer noch abgeschnitten.

- Die zweite Version dieser Funktion kann dieses Handle kann NULL sein, nur dann, wenn der Modus RGN_COPY angegeben wird.

*nMode*<br/>
Gibt den Vorgang ausgeführt werden. Es muss eine der folgenden Werte sein:

- RGN_AND der neuen Ausschneidebereich kombiniert die überlappenden Bereiche des aktuellen Ausschneidebereichs und der Region identifizierte *PRNG*.

- RGN_COPY der neue Ausschneidebereich ist eine Kopie des identifizierten von *PRNG*. Dies ist eine Funktion ist identisch mit der ersten Version von `SelectClipRgn`. Wenn die Region von identifiziert *PRNG* NULL ist, der neuen Ausschneidebereich wird das Clipping die Standardregion (ein null-Region).

- RGN_DIFF der neuen Ausschneidebereich kombiniert die Bereiche des aktuellen Ausschneidebereichs mit diesen Bereichen, die von der Region identifizierte ausgeschlossen *PRNG*.

- RGN_OR der neuen Ausschneidebereich kombiniert, des aktuellen Ausschneidebereichs und der Region identifizierte *PRNG*.

- RGN_XOR der neuen Ausschneidebereich kombiniert, des aktuellen Ausschneidebereichs und der Region identifizierte *PRNG* jedoch keine sich überschneidenden Bereiche ausschließt.

### <a name="return-value"></a>Rückgabewert

Der Bereichstyp. Eines der folgenden Werte sind möglich:

- Neue COMPLEXREGION Ausschneidebereich hat überlappende Grenzen.

- Fehlerkontext-Gerät oder eine Region ist ungültig.

- Neue NULLREGION Ausschneidebereich ist leer.

- Neue SIMPLEREGION Ausschneidebereich verfügt über keine überlappenden Rahmen.

### <a name="remarks"></a>Hinweise

Es wird nur eine Kopie des ausgewählten Bereichs verwendet. Die Region selbst für eine beliebige Anzahl von anderen Gerätekontexte ausgewählt werden kann, oder er gelöscht werden kann.

Die Funktion wird davon ausgegangen, dass die Koordinaten für den angegebenen Bereich in Geräteeinheiten angegeben werden. Einige Druckergeräte unterstützen, die Ausgabe von Text mit einer höheren Auflösung als Grafikausgabe, um die Genauigkeit erforderlich, um die Textmetrik express beibehalten wird. Diese Geräte melden Geräteeinheiten mit höherer Auflösung, d. h. in Texteinheiten. Diese Geräte skalieren Koordinaten für Grafiken, damit mehrere Einheiten gerätezuordnungen auf nur 1 grafische Einheit gemeldet. Rufen Sie immer die `SelectClipRgn` -Funktion mithilfe von Texteinheiten.

Anwendungen, die ausführen müssen, die Skalierung von Grafikobjekten in GDI können die GETSCALINGFACTOR Druckerescape bestimmt den Skalierungsfaktor. Dieser Faktor für die Skalierung wirkt sich auf Clipping. Wenn eine Region für das Abschneiden von Grafiken verwendet wird, teilt GDI die Koordinaten entsprechend dem Skalierungsfaktor. Wenn die Region für das Abschneiden von Text verwendet wird, wird die GDI keine Skalierung Anpassung. Ein Skalierungsfaktor von 1 bewirkt, dass die Koordinaten durch 2 dividiert wird. ein Skalierungsfaktor von 2 führt dazu, dass die Koordinaten durch 4 geteilt werden soll; Und so weiter.

##  <a name="selectobject"></a>  CDC:: SelectObject

Wählt ein Objekt in den Gerätekontext.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parameter

*pPen*<br/>
Ein Zeiger auf eine [CPen](../../mfc/reference/cpen-class.md) Objekt ausgewählt werden.

*pBrush*<br/>
Ein Zeiger auf eine [CBrush](../../mfc/reference/cbrush-class.md) Objekt ausgewählt werden.

*pFont*<br/>
Ein Zeiger auf eine [CFont](../../mfc/reference/cfont-class.md) Objekt ausgewählt werden.

*pBitmap*<br/>
Ein Zeiger auf eine [CBitmap](../../mfc/reference/cbitmap-class.md) Objekt ausgewählt werden.

*PRNG*<br/>
Ein Zeiger auf eine [CRgn](../../mfc/reference/crgn-class.md) Objekt ausgewählt werden.

*pObject*<br/>
Ein Zeiger auf eine [CGdiObject](../../mfc/reference/cgdiobject-class.md) Objekt ausgewählt werden.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf das Objekt, das ersetzt wird. Dies ist ein Zeiger auf ein Objekt eines abgeleitete `CGdiObject`, z. B. `CPen`, je nachdem welche Version der Funktion verwendet wird. Der Rückgabewert ist NULL, wenn ein Fehler auftritt. Diese Funktion möglicherweise einen Zeiger auf ein temporäres Objekt zurückzugeben. Dieses temporäre Objekt ist nur gültig, während der Verarbeitung einer Windows-Nachricht. Weitere Informationen finden Sie unter `CGdiObject::FromHandle`.

Die Version von der Memberfunktion, die einen Bereichsparameter annimmt, führt die gleiche Aufgabe wie die `SelectClipRgn` Member-Funktion. Der Rückgabewert kann einer der folgenden sein:

- Neue COMPLEXREGION Ausschneidebereich hat überlappende Grenzen.

- Fehlerkontext-Gerät oder eine Region ist ungültig.

- Neue NULLREGION Ausschneidebereich ist leer.

- Neue SIMPLEREGION Ausschneidebereich verfügt über keine überlappenden Rahmen.

### <a name="remarks"></a>Hinweise

Klasse `CDC` enthält fünf Versionen speziell für bestimmte Arten von GDI-Objekte, einschließlich der Pinsel, Stifte, Schriftarten, Bitmaps und Regionen. Das neu ausgewählte Objekt ersetzt das vorherige Objekt desselben Typs. Z. B. wenn *pObject* der die allgemeine Version der `SelectObject` verweist auf eine [CPen](../../mfc/reference/cpen-class.md) Objekt ersetzt die Funktion den aktuellen Stift, mit dem Stift gemäß *pObject* .

Eine Anwendung kann eine Bitmap in Gerätekontexte Arbeitsspeicher nur und nur eine Arbeitsspeicher-Gerätekontext zu einem Zeitpunkt auswählen. Das Format der Bitmap muss Monochrom oder mit den Gerätekontext kompatibel sein; ist dies nicht der Fall, `SelectObject` gibt einen Fehler zurück.

Windows 3.1 und höher die `SelectObject` Funktion derselbe Wert zurückgegeben, ob es in einer Metadatei oder nicht verwendet wird. Unter früheren Versionen von Windows `SelectObject` einen Wert ungleich NULL für den Erfolg und 0 für Fehler zurückgegeben, wenn es in einer Metadatei verwendet wurde.

##  <a name="selectpalette"></a>  CDC::SelectPalette

Wählt die logische Palette, die angegeben wird *pPalette* wie das Palettenobjekt der ausgewählten des Gerätekontexts.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parameter

*pPalette*<br/>
Gibt die logische Palette ausgewählt werden. Diese Palette muss haben bereits mit der `CPalette` Memberfunktion [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).

*bForceBackground*<br/>
Gibt an, ob die logische Palette erzwungen wird, eine Hintergrundpalette sein. Wenn *bForceBackground* ist ungleich NULL ist, die ausgewählten Palette ist immer einer Hintergrundpalette, unabhängig davon, ob das Fenster den Eingabefokus besitzt. Wenn *bForceBackground* gleich 0 ist und der Gerätekontext ein Fenster angefügt ist, die logische Palette ist eine Palette Vordergrund aus, wenn das Fenster den Eingabefokus besitzt.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf eine `CPalette` Objekt, das die logische Palette, die durch die Palette anhand des ersetzt identifiziert *pPalette*. Ist NULL, wenn ein Fehler auftritt.

### <a name="remarks"></a>Hinweise

Die neue Palette der Palette-Objekt, das von GDI verwendet, um steuerelementfarben, die in den Gerätekontext angezeigt wird, und ersetzt die vorherige Palette.

Eine Anwendung kann eine logische Palette in mehr als eine Gerätekontext auswählen. Änderungen an einer logischen Palette wirkt alle Gerätekontexte sich jedoch bei denen es aktiviert ist. Wenn eine Anwendung eine Palette in mehr als eine Gerätekontext auswählt, müssen die Gerätekontexte alle auf demselben physischen Gerät gehören.

##  <a name="selectstockobject"></a>  CDC::SelectStockObject

Wählt eine [CGdiObject](../../mfc/reference/cgdiobject-class.md) Objekt, das eine der vordefinierten vordefinierten Stifte, Pinsel oder Schriftarten entspricht.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parameter

*nIndex*<br/>
Gibt die Art des gewünschten vordefinierten-Objekts. Es kann eine der folgenden Werte sein:

- BLACK_BRUSH schwarzer Pinsel.

- DKGRAY_BRUSH dunkel grauen Pinsel.

- GRAY_BRUSH grauen Pinsel.

- Leerer HOLLOW_BRUSH Pinsel.

- LTGRAY_BRUSH Licht grauen Pinsel.

- NULL_BRUSH Nullpinsel.

- WHITE_BRUSH weiß Pinsel.

- BLACK_PEN Schwarz Stift.

- NULL_PEN Null Stift.

- WHITE_PEN weiß Stift.

- ANSI_FIXED_FONT-ANSI-Systemschriftart behoben.

- Variable ANSI_VAR_FONT ANSI-Systemschriftart.

- DEVICE_DEFAULT_FONT geräteabhängigen Schriftart.

- OEM_FIXED_FONT OEM-abhängige Schriftart behoben.

- SYSTEM_FONT Systemschriftart. In der Standardeinstellung verwendet Windows die Systemschriftart, um Menüs, Dialogfeld-Steuerelemente und anderer Text zu zeichnen. Es wird jedoch empfohlen, nicht, sich auf SYSTEM_FONT zum Abrufen der Schriftart, die für Dialogfelder und Fenster verlassen. Verwenden Sie stattdessen die `SystemParametersInfo` Funktion mit dem Parameter SPI_GETNONCLIENTMETRICS ab, um die aktuelle Schriftart abzurufen. `SystemParametersInfo` berücksichtigt das aktuelle Design sowie Informationen zur Schriftart für Beschriftungen, Menüs und Dialogfelder der Nachricht.

- SYSTEM_FIXED_FONT fester Breite Systemschriftart in Windows verwendet werden, vor der Version 3.0. Dieses Objekt ist für die Kompatibilität mit früheren Versionen von Windows verfügbar.

- Farbpalette DEFAULT_PALETTE Standard. Diese Palette besteht aus den 20 statische Farben der Systempalette.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf die `CGdiObject` -Objekt, das ersetzt wurde, wenn die Funktion erfolgreich ist. Das tatsächliche Objekt verwies auf eine [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), oder [CFont](../../mfc/reference/cfont-class.md) Objekt. Wenn der Aufruf nicht erfolgreich ist, ist der Rückgabewert NULL.

##  <a name="setabortproc"></a>  CDC:: setabortproc

Installiert die Abort-Prozedur für den Druckauftrag an.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parameter

*lpfn*<br/>
Ein Zeiger auf die Abort-Funktion, die als Abbruchvorgangs zu installieren. Weitere Informationen über die Callback-Funktion finden Sie unter [Rückruffunktion für CDC:: setabortproc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Rückgabewert

Gibt das Ergebnis des der `SetAbortProc` Funktion. Einige der folgenden Werte sind wahrscheinlicher als andere, aber alle möglich sind.

- SP_ERROR allgemeiner Fehler.

- SP_OUTOFDISK nicht genügend Speicherplatz auf dem Datenträger steht zurzeit zum Spoolen und keinen Speicherplatz mehr zur Verfügung stehen.

- SP_OUTOFMEMORY nicht genügend Arbeitsspeicher zum Spoolen verfügbar ist.

- SP_USERABORT Benutzer beendet den Auftrag über die Druck-Manager.

### <a name="remarks"></a>Hinweise

Wenn eine Anwendung ist, können den Druckauftrag, während Aufträge abgebrochen werden soll, muss er die Abort-Funktion festgelegt, bevor der Druckauftrag mit gestartet wird die [StartDoc](#startdoc) Member-Funktion. Der Druck-Manager ruft die Abort-Funktion während der Aufträge, damit die Anwendung, die den Druckauftrag abbrechen oder Out-von-Speicherplatz verarbeiten kann. Wenn keine Abort-Funktion festgelegt ist, schlägt der Druckauftrag, wenn es nicht genügend Speicherplatz zum Spoolen ist.

Beachten Sie, dass die Funktionen von Microsoft Visual C++ das Erstellen, die an die Callback-Funktion vereinfachen `SetAbortProc`. Die Adresse übergeben, um die `EnumObjects` Member-Funktion ist ein Zeiger auf eine Funktion, die mit exportierten `__declspec(dllexport)` und mit der `__stdcall` Aufrufkonvention.

Keine Sie auch den Funktionsnamen im Exportieren einer **EXPORTE** -Anweisung in DEF-Datei von Ihrer Anwendung. Sie können stattdessen verwenden die **EXPORTIEREN** Modifizierer funktionieren, wie in

**"Bool" RÜCKRUF EXPORT** AFunction ( **HDC**, `int` **);**

den Compiler den ordnungsgemäßen Export-Datensatz für den Export nach Namen ohne Aliasing ausgeben zu verursachen. Dies funktioniert für die häufigsten Anforderungen. Für einige Sonderfälle, z. B. eine Funktion nach Ordnungszahl oder Aliasing exportieren exportieren, Sie weiterhin verwenden müssen eine **EXPORTE** -Anweisung in eine DEF-Datei.

Registrierung von Rückrufschnittstellen sind jetzt als typsicherer (Sie müssen in einen Funktionszeiger, der auf die richtige Art von Funktion, die für den bestimmten Rückruf zeigt übergeben).

Beachten Sie außerdem, dass alle Rückruffunktionen vor der Rückgabe auf Windows, da Ausnahmen hinweg Rückruf ausgelöst werden, können nicht Microsoft Foundation Ausnahmen abfangen müssen. Weitere Informationen zu Ausnahmen finden Sie im Artikel [Ausnahmen](../../mfc/exception-handling-in-mfc.md).

##  <a name="setarcdirection"></a>  CDC::SetArcDirection

Richtung für das Zeichnen für Bogen und Rechteck Funktionen verwendet werden.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parameter

*nArcDirection*<br/>
Gibt die neue Richtung der Bogen an. Dieser Parameter kann einen der folgenden Werte sein:

- AD_COUNTERCLOCKWISE Abbildungen, die gegen den Uhrzeigersinn gezeichnet.

- AD_CLOCKWISE Abbildungen, die im Uhrzeigersinn gezeichnet.

### <a name="return-value"></a>Rückgabewert

Gibt die alte Bogen Richtung an, bei erfolgreicher Ausführung; andernfalls 0.

### <a name="remarks"></a>Hinweise

Die standardrichtung ist gegen den Uhrzeigersinn. Die `SetArcDirection` -Funktion gibt die Richtung, in dem Sie die folgenden Zeichnen-Befehl Funktionen, an:

|Einen Bogen konvertiert.|Segment|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

##  <a name="setattribdc"></a>  CDC::SetAttribDC

Mit dieser Funktion wird zum Festlegen der Attribut-Gerätekontext, `m_hAttribDC`.

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parameter

*hDC*<br/>
Einen Windows-Gerätekontext.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion wird nicht den Gerätekontext zu angefügt der `CDC` Objekt. Nur die Ausgabe-Gerätekontext angefügt ist eine `CDC` Objekt.

##  <a name="setbkcolor"></a>  CDC::SetBkColor

Legt die aktuelle Hintergrundfarbe auf die angegebene Farbe fest.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crColor*<br/>
Die neue Hintergrundfarbe angibt.

### <a name="return-value"></a>Rückgabewert

Die vorherigen Hintergrundfarbe als ein RGB-Farbwert. Wenn ein Fehler auftritt, ist der Rückgabewert 0 x 80000000.

### <a name="remarks"></a>Hinweise

Wenn der Hintergrundmodus DECKEND ist, verwendet das System die Hintergrundfarbe zum Füllen der Lücken in formatierte Zeilen, die Lücken zwischen schraffierten Linien in Pinsel und den Hintergrund des Zeichenzellen an. Das System verwendet außerdem die Farbe des Hintergrunds beim Konvertieren von Bitmaps zwischen Farbe und monochromen Gerätekontexte.

Wenn das Gerät kann nicht die angegebene Farbe angezeigt wird, setzt das System die Hintergrundfarbe auf die nächste physische Farbe.

##  <a name="setbkmode"></a>  CDC::SetBkMode

Legt den Hintergrundmodus fest.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parameter

*nBkMode*<br/>
Gibt den Modus festgelegt werden. Dieser Parameter kann einen der folgenden Werte sein:

- Nicht TRANSPARENTER Hintergrund ist mit der aktuellen Hintergrundfarbe vor dem Text, schraffierten Pinsels, gefüllt oder Stifts gezeichnet wird. Dies ist der Standardmodus für den Hintergrund.

- TRANSPARENTER Hintergrund ist vor dem Zeichnen nicht geändert werden.

### <a name="return-value"></a>Rückgabewert

Der vorherige Hintergrundmodus.

### <a name="remarks"></a>Hinweise

Der Hintergrundmodus definiert, ob das System vorhandene Hintergrundfarben auf die Zeichenoberfläche entfernt vor dem Zeichnen von Text, schraffierten Pinsel oder jede Pen-Formatvorlage, die keine durchgehende Linie ist.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="setboundsrect"></a>  CDC::SetBoundsRect

Steuert die Ansammlung von umgebenden Rechteck-Informationen für den angegebenen Gerätekontext.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parameter

*lpRectBounds*<br/>
Verweist auf eine `RECT` Struktur oder `CRect` -Objekt, das zum Festlegen des umschließenden Rechtecks verwendet wird. Rechteck Dimensionen werden in logischen Koordinaten angegeben. Dieser Parameter kann NULL sein.

*flags*<br/>
Gibt an, wie das neue Rechteck mit dem kumulierten Rechteck kombiniert werden. Dieser Parameter kann eine Kombination der folgenden Werte sein:

- DCB_ACCUMULATE hinzufügen anhand des Rechtecks *LpRectBounds* auf das umschließende Rechteck (mit einem Rechteck-Union-Vorgang).

- DCB_DISABLE deaktivieren Ansammlung von Grenzen aus.

- DCB_ENABLE Grenzen Accumulation / aktivieren. (Die Standardeinstellung für Grenzen Accumulation / ist deaktiviert.)

### <a name="return-value"></a>Rückgabewert

Der aktuelle Status des umschließenden Rechtecks, wenn die Funktion erfolgreich ist. Wie *Flags*, der Rückgabewert kann eine Kombination sein **DCB_** Werte:

- DCB_ACCUMULATE das umschließende Rechteck ist nicht leer. Dieser Wert wird immer festgelegt werden.

- DCB_DISABLE Grenzen Accumulation / ist deaktiviert.

- DCB_ENABLE Grenzen Accumulation / ist.

### <a name="remarks"></a>Hinweise

Windows kann ein umschließendes Rechteck für alle Zeichenoperationen verwalten. Dieses Rechteck kann zurücksetzen, indem Sie die Anwendung und abgefragt werden. Die Begrenzungen für das Zeichnen sind nützlich für das Bitmap-Caches für ungültig zu erklären.

##  <a name="setbrushorg"></a>  CDC::SetBrushOrg

Gibt die Ursprungsdomäne, die GDI auf den nächsten Pinsel zuweist, die die Anwendung in den Gerätekontext auswählt.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die X-Koordinate (in Geräteeinheiten) der neuen Ursprung an. Dieser Wert muss im Bereich von 0 bis 7 sein.

*y*<br/>
Gibt die y-Koordinate (in Geräteeinheiten) der neuen Ursprung an. Dieser Wert muss im Bereich von 0 bis 7 sein.

*Zeigen Sie*<br/>
Gibt an, die x- und y-Koordinaten des neuen Ursprungs. Jeder Wert muss im Bereich von 0 bis 7 sein. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Der vorherige Ursprung des Pinsels in Geräteeinheiten.

### <a name="remarks"></a>Hinweise

Der Standardwert für den Ursprung des Pinsels koordiniert werden (0, 0). Aufrufen, um den Ursprung eines Pinsels ändern zu können, die `UnrealizeObject` für funktionsfähig sein, die `CBrush` Objekt, rufen Sie `SetBrushOrg`, und rufen Sie dann die `SelectObject` Memberfunktion, um den Pinsel für den Gerätekontext wählen.

Verwenden Sie keine `SetBrushOrg` mit Stock `CBrush` Objekte.

##  <a name="setcoloradjustment"></a>  CDC::SetColorAdjustment

Legt die Farbe Anpassungswerte für den Gerätekontext, die mit den angegebenen Werten.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parameter

*lpColorAdjust*<br/>
Verweist auf eine [COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md) Datenstruktur, die die Anpassung Farbwerte enthält.

### <a name="return-value"></a>Rückgabewert

Ungleich Null, wenn erfolgreich, andernfalls 0 (Null).

### <a name="remarks"></a>Hinweise

Die Anpassung Farbwerte werden verwendet, um passen Sie die Eingabefarbe des Quellbitmaps für Aufrufe an die `CDC::StretchBlt` Memberfunktion Halbtonmodus festgelegt ist.

##  <a name="setdcbrushcolor"></a>  CDC::SetDCBrushColor

Legt die aktuelle Pinselfarbe Geräts Gerätekontext (DC) auf den Wert der angegebenen Farbe fest.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crColor*<br/>
Gibt an, die neue Farbe des Pinsels.

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, gibt der Rückgabewert der vorherige Farbe des Hintergrundpinsels DC als COLORREF Wert.

Wenn die Funktion fehlschlägt, ist der Rückgabewert CLR_INVALID an.

### <a name="remarks"></a>Hinweise

Diese Methode emuliert die Funktionen der Funktion [SetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-setdcbrushcolor), wie im Windows SDK beschrieben.

##  <a name="setdcpencolor"></a>  CDC::SetDCPenColor

Legt die aktuelle Stiftfarbe für Geräts Gerätekontext (DC) auf den Wert der angegebenen Farbe fest.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crColor*<br/>
Gibt an, die neue Stiftfarbe.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Diese Memberfunktion verwendet die Win32-Funktion [SetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-setdcpencolor), wie im Windows SDK beschrieben.

##  <a name="setgraphicsmode"></a>  CDC::SetGraphicsMode

Legt den Modus "Graphics" für den angegebenen Gerätekontext.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parameter

*iMode*<br/>
Gibt den Grafikmodus. Eine Liste der Werte, die für diesen Parameter, finden Sie unter [SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Rückgabewert

Gibt den alten Grafikmodus bei Erfolg zurück.

Gibt 0 bei einem Fehler zurück. Um erweiterte Fehlerinformationen abzurufen, rufen Sie [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Hinweise

Diese Methode dient als Wrapper für die Windows-GDI-Funktion [SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode).

##  <a name="setlayout"></a>  CDC::SetLayout

Rufen Sie diese Memberfunktion, um das Layout von Text und Grafiken für einen Gerätekontext nach rechts nach links ist; das Standardlayout für Kulturen wie Arabisch und Hebräisch zu ändern.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parameter

*dwLayout*<br/>
Gerät Kontextlayout und die Bitmap Steuerungsflags. Sie können eine Kombination der folgenden Werte sein.

|Wert|Bedeutung|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Deaktiviert alle Reflektion für Aufrufe von [CDC:: BitBlt](#bitblt) und [CDC::StretchBlt](#stretchblt).|
|LAYOUT_RTL|Legt fest, das horizontale Standardlayout werden von rechts nach links orientiert.|
|LAYOUT_LTR|Legt fest, das Standardlayout, links nach rechts ausgewertet werden.|

### <a name="return-value"></a>Rückgabewert

Bei erfolgreicher Ausführung dem vorherigen Layout des Gerätekontexts.

Wenn Fehler auftreten, GDI_ERROR. Um erweiterte Fehlerinformationen abzurufen, rufen Sie [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Hinweise

Normalerweise würden Sie nicht aufrufen `SetLayout` für ein Fenster. Stattdessen durch Festlegen der rechts-nach-links-Layout in einem Fenster steuern die [erweiterte Fensterstile](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) wie z. B. WS_EX_RTLREADING. Dieses Layout ein Gerätekontext, z. B. ein Drucker oder eine Metadatei nicht geerbt. Die einzige Möglichkeit, den Gerätekontext legen Sie für eine rechts-nach-links-Layout durch den Aufruf ist `SetLayout`.

Wenn Sie aufrufen **SetLayout (LAYOUT_RTL** ), `SetLayout` automatisch den Zuordnungsmodus in MM_ISOTROPIC geändert. Als Ergebnis ein nachfolgender Aufruf von [GetMapMode](#getmapmode) MM_ISOTROPIC statt MM_TEXT zurück.

In einigen Fällen sollten wie z. B. mit vielen Bitmaps, Sie das links-nach-rechts-Layout beibehalten. In diesen Fällen das Bild zu rendern durch Aufrufen von `BitBlt` oder `StretchBlt`, legen Sie dann auf die Bitmap für protokollierungssteuerungs-Flag für *DwLayout* zu LAYOUT_BITMAPORIENTATIONPRESERVED.

Sobald Sie das Layout mit dem Flag LAYOUT_RTL geändert wurde, werden die Flags, die normalerweise angeben rechten oder linken rückgängig gemacht. Um Verwirrung zu vermeiden, empfiehlt es sich um alternativen Namen für die standard-Flags zu definieren. Eine Liste der Namen vorgeschlagenen alternativen markieren, finden Sie unter [SetLayout](/windows/desktop/api/wingdi/nf-wingdi-setlayout) im Windows SDK.

##  <a name="setmapmode"></a>  CDC::SetMapMode

Legt den Zuordnungsmodus.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parameter

*nMapMode*<br/>
Gibt den neuen Zuordnungsmodus an. Eine der folgenden Werte sind möglich:

- MM_ANISOTROPIC logische Einheiten werden in beliebigen Einheiten mit beliebig skaliert Achsen konvertiert. Festlegen der Zuordnungsmodus, MM_ANISOTROPIC ändert sich nicht auf die aktuellen Einstellungen für Fenster oder der Viewport aus. Ausrichtung und die Skalierung aufrufen, um die Einheiten zu ändern, die [SetWindowExt](#setwindowext) und [SetViewportExt](#setviewportext) Memberfunktionen.

- MM_HIENGLISH jeder logischen Einheit wird in 0,001 Zoll konvertiert. Positive x ist auf der rechten Seite. positive y ist aktiv.

- MM_HIMETRIC jeder logischen Einheit wird in 0,01 Millimeter konvertiert. Positive x ist auf der rechten Seite. positive y ist aktiv.

- MM_ISOTROPIC logische Einheiten werden mit den gleichmäßig skalierten Achsen auf beliebige Einheiten konvertiert. 1 Einheit entlang der x-Achse entspricht, also 1 Einheit entlang der y-Achse. Verwenden der `SetWindowExt` und `SetViewportExt` Memberfunktionen Geben Sie die gewünschte Einheiten und die Ausrichtung der Achsen. GDI werden Anpassungen in Schritten nach Bedarf um sicherzustellen, dass die x- und y-Einheiten bleiben die gleiche Größe.

- MM_LOENGLISH jeder logischen Einheit wird in 0,01 Zoll konvertiert. Positive x ist auf der rechten Seite. positive y ist aktiv.

- MM_LOMETRIC jeder logischen Einheit wird in 0,1 Millimeter konvertiert. Positive x ist auf der rechten Seite. positive y ist aktiv.

- MM_TEXT jeder logischen Einheit wird in 1 Gerätepixel konvertiert. Positive x ist auf der rechten Seite. positive y ist nicht verfügbar.

- MM_TWIPS jeder logischen Einheit wird in 1/20, eines Punkts konvertiert. (Da ein Punkt 1/72 Zoll ist, ist eine Twips 1/1440 Zoll). Positive x ist auf der rechten Seite. positive y ist aktiv.

### <a name="return-value"></a>Rückgabewert

Der vorherige Zuordnungsmodus.

### <a name="remarks"></a>Hinweise

Der Zuordnungsmodus definiert, die Maßeinheit, die zum Konvertieren von logischer Einheiten in Geräteeinheiten verwendet wird. Außerdem wird die Ausrichtung des Geräts in dessen x- und y-Achse definiert. GDI verwendet den Zuordnungsmodus zum Konvertieren von logischer Koordinaten in der entsprechenden Gerätekoordinaten. Der MM_TEXT-Modus ermöglicht es Anwendungen in Pixeln, wobei 1 Einheit gleich 1-Pixel. Die physische Größe eines Pixels variiert je nach Gerät.

Die Modi MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC und MM_TWIPS eignen sich für Anwendungen, die physisch von Bedeutung Einheiten (z. B. Zoll oder Millimeter) abrufen müssen. Der Modus MM_ISOTROPIC stellt sicher ein Seitenverhältnis 1:1, was nützlich ist, es wichtig ist, die genaue Form eines Bildes beibehalten. Der MM_ANISOTROPIC-Modus ermöglicht die x- und y-Koordinaten unabhängig voneinander angepasst werden.

> [!NOTE]
>  Wenn Sie aufrufen [SetLayout](#setlayout) so ändern Sie den DC (Gerätekontext) in rechts-nach-links-Layout, `SetLayout` automatisch den Zuordnungsmodus in MM_ISOTROPIC geändert.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setmapperflags"></a>  CDC::SetMapperFlags

Ändert die Methode, die von der Schriftartenmapper verwendet werden, wenn eine logische Schriftart in einer physikalischen Schriftart konvertiert.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parameter

*dwFlag*<br/>
Gibt an, ob die Schriftartenmapper versucht, einer Schriftart Aspekt Höhe und Breite auf dem Gerät übereinstimmen. Wenn dieser Wert ASPECT_FILTERING ist, wählt der Mapper nur Schriftarten, deren Aspect-X und y-Aspekt genau das angegebene Gerät übereinstimmen.

### <a name="return-value"></a>Rückgabewert

Der vorherige Wert des Flags Schriftarten-Mapper.

### <a name="remarks"></a>Hinweise

Eine Anwendung kann mithilfe `SetMapperFlags` , dazu führen, dass den Schriftartenmapper versucht, die nur eine physikalische Schriftart auswählen, die genau mit das Seitenverhältnis der das angegebene Gerät übereinstimmt.

Eine Anwendung, die nur Rasterschriftarten verwendet können die `SetMapperFlags` Funktion, um sicherzustellen, dass die vom Schriftartenmapper ausgewählte Schriftart ansprechend und lesbar ist, auf dem Gerät ist. Anwendungen, die skalierbare (TrueType) Schriftarten, in der Regel verwenden verwenden Sie keine `SetMapperFlags`.

Wenn keine physischen Schriftart ein Seitenverhältnis, die die Spezifikation in die logische Schriftart entspricht besitzt, ist GDI wählt ein neues Seitenverhältnis und wählt eine Schriftart, die diese neue Seitenverhältnis entspricht.

##  <a name="setmiterlimit"></a>  CDC::SetMiterLimit

Legt das Limit für die Dauer der Gehrungslänge Joins für den Gerätekontext.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parameter

*fMiterLimit*<br/>
Gibt an, die neue Gehrungsgrenze für den Gerätekontext.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Gehrungslänge ist als die Entfernung aus der Schnittmenge der Zeile Wände innerhalb des Joins auf die Schnittmenge der Zeile an der Außenseite des Joins Wände definiert. Die Gehrungsgrenze ist die maximale zulässige Verhältnis der Gehrungslänge auf die Linienstärke. Die Gehrungsgrenze der Standardwert ist 10,0.

##  <a name="setoutputdc"></a>  CDC::SetOutputDC

Rufen Sie diese Memberfunktion zum Festlegen der Gerätekontext, die Ausgabe `m_hDC`.

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parameter

*hDC*<br/>
Einen Windows-Gerätekontext.

### <a name="remarks"></a>Hinweise

Diese Memberfunktion kann nur aufgerufen werden, wenn Sie ein Gerätekontext nicht zugeordnet wurde die `CDC` Objekt. Diese Memberfunktion legt `m_hDC` jedoch nicht den Gerätekontext zu angefügt ist die `CDC` Objekt.

##  <a name="setpixel"></a>  CDC::SetPixel

Legt die Pixel der Zeitpunkt angegeben, um die größte Annäherung der Farbe anhand des *CrColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate des Punkts, der festgelegt werden.

*y*<br/>
Gibt die logische y-Koordinate des Punkts, der festgelegt werden.

*crColor*<br/>
Ein COLORREF RGB-Wert, der angibt, die Farbe verwendet, um den Punkt zu zeichnen. Finden Sie unter [COLORREF](/windows/desktop/gdi/colorref) im Windows SDK für eine Beschreibung dieses Werts.

*Zeigen Sie*<br/>
Gibt die logische X - und y-Koordinaten des Punkts, der festgelegt werden. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ein RGB-Wert für die Farbe an, dass der Punkt tatsächlich gezeichnet wird. Dieser Wert kann sich von dem vom angegebenen sein *CrColor* Wenn ein Näherungswert für die entsprechende Farbe verwendet wird. Wenn die Funktion ein Fehler auftritt (wenn der Punkt außerhalb des Clippingbereichs ist), wird der Wert-1 zurückgegeben.

### <a name="remarks"></a>Hinweise

Der Punkt muss in den Ausschneidebereich sein. Wenn der Punkt nicht in den Ausschneidebereich ist, bleibt die Funktion untätig.

Nicht alle Geräte unterstützen die `SetPixel`-Funktion. Um festzustellen, ob ein Gerät unterstützt `SetPixel`, rufen Sie die `GetDeviceCaps` Member mit dem Index RASTERCAPS Funktion und den Rückgabewert für das Flag RC_BITBLT überprüfen.

##  <a name="setpixelv"></a>  CDC::SetPixelV

Das Pixel festgelegt auf den angegebenen Koordinaten auf diesem am ehesten der angegebenen Farbe.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die X-Koordinate, in logischen Einheiten des Punkts, der festgelegt werden.

*y*<br/>
Gibt die y-Koordinate, in logischen Einheiten des Punkts, der festgelegt werden.

*crColor*<br/>
Gibt die Farbe verwendet werden, um den Punkt zu zeichnen.

*Zeigen Sie*<br/>
Gibt die logische X - und y-Koordinaten des Punkts, der festgelegt werden. Sie können entweder übergeben eine [Punkt](../../mfc/reference/point-structure1.md) Datenstruktur oder ein [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Der Punkt muss sich in den Ausschneidebereich und der sichtbare Teil der Geräteoberfläche. Nicht alle Geräte unterstützen die Member-Funktion. Weitere Informationen finden Sie unter der RC_BITBLT-Funktion der `CDC::GetDeviceCaps` Member-Funktion. `SetPixelV` ist schneller als `SetPixel` , da sie nicht den Farbwert der der Punkt tatsächlich gezeichnet zurückgeben muss.

##  <a name="setpolyfillmode"></a>  CDC::SetPolyFillMode

Legt den Modus für die Polygon-füllen.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parameter

*nPolyFillMode*<br/>
Gibt den Füllmodus für neue zu. Dieser Wert kann entweder alternative oder WICKELN sein. Der Standardmodus in Windows festgelegt ist, alternative.

### <a name="return-value"></a>Rückgabewert

Der vorherige ausfüllen-Modus, wenn erfolgreich; andernfalls 0.

### <a name="remarks"></a>Hinweise

Wenn der Modus für die Polygon-füllen-Alternative ist, füllt das System den Bereich zwischen ungerade und geradzahlige Polygonseiten für jede Scanzeile an. Das System füllt, also den Bereich zwischen der ersten und zweiten Seite, zwischen der dritte und vierte Seite, und So weiter. Dieser Modus ist die Standardeinstellung.

Wenn der Modus für die Polygon-füllen WICKLUNG ist, verwendet das System die Richtung, in der eine Abbildung gezeichnet wurde, um festzustellen, ob das Ausfüllen eines Bereichs, an. Jedes Liniensegment in einem Polygon, die in einen im Uhrzeigersinn oder gegen den Uhrzeigersinn gezeichnet wird. Wenn Sie eine gedachte Linie, die von eine eingeschlossene Bereich gezeichnet wird, an die Außenwelt einer Abbildung im Uhrzeigersinn Liniensegment durchläuft, wird eine Anzahl erhöht. Wenn die Zeile ein gegen den Uhrzeigersinn Liniensegment durchläuft, wird die Anzahl die verringert. Der Bereich wird ausgefüllt, wenn die Anzahl die ungleich NULL ist, wenn die Zeile außerhalb der in der Abbildung erreicht.

##  <a name="setrop2"></a>  CDC::SetROP2

Legt den aktuellen Zeichnungsmodus fest.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parameter

*nDrawMode*<br/>
Gibt den neuen Zeichnungsmodus an. Eines der folgenden Werte sind möglich:

- R2_BLACK Pixel ist immer Schwarz.

- Es ist immer R2_WHITE Pixel weiß.

- R2_NOP Pixel bleibt unverändert.

- R2_NOT Pixel ist die Umkehrung der Bildschirmfarbe.

- R2_COPYPEN Pixel ist die Stiftfarbe.

- R2_NOTCOPYPEN Pixel ist die Umkehrung der Stiftfarbe.

- R2_MERGEPENNOT Pixel ist, eine Kombination aus die Stiftfarbe und die Umkehrung der Bildschirmfarbe (letzte Pixel = (keine in Bildschirmpixel) oder Stifteingabe).

- R2_MASKPENNOT Pixel ist, eine Kombination der Farben auf den Stift und der Umkehrung des Bildschirms (letzte Pixel = (keine in Bildschirmpixel) und Stifteingabe).

- R2_MERGENOTPEN Pixel ist, eine Kombination aus der Bildschirmfarbe und die Umkehrung der Stiftfarbe (letzte Pixel (nicht Stift) = ' oder ' Bildschirm Pixel).

- R2_MASKNOTPEN Pixel ist, eine Kombination der Farben auf dem Bildschirm und die Umkehrung des Stifts (letzte Pixel = (nicht "Stift") als auch Pixel).

- R2_MERGEPEN Pixel ist eine Kombination von Farbe des Stifts und der Bildschirmfarbe (letzte Pixel = Stift oder Bildschirmpixel).

- R2_NOTMERGEPEN Pixel ist die Umkehrung der R2_MERGEPEN Farbe (letzte Pixel = nicht (Stift oder Bildschirmpixel)).

- R2_MASKPEN Pixel ist eine Kombination der Farben der Stift und der Bildschirm gemeinsam (letzte Pixel = Stift und Bildschirmpixel).

- R2_NOTMASKPEN Pixel ist die Umkehrung der R2_MASKPEN Farbe (letzte Pixel = nicht (pen und Bildschirmpixel)).

- R2_XORPEN Pixel ist eine Kombination der Farben, die in den Stift oder auf dem Bildschirm, aber nicht in beiden sind (letzte Pixel = Stift XOR Bildschirmpixel).

- R2_NOTXORPEN Pixel ist die Umkehrung der R2_XORPEN Farbe (letzte Pixel = nicht (Stift XOR Bildschirmpixel)).

### <a name="return-value"></a>Rückgabewert

Der vorherige zeichnen-Modus.

Es kann einer der Werte im Windows SDK sein.

### <a name="remarks"></a>Hinweise

Zeichnungsmodus des gibt an, wie die Farben des Stifts und das Innere des ausgefüllten Objekte mit der Farbe bereits auf der Anzeigeoberfläche kombiniert werden.

Zeichnungsmodus des ist nur für Rastergeräte. Sie gelten nicht für Geräte der Vektor. Zeichnung Modi handelt es sich um binäre rastervorgang-Codes, die alle mögliche booleschen Kombinationen von zwei Variablen, die nicht unter Verwendung der binären Operatoren AND, OR und XOR (exklusives OR) und der unären Operation darstellt.

##  <a name="setstretchbltmode"></a>  CDC::SetStretchBltMode

Legt den Modus Strecken einer Bitmap für die `StretchBlt` Member-Funktion.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parameter

*nStretchMode*<br/>
Gibt den streckmodus an. Eines der folgenden Werte sind möglich:

|Wert|Beschreibung|
|-----------|-----------------|
|BLACKONWHITE|Führt eine boolesche AND-Operation mit den Werten für die Farbe für die Pixel entfernt und vorhandene. Wenn die Bitmap eine monochrome Bitmap ist, behält diesen Modus schwarze Pixel auf Kosten der weißen Pixel.|
|COLORONCOLOR|Löscht die Pixel. In diesem Modus werden alle Zeilen von Pixeln gelöscht, ohne zu versuchen, ihre Informationen zu erhalten.|
|HALBTON|Ordnet Blöcke der Pixel in das Zielrechteck Pixel vom Quellrechtecks. Die durchschnittliche Farbe der Pixel, den Ziel-Block erfolgt eine Annäherung an die Farbe der Pixel der Quelle.|
||Nach dem Festlegen von HALBTON Strecken Modus, muss eine Anwendung die Win32-Funktion aufrufen [SetBrushOrgEx](/windows/desktop/api/wingdi/nf-wingdi-setbrushorgex) Festlegen des Ursprungs Pinsel. Wenn sie nicht dazu, tritt ein, Pinsel fehlausrichtung.|
|STRETCH_ANDSCANS|**Windows 95/98**: identisch mit BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: identisch mit COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: HALBTON identisch.|
|STRETCH_ORSCANS|**Windows 95/98**: identisch mit WHITEONBLACK|
|WHITEONBLACK|Führt eine boolesche OR-Operation mit den Werten für die Farbe für die entfernt und vorhandene Pixel. Wenn die Bitmap eine monochrome Bitmap ist, behält diesen Modus weißen Pixel auf Kosten der schwarze Pixel.|

### <a name="return-value"></a>Rückgabewert

Der vorherige stretching Modus. Sie können STRETCH_ANDSCANS, STRETCH_DELETESCANS oder STRETCH_ORSCANS sein.

### <a name="remarks"></a>Hinweise

Der Modus zum Strecken einer Bitmap definiert, wie Informationen von Bitmaps, die komprimiert werden, mithilfe der Funktion entfernt werden.

Die Modi BLACKONWHITE (STRETCH_ANDSCANS) und WHITEONBLACK (STRETCH_ORSCANS) werden in der Regel verwendet, Vordergrund Pixel monochrome Bitmaps beibehalten. Der Modus COLORONCOLOR (STRETCH_DELETESCANS) wird normalerweise verwendet, um Farbe in Farbe Bitmaps zu erhalten.

Den HALBTON ist erforderlich, weitere Verarbeitung des Quellbilds als die anderen drei Modi werden; Es ist langsamer als die anderen, aber Sie Bilder mit höherer Qualität erzeugt. Beachten Sie, dass `SetBrushOrgEx` muss aufgerufen werden, nach dem Festlegen des Modus HALBTON Pinsel fehlausrichtung zu vermeiden.

Weitere Modi für das stretching möglicherweise ebenfalls zur Verfügung, abhängig von den Funktionen des Gerätetreibers.

##  <a name="settextalign"></a>  CDC::SetTextAlign

Legt die textausrichtung Flags.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parameter

*nFlags*<br/>
Gibt die textausrichtung Flags. Die Flags Geben Sie die Beziehung zwischen einem Punkt und ein Rechteck, das den Text umschließende. Der Punkt kann der aktuellen Position oder eine Textausgabe Funktion angegebenen Koordinaten sein. Das Rechteck, das den Text umschließende wird durch die angrenzenden Zeichenzellen in der Textzeichenfolge definiert. Die *nFlags* Parameter kann ein oder mehrere Flags aus den folgenden drei Kategorien sein. Wählen Sie nur einen Flag aus jeder Kategorie an. Die erste Kategorie wirkt sich auf die Ausrichtung des Texts in der X-Richtung:

- TA_CENTER richtet den Punkt mit der horizontalen Mitte des umschließenden Rechtecks aus.

- TA_LEFT richtet den Punkt mit der linken Seite des umschließenden Rechtecks aus. Dies ist die Standardeinstellung.

- TA_RIGHT richtet den Punkt mit der rechten Seite des umschließenden Rechtecks aus.

Die zweite Kategorie wirkt sich auf die Ausrichtung des Texts in der y-Richtung:

- TA_BASELINE richtet den Punkt mit der Baseline der ausgewählten Schriftart aus.

- TA_BOTTOM richtet den Punkt am unteren Rand des umschließenden Rechtecks aus.

- TA_TOP richtet den Punkt am oberen Rand des umschließenden Rechtecks aus. Dies ist die Standardeinstellung.

Die dritte Kategorie bestimmt, ob die aktuelle Position aktualisiert wird, wenn der Text geschrieben wird:

- TA_NOUPDATECP wird aktualisiert wird, wird damit nicht die aktuelle Position nach jedem Aufruf an eine Ausgabe von Text-Funktion. Dies ist die Standardeinstellung.

- TA_UPDATECP aktualisiert die aktuelle X-Position nach jedem Aufruf an eine Ausgabe von Text-Funktion. Die neue Position ist auf der rechten Seite des umschließenden Rechtecks für den Text. Wenn dieses Flag festgelegt ist, die in Aufrufen an angegebenen Koordinaten den `TextOut` Memberfunktion werden ignoriert.

### <a name="return-value"></a>Rückgabewert

Die vorherige textausrichtung-Einstellung, wenn erfolgreich. Das niedrige Byte enthält das horizontale und das höherwertige Byte enthält das vertikale; andernfalls 0.

### <a name="remarks"></a>Hinweise

Die `TextOut` und `ExtTextOut` Memberfunktionen diese Flags verwenden, wenn es sich bei eine Textzeichenfolge auf ein Gerät oder die Anzeige zu positionieren. Die Flags Geben Sie die Beziehung zwischen einem bestimmten Zeitpunkt und ein Rechteck, das den Text umschließende. Die Koordinaten von diesem Punkt werden als Parameter zum Übergeben der `TextOut` Member-Funktion. Das Rechteck, das den Text umschließende wird durch die angrenzenden Zeichenzellen in der Textzeichenfolge gebildet.

##  <a name="settextcharacterextra"></a>  CDC::SetTextCharacterExtra

Legt die Menge des Zeichenabstands fest.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parameter

*nCharExtra*<br/>
Gibt die Menge des zusätzlichen Speicherplatzes (in logischen Einheiten) auf jedes Zeichen hinzugefügt werden. Ist der aktuelle Zuordnungsmodus nicht `MM_TEXT`, *nCharExtra* transformiert und gerundet auf den nächsten Pixel.

### <a name="return-value"></a>Rückgabewert

Die Menge an die vorherigen Zeichenabstands.

### <a name="remarks"></a>Hinweise

GDI hinzugefügt jedes Zeichen, einschließlich der Zeilenumbruchzeichen, wenn sie eine Zeile mit Text in den Gerätekontext schreibt diese Leerzeichen. Der Standardwert für die Menge an Zeichenabstands ist 0.

##  <a name="settextcolor"></a>  CDC::SetTextColor

Legt die Farbe des Textes auf der angegebenen Farbe fest.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parameter

*crColor*<br/>
Gibt die Farbe des Texts als ein RGB-Farbwert an.

### <a name="return-value"></a>Rückgabewert

Ein RGB-Wert für die vorherigen Textfarbe.

### <a name="remarks"></a>Hinweise

Das System wird diese Textfarbe verwenden, beim Schreiben von Text in dieser Gerätekontext sowie beim Konvertieren von Bitmaps zwischen Farbe und monochrome Gerätekontexte.

Wenn das Gerät die angegebene Farbe nicht darstellen kann, setzt das System die Farbe des Textes auf die nächste physische Farbe. Die Farbe des Hintergrunds nach einem Zeichen wird angegeben, indem die `SetBkColor` und `SetBkMode` Memberfunktionen.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="settextjustification"></a>  CDC::SetTextJustification

Das Zeilenumbruchzeichen in einer Zeichenfolge werden Leerzeichen hinzugefügt.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parameter

*nBreakExtra*<br/>
Gibt den gesamten zusätzlichen Speicherplatz, die Zeile des Texts (in logischen Einheiten) hinzugefügt werden. Ist der aktuelle Zuordnungsmodus nicht `MM_TEXT`, der durch diesen Parameter angegebene Wert in der aktuellen Zuordnungsmodus konvertiert und auf die nächste Geräteeinheit gerundet.

*nBreakCount*<br/>
Gibt die Anzahl der Zeilenumbruchzeichen in der Zeile an.

### <a name="return-value"></a>Rückgabewert

Eine Falls die Funktion erfolgreich ist; andernfalls 0.

### <a name="remarks"></a>Hinweise

Eine Anwendung kann mithilfe der `GetTextMetrics` Memberfunktionen zum Abrufen einer Schriftart unterbrechen Zeichen.

Nach der `SetTextJustification` Memberfunktion aufgerufen wird, wird einen Aufruf an eine Ausgabe von Text-Funktion (z. B. `TextOut`) verteilt den angegebenen zusätzlichen Platz gleichmäßig auf die angegebene Anzahl der Zeilenumbruchzeichen. Die Umbruchzeichen ist in der Regel das Leerzeichen (ASCII 32), aber eine Schriftart als ein anderes Zeichen kann definiert werden.

Die Memberfunktion `GetTextExtent` wird normalerweise verwendet, mit `SetTextJustification`. `GetTextExtent` berechnet die Breite einer bestimmten Zeile vor der Ausrichtung an. Eine Anwendung kann bestimmen, wie viel Speicherplatz für die Angabe in der *nBreakExtra* Parameter durch Subtrahieren den Rückgabewert von `GetTextExtent` von der Breite der Zeichenfolge nach der Ausrichtung.

Die `SetTextJustification` Funktion kann verwendet werden, eine Zeile an, die mehrere Ausführungen in verschiedenen Schriftarten enthält. In diesem Fall muss die Zeile schrittweise durch das Ausrichten und Schreiben von jeder Ausführung separat erstellt werden.

Da Rundungsfehler während der Ausrichtung auftreten kann, speichert das System eine ausgeführte Fehlerterm, der den aktuellen Fehler definiert. Wenn eine Zeile ausrichten, die mehrere ausgeführt wird, enthält `GetTextExtent` automatisch diese Fehlerterm, wenn das Ausmaß der nächsten Ausführung berechnet, verwendet. Dadurch wird die Ausgabe von Text-Funktion, die den Fehler an die neue Ausführung blend.

Nachdem jede Zeile aneinander ausgerichtet ist, muss diese Fehlerterm gelöscht werden, um zu verhindern, dass es in die nächste Zeile integriert wird. Der Begriff kann gelöscht werden, durch den Aufruf `SetTextJustification` mit *nBreakExtra* auf 0 festgelegt.

##  <a name="setviewportext"></a>  CDC::SetViewportExt

Legt fest, die x und y-Blöcke des Viewports des Gerätekontexts.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parameter

*CX*<br/>
Gibt den X-Umfang des Viewports (in Geräteeinheiten).

*CY*<br/>
Gibt den y-Umfang des Viewports (in Geräteeinheiten).

*size*<br/>
Gibt an, die x und y-Blöcke des Viewports (in Geräteeinheiten).

### <a name="return-value"></a>Rückgabewert

Die vorherigen Blöcke des Viewports als eine [CSize](../../atl-mfc-shared/reference/csize-class.md) Objekt. Wenn ein Fehler auftritt, werden die x- und y-Koordinaten des zurückgegebenen `CSize` Objekt sind beide auf 0 festgelegt.

### <a name="remarks"></a>Hinweise

Der Viewport sind, sowie das Gerätekontext Fenster wird definiert, wie GDI Punkt im Koordinatensystem des tatsächlichen Geräts Punkte im logischen Koordinatensystem zugeordnet. Das heißt, definieren sie, wie GDI logische Koordinaten in Gerätekoordinaten konvertiert.

Wenn die folgenden Zuordnungsmodi festgelegt sind, Aufrufe von `SetWindowExt` und `SetViewportExt` werden ignoriert:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Wenn MM_ISOTROPIC-Modus festgelegt ist, muss eine Anwendung Aufrufen der `SetWindowExt` Memberfunktion vor `SetViewportExt`.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setviewportorg"></a>  CDC::SetViewportOrg

Legt den Ursprung der Viewport des Gerätekontexts fest.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die X-Koordinate (in Geräteeinheiten) des Ursprungs des Viewports an. Der Wert muss innerhalb des Bereichs von Koordinatensystem des Geräts.

*y*<br/>
Gibt die y-Koordinate (in Geräteeinheiten) des Ursprungs des Viewports an. Der Wert muss innerhalb des Bereichs von Koordinatensystem des Geräts.

*Zeigen Sie*<br/>
Gibt den Ursprung des Viewports. Die Werte müssen innerhalb des Bereichs von Koordinatensystem des Geräts sein. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Die vorherigen Herkunft des Viewports (in Gerätekoordinaten) als eine `CPoint` Objekt.

### <a name="remarks"></a>Hinweise

Der Viewport sind, sowie das Gerätekontext Fenster wird definiert, wie GDI Punkt im Koordinatensystem des tatsächlichen Geräts Punkte im logischen Koordinatensystem zugeordnet. Das heißt, definieren sie, wie GDI logische Koordinaten in Gerätekoordinaten konvertiert.

Der Ursprung des Ausschnitts kennzeichnet den Punkt im Koordinatensystem Geräts, der zugeordnet GDI Fensterursprung, einem Punkt im logischen Koordinatensystem gemäß, der `SetWindowOrg` Member-Funktion. GDI ordnet alle sonstigen Punkte durch Befolgung desselben Prozesses erforderlich, um den Fensterursprung an den Ursprung des Viewports zuzuordnen. Beispielsweise werden alle Punkte in einem Kreis, um den Punkt am ursprünglichen Speicherort Fenster in einem Kreis, um den Punkt, an den Ursprung des Viewports. Auf ähnliche Weise werden alle Punkte in einer Zeile, die den Fensterursprung durchlaufen in einer Zeile, die der Ursprung des Ausschnitts durchlaufen.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindowext"></a>  CDC::SetWindowExt

Legt fest, die x und y-Blöcke des Fensters mit den Gerätekontext verknüpft ist.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parameter

*CX*<br/>
Gibt den X-Umfang (in logischen Einheiten) des Fensters.

*CY*<br/>
Gibt den y-Umfang (in logischen Einheiten) des Fensters.

*size*<br/>
Gibt an, die X - und y-Blöcke (in logischen Einheiten) des Fensters.

### <a name="return-value"></a>Rückgabewert

Die vorherigen Blöcke des Fensters (in logischen Einheiten) als eine `CSize` Objekt. Wenn ein Fehler auftritt, die x- und y-Koordinaten des zurückgegebenen `CSize` Objekt sind beide auf 0 festgelegt.

### <a name="remarks"></a>Hinweise

Im Fenster zusammen mit dem Viewport Gerätekontext, definiert, wie GDI Punkte im logischen Koordinatensystem Punkt im Koordinatensystem Geräts zugeordnet.

Wenn die folgenden Zuordnungsmodi festgelegt sind, Aufrufe von `SetWindowExt` und `SetViewportExt` Funktionen werden ignoriert:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Wenn MM_ISOTROPIC-Modus festgelegt ist, muss eine Anwendung Aufrufen der `SetWindowExt` Memberfunktion vor dem Aufruf `SetViewportExt`.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindoworg"></a>  CDC::SetWindowOrg

Legt den Fensterursprung im des Gerätekontexts fest.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate der neuen Ursprung des Fensters an.

*y*<br/>
Gibt die logische y-Koordinate der neuen Ursprung des Fensters an.

*Zeigen Sie*<br/>
Gibt den logischen Koordinaten des Ursprungs neue Fenster an. Sie können entweder übergeben eine `POINT` Struktur oder ein `CPoint` Objekt für diesen Parameter.

### <a name="return-value"></a>Rückgabewert

Der vorherige Ursprung des Fensters als eine `CPoint` Objekt.

### <a name="remarks"></a>Hinweise

Im Fenster zusammen mit dem Viewport Gerätekontext, definiert, wie GDI Punkte im logischen Koordinatensystem Punkt im Koordinatensystem Geräts zugeordnet.

Der Fensterursprung kennzeichnet den Punkt im logischen Koordinatensystem aus dem GDI ordnet den Ursprung des Ausschnitts, einem Punkt im Koordinatensystem Geräts gemäß der `SetWindowOrg` Funktion. GDI ordnet alle sonstigen Punkte durch Befolgung desselben Prozesses erforderlich, um den Fensterursprung an den Ursprung des Viewports zuzuordnen. Beispielsweise werden alle Punkte in einem Kreis, um den Punkt am ursprünglichen Speicherort Fenster in einem Kreis, um den Punkt, an den Ursprung des Viewports. Auf ähnliche Weise werden alle Punkte in einer Zeile, die den Fensterursprung durchlaufen in einer Zeile, die der Ursprung des Ausschnitts durchlaufen.

##  <a name="setworldtransform"></a>  CDC::SetWorldTransform

Legt eine zweidimensionale lineare Umformung zwischen Raum und Seite-Speicherplatz für den angegebenen Gerätekontext. Diese Transformation kann verwendet werden, zu skalieren, drehen, Scheren oder Grafikausgabe zu übersetzen.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parameter

*rXform*<br/>
Ein Verweis auf ein [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) Struktur, die die Transformationsdaten enthält.

### <a name="return-value"></a>Rückgabewert

Gibt einen Wert ungleich NULL bei Erfolg zurück.

Gibt 0 bei einem Fehler zurück.

Um erweiterte Fehlerinformationen abzurufen, rufen Sie [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Hinweise

Diese Methode dient als Wrapper für die Windows-GDI-Funktion [SetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-setworldtransform).

##  <a name="startdoc"></a>  CDC::StartDoc

Informiert den Gerätetreiber, die ein neuer Druckauftrag gestartet wird und dass alle nachfolgenden `StartPage` und `EndPage` Aufrufe gespoolt werden sollte, unter dem gleichen Auftrag erst eine `EndDoc` des Anrufs gewählt.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parameter

*lpDocInfo*<br/>
Verweist auf eine [DOCINFO](/windows/desktop/api/wingdi/ns-wingdi-_docinfoa) Struktur, die den Namen der Dokumentdatei und den Namen der Ausgabedatei enthält.

*lpszDocName*<br/>
Zeiger auf eine Zeichenfolge, die mit dem Namen der Dokumentdatei.

### <a name="return-value"></a>Rückgabewert

Wenn die Funktion erfolgreich ist, ist der Rückgabewert größer als 0 (null). Dieser Wert ist der Druckauftrag-Bezeichner für das Dokument.

Wenn die Funktion fehlschlägt, ist der Rückgabewert kleiner oder gleich 0 (null).

### <a name="remarks"></a>Hinweise

Dadurch wird sichergestellt, dass Dokumente mehr als eine Seite nicht mit anderen Aufträgen vermischt werden werden.

Für Windows-Versionen 3.1 und höher ersetzt diese Funktion die STARTDOC Druckerescape. Mit dieser Funktion wird sichergestellt, dass Dokumente mit mehr als eine Seite nicht mit anderen Druckaufträgen vermischt werden.

`StartDoc` sollte nicht innerhalb von Metadateien verwendet werden.

### <a name="example"></a>Beispiel

Dieses Codefragment ruft den Standarddrucker, öffnet einen Druckauftrag und spoolt eine Seite mit "Hello, World!" darauf. Da der Text, der durch den folgenden Code ausgegeben, logische Einheiten des Druckers skaliert ist nicht, möglicherweise der Ausgabetext in diese kleinen Buchstaben, dass das Ergebnis nicht gelesen werden. Der CDC-Funktionen, z. B. Skalierung `SetMapMode`, `SetViewportOrg`, und `SetWindowExt`, kann verwendet werden, um die Skalierung zu beheben.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

##  <a name="startpage"></a>  CDC::StartPage

Rufen Sie diese Memberfunktion zum Vorbereiten des Druckertreibers, um Daten zu empfangen.

```
int StartPage();
```

### <a name="return-value"></a>Rückgabewert

Größer als oder gleich 0, wenn die Funktion erfolgreich ist oder ein negativer Wert, wenn ein Fehler aufgetreten.

### <a name="remarks"></a>Hinweise

`StartPage` hat Vorrang vor den NEWFRAME und BANDINFO Escapezeichen.

Eine Übersicht über die Aufrufsequenz drucken, finden Sie unter den [StartDoc](#startdoc) Member-Funktion.

Deaktiviert das System die `ResetDC` Memberfunktion zwischen den Aufrufen `StartPage` und `EndPage`.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CDC::StartDoc](#startdoc).

##  <a name="stretchblt"></a>  CDC::StretchBlt

Kopiert eine Bitmap aus einem Quellrechteck in ein Zielrechteck, wobei das Bitmap gestreckt oder komprimiert wird, falls dies notwendig ist, um zu den Maßen des Zielrechtecks zu passen.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Zielrechtecks an.

*y*<br/>
Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Zielrechtecks an.

*nWidth*<br/>
Gibt die Breite (in logischen Einheiten) des Zielrechtecks an.

*nHeight*<br/>
Gibt die Höhe (in logischen Einheiten) des Zielrechtecks an.

*pSrcDC*<br/>
Gibt den Quellgerätekontext an.

*xSrc*<br/>
Gibt die x-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quellrechtecks an.

*ySrc*<br/>
Gibt die y-Koordinate (in logischen Einheiten) der oberen linken Ecke des Quellrechtecks an.

*nSrcWidth*<br/>
Gibt die Breite (in logischen Einheiten) des Quellrechtecks an.

*nSrcHeight*<br/>
Gibt die Höhe (in logischen Einheiten) des Quellrechtecks an.

*dwRop*<br/>
Gibt das Raster des auszuführenden Vorgangs an. Rastervorgangscode definiert, wie GDI Farben in Ausgabevorgängen kombiniert, an denen ein aktueller Pinsel, eine mögliche Quellbitmap und eine Zielbitmap beteiligt sind. Dieser Parameter kann möglicherweise einen der folgenden Werte aufweisen:

- BLACKNESS aktiviert, die Ausgabe Schwarz.

- DSTINVERT kehrt die Zielbitmap.

- MERGECOPY werden das Muster und die Quellbitmap mithilfe des booleschen AND-Operators kombiniert.

- MERGEPAINT werden die umgekehrte Quellbitmap mit der Zielbitmap mithilfe des booleschen OR-Operators kombiniert.

- NOTSRCCOPY kopiert die umgekehrte Quellbitmap in das Ziel.

- NOTSRCERASE kehrt das Ergebnis der Kombination der Ziel- und Quellbitmaps mithilfe des booleschen OR-Operators an.

- PATCOPY kopiert das Muster in die Zielbitmap.

- PATINVERT werden die Zielbitmap mithilfe des booleschen XOR-Operators mit dem Muster kombiniert.

- PATPAINT werden die umgekehrte Quellbitmap mithilfe des booleschen OR-Operators mit dem Muster kombiniert. Hierdurch wird das Ziel dieses Vorgangs mithilfe des booleschen OR-Operators mit dem Zielbitmap kombiniert.

- SRCAND kombiniert Pixel der Ziel- und Quellbitmaps mithilfe des booleschen AND-Operators.

- SRCCOPY kopiert die Quellbitmap in die Zielbitmap.

- SRCERASE Hierdurch wird die Zielbitmap und das Ergebnis mit dem Quellbitmap mithilfe des booleschen AND-Operators kombiniert.

- SRCINVERT kombiniert Pixel der Ziel- und Quellbitmaps mithilfe des booleschen XOR-Operators.

- SRCPAINT kombiniert Pixel der Ziel- und Quellbitmaps mithilfe des booleschen OR-Operators.

- WHITENESS aktiviert, die Ausgabe weiß.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Bitmap gezeichnet wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Die Funktion verwendet den Streckmodus des Zielgerätkontexts (durch `SetStretchBltMode` festgelegt), um zu bestimmen, wie die Bitmap gestreckt oder komprimiert werden soll.

Die `StretchBlt` -Funktion verschiebt die Bitmap vom Quellgerät vom *pSrcDC* an das Zielgerät, dargestellt durch das Gerätekontext Objekt, dessen Memberfunktion aufgerufen wird. Die *xSrc*, *ySrc*, *nSrcWidth*, und *nSrcHeight* Parameter definieren, die linke obere Ecke und die Dimensionen des Quellrechtecks . Die *x*, *y*, *nWidth*, und *nHeight* Parameter geben die linke obere Ecke und die Dimensionen des Zielrechtecks. Durch angegebene rastervorgang *DwRop* definiert, wie die Quellbitmap und die Bits bereits auf dem Zielgerät kombiniert werden.

Die `StretchBlt` Funktion ein Spiegelbild der Bitmap erstellt, wenn die Zeichen der *nSrcWidth* und *nWidth* oder *nSrcHeight* und *nHeight* Parameter unterscheiden. Wenn *nSrcWidth* und *nWidth* unterschiedliche Vorzeichen haben, die Funktion erstellt ein Spiegelbild der Bitmap entlang der x-Achse. Wenn *nSrcHeight* und *nHeight* unterschiedliche Vorzeichen haben, die Funktion erstellt ein Spiegelbild der Bitmap entlang der y-Achse.

Die Funktion `StretchBlt` streckt oder komprimiert die Quellbitmap im Speicher und kopiert dann das Ergebnis in das Ziel. Wenn ein Muster mit dem Ergebnis zusammengeführt werden soll, wird es erst zusammengeführt, wenn die gestreckte Quellbitmap in das Ziel kopiert wurde. Wenn ein Pinsel verwendet wird, ist es der ausgewählte Pinsel im Zielgerätekontext. Die Zielkoordinaten werden gemäß dem Zielgerätekontext umgewandelt. Die Quellkoordinaten werden gemäß dem Quellgerätekontext umgewandelt.

Wenn das Ziel, die Quelle und die Musterbitmaps nicht dasselbe Farbformat haben, konvertiert `StretchBlt` die Quelle und die Musterbitmaps so, dass sie mit den Zielbitmaps übereinstimmen. Die Vordergrund- und Hintergrundfarben des Zielgerätekontexts werden bei der Konvertierung verwendet.

Wenn `StretchBlt` eine monochrome Bitmap in eine farbige konvertiere muss, legt sie weiße Bits (1) für die Hintergrundfarbe und schwarze Bits (0) für die Vordergrundfarbe fest. Um Farbe in monochrom zu verwandeln, legt sie Pixel, die mit der Hintergrundfarbe übereinstimmen, auf weiß (1) fest und legt alle anderen Pixel auf schwarz (0) fest. Die Vordergrund- und Hintergrundfarben des Gerätekontexts mit Farbe werden verwendet.

Nicht alle Geräte unterstützen die `StretchBlt`-Funktion. Um festzustellen, ob ein Gerät unterstützt `StretchBlt`, rufen Sie die `GetDeviceCaps` Member mit dem Index RASTERCAPS Funktion und den Rückgabewert für das Flag RC_STRETCHBLT überprüfen.

##  <a name="strokeandfillpath"></a>  CDC::StrokeAndFillPath

Schließt alle geöffneten Figuren in einen Pfad, den Umriss des Pfads, die mit der aktuelle Stift Striche und füllt mit der aktuellen Pinsel inneren.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Der Gerätekontext muss es sich um einen geschlossenen Pfad enthalten. Die `StrokeAndFillPath` Memberfunktion hat dieselbe Wirkung wie das Schließen aller geöffneten Abbildungen in den Pfad und Kontur zuweisen, und füllen den Pfad, mit dem Unterschied, dass der ausgefüllte Bereich nicht selbst wenn die gestrichelt Region überschneiden, wird des Stifts breit.

##  <a name="strokepath"></a>  CDC::StrokePath

Rendert den angegebenen Pfad mit der aktuelle Stift.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Der Gerätekontext muss es sich um einen geschlossenen Pfad enthalten.

##  <a name="tabbedtextout"></a>  CDC::TabbedTextOut

Rufen Sie diese Memberfunktion zum Schreiben einer Zeichenfolge an der angegebenen Position, und Erweitern von Registerkarten auf die Werte im Array der Tabstopp Positionen angegeben.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische X-Koordinate des Anfangspunkts der Zeichenfolge an.

*y*<br/>
Gibt die logische y-Koordinate des Anfangspunkts der Zeichenfolge an.

*lpszString*<br/>
Verweist auf die Zeichenfolge, die gezeichnet werden soll. Sie können entweder einen Zeiger übergeben, um ein Array von Zeichen oder ein [CString](../../atl-mfc-shared/reference/cstringt-class.md) Objekt für diesen Parameter.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an. Wenn *nCount* -1 ist, wird die Länge berechnet.

*nTabPositions*<br/>
Gibt die Anzahl der Werte im Array der Tabstopp Positionen an.

*lpnTabStopPositions*<br/>
Verweist auf ein Array mit den Tabstopp Positionen (in logischen Einheiten). Die Tabstopps müssen in aufsteigender Reihenfolge sortiert werden; der kleinste X-Wert sollte das erste Element im Array.

*nTabOrigin*<br/>
Gibt die X-Koordinate der Startposition aus der Registerkarten (in logischen Einheiten) erweitert werden.

*str*<br/>
Ein `CString` Objekt, das die angegebenen Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Die Abmessungen der Zeichenfolge (in logischen Einheiten) als eine `CSize` Objekt.

### <a name="remarks"></a>Hinweise

Text wird in der aktuell ausgewählten Schriftart geschrieben. Wenn *nTabPositions* ist 0 und *LpnTabStopPositions* NULL ist, Registerkarten auf acht Mal die durchschnittliche Zeichenbreite erweitert werden.

Wenn *nTabPositions* ist 1, die Registerkarte, die beendet von den durch den ersten Wert im angegebenen Abstand getrennt werden der *LpnTabStopPositions* Array. Wenn die *LpnTabStopPositions* Array enthält mehr als einen Wert, der ein Tabstopp festgelegt ist, für jeden Wert im Array fest, bis die angegebene Anzahl *nTabPositions*. Die *nTabOrigin* Parameter kann eine Anwendung zum Aufrufen der `TabbedTextOut` Funktion mehrmals für eine einzelne Zeile. Wenn die Anwendung ruft die Funktion mehrmals mit dem *nTabOrigin* jedes Mal auf den gleichen Wert festgelegt, die Funktion erweitert alle Registerkarten relativ zur Position gemäß *nTabOrigin*.

Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert. Die Anwendung kann aufrufen, wenn eine Anwendung muss die aktuelle Position aktualisieren, wenn es sich um die Funktion aufruft, die [SetTextAlign](#settextalign) Member-Funktion mit *nFlags* TA_UPDATECP festgelegt. Wenn dieses Flag festgelegt ist, ignoriert Windows die *x* und *y* Parameter bei nachfolgenden Aufrufen `TabbedTextOut`, verwenden Sie stattdessen die aktuelle Position.

##  <a name="textout"></a>  TextOut

Schreibt mithilfe der aktuell ausgewählten Schriftart eine Zeichenfolge an dem angegebenen Speicherort.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parameter

*w*<br/>
Gibt die logische x-Koordinate des Anfangspunkts des Texts an.

*y*<br/>
Gibt die logische y-Koordinate des Anfangspunkts des Texts an.

*lpszString*<br/>
Zeigt auf die zu zeichnende Zeichenfolge.

*nCount*<br/>
Gibt die Anzahl von Zeichen in der Zeichenfolge an.

*str*<br/>
Ein `CString`-Objekt, das die zu zeichnenden Zeichen enthält.

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Zeichenursprünge befindet sich in der oberen linken Ecke der Zeichenzelle. Standardmäßig wird die aktuelle Position von der Funktion nicht verwendet oder aktualisiert.

Wenn eine Anwendung muss die aktuelle Position aktualisieren, wenn aufgerufen `TextOut`, rufen Sie die Anwendung kann die `SetTextAlign` Member-Funktion mit *nFlags* TA_UPDATECP festgelegt. Wenn dieses Flag festgelegt ist, ignoriert Windows die *x* und *y* Parameter bei nachfolgenden Aufrufen `TextOut`, verwenden Sie stattdessen die aktuelle Position.

### <a name="example"></a>Beispiel

  Siehe das Beispiel für [CDC:: beginpath](#beginpath).

##  <a name="transparentblt"></a>  CDC::TransparentBlt

Rufen Sie diese Memberfunktion zum Übertragen von eines Bit-Datenblocks die Farbe, die einem Rechteck aus Pixeln aus der angegebenen Quelle-Gerätekontext, eine Ziel-Gerätekontext entspricht.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parameter

*xDest*<br/>
Gibt die X-Koordinate, in logischen Einheiten, der die linke obere Ecke des Zielrechtecks an.

*yDest*<br/>
Gibt die y-Koordinate, in logischen Einheiten, der die linke obere Ecke des Zielrechtecks an.

*nDestWidth*<br/>
Gibt die Breite in logischen Einheiten des Zielrechtecks an.

*nDestHeight*<br/>
Gibt die Höhe in logischen Einheiten des Zielrechtecks an.

*pSrcDC*<br/>
Zeiger auf den Quellgerätekontext.

*xSrc*<br/>
Gibt die X-Koordinate, in logischen Einheiten des Quellrechtecks an.

*ySrc*<br/>
Gibt die y-Koordinate, in logischen Einheiten des Quellrechtecks an.

*nSrcWidth*<br/>
Gibt die Breite in logischen Einheiten des Quellrechtecks an.

*nSrcHeight*<br/>
Gibt die Höhe in logischen Einheiten des Quellrechtecks an.

*clrTransparent*<br/>
Die RGB-Farbe in der Quell-Bitmap als transparent behandelt werden soll.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn erfolgreich, andernfalls FALSE.

### <a name="remarks"></a>Hinweise

`TransparentBlt` Transparenz ermöglicht. d. h. die RGB-Farbe erkennbar *ClrTransparent* für die Übertragung transparent gerendert wird.

Weitere Informationen finden Sie unter [TransparentBlt](/windows/desktop/api/wingdi/nf-wingdi-transparentblt) im Windows SDK.

##  <a name="updatecolors"></a>  CDC::UpdateColors

Updates des Clientbereichs der Systempalette auf Pixel-für-Pixel-Basis der Clientbereich des Gerätekontexts durch Vergleich der aktuellen Farben.

```
void UpdateColors();
```

### <a name="remarks"></a>Hinweise

Kann mit einer realisierten logischen Palette ein inaktives Fensters Aufrufen `UpdateColors` als Alternative zum Neuzeichnen seinen Clientbereich, wenn sich die Systempalette ändert.

Weitere Informationen zur Verwendung von Farbpaletten finden Sie unter [UpdateColors](/windows/desktop/api/wingdi/nf-wingdi-updatecolors) im Windows SDK.

Die `UpdateColors` Memberfunktion updates in der Regel einen Client-Bereich schneller als das Neuzeichnen des Bereichs. Da die Funktion ausführt, die Farbe Übersetzung basierend auf der Farbe jedes Pixels, bevor die Systempalette geändert wird, führt jedoch zu jeder Aufruf dieser Funktion zum Verlust der Genauigkeit der einige Farben.

##  <a name="widenpath"></a>  CDC::WidenPath

Definiert den aktuellen Pfad als der Bereich, der gezeichnet werden sollen, wenn der Pfad mit Strichen gezeichnet wurden mit dem Stift in den Gerätekontext derzeit ausgewählt.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Rückgabewert

Ist ungleich null (0), wenn die Funktion erfolgreich ausgeführt wird, andernfalls null (0).

### <a name="remarks"></a>Hinweise

Diese Funktion ist nur erfolgreich, wenn der aktuelle Stift einen geometrischen Stift erstellt, indem Sie die zweite Version der ist `CreatePen` Member-Funktion, oder wenn der Stift, mit der ersten Version von erstellt wird `CreatePen` und verfügt über eine Breite in Geräteeinheiten, der größer als 1. Der Gerätekontext muss es sich um einen geschlossenen Pfad enthalten. Alle Bzier Kurven im Pfad werden in Sequenzen von geraden annähern der erweiterten Kurven konvertiert. Daher keine Kurven Bzier verbleiben in den Pfad nach `WidenPath` aufgerufen wird.

## <a name="see-also"></a>Siehe auch

[CObject-Klasse](../../mfc/reference/cobject-class.md)<br/>
[Hierarchiediagramm](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC-Klasse](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC-Klasse](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC-Klasse](../../mfc/reference/cclientdc-class.md)<br/>
[CMetaFileDC-Klasse](../../mfc/reference/cmetafiledc-class.md)
