---
title: CMDIFrameWndEx-Klasse
ms.date: 11/04/2016
f1_keywords:
- CMDIFrameWndEx
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ActiveItemRecalcLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AddPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AdjustClientArea
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AdjustDockingLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AreMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CanCovertControlBarToMDIChild
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ControlBarToTabbedDocument
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CreateDocumentWindow
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CreateNewWindow
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::DockPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::DockPaneLeftOf
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableAutoHidePanes
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableDocking
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableFullScreenMainMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableFullScreenMode
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableLoadDockState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabbedGroups
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabsLastActiveActivation
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnablePaneMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableWindowsDialog
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetActivePopup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetDefaultResId
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabGroups
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabsContextMenuAllowedItems
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMenuBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetRibbonBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetTearOffBars
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetToolbarButtonToolTipText
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::InsertPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsFullScreen
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMDITabbedGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMemberOfMDITabGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMenuBarAvailable
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsPointNearDockSite
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsPrintPreview
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::LoadFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::LoadMDIState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::MDITabMoveToNextGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::MDITabNewGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::NegotiateBorderSpace
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCloseDockingPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCloseMiniFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnClosePopupMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCmdMsg
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnDrawMenuImage
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnDrawMenuLogo
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnEraseMDIClientBackground
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnMenuButtonToolHitTest
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnMoveMiniFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnSetPreviewMode
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowCustomizePane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowMDITabContextMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowPanes
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowPopupMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnSizeMDIClient
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnTearOffMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnUpdateFrameMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::PaneFromPoint
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::RecalcLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::RemovePaneFromDockManager
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SaveMDIState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SetPrintPreviewFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SetupToolbarMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowFullScreen
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowWindowsDialog
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::TabbedDocumentToControlBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::UpdateCaption
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::UpdateMDITabbedBarsIcons
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::WinHelp
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::m_bDisableSetRedraw
helpviewer_keywords:
- CMDIFrameWndEx [MFC], ActiveItemRecalcLayout
- CMDIFrameWndEx [MFC], AddPane
- CMDIFrameWndEx [MFC], AdjustClientArea
- CMDIFrameWndEx [MFC], AdjustDockingLayout
- CMDIFrameWndEx [MFC], AreMDITabs
- CMDIFrameWndEx [MFC], CanCovertControlBarToMDIChild
- CMDIFrameWndEx [MFC], ControlBarToTabbedDocument
- CMDIFrameWndEx [MFC], CreateDocumentWindow
- CMDIFrameWndEx [MFC], CreateNewWindow
- CMDIFrameWndEx [MFC], DockPane
- CMDIFrameWndEx [MFC], DockPaneLeftOf
- CMDIFrameWndEx [MFC], EnableAutoHidePanes
- CMDIFrameWndEx [MFC], EnableDocking
- CMDIFrameWndEx [MFC], EnableFullScreenMainMenu
- CMDIFrameWndEx [MFC], EnableFullScreenMode
- CMDIFrameWndEx [MFC], EnableLoadDockState
- CMDIFrameWndEx [MFC], EnableMDITabbedGroups
- CMDIFrameWndEx [MFC], EnableMDITabs
- CMDIFrameWndEx [MFC], EnableMDITabsLastActiveActivation
- CMDIFrameWndEx [MFC], EnablePaneMenu
- CMDIFrameWndEx [MFC], EnableWindowsDialog
- CMDIFrameWndEx [MFC], GetActivePopup
- CMDIFrameWndEx [MFC], GetPane
- CMDIFrameWndEx [MFC], GetDefaultResId
- CMDIFrameWndEx [MFC], GetMDITabGroups
- CMDIFrameWndEx [MFC], GetMDITabs
- CMDIFrameWndEx [MFC], GetMDITabsContextMenuAllowedItems
- CMDIFrameWndEx [MFC], GetMenuBar
- CMDIFrameWndEx [MFC], GetRibbonBar
- CMDIFrameWndEx [MFC], GetTearOffBars
- CMDIFrameWndEx [MFC], GetToolbarButtonToolTipText
- CMDIFrameWndEx [MFC], InsertPane
- CMDIFrameWndEx [MFC], IsFullScreen
- CMDIFrameWndEx [MFC], IsMDITabbedGroup
- CMDIFrameWndEx [MFC], IsMemberOfMDITabGroup
- CMDIFrameWndEx [MFC], IsMenuBarAvailable
- CMDIFrameWndEx [MFC], IsPointNearDockSite
- CMDIFrameWndEx [MFC], IsPrintPreview
- CMDIFrameWndEx [MFC], LoadFrame
- CMDIFrameWndEx [MFC], LoadMDIState
- CMDIFrameWndEx [MFC], MDITabMoveToNextGroup
- CMDIFrameWndEx [MFC], MDITabNewGroup
- CMDIFrameWndEx [MFC], NegotiateBorderSpace
- CMDIFrameWndEx [MFC], OnCloseDockingPane
- CMDIFrameWndEx [MFC], OnCloseMiniFrame
- CMDIFrameWndEx [MFC], OnClosePopupMenu
- CMDIFrameWndEx [MFC], OnCmdMsg
- CMDIFrameWndEx [MFC], OnDrawMenuImage
- CMDIFrameWndEx [MFC], OnDrawMenuLogo
- CMDIFrameWndEx [MFC], OnEraseMDIClientBackground
- CMDIFrameWndEx [MFC], OnMenuButtonToolHitTest
- CMDIFrameWndEx [MFC], OnMoveMiniFrame
- CMDIFrameWndEx [MFC], OnSetPreviewMode
- CMDIFrameWndEx [MFC], OnShowCustomizePane
- CMDIFrameWndEx [MFC], OnShowMDITabContextMenu
- CMDIFrameWndEx [MFC], OnShowPanes
- CMDIFrameWndEx [MFC], OnShowPopupMenu
- CMDIFrameWndEx [MFC], OnSizeMDIClient
- CMDIFrameWndEx [MFC], OnTearOffMenu
- CMDIFrameWndEx [MFC], OnUpdateFrameMenu
- CMDIFrameWndEx [MFC], PaneFromPoint
- CMDIFrameWndEx [MFC], RecalcLayout
- CMDIFrameWndEx [MFC], RemovePaneFromDockManager
- CMDIFrameWndEx [MFC], SaveMDIState
- CMDIFrameWndEx [MFC], SetPrintPreviewFrame
- CMDIFrameWndEx [MFC], SetupToolbarMenu
- CMDIFrameWndEx [MFC], ShowFullScreen
- CMDIFrameWndEx [MFC], ShowPane
- CMDIFrameWndEx [MFC], ShowWindowsDialog
- CMDIFrameWndEx [MFC], TabbedDocumentToControlBar
- CMDIFrameWndEx [MFC], UpdateCaption
- CMDIFrameWndEx [MFC], UpdateMDITabbedBarsIcons
- CMDIFrameWndEx [MFC], WinHelp
- CMDIFrameWndEx [MFC], m_bCanCovertControlBarToMDIChild
- CMDIFrameWndEx [MFC], m_bDisableSetRedraw
ms.assetid: dbcafcb3-9a7a-4f11-9dfe-ba57565c81d0
ms.openlocfilehash: 7973cf89eaa2090a8f1548f38a728f1100d5cbec
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/15/2019
ms.locfileid: "69505538"
---
# <a name="cmdiframewndex-class"></a>CMDIFrameWndEx-Klasse

Erweitert die Funktionalität von [CMDIFrameWnd](../../mfc/reference/cframewnd-class.md), einem Windows-MDI-Rahmen Fenster (Multiple Document Interface).

## <a name="syntax"></a>Syntax

```
class CMDIFrameWndEx : public CMDIFrameWnd
```

## <a name="members"></a>Member

### <a name="public-methods"></a>Öffentliche Methoden

|Name|Beschreibung|
|----------|-----------------|
|[CMDIFrameWndEx::ActiveItemRecalcLayout](#activeitemrecalclayout)|Berechnet das Layout des aktiven Elements neu.|
|`CMDIFrameWndEx::AddDockSite`|Diese Methode wird nicht verwendet.|
|[CMDIFrameWndEx::AddPane](#addpane)|Registriert einen Bereich beim Docking-Manager.|
|[CMDIFrameWndEx::AdjustClientArea](#adjustclientarea)|Reduziert den Client Bereich, um einen Rahmen zuzulassen.|
|[CMDIFrameWndEx:: Anpassungen dockinglayout](#adjustdockinglayout)|Berechnet das Layout aller angedockten Bereiche neu.|
|[CMDIFrameWndEx::AreMDITabs](#aremditabs)|Bestimmt, ob die MDI-Registerkarten oder die MDI-Funktion für Registerkarten im Registerkarten Format aktiviert ist.|
|[CMDIFrameWndEx::CanCovertControlBarToMDIChild](#cancovertcontrolbartomdichild)|Wird von Framework aufgerufen, um zu bestimmen, ob das Rahmen Fenster andockbare Bereiche in Dokumente im Register Format konvertieren kann.|
|[CMDIFrameWndEx::ControlBarToTabbedDocument](#controlbartotabbeddocument)|Konvertiert den angegebenen Andock Bereich in ein Dokument im Registerkarten Format.|
|[CMDIFrameWndEx::CreateDocumentWindow](#createdocumentwindow)|Erstellt ein untergeordnetes Dokument Fenster.|
|[CMDIFrameWndEx::CreateNewWindow](#createnewwindow)|Wird von Framework aufgerufen, um ein neues Fenster zu erstellen.|
|`CMDIFrameWndEx::CreateObject`|Wird vom Framework verwendet, um eine dynamische Instanz dieses Klassentyps zu erstellen.|
|[CMDIFrameWndEx::DockPane](#dockpane)|Dockt den angegebenen Bereich an das Rahmen Fenster an.|
|[CMDIFrameWndEx::DockPaneLeftOf](#dockpaneleftof)|Dockt einen Bereich auf der linken Seite eines anderen Bereichs an.|
|[CMDIFrameWndEx::EnableAutoHidePanes](#enableautohidepanes)|Aktiviert den Modus für Automatisches Ausblenden von Bereichen, wenn diese an angegebenen Seiten des Hauptrahmen Fensters angedockt werden.|
|[CMDIFrameWndEx::EnableDocking](#enabledocking)|Aktiviert das Andocken der Bereiche, die zum MDI-Rahmen Fenster gehören.|
|[CMDIFrameWndEx::EnableFullScreenMainMenu](#enablefullscreenmainmenu)|Zeigt das Hauptmenü im Vollbildmodus an oder blendet es aus.|
|[CMDIFrameWndEx::EnableFullScreenMode](#enablefullscreenmode)|Aktiviert den Vollbildmodus für das Rahmen Fenster.|
|[CMDIFrameWndEx::EnableLoadDockState](#enableloaddockstate)|Aktiviert oder deaktiviert das Laden des Andock Zustands.|
|[CMDIFrameWndEx::EnableMDITabbedGroups](#enablemditabbedgroups)|Aktiviert oder deaktiviert die MDI-Funktion für Gruppen im Registerkarten Format.|
|[CMDIFrameWndEx::EnableMDITabs](#enablemditabs)|Aktiviert oder deaktiviert das Feature "MDI-Registerkarten". Wenn diese Option aktiviert ist, wird im Rahmen Fenster eine Registerkarte für jedes untergeordnete MDI-Fenster angezeigt.|
|[CMDIFrameWndEx::EnableMDITabsLastActiveActivation](#enablemditabslastactiveactivation)|Gibt an, ob die letzte aktive Registerkarte aktiviert werden soll, wenn der Benutzer die aktuelle Registerkarte schließt.|
|[CMDIFrameWndEx::EnablePaneMenu](#enablepanemenu)|Aktiviert oder deaktiviert die automatische Erstellung und Verwaltung des Popup-Menü Menüs, das eine Liste der Anwendungsbereiche anzeigt.  .|
|[CMDIFrameWndEx::EnableWindowsDialog](#enablewindowsdialog)|Fügt ein Menü Element ein, dessen Befehls-ID ein [cmfcwindowsmanagerdialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md) -Dialogfeld aufruft.|
|[CMDIFrameWndEx::GetActivePopup](#getactivepopup)|Gibt einen Zeiger auf das aktuell angezeigte Popupmenü zurück.|
|[CMDIFrameWndEx::GetPane](#getpane)|Gibt einen Zeiger auf den Bereich zurück, der die angegebene Steuerelement-ID aufweist.|
|[CMDIFrameWndEx::GetDefaultResId](#getdefaultresid)|Gibt die ID der freigegebenen Ressourcen für das MDI-Rahmen Fenster zurück.|
|[CMDIFrameWndEx::GetMDITabGroups](#getmditabgroups)|Gibt eine Liste von MDI-Fenstern im Registerkarten Format zurück.|
|[CMDIFrameWndEx::GetMDITabs](#getmditabs)|Gibt einen Verweis auf das unterstrichene Fenster im Register Format zurück.|
|[CMDIFrameWndEx::GetMDITabsContextMenuAllowedItems](#getmditabscontextmenualloweditems)|Gibt eine Kombination von Flags zurück, die bestimmt, welche Kontextmenü Elemente gültig sind, wenn die MDI-Funktion mit Registerkarten für Gruppen aktiviert ist.|
|[CMDIFrameWndEx::GetMenuBar](#getmenubar)|Gibt einen Zeiger auf ein Menüleisten Objekt zurück, das an das Rahmen Fenster angefügt ist.|
|[CMDIFrameWndEx::GetRibbonBar](#getribbonbar)|Ruft das Menü Band leisten-Steuerelement für den Frame ab.|
|[CMDIFrameWndEx:: gettearoffbars](#gettearoffbars)|Gibt eine Liste von Objekten zurück, die von [CPANE](../../mfc/reference/cpane-class.md)abgeleitet wurden und die sich in einem abtrenn Zustand befinden.|
|`CMDIFrameWndEx::GetThisClass`|Wird von Framework aufgerufen, um einen Zeiger auf das [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) -Objekt zu erhalten, das diesem Klassentyp zugeordnet ist.|
|[CMDIFrameWndEx::GetToolbarButtonToolTipText](#gettoolbarbuttontooltiptext)|Wird von Framework aufgerufen, wenn die Anwendung die QuickInfo für eine Symbolleisten-Schaltfläche anzeigt.|
|[CMDIFrameWndEx:: insertpane](#insertpane)|Registriert den angegebenen Bereich beim Docking-Manager.|
|[CMDIFrameWndEx::IsFullScreen](#isfullscreen)|Bestimmt, ob sich das Rahmen Fenster im Vollbildmodus befindet.|
|[CMDIFrameWndEx::IsMDITabbedGroup](#ismditabbedgroup)|Bestimmt, ob die MDI-Funktion für Gruppen im Registerkarten Format aktiviert ist.|
|[CMDIFrameWndEx::IsMemberOfMDITabGroup](#ismemberofmditabgroup)|Bestimmt, ob das angegebene Fenster im Register Format in der Liste der Fenster enthalten ist, die in MDI-Gruppen im Registerkarten Format enthalten sind.|
|[CMDIFrameWndEx::IsMenuBarAvailable](#ismenubaravailable)|Bestimmt, ob das Rahmen Fenster über eine Menüleiste verfügt.|
|[CMDIFrameWndEx:: ispointneardocksite](#ispointneardocksite)|Bestimmt, ob sich ein angegebener Punkt in der Nähe des Dock Standorts befindet|
|[CMDIFrameWndEx::IsPrintPreview](#isprintpreview)|Bestimmt, ob sich das Rahmen Fenster im Druckvorschau Modus befindet.|
|[CMDIFrameWndEx::LoadFrame](#loadframe)|Erstellt ein Rahmen Fenster anhand von Ressourcen Informationen. (Überschreibt `CMDIFrameWnd::LoadFrame`.)|
|[CMDIFrameWndEx::LoadMDIState](#loadmdistate)|Lädt das angegebene Layout der MDI-Gruppen im Registerkarten Format und die Liste der zuvor geöffneten Dokumente.|
|[CMDIFrameWndEx::MDITabMoveToNextGroup](#mditabmovetonextgroup)|Verschiebt die aktive Registerkarte aus dem momentan aktiven Fenster im Registerkarten Format in die nächste oder vorherige Gruppe im Registerkarten Format.|
|[CMDIFrameWndEx::MDITabNewGroup](#mditabnewgroup)|Erstellt eine neue Gruppe mit Registerkarten, die über ein einzelnes Fenster verfügt.|
|[CMDIFrameWndEx::NegotiateBorderSpace](#negotiateborderspace)|Aushandiert einen Rahmen Bereich in einem Rahmen Fenster während der OLE-direkten Aktivierung.|
|[CMDIFrameWndEx::OnCloseDockingPane](#onclosedockingpane)|Wird von Framework aufgerufen, wenn der Benutzer auf die Schaltfläche **Schließen** in einem andockbaren Bereich klickt.|
|[CMDIFrameWndEx::OnCloseMiniFrame](#oncloseminiframe)|Wird von Framework aufgerufen, wenn der Benutzer auf die Schaltfläche **Schließen** in einem unverankerten Mini Rahmen Fenster klickt.|
|[CMDIFrameWndEx::OnClosePopupMenu](#onclosepopupmenu)|Wird vom Framework aufgerufen, wenn ein aktives Popupmenü eine WM_DESTROY-Meldung verarbeitet.|
|[CMDIFrameWndEx::OnCmdMsg](#oncmdmsg)|Wird von Framework aufgerufen, um Befehls Meldungen weiterzuleiten und zu verteilen und Befehls Benutzeroberflächen Objekte zu aktualisieren.|
|[CMDIFrameWndEx::OnDrawMenuImage](#ondrawmenuimage)|Wird vom Framework aufgerufen, wenn das einem Menüelement zugeordnete Bild gezeichnet wird.|
|[CMDIFrameWndEx::OnDrawMenuLogo](#ondrawmenulogo)|Wird von Framework aufgerufen, wenn ein [cmfcpopupmenu](../../mfc/reference/cmfcpopupmenu-class.md)eine WM_PAINT-Meldung verarbeitet.|
|[CMDIFrameWndEx:: onerasemdiclientbackground](#onerasemdiclientbackground)|Wird von Framework aufgerufen, wenn das MDI-Rahmen Fenster eine WM_ERASEBKGND-Nachricht verarbeitet.|
|[CMDIFrameWndEx::OnMenuButtonToolHitTest](#onmenubuttontoolhittest)|Wird von Framework aufgerufen, wenn ein [cmfctoolbarbutton](../../mfc/reference/cmfctoolbarbutton-class.md)-Objekt eine WM_NCHITTEST-Nachricht verarbeitet.|
|[CMDIFrameWndEx::OnMoveMiniFrame](#onmoveminiframe)|Wird von Framework aufgerufen, um ein Mini Rahmen Fenster zu verschieben.|
|[CMDIFrameWndEx::OnSetPreviewMode](#onsetpreviewmode)|Legt den Druck-Vorschaumodus der Anwendung fest. (Überschreibt [CFrameWnd::OnSetPreviewMode](../../mfc/reference/cframewnd-class.md#onsetpreviewmode).)|
|[CMDIFrameWndEx:: onshowcustomizepane](#onshowcustomizepane)|Wird von Framework aufgerufen, wenn ein Bereich für die schnelle Anpassung aktiviert wird.|
|[CMDIFrameWndEx::OnShowMDITabContextMenu](#onshowmditabcontextmenu)|Wird von Framework aufgerufen, wenn ein Kontextmenü auf einer der Registerkarten angezeigt werden soll. (Gilt nur für MDI-Gruppen im Registerkarten Format.)|
|[CMDIFrameWndEx::OnShowPanes](#onshowpanes)|Wird von Framework aufgerufen, um Bereiche anzuzeigen oder auszublenden.|
|[CMDIFrameWndEx::OnShowPopupMenu](#onshowpopupmenu)|Wird vom Framework aufgerufen, wenn ein Popupmenü aktiviert wird.|
|[CMDIFrameWndEx::OnSizeMDIClient](#onsizemdiclient)|Wird von Framework aufgerufen, wenn die Größe des Client-MDI-Fensters geändert wird.|
|[CMDIFrameWndEx::OnTearOffMenu](#ontearoffmenu)|Wird vom Framework aufgerufen, wenn ein Menü mit abtrennbarer Leiste aktiviert wird.|
|[CMDIFrameWndEx::OnUpdateFrameMenu](#onupdateframemenu)|Wird von Framework aufgerufen, um das Frame Menü zu aktualisieren. (Überschreibt `CMDIFrameWnd::OnUpdateFrameMenu`.)|
|[CMDIFrameWndEx::PaneFromPoint](#panefrompoint)|Gibt den andockbaren Bereich zurück, der den angegebenen Punkt enthält.|
|`CMDIFrameWndEx::PreTranslateMessage`|Wird von der [CWinApp](../../mfc/reference/cwinapp-class.md) -Klasse verwendet, um Fenstermeldungen zu übersetzen, bevor diese an die Windows-Funktionen [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) und [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) gesendet werden.  (Überschreibt `CMDIFrameWnd::PreTranslateMessage`.)|
|[CMDIFrameWndEx:: Neuberechnung](#recalclayout)|Wird von Framework aufgerufen, um das Layout des Rahmen Fensters neu zu berechnen. (Überschreibt [CFrameWnd:: Neuberechnung](../../mfc/reference/cframewnd-class.md#recalclayout).)|
|[CMDIFrameWndEx::RemovePaneFromDockManager](#removepanefromdockmanager)|Hebt die Registrierung eines Bereichs auf und entfernt ihn aus dem Docking-Manager.|
|[CMDIFrameWndEx::SaveMDIState](#savemdistate)|Speichert das aktuelle Layout der MDI-Gruppen im Registerkarten Format und die Liste der zuvor geöffneten Dokumente.|
|[CMDIFrameWndEx::SetPrintPreviewFrame](#setprintpreviewframe)|Legt das Rahmen Fenster der Druckvorschau fest.|
|[CMDIFrameWndEx:: setuptoolbarmenu](#setuptoolbarmenu)|Ändert ein Symbolleistenobjekt durch die Suche nach Dummy-Elementen und durch das anschließende Ersetzen dieser Dummy-Elemente durch die angegebenen benutzerdefinierten Elemente.|
|[CMDIFrameWndEx::ShowFullScreen](#showfullscreen)|Schaltet den Hauptframe vom regulären zum Vollbildmodus.|
|[CMDIFrameWndEx::ShowPane](#showpane)|Blendet den angegebenen Bereich ein oder aus.|
|[CMDIFrameWndEx::ShowWindowsDialog](#showwindowsdialog)|Erstellt ein [cmfcwindowsmanagerdialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md) -Feld und öffnet es.|
|[CMDIFrameWndEx::TabbedDocumentToControlBar](#tabbeddocumenttocontrolbar)|Konvertiert das angegebene Dokument im Registerkarten Format in einen Andock Bereich.|
|[CMDIFrameWndEx::UpdateCaption](#updatecaption)|Wird von Framework aufgerufen, um die Fensterrahmen Beschriftung zu aktualisieren.|
|[CMDIFrameWndEx::UpdateMDITabbedBarsIcons](#updatemditabbedbarsicons)|Legt das Symbol für jedes MDI-Fenster im Registerkarten Format fest.|
|[CMDIFrameWndEx::WinHelp](#winhelp)|Wird vom Framework aufgerufen, um die WinHelp-Anwendung oder die Kontexthilfe zu initiieren. (Überschreibt [CWnd:: WinHelp](../../mfc/reference/cwnd-class.md#winhelp).)|

### <a name="data-members"></a>Datenmember

|Name|Beschreibung|
|----------|-----------------|
|[CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild](#m_bcancovertcontrolbartomdichild)|Bestimmt, ob Docking Bereiche in untergeordnete MDI-Fenster konvertiert werden können.|
|[CMDIFrameWndEx:: m_bDisableSetRedraw](#m_bdisablesetredraw)|Aktiviert oder deaktiviert die neuzeichnungs Optimierung für untergeordnete MDI-Fenster.|

## <a name="remarks"></a>Hinweise

Um die erweiterten Anpassungs Features in der MDI-Anwendung zu nutzen, leiten Sie die MDI-Frame Fenster Klasse der `CMDIFrameWndEx` Anwendung von `CMDIFrameWnd`anstelle von ab.

## <a name="example"></a>Beispiel

Im folgenden Beispiel wird eine Klasse von `CMDIFrameWndEx`abgeleitet. Der folgende Code Ausschnitt stammt aus dem [drawclient-Beispiel: MFC-Menüband-basiertes OLE-](../../overview/visual-cpp-samples.md)Objekt Zeichnungsanwendung.

[!code-cpp[NVC_MFC_DrawClient#1](../../mfc/reference/codesnippet/cpp/cmdiframewndex-class_1.h)]

## <a name="inheritance-hierarchy"></a>Vererbungshierarchie

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWnd](../../mfc/reference/cwnd-class.md)

[CFrameWnd](../../mfc/reference/cframewnd-class.md)

[CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md)

[CMDIFrameWndEx](../../mfc/reference/cmdiframewndex-class.md)

## <a name="requirements"></a>Anforderungen

**Header:** afxmdiframewndex. h

##  <a name="activeitemrecalclayout"></a>CMDIFrameWndEx:: activeitemneueyout

Berechnet das Layout des aktiven Elements neu.

```
void ActiveItemRecalcLayout();
```

##  <a name="addpane"></a>CMDIFrameWndEx:: addpane

Registriert einen Bereich beim Docking-Manager.

```
BOOL AddPane(
    CBasePane* pControlBar,
    BOOL bTail=TRUE);
```

### <a name="parameters"></a>Parameter

*pControlBar*<br/>
in Zeiger auf den Bereich, der registriert werden soll.

*bTail*<br/>
in Gibt an, ob dieser Bereich am Ende der Liste hinzugefügt werden soll.

### <a name="return-value"></a>Rückgabewert

Gibt einen Wert ungleich 0 (null) zurück, wenn der Bereich erfolgreich registriert wurde. Gibt 0 zurück, wenn der Bereich bereits beim Docking-Manager registriert ist.

### <a name="remarks"></a>Hinweise

Jeder Bereich muss bei der [cdockingmanager-Klasse](../../mfc/reference/cdockingmanager-class.md) registriert werden, bevor er ein Teil des Andock Layouts nehmen kann. Verwenden Sie diese Methode, um den Docking-Manager zu benachrichtigen, dass Sie einen bestimmten Bereich andocken möchten. Sobald dieser Bereich registriert ist, richtet der Andock-Manager ihn basierend auf der Ausrichtungs Einstellung und Position in der Liste der Bereiche aus, die vom Docking-Manager verwaltet werden.

##  <a name="adjustclientarea"></a>CMDIFrameWndEx::-Client Bereich

Reduziert den Client Bereich, um einen Rahmen zuzulassen.

```
virtual void AdjustClientArea();
```

##  <a name="adjustdockinglayout"></a>CMDIFrameWndEx:: Anpassungen dockinglayout

Berechnet das Layout aller angedockten Bereiche neu.

```
virtual void AdjustDockingLayout(HDWP hdwp=NULL);
```

### <a name="parameters"></a>Parameter

*hdwp*<br/>
in Gibt die Struktur mit mehreren Fenstern an. Sie können diesen Wert abrufen, indem `BeginDeferWindowPos`Sie aufrufen.

### <a name="remarks"></a>Hinweise

Mit dieser Member-Funktion können Sie das Layout aller Bereiche neu berechnen, die an das Rahmen Fenster angedockt sind.

##  <a name="aremditabs"></a>CMDIFrameWndEx:: aremditabs

Bestimmt, ob die MDI-Registerkarten oder die MDI-Funktion für Registerkarten im Registerkarten Format aktiviert ist.

```
BOOL AreMDITabs(int* pnMDITabsType=NULL) const;
```

### <a name="parameters"></a>Parameter

*pnMDITabsType*<br/>
vorgenommen Ein Zeiger auf eine ganzzahlige Variable, die angibt, welche Funktionen aktiviert sind:

- 0: Alle Funktionen sind deaktiviert.

- 1: Die MDI-Registerkarten sind aktiviert.

- 2: MDI-Gruppen im Registerkarten Format sind aktiviert.

### <a name="return-value"></a>Rückgabewert

Gibt true zurück, wenn MDI-Registerkarten oder MDI-Gruppen im Registerkarten Format aktiviert ist.

Gibt false zurück, wenn keine der obigen Features aktiviert ist.

### <a name="remarks"></a>Hinweise

Verwenden Sie diese Funktion, um zu bestimmen, ob MDI-Registerkarten oder MDI-Gruppen im Registerkarten Format für das Rahmen Fenster aktiviert sind Verwenden Sie [CMDIFrameWndEx:: enablemditabs](#enablemditabs) , um die MDI-Registerkarten Funktion zu aktivieren oder zu deaktivieren.

Verwenden Sie [CMDIFrameWndEx:: EnableMDITabbedGroups](#enablemditabbedgroups) , um die MDI-Funktion mit Registerkarten im Registerkarten Format zu aktivieren oder zu deaktivieren.

##  <a name="cancovertcontrolbartomdichild"></a>CMDIFrameWndEx:: cancovertcontrolbartomdichild

Wird von Framework aufgerufen, um zu bestimmen, ob das Rahmen Fenster andockbare Bereiche in Dokumente im Register Format konvertieren kann.

```
virtual BOOL CanCovertControlBarToMDIChild();
```

### <a name="return-value"></a>Rückgabewert

Gibt true zurück, wenn das Rahmen Fenster andockbare Bereiche in Dokumente im Register Format konvertieren kann. Andernfalls wird false zurückgegeben.

### <a name="remarks"></a>Hinweise

Überschreiben Sie diese Methode in einer abgeleiteten Klasse, und geben Sie true zurück, um die Konvertierung von andockbaren Bereichen in Dokumente im Register Format Alternativ können Sie [CMDIFrameWndEx:: m_bCanCovertControlBarToMDIChild](#m_bcancovertcontrolbartomdichild) auf true festlegen.

##  <a name="controlbartotabbeddocument"></a>CMDIFrameWndEx:: controlbartotabbeddocument

Konvertiert den angegebenen Andock Bereich in ein Dokument im Registerkarten Format.

```
virtual CMDIChildWndEx* ControlBarToTabbedDocument(CDockablePane* pBar);
```

### <a name="parameters"></a>Parameter

*pBar*<br/>
Ein Zeiger auf den zu konvertierenden Andock Bereich.

### <a name="return-value"></a>Rückgabewert

Gibt einen Zeiger auf das neue untergeordnete MDI-Fenster zurück, das den andockbaren Bereich enthält.

### <a name="remarks"></a>Hinweise

Diese Methode konvertiert einen Andock Bereich in ein Dokument im Registerkarten Format. Wenn Sie diese Methode aufgerufen haben, erstellt das Framework ein [CMDIChildWndEx-Klassen](../../mfc/reference/cmdichildwndex-class.md) Objekt, entfernt den Docking Bereich aus dem Docking-Manager und fügt den andockbaren Bereich zum neuen untergeordneten MDI-Fenster hinzu. Das untergeordnete MDI-Fenster passt die Größe des Andock Bereichs an, um den gesamten Client Bereich abzudecken.

##  <a name="createdocumentwindow"></a>CMDIFrameWndEx:: angleichen DocumentWindow

Erstellt ein untergeordnetes Dokument Fenster.

```
virtual CMDIChildWndEx* CreateDocumentWindow(
    LPCTSTR lpcszDocName,
    CObject* pObj);
```

### <a name="parameters"></a>Parameter

*lpcszDocName*<br/>
in Eine Text Zeichenfolge, die einen Dokument Bezeichner enthält. In der Regel handelt es sich dabei um den vollständigen Pfad einer Dokument Datei.

*pObj*<br/>
in Ein Zeiger auf ein benutzerdefiniertes Objekt. Ein Entwickler kann z. b. eine anwendungsspezifische Datenstruktur erstellen, die das Dokument beschreibt und erläutert, wie das Dokument beim Start initialisiert werden soll.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf `CMDIChildWndEx`.

### <a name="remarks"></a>Hinweise

Das Framework ruft diese Methode auf, wenn es die Liste der zuvor in der Registrierung gespeicherten Dokumente lädt.

Überschreiben Sie diese Methode, um Dokumente zu erstellen, wenn Sie aus der Registrierung geladen werden.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `CreateDocumentWindow` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

In diesem Beispiel `g_strStartViewName` kann der Name eines "virtuellen Dokuments" (z. b. "Start Seite") sein, das nicht tatsächlich aus einer Datenträger Datei geladen wird. Daher ist eine spezielle Verarbeitung erforderlich, um diesen Fall zu verarbeiten.

[!code-cpp[NVC_MFC_VisualStudioDemo#13](../../mfc/codesnippet/cpp/cmdiframewndex-class_2.cpp)]

##  <a name="createnewwindow"></a>CMDIFrameWndEx:: kreatenewwindow

Wird von Framework aufgerufen, um ein neues Fenster zu erstellen.

```
virtual CMDIChildWndEx* CreateNewWindow(
    LPCTSTR lpcszDocName,
    CObject* pObj);
```

### <a name="parameters"></a>Parameter

*lpcszDocName*<br/>
in Der Dokument Name.

*pObj*<br/>
in Reserviert für zukünftige Verwendung.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf das neue Fenster.

##  <a name="dockpane"></a>CMDIFrameWndEx::D ockpane

Dockt den angegebenen Bereich an das Rahmen Fenster an.

```
void DockPane(
    CBasePane* pBar,
    UINT nDockBarID=0,
    LPCRECT lpRect=NULL);
```

### <a name="parameters"></a>Parameter

*pBar*<br/>
in Zeiger auf den Bereich, der Andocken soll.

*nDockBarID*<br/>
in Gibt an, an welche Seiten des Rahmen Fensters angedockt werden soll.

*lpRect*<br/>
in Nicht verwendet.

### <a name="remarks"></a>Hinweise

Diese Methode Dockt den angegebenen Bereich an eine der Seiten des Rahmen Fensters an, das angegeben wurde, als [cbasepane:: EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking) und [CMDIFrameWndEx:: EnableDocking](#enabledocking) aufgerufen wurden.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird die Verwendung der `DockPane`-Methode gezeigt. Dieser Code Ausschnitt stammt aus dem [visualstudiodemo-Beispiel: MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#4](../../mfc/codesnippet/cpp/cmdiframewndex-class_3.cpp)]

##  <a name="dockpaneleftof"></a>CMDIFrameWndEx::D ockpaneleftof

Dockt einen Bereich auf der linken Seite eines anderen Bereichs an.

```
BOOL DockPaneLeftOf(
    CPane* pBar,
    CPane* pLeftOf);
```

### <a name="parameters"></a>Parameter

*pBar*<br/>
in Ein Zeiger auf den Andock Bereich.

*pLeftOf*<br/>
in Ein Zeiger auf den Bereich, der als Dock Site fungiert. .

### <a name="return-value"></a>Rückgabewert

Gibt true zurück, wenn der Vorgang erfolgreich ist. Andernfalls wird false zurückgegeben.

### <a name="remarks"></a>Hinweise

Mit dieser Methode können Sie mehrere Pane-Objekte in einer vordefinierten Reihenfolge andocken. Diese Methode Dockt den von *pbar* angegebenen Bereich links neben dem Bereich an, der von *pleftof*angegeben wird.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt, `DockPaneLeftOf` wie die-Methode [im visualstudiodemo-Beispiel verwendet wird: MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#5](../../mfc/codesnippet/cpp/cmdiframewndex-class_4.cpp)]

##  <a name="enableautohidepanes"></a>CMDIFrameWndEx:: enableautohidebereiche

Aktiviert den Modus für Automatisches Ausblenden von Bereichen, wenn diese an den angegebenen Seiten des Hauptrahmen Fensters angedockt werden.

```
BOOL EnableAutoHidePanes(DWORD dwDockStyle);
```

### <a name="parameters"></a>Parameter

*dwDockStyle*<br/>
in Gibt die Seiten des Hauptrahmen Fensters an, das aktiviert wird. Verwenden Sie mindestens eines der folgenden Flags.

- CBRS_ALIGN_LEFT

- CBRS_ALIGN_RIGHT

- CBRS_ALIGN_TOP

- CBRS_ALIGN_BOTTOM

### <a name="return-value"></a>Rückgabewert

Mit dieser Funktion können Sie den Modus für das automatische Ausblenden von Bereichen aktivieren, wenn Sie an den angegebenen Seiten des Hauptrahmen Fensters angedockt sind.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt, `EnableAutoHidePanes` wie die-Methode [im visualstudiodemo-Beispiel verwendet wird: MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#6](../../mfc/codesnippet/cpp/cmdiframewndex-class_5.cpp)]

### <a name="remarks"></a>Hinweise

##  <a name="enabledocking"></a>CMDIFrameWndEx:: EnableDocking

Aktiviert das Andocken der Bereiche, die zum MDI-Rahmen Fenster gehören.

```
BOOL EnableDocking(DWORD dwDockStyle);
```

### <a name="parameters"></a>Parameter

*dwDockStyle*<br/>
in Gibt die Andock Art an, die Sie anwenden möchten.

### <a name="return-value"></a>Rückgabewert

### <a name="remarks"></a>Hinweise

Mit dieser Funktion wird das Andocken von Bereichen aktiviert, `CMDIFrameWndEx` die zum-Objekt gehören.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt, `EnableDocking` wie die-Methode [im visualstudiodemo-Beispiel verwendet wird: MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#7](../../mfc/codesnippet/cpp/cmdiframewndex-class_6.cpp)]

##  <a name="enablefullscreenmainmenu"></a>CMDIFrameWndEx:: enablefullscreenmainmenu

Zeigt das Hauptmenü im Vollbildmodus an oder blendet es aus.

```
void EnableFullScreenMainMenu(BOOL bEnableMenu);
```

### <a name="parameters"></a>Parameter

*bEnableMenu*<br/>
in TRUE, wenn das Hauptmenü im Vollbildmodus angezeigt werden soll, oder false, um es auszublenden.

### <a name="remarks"></a>Hinweise

##  <a name="enablefullscreenmode"></a>CMDIFrameWndEx:: enablefullscreenmode

Aktiviert den Vollbildmodus für das Rahmen Fenster.

```
void EnableFullScreenMode(UINT uiFullScreenCmd);
```

### <a name="parameters"></a>Parameter

*uiFullScreenCmd*<br/>
in Die ID eines Befehls, der den Vollbildmodus aktiviert oder deaktiviert.

### <a name="remarks"></a>Hinweise

Im Vollbildmodus werden alle andockbaren Steuer leisten, Symbolleisten und Menüs ausgeblendet, und die Größe der aktiven Ansicht wird so angepasst, dass Sie den voll Bildschirm einnimmt. Wenn Sie den Vollbildmodus aktivieren, müssen Sie eine ID des Befehls angeben, von dem Sie aktiviert oder deaktiviert wird. Sie können von `EnableFullScreenMode` der- `OnCreate` Funktion des Haupt Frames aus aufzurufen. Wenn ein Rahmen Fenster in den Vollbildmodus gewechselt wird, erstellt das Framework eine unverankerte Symbolleiste mit einer Schaltfläche, die über die angegebene Befehls-ID verfügt. Wenn Sie das Hauptmenü auf dem Bildschirm behalten möchten, können Sie [CMDIFrameWndEx:: enablefullscreenmainmenu](#enablefullscreenmainmenu)abrufen.

##  <a name="enableloaddockstate"></a>CMDIFrameWndEx:: enableloaddockstate

Aktiviert oder deaktiviert das Laden des Andock Zustands.

```
void EnableLoadDockState(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>Parameter

*bEnable*<br/>
in "True", um das Laden des Andock Zustands zu aktivieren, "false", um das Laden des Andock Zustands zu deaktivieren.

### <a name="remarks"></a>Hinweise

##  <a name="enablemditabbedgroups"></a>CMDIFrameWndEx:: EnableMDITabbedGroups

Aktiviert oder deaktiviert die MDI-Funktion im Registerkarten Format für das Rahmen Fenster.

```
void EnableMDITabbedGroups(
    BOOL bEnable,
    const CMDITabInfo& params);
```

### <a name="parameters"></a>Parameter

*bEnable*<br/>
in TRUE gibt an, dass die MDI-Funktion für Gruppen im Registerkarten Format aktiviert ist. FALSE gibt an, dass die MDI-Funktion im Registerkarten Format deaktiviert ist.

*params*<br/>
in Gibt Parameter an, die das Framework für untergeordnete Fenster anwendet, die im MDI-Client Bereich erstellt werden.

### <a name="remarks"></a>Hinweise

Verwenden Sie diese Methode zum Aktivieren oder Deaktivieren der MDI-Funktion für Registerkarten im Registerkarten Format. Mit dieser Funktion können MDI-Anwendungen untergeordnete Fenster als Fenster im Registerkarten Format anzeigen, die vertikal oder horizontal innerhalb des MDI-Client Bereichs ausgerichtet sind. Gruppen von Fenstern im Registerkarten Format werden durch Splitters getrennt. Der Benutzer kann die Größe von Gruppen im Registerkarten Format mithilfe eines Splitters ändern.

- Der Benutzer kann folgende Aktionen ausführen:

- Ziehen Sie einzelne Registerkarten zwischen Gruppen.

- Ziehen Sie einzelne Registerkarten an den Rand des Fensters, um neue Gruppen zu erstellen.

- Verschieben von Registerkarten oder Erstellen neuer Gruppen mithilfe eines Kontextmenüs

- Die Anwendung kann das aktuelle Layout von Fenstern im Registerkarten Format und die Liste der aktuell geöffneten Dokumente speichern.

Wenn Sie diese Methode mit dem *Wert* false auf false festlegen, wird der Parameter ignoriert.

Auch wenn die MDI-Gruppen im Registerkarten Format bereits aktiviert sind, können Sie diese Methode erneut aufzurufen, um die Einstellungen für untergeordnete Fenster zu ändern. Aufrufen der-Methode, bei der *benable* auf true festgelegt ist, `CMDITabInfo` und Ändern der Member des Objekts , die durch den Parameter Parameters angegeben werden.

Weitere Informationen zur Verwendung von MDI-Gruppen im Registerkarten Format finden Sie unter [MDI-Gruppen im Register](../../mfc/mdi-tabbed-groups.md)Kartenformat.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `EnableMDITabbedGroups` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#8](../../mfc/codesnippet/cpp/cmdiframewndex-class_7.cpp)]

##  <a name="enablemditabs"></a>CMDIFrameWndEx:: enablemditabs

Aktiviert oder deaktiviert das MDI-Registerkarten Feature für das MDI-Rahmen Fenster. Wenn diese Option aktiviert ist, wird im Rahmen Fenster eine Registerkarte für jedes untergeordnete MDI-Fenster angezeigt.

```
void EnableMDITabs(
    BOOL bEnable=TRUE,
    BOOL bIcons=TRUE,
    CMFCTabCtrl::Location tabLocation=CMFCTabCtrl::LOCATION_BOTTOM,
    BOOL bTabCloseButton=FALSE,
    CMFCTabCtrl::Style style=CMFCTabCtrl::STYLE_3D_SCROLLED,
    BOOL bTabCustomTooltips=FALSE,
    BOOL bActiveTabCloseButton=FALSE);
```

### <a name="parameters"></a>Parameter

*bEnable*<br/>
Gibt an, ob Registerkarten aktiviert sind.

*bIcons*<br/>
Gibt an, ob auf den Registerkarten Symbole angezeigt werden sollen.

*tabLocation*<br/>
Gibt den Speicherort der Registerkarten Bezeichnungen an.

*bTabCloseButton*<br/>
Gibt an, ob Registerkarten schließen angezeigt werden sollen.

*style*<br/>
Gibt den Stil von Registerkarten an. Verwenden Sie STYLE_3D_SCROLLED für reguläre Registerkarten oder STYLE_3D_ONENOTE für Microsoft OneNote-Registerkarten.

*bTabCustomTooltips*<br/>
Gibt an, ob benutzerdefinierte Quick Infos aktiviert sind.

*bActiveTabCloseButton*<br/>
Wenn true, wird die Schaltfläche **Schließen** auf der aktiven Registerkarte anstatt in der rechten Ecke des Registerkarten Bereichs angezeigt.

### <a name="remarks"></a>Hinweise

Mit dieser Methode können Sie das MDI-Registerkarten Feature für das MDI-Rahmen Fenster aktivieren oder deaktivieren. Wenn diese Option aktiviert ist, werden alle untergeordneten Fenster als Registerkarten angezeigt.

Die Registerkarten Bezeichnungen können sich abhängig von der Einstellung des Parameters *tablocation*oben oder unten im Frame befinden. Sie können entweder `CMFCTabCtrl::LOCATION_BOTTOM` (die Standardeinstellung) oder `CMFCTabCtrl::LOCATION_TOP`angeben.

Wenn *btabcustomtooltips* den Wert true hat, wird eine AFX_WM_ON_GET_TAB_TOOLTIP-Nachricht an das Hauptrahmen Fenster gesendet. Ihr Code kann diese Nachricht verarbeiten und dem Framework benutzerdefinierte Quick Infos für MDI-Registerkarten bereitstellen.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `EnableMDITabs` , wie im MDITabsDemo-Beispielverwendetwird:[ MFC-MDI-Anwendung](../../overview/visual-cpp-samples.md)im Registerkarten Format.

[!code-cpp[NVC_MFC_MDITabsDemo#3](../../mfc/reference/codesnippet/cpp/cmdiframewndex-class_8.cpp)]

##  <a name="enablemditabslastactiveactivation"></a>CMDIFrameWndEx:: enablemditabslastactiveactivation

Gibt an, ob die letzte aktive Registerkarte geöffnet werden soll, wenn der Benutzer die aktuelle Registerkarte schließt.

```
void EnableMDITabsLastActiveActivation(BOOL bLastActiveTab=TRUE);
```

### <a name="parameters"></a>Parameter

*bLastActiveTab*<br/>
in Wenn true, aktivieren Sie die Aktivierung der letzten aktiven Registerkarte. Wenn der Wert false ist, deaktivieren Sie die Aktivierung der letzten aktiven Registerkarte.

### <a name="remarks"></a>Hinweise

Es gibt zwei Möglichkeiten, eine Registerkarte zu öffnen, wenn die aktive Registerkarte geschlossen ist:

- Aktivieren Sie die nächste Registerkarte.

- Aktivieren Sie die zuvor aktive Registerkarte.

Die Standard Implementierung verwendet die erste Methode.

Verwenden `EnableMDITabsLastActiveActivation` Sie, um die zweite Methode der Tab-Aktivierung zu aktivieren. Es emuliert die Art und Weise, wie Fenster untergeordnete MDI-Fenster öffnen.

##  <a name="enablepanemenu"></a>CMDIFrameWndEx:: enablepanemenu

Aktiviert oder deaktiviert die automatische Erstellung und Verwaltung des Popup-Menü Menüs, das eine Liste der Anwendungsbereiche anzeigt.

```
void EnablePaneMenu(
    BOOL bEnable,
    UINT uiCustomizeCmd,
    const CString& strCustomizeLabel,
    UINT uiViewToolbarsMenuEntryID,
    BOOL bContextMenuShowsToolbarsOnly=FALSE,
    BOOL bViewMenuShowsToolbarsOnly=FALSE);
```

### <a name="parameters"></a>Parameter

*bEnable*<br/>
in TRUE gibt an, dass die automatische Behandlung des Bereichs Menüs aktiviert ist. FALSE gibt an, dass die automatische Handhabung deaktiviert ist.

*uicustomizecmd*<br/>
in Befehls-ID des Menü Elements " **Anpassen** ". Dieses Menü Element wird in der Regel am Ende der Liste der Bereiche hinzugefügt.

*strCustomizeLabel*<br/>
in Der Text, der für das Menü Element **Anpassen** (für die Lokalisierung) angezeigt werden soll.

*uiViewToolbarsMenuEntryID*<br/>
in Gibt die ID eines Symbolleisten-Menü Elements an, das das Menübereich öffnet. Normalerweise ist dies das unter Menü " **Symbolleisten** " im Menü **Ansicht** .

*bContextMenuShowsToolbarsOnly*<br/>
in Wenn true, zeigt das Menübereich nur eine Liste von Symbolleisten an. Wenn der Wert false ist, zeigt das Menü eine Liste von Symbolleisten und Andock leisten an.

*bViewMenuShowsToolbarsOnly*<br/>
in Wenn true, zeigt das Menübereich nur eine Liste von Symbolleisten an. Wenn der Wert false ist, zeigt das Menü eine Liste von Symbolleisten und Andock leisten an.

### <a name="remarks"></a>Hinweise

Das Popup Menü Menü zeigt die Liste der Anwendungsbereiche an und ermöglicht dem Benutzer das Anzeigen oder Ausblenden einzelner Bereiche.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `EnablePaneMenu` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#9](../../mfc/codesnippet/cpp/cmdiframewndex-class_9.cpp)]

##  <a name="enablewindowsdialog"></a>CMDIFrameWndEx:: enablewindowsdialog

Fügt ein Menü Element ein, dessen Befehls-ID ein [cmfcwindowsmanagerdialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md) -Dialogfeld aufruft.

```
void EnableWindowsDialog(
    UINT uiMenuId,
    LPCTSTR lpszMenuText,
    BOOL bShowAllways=FALSE,
    BOOL bShowHelpButton=FALSE);

void EnableWindowsDialog(
    UINT uiMenuId,
    UINT uiMenuTextResId,
    BOOL bShowAllways=FALSE,
    BOOL bShowHelpButton=FALSE);
```

### <a name="parameters"></a>Parameter

*uiMenuId*<br/>
in Gibt die Ressourcen-ID eines Menüs an.

*lpszMenuText*<br/>
in Gibt den Text des Elements an.

*bShowHelpButton*<br/>
in Gibt an, ob eine **Hilfe** Schaltfläche im Dialogfeld Windows-Verwaltung angezeigt werden soll.

*uiMenuTextResId*<br/>
in Der Zeichen folgen Ressourcen Bezeichner, der die Text Zeichenfolge des Elements enthält.

### <a name="remarks"></a>Hinweise

Verwenden Sie diese Methode, um ein Menü Element einzufügen, dessen Befehl ein MDI-Dialogfeld für die untergeordnete Fensterverwaltung ( [cmfcwindowsmanagerdialog-Klasse](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)) aufruft. Das neue Element wird in das durch *uimenuid*angegebene Menü eingefügt. Wird `EnableWindowsDialog` aufgerufen, wenn Sie die WM_CREATE-Nachricht verarbeiten.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `EnableWindowsDialog` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#10](../../mfc/codesnippet/cpp/cmdiframewndex-class_10.cpp)]

##  <a name="getactivepopup"></a>CMDIFrameWndEx:: getactivepopup

Gibt einen Zeiger auf das aktuell angezeigte Popupmenü zurück.

```
CMFCPopupMenu* GetActivePopup() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf das aktive Popupmenü. NULL, wenn kein Popup Menü aktiv ist.

### <a name="remarks"></a>Hinweise

Verwenden Sie diese Funktion, um einen Zeiger auf das [cmfcpopupmenu-Klassen](../../mfc/reference/cmfcpopupmenu-class.md) Objekt zu erhalten, das momentan angezeigt wird.

##  <a name="getdefaultresid"></a>CMDIFrameWndEx:: getdefaultresid

Gibt die ID der freigegebenen Ressourcen für das MDI-Rahmen Fenster zurück.

```
UINT GetDefaultResId() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Ressourcen-ID-Wert. 0, wenn das Rahmen Fenster keine Menüleiste hat.

### <a name="remarks"></a>Hinweise

Diese Methode gibt die Ressourcen-ID zurück, die angegeben wurde, als das MDI-Rahmen Fenster von [CFrameWnd:: LoadFrame](../../mfc/reference/cframewnd-class.md#loadframe)geladen wurde.

##  <a name="getmditabgroups"></a>CMDIFrameWndEx:: getmditabgroups

Gibt eine Liste von MDI-Fenstern im Registerkarten Format zurück.

```
const CObList& GetMDITabGroups() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Verweis auf ein [CObList-Klassen](../../mfc/reference/coblist-class.md) Objekt, das eine Liste von Fenstern im Registerkarten Format enthält. Speichern oder ändern Sie die Liste nicht.

### <a name="remarks"></a>Hinweise

Verwenden Sie diese Methode, um auf die Liste der Fenster im Registerkarten Format zuzugreifen. Dies kann hilfreich sein, wenn Sie einige Parameter von einzelnen Fenstern im Registerkarten Format ändern oder Abfragen möchten.

##  <a name="getmditabs"></a>CMDIFrameWndEx:: getmditabs

Gibt einen Verweis auf das unterstrichene Fenster im Register Format zurück.

```
CMFCTabCtrl& GetMDITabs();
```

### <a name="return-value"></a>Rückgabewert

Ein Verweis auf das unterstrichene Fenster im Registerkarten Format.

##  <a name="getmditabscontextmenualloweditems"></a>CMDIFrameWndEx:: getmditabscontextmenuzugewiesene weditems

Gibt eine Kombination von Flags zurück, die bestimmt, welche Vorgänge gültig sind, wenn die MDI-Funktion mit Registerkarten für Gruppen aktiviert ist.

```
DWORD GetMDITabsContextMenuAllowedItems();
```

### <a name="return-value"></a>Rückgabewert

Eine bitweise OR-Kombination der folgenden Flags:

- BCGP_MDI_CREATE_VERT_GROUP-kann eine vertikale Registerkarten Gruppe erstellen.

- BCGP_MDI_CREATE_HORZ_GROUP-kann eine horizontale Registerkarten Gruppe erstellen.

- BCGP_MDI_CAN_MOVE_PREV: eine Registerkarte kann zur vorherigen Registerkarten Gruppe verschoben werden.

- BCGP_MDI_CAN_MOVE_NEXT: eine Registerkarte kann in die nächste Registerkarten Gruppe verschoben werden.

### <a name="remarks"></a>Hinweise

Wenn die MDI-Funktion für Registerkarten im Registerkarten Format aktiviert ist, müssen Sie wissen, welche Vorgänge auf den Registerkarten eines bestimmten Fensters zulässig sind. Diese Methode analysiert das aktuelle Layout von Fenstern im Registerkarten Format und gibt eine Kombination von Flags zurück, die verwendet werden können, um z. b. ein Kontextmenü zu erstellen.

Sie können eine neue vertikale Registerkarten Gruppe erstellen, wenn alle Fenster im Register Format vertikal ausgerichtet sind oder wenn nur ein Fenster im Registerkarten Format vorhanden ist.

Sie können eine neue horizontale Registerkarten Gruppe erstellen, wenn alle Fenster im Registerkarten Format horizontal ausgerichtet sind oder wenn nur ein Fenster im Registerkarten Format vorhanden ist.

Sie können eine Registerkarte nur in die vorherige Gruppe verschieben, wenn mehrere Registerkarten in einem Fenster im Registerkarten Format vorhanden sind.

Sie können eine Registerkarte nur dann in die nächste Gruppe verschieben, wenn mehr als eine Registerkarte in einem Fenster im Registerkarten Format vorhanden ist.

##  <a name="getmenubar"></a>CMDIFrameWndEx:: getmenubar

Gibt einen Zeiger auf ein Menüleisten Objekt zurück, das an das Rahmen Fenster angefügt ist.

```
const CMFCMenuBar* GetMenuBar() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf ein Menüleisten Objekt.

##  <a name="getpane"></a>CMDIFrameWndEx:: GetPane

Gibt einen Zeiger auf den Bereich zurück, der die angegebene Steuerelement-ID aufweist.

```
CBasePane* GetPane(UINT nID);
```

### <a name="parameters"></a>Parameter

*nID*<br/>
in Die Steuerelement-ID.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf den Bereich, der über die angegebene Steuerelement-ID verfügt, sofern vorhanden. Andernfalls NULL.

##  <a name="getribbonbar"></a>CMDIFrameWndEx:: getribbonbar

Ruft das Menü Band leisten-Steuerelement für den Frame ab.

```
CMFCRibbonBar* GetRibbonBar();
```

### <a name="return-value"></a>Rückgabewert

Zeiger auf die [CMFCRibbonBar-Klasse](../../mfc/reference/cmfcribbonbar-class.md) für den Frame.

### <a name="remarks"></a>Hinweise

##  <a name="gettearoffbars"></a>CMDIFrameWndEx:: gettearoffbars

Gibt eine Liste von abtrenn Menüs zurück.

```
const CObList& GetTearOffBars() const;
```

### <a name="return-value"></a>Rückgabewert

Ein Verweis auf ein [CObList-Klassen](../../mfc/reference/coblist-class.md) Objekt, das eine Auflistung von Zeigern auf `CPane`von abgeleitete-Objekte enthält, die sich in einem deaktivierten Zustand befinden.

### <a name="remarks"></a>Hinweise

`CMDIFrameWndEx`verwaltet eine Auflistung von abtrenn Menüs. Verwenden Sie diese Methode, um einen Verweis auf diese Liste abzurufen.

##  <a name="gettoolbarbuttontooltiptext"></a>CMDIFrameWndEx:: gettoolbarbuttontooltiptext

Wird von Framework aufgerufen, wenn die Anwendung die QuickInfo für eine Symbolleisten-Schaltfläche anzeigt.

```
virtual BOOL GetToolbarButtonToolTipText(
    CMFCToolBarButton* pButton,
    CString& strTTText);
```

### <a name="parameters"></a>Parameter

*pButton*<br/>
in Ein Zeiger auf eine Symbolleisten Schaltfläche.

*strTTText*<br/>
in Der QuickInfo-Text, der für die Schaltfläche angezeigt wird.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die QuickInfo angezeigt wird. Andernfalls false.

### <a name="remarks"></a>Hinweise

##  <a name="insertpane"></a>CMDIFrameWndEx:: insertpane

Registriert den angegebenen Bereich beim Docking-Manager.

```
BOOL InsertPane(
    CBasePane* pControlBar,
    CBasePane* pTarget,
    BOOL bAfter=TRUE);
```

### <a name="parameters"></a>Parameter

*pControlBar*<br/>
in Ein Zeiger auf den Bereich, der eingefügt werden soll.

*pTarget*<br/>
in Ein Zeiger auf den Bereich vor oder nach dem der Bereich eingefügt werden soll.

*bAfter*<br/>
in TRUE gibt an, dass *pcontrolbar* nach " *pTARGET*" eingefügt wird. Wenn false, wird *pcontrolbar* vor *pTARGET*eingefügt.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die Methode den Bereich erfolgreich registriert hat, false, wenn der Bereich bereits beim Docking-Manager registriert wurde.

### <a name="remarks"></a>Hinweise

Verwenden Sie diese Methode, um dem Docking-Manager über einen von *pcontrolbar angegebenen Bereich*zu informieren. Der Andock-Manager richtet diesen Bereich entsprechend der Ausrichtung und Position des Bereichs in der internen Liste des Docking Managers aus.

##  <a name="isfullscreen"></a>CMDIFrameWndEx:: IsFullScreen

Bestimmt, ob sich das Rahmen Fenster im Vollbildmodus befindet.

```
BOOL IsFullScreen() const;
```

### <a name="return-value"></a>Rückgabewert

TRUE, wenn sich das Rahmen Fenster im Vollbildmodus befindet. andernfalls false.

### <a name="remarks"></a>Hinweise

Sie können den Vollbildmodus festlegen, indem Sie die [CMDIFrameWndEx:: enablefullscreenmode](#enablefullscreenmode) -Methode aufrufen.

##  <a name="ismditabbedgroup"></a>CMDIFrameWndEx:: ismditabbedgroup

Gibt an, ob die MDI-Funktion für Gruppen im Registerkarten Format aktiviert ist.

```
BOOL IsMDITabbedGroup() const;
```

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die MDI-Funktion für Gruppen im Registerkarten Format aktiviert ist. andernfalls false.

### <a name="remarks"></a>Hinweise

Verwenden Sie [CMDIFrameWndEx:: aremditabs](#aremditabs), um zu bestimmen, ob reguläre MDI-Registerkarten oder die MDI-Funktion mit Registerkarten im Registerkarten Format aktiviert ist.

##  <a name="ismemberofmditabgroup"></a>CMDIFrameWndEx:: ismembership ofmditabgroup

Bestimmt, ob das angegebene Fenster im Register Format in der Liste der Fenster enthalten ist, die in MDI-Gruppen im Registerkarten Format enthalten sind.

```
BOOL IsMemberOfMDITabGroup(CWnd* pWnd);
```

### <a name="parameters"></a>Parameter

*pWnd*<br/>
in Ein Zeiger auf ein Fenster im Registerkarten Format.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn das angegebene Fenster im Register Format in der Liste der Fenster im Registerkarten Format enthalten ist, die MDI-Gruppen im Registerkarten Format bilden. Andernfalls false.

##  <a name="ismenubaravailable"></a>CMDIFrameWndEx:: ismenubaravailable

Bestimmt, ob das Rahmen Fenster über eine Menüleiste verfügt.

```
BOOL IsMenuBarAvailable() const;
```

### <a name="return-value"></a>Rückgabewert

TRUE, wenn der Zeiger auf das Menüleisten Objekt nicht NULL ist. andernfalls false.

##  <a name="ispointneardocksite"></a>CMDIFrameWndEx:: ispointneardocksite

Bestimmt, ob sich ein angegebener Punkt in der Nähe des Dock Standorts befindet

```
BOOL IsPointNearDockSite(
    CPoint point,
    DWORD& dwBarAlignment,
    BOOL& bOuterEdge) const;
```

### <a name="parameters"></a>Parameter

*point*<br/>
in Der angegebene Punkt in Bildschirm Koordinaten.

*dwBarAlignment*<br/>
in Gibt an, an welchem Rand sich der Punkt nähert. Mögliche Werte sind CBRS_ALIGN_LEFT, CBRS_ALIGN_RIGHT, CBRS_ALIGN_TOP und CBRS_ALIGN_BOTTOM.

*bOuterEdge*<br/>
in TRUE, wenn sich der Punkt in der Nähe des äußeren Rahmens der Dock Site befindet. Andernfalls false.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn sich der Punkt in der Nähe der Dock Site befindet. andernfalls false.

### <a name="remarks"></a>Hinweise

Der Punkt befindet sich in der Nähe der Dock Site, wenn er sich innerhalb der Vertraulichkeits Gruppe im Docking-Manager befindet. Die Standard Sensitivität beträgt 15 Pixel.

##  <a name="isprintpreview"></a>CMDIFrameWndEx:: isprintpreview

Bestimmt, ob sich das Rahmen Fenster im Druckvorschau Modus befindet.

```
BOOL IsPrintPreview();
```

### <a name="return-value"></a>Rückgabewert

TRUE, wenn sich das Rahmen Fenster im Druck-Vorschaumodus befindet. andernfalls false.

### <a name="remarks"></a>Hinweise

##  <a name="loadframe"></a>CMDIFrameWndEx:: LoadFrame

Erstellt ein Rahmen Fenster anhand von Ressourcen Informationen.

```
virtual BOOL LoadFrame(
    UINT nIDResource,
    DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
    CWnd* pParentWnd = NULL,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>Parameter

*nIDResource*<br/>
in Die ID einer freigegebenen Ressource, die mit dem Rahmen Fenster verknüpft ist.

*dwDefaultStyle*<br/>
in Der Stil des Rahmen Fensters.

*pParentWnd*<br/>
in Ein Zeiger auf das übergeordnete Element des Frames.

*pContext*<br/>
in Ein Zeiger auf eine [ckreatecontext-Struktur](../../mfc/reference/ccreatecontext-structure.md). Dieser Parameter kann NULL sein.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die Methode erfolgreich ist, andernfalls false.

##  <a name="loadmdistate"></a>CMDIFrameWndEx:: loadmdistate

Lädt das angegebene Layout der MDI-Gruppen im Registerkarten Format und die Liste der zuvor geöffneten Dokumente.

```
virtual BOOL LoadMDIState(LPCTSTR lpszProfileName);
```

### <a name="parameters"></a>Parameter

*lpszProfileName*<br/>
in Gibt den Namen des Profils an.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn der Ladevorgang erfolgreich war. FALSE, wenn der Ladevorgang fehlgeschlagen ist oder keine zu ladenden Daten vorhanden sind.

### <a name="remarks"></a>Hinweise

Gehen Sie folgendermaßen vor, um den Status von MDI-Registerkarten und-Gruppen und die Liste der geöffneten Dokumente zu laden oder zu speichern:

- [CMDIFrameWndEx:: savemdistate](#savemdistate) beim Schließen des Hauptrahmens abrufen

- Wenn der Hauptframe erstellt wird, wird [CMDIFrameWndEx:: loadmdistate](#loadmdistate) aufgerufen. Für diesen Aufruf wird empfohlen, dass der Hauptframe zum ersten Mal angezeigt wird. Fügen `CWinAppEx::EnableLoadWindowPlacement` Sie `(FALSE);` vor demhinzu`CBCGPWorkspace::ReloadWindowPlacement` fügen nachdem`LoadMDIState` -Befehl hinzu, um den Hauptframe an der in der Registrierung gespeicherten Position anzuzeigen. `(pMainFrame);` `pMainFrame->LoadFrame (IDR_MAINFRAME);.`

- Über `GetDocumentName` schreiben Sie `CMDIChildWndEx`in der von abgeleiteten Klasse, wenn in der Anwendung Dokumente angezeigt werden, die nicht als Dateien gespeichert sind. Die zurückgegebene Zeichenfolge wird in der Registrierung als Dokument Bezeichner gespeichert. Die Basis Implementierung von [CMDIChildWndEx:: getdocumentname](../../mfc/reference/cmdichildwndex-class.md#getdocumentname) gibt einen Wert zurück, der aus [CDocument:: getPathname](../../mfc/reference/cdocument-class.md#getpathname)abgerufen wurde.

- Überschreiben Sie [CMDIFrameWndEx:: deatedocumentwindow](#createdocumentwindow) , um Dokumente ordnungsgemäß zu erstellen, wenn Sie aus der Registrierung geladen werden. Der erste Parameter ist die Zeichenfolge `GetDocumentName` , die zurückgegeben wurde.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `LoadMDIState` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#11](../../mfc/codesnippet/cpp/cmdiframewndex-class_11.cpp)]

##  <a name="mditabmovetonextgroup"></a>CMDIFrameWndEx:: mditabmuvetonextgroup

Verschiebt die aktive Registerkarte aus dem momentan aktiven Fenster im Registerkarten Format in die nächste oder vorherige Gruppe im Registerkarten Format.

```
void MDITabMoveToNextGroup(BOOL bNext=TRUE);
```

### <a name="parameters"></a>Parameter

*bnext*<br/>
in Wenn true, verschieben Sie die Registerkarte in die nächste Gruppe im Registerkarten Format. Wenn der Wert false ist, verschieben Sie ihn in die vorherige Gruppe im Registerkarten Format.

##  <a name="mditabnewgroup"></a>CMDIFrameWndEx:: mditabnewgroup

Erstellt eine neue Gruppe mit Registerkarten, die über ein einzelnes Fenster verfügt.

```
void MDITabNewGroup(BOOL bVert=TRUE);
```

### <a name="parameters"></a>Parameter

*bVert*<br/>
in Gibt die neue Gruppen Ausrichtung an. TRUE gibt an, dass die neue Gruppe vertikal ausgerichtet wird. Wenn der Wert false ist, wird die neue Gruppe horizontal ausgerichtet.

### <a name="remarks"></a>Hinweise

Verwenden Sie diese Funktion, um ein neues Fenster im Registerkarten Format (neue Gruppe im Registerkarten Format) zu erstellen und die erste Registerkarte hinzuzufügen.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `MDITabNewGroup` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#12](../../mfc/codesnippet/cpp/cmdiframewndex-class_12.cpp)]

##  <a name="m_bcancovertcontrolbartomdichild"></a>CMDIFrameWndEx:: m_bCanCovertControlBarToMDIChild

Gibt an, ob Docking Bereiche in untergeordnete MDI-Fenster konvertiert werden können.

```
BOOL m_bCanCovertControlBarToMDIChild;
```

### <a name="remarks"></a>Hinweise

Gibt an, ob andockbare Steuer leisten in untergeordnete MDI-Fenster konvertiert werden können. Wenn dieses Flag true ist, verarbeitet das Framework die Konvertierung automatisch, wenn der Benutzer den Befehl im **Register** Kartenformat auswählt. Das-Flag ist geschützt, und Sie müssen diese Option explizit aktivieren, `m_bCanCovertControlBarToMDIChild` indem Sie in einem Konstruktor `CMDIFrameWndEx`einer von abgeleiteten `CanConvertControlBarToMDIChild`Klasse festlegen oder indem Sie überschreiben.

Der Standardwert ist `FALSE`.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `m_bCanCovertControlBarToMDIChild` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#13](../../mfc/codesnippet/cpp/cmdiframewndex-class_2.cpp)]

##  <a name="m_bdisablesetredraw"></a>CMDIFrameWndEx:: m_bDisableSetRedraw

Aktiviert oder deaktiviert die neuzeichnungs Optimierung für untergeordnete MDI-Fenster.

```
AFX_IMPORT_DATA static BOOL m_bDisableSetRedraw;
```

### <a name="remarks"></a>Hinweise

Der Standardwert ist "true".

Legen Sie dieses Flag auf false fest, wenn Sie das erneute Zeichnen von untergeordneten MDI-Elementen optimieren möchten. In diesem Fall ruft `SetRedraw (FALSE)` das Framework für den Hauptframe auf, wenn die Anwendung die aktive Registerkarte ändert.

Dieses Flag kann unerwünschte Effekte (z. b. Hintergrundanwendungen, die sichtbar werden) verursachen. Daher wird empfohlen, den Standardwert nur dann zu ändern, wenn beim Aktivieren der MDI-Registerkarte ein merkbares Flimmern fest steht.

##  <a name="negotiateborderspace"></a>CMDIFrameWndEx:: aushandateborderspace

Aushandiert einen Rahmen Bereich in einem Rahmen Fenster während der OLE-direkten Aktivierung.

```
virtual BOOL NegotiateBorderSpace(
    UINT nBorderCmd,
    LPRECT lpRectBorder);
```

### <a name="parameters"></a>Parameter

*nBorderCmd*<br/>
in Enthält einen der folgenden Werte aus der `CFrameWnd::BorderCmd`-Enumeration:

- `borderGet` = 1

- `borderRequest` = 2

- `borderSet` = 3

*lpRectBorder*<br/>
[in, out] Ein Zeiger auf eine [Rect-Struktur](/windows/win32/api/windef/ns-windef-rect) oder ein [CRect-Klassen](../../atl-mfc-shared/reference/crect-class.md) Objekt, das die Koordinaten des Rahmens angibt.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn die Methode erfolgreich war. andernfalls 0.

### <a name="remarks"></a>Hinweise

Diese Methode ist eine Implementierung der OLE-Border-Space-Aushandlung.

##  <a name="onclosedockingpane"></a>CMDIFrameWndEx:: onclosedockingpane

Wird von Framework aufgerufen, wenn der Benutzer auf die Schaltfläche **Schließen** in einem andockbaren Bereich klickt.

```
virtual BOOL OnCloseDockingPane(CDockablePane* pWnd);
```

### <a name="parameters"></a>Parameter

*pWnd*<br/>
in Zeiger auf den Bereich, der geschlossen wird.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn der Andock Bereich geschlossen werden kann. Andernfalls false.

### <a name="remarks"></a>Hinweise

Überschreiben Sie diese Methode, um das Ausblenden von Docking Bereichen zu behandeln. Wenn Sie verhindern möchten, dass ein andockbarer Bereich ausgeblendet wird, wird false zurückgegeben.

Die Standard Implementierung führt keine Aktion aus und gibt true zurück.

##  <a name="oncloseminiframe"></a>CMDIFrameWndEx:: oncloseminiframe

Wird von Framework aufgerufen, wenn der Benutzer auf die Schaltfläche **Schließen** in einem unverankerten Mini Rahmen Fenster klickt.

```
virtual BOOL OnCloseMiniFrame(CPaneFrameWnd*);
```

### <a name="parameters"></a>Parameter

*pWnd*<br/>
in Zeiger auf das zu schließende Mini Rahmen Fenster.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn das unverankerte Mini Rahmen Fenster geschlossen werden kann. Andernfalls false.

### <a name="remarks"></a>Hinweise

Überschreiben Sie diese Methode, um das Ausblenden von Gleit Komma-Mini Frame Fenstern zu behandeln. Wenn Sie verhindern möchten, dass ein unverankertes Mini Rahmen Fenster ausgeblendet wird, wird false zurückgegeben.

Die Standard Implementierung führt keine Aktion aus und gibt true zurück.

##  <a name="onclosepopupmenu"></a>CMDIFrameWndEx:: onclosepopupmenu

Wird vom Framework aufgerufen, wenn ein aktives Popupmenü eine WM_DESTROY-Meldung verarbeitet.

```
virtual void OnClosePopupMenu(CMFCPopupMenu* pMenuPopup);
```

### <a name="parameters"></a>Parameter

*pMenuPopup*<br/>
in Zeiger auf ein Popupmenü.

### <a name="remarks"></a>Hinweise

Überschreiben Sie diese Methode, wenn Sie Benachrichtigungen von [cmfcpopupmenu-Klassen](../../mfc/reference/cmfcpopupmenu-class.md) Objekten verarbeiten möchten, die dem MDI-Rahmen Fenster angehören, wenn diese Objekte WM_DESTROY-Nachrichten verarbeiten.

##  <a name="oncmdmsg"></a>CMDIFrameWndEx:: OnCmdMsg

Wird von Framework aufgerufen, um Befehls Meldungen weiterzuleiten und zu verteilen und Befehls Benutzeroberflächen Objekte zu aktualisieren.

```
virtual BOOL OnCmdMsg(
    UINT nID,
    int nCode,
    void* pExtra,
    AFX_CMDHANDLERINFO* pHandlerInfo);
```

### <a name="parameters"></a>Parameter

*nID*<br/>
in Die Befehls-ID.

*nCode*<br/>
in Identifiziert den Befehls Benachrichtigungs Code. Weitere Informationen zu den Werten für *nCode*finden Sie unter [CCmdTarget:: OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg) .

*pExtra*<br/>
in Wird gemäß dem Wert von *nCode*verwendet. Weitere Informationen zu *pextra*finden Sie unter [CCmdTarget:: OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg) .

*pHandlerInfo*<br/>
[in, out] In der Regel sollte dieser Parameter NULL sein. Wenn nicht NULL, `OnCmdMsg` füllt die `pTarget` -und `pmf` -Member der *phandlerinfo* -Struktur aus, anstatt den Befehl zu verteilen.

### <a name="return-value"></a>Rückgabewert

Ungleich 0 (null), wenn die Meldung verarbeitet wird. andernfalls 0.

##  <a name="ondrawmenuimage"></a>CMDIFrameWndEx:: ondrawmenuimage

Wird vom Framework aufgerufen, wenn das einem Menüelement zugeordnete Bild gezeichnet wird.

```
virtual BOOL OnDrawMenuImage(
    CDC* pDC,
    const CMFCToolBarMenuButton* pMenuButton,
    const CRect& rectImage);
```

### <a name="parameters"></a>Parameter

*pDC*<br/>
in Zeiger auf einen Gerätekontext.

*pMenuButton*<br/>
in Zeiger auf die Menü Schaltfläche.

*rectImage*<br/>
in Begrenzungs Rechteck des Bilds.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die Methode das Bild zeichnet. Die Standard Implementierung gibt false zurück.

### <a name="remarks"></a>Hinweise

Überschreiben Sie diese Methode, wenn Sie das Bild Rendering für die Menü Elemente anpassen möchten, die zur Menüleiste gehören `CMDIFrameWndEx`, die das von abgeleitete Objekt besitzt. Bei der Standardimplementierung wird keine Aktion ausgeführt.

##  <a name="ondrawmenulogo"></a>CMDIFrameWndEx:: ondrawmenulogo

Wird von Framework aufgerufen, wenn ein [cmfcpopupmenu](../../mfc/reference/cmfcpopupmenu-class.md)eine WM_PAINT-Meldung verarbeitet.

```
virtual void OnDrawMenuLogo(
    CDC*,
    CMFCPopupMenu*,
    const CRect&);
```

### <a name="remarks"></a>Hinweise

Überschreiben Sie diese Funktion, um ein Logo im Popup Menü anzuzeigen, das zur Menüleiste gehört, die im `CMDIFrameWndEx`Besitz des von abgeleiteten Objekts ist. Bei der Standardimplementierung wird keine Aktion ausgeführt.

##  <a name="onerasemdiclientbackground"></a>CMDIFrameWndEx:: onerasemdiclientbackground

Wird von Framework aufgerufen, wenn das MDI-Rahmen Fenster eine WM_ERASEBKGND-Nachricht verarbeitet.

```
virtual BOOL OnEraseMDIClientBackground(CDC*);
```

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die Anwendung die Nachricht verarbeitet und den Hintergrund löscht.

### <a name="remarks"></a>Hinweise

Überschreiben Sie diese Member-Funktion, wenn Sie die WM_ERASEBKGND-Nachricht `CMDIFrameWndEx`in einer von abgeleiteten Klasse verarbeiten möchten.

##  <a name="onmenubuttontoolhittest"></a>CMDIFrameWndEx:: onmenubuttontoolhittest

Wird von Framework aufgerufen, wenn ein [cmfctoolbarbutton](../../mfc/reference/cmfctoolbarbutton-class.md)-Objekt eine WM_NCHITTEST-Nachricht verarbeitet.

```
virtual BOOL OnMenuButtonToolHitTest(
    CMFCToolBarButton* pButton,
    TOOLINFO* pTI);
```

### <a name="parameters"></a>Parameter

*pButton*<br/>
in Die Symbolleisten Schaltfläche.

*pTI*<br/>
vorgenommen Zeiger auf eine [toolinfo](/windows/win32/api/commctrl/ns-commctrl-toolinfow) -Struktur.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die Anwendung den *PTI* -Parameter füllt. Die Standard Implementierung gibt false zurück.

### <a name="remarks"></a>Hinweise

Überschreiben Sie diese Methode, wenn Sie der QuickInfo Informationen zu bestimmten Menü Elementen bereitstellen möchten. Bei der Standardimplementierung wird keine Aktion ausgeführt.

##  <a name="onmoveminiframe"></a>CMDIFrameWndEx:: onmoveminiframe

Wird von Framework aufgerufen, um ein Mini Rahmen Fenster zu verschieben.

```
virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
```

### <a name="parameters"></a>Parameter

*pFrame*<br/>
in Ein Zeiger auf ein Mini Rahmen Fenster.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die Methode erfolgreich ist, andernfalls false.

##  <a name="onsetpreviewmode"></a>CMDIFrameWndEx:: onsetpreviewmode

Legt den Druck-Vorschaumodus der Anwendung fest.

```
virtual void OnSetPreviewMode(
    BOOL bPreview,
    CPrintPreviewState* pState);
```

### <a name="parameters"></a>Parameter

*bPreview*<br/>
in Wenn true, wird der Druck-Vorschaumodus festgelegt. Wenn false, wird der Vorschaumodus abgebrochen.

*pState*<br/>
in Ein Zeiger auf eine `CPrintPreviewState` -Struktur.

### <a name="remarks"></a>Hinweise

Diese Methode überschreibt [CFrameWnd:: onsetpreviewmode](../../mfc/reference/cframewnd-class.md#onsetpreviewmode).

##  <a name="onshowcustomizepane"></a>CMDIFrameWndEx:: onshowcustomizepane

Wird von Framework aufgerufen, wenn ein Bereich für die schnelle Anpassung aktiviert wird.

```
virtual BOOL OnShowCustomizePane(
    CMFCPopupMenu* pMenuPane,
    UINT uiToolbarID);
```

### <a name="parameters"></a>Parameter

*pMenuPane*<br/>
in Ein Zeiger auf den Bereich für die schnelle Anpassung.

*uiToolbarID*<br/>
in Die Steuerelement-ID der zu anpassenden Symbolleiste.

### <a name="return-value"></a>Rückgabewert

Diese Methode gibt immer true zurück.

### <a name="remarks"></a>Hinweise

Der Bereich für die schnelle Anpassung ist ein Menü, das geöffnet wird, wenn der Benutzer auf der Symbolleiste auf **Anpassen** klickt.

Überschreiben Sie diese Methode in einer abgeleiteten Klasse, um Änderungen im Bereich für die schnelle Anpassung vorzunehmen.

##  <a name="onshowmditabcontextmenu"></a>CMDIFrameWndEx:: onshowmditabcontextmenu

Wird von Framework aufgerufen, bevor ein Kontextmenü auf einer der Registerkarten angezeigt wird. Gilt nur für MDI-Gruppen im Registerkarten Format.

```
virtual BOOL OnShowMDITabContextMenu(
    CPoint point,
    DWORD dwAllowedItems,
    BOOL bTabDrop);
```

### <a name="parameters"></a>Parameter

*point*<br/>
in Die Position des Menüs in Bildschirm Koordinaten.

*dwAllowedItems*<br/>
in Eine bitweise OR-Kombination von-Flags, die angibt, welche Aktionen für die aktuelle Registerkarte zulässig sind:

- BCGP_MDI_CREATE_VERT_GROUP-kann eine vertikale Registerkarten Gruppe erstellen.

- BCGP_MDI_CREATE_HORZ_GROUP-kann eine horizontale Registerkarten Gruppe erstellen.

- BCGP_MDI_CAN_MOVE_PREV: eine Registerkarte kann zur vorherigen Registerkarten Gruppe verschoben werden.

- BCGP_MDI_CAN_MOVE_NEXT: eine Registerkarte kann in die nächste Registerkarten Gruppe verschoben werden.

- BCGP_MDI_CAN_BE_DOCKED: schaltet ein Dokument im Registerkarten Format in den angedockten Zustand um (nur für Dokumente im Registerkarten Format).

*bTabDrop*<br/>
in TRUE, wenn das Menü angezeigt werden soll, wenn die Registerkarte auf eine andere Gruppe im Registerkarten Format gezogen wird. FALSE, um das Menü als Kontextmenü auf der derzeit aktiven Registerkarte anzuzeigen.

### <a name="return-value"></a>Rückgabewert

Überschreiben Sie diese Methode in einer von [cbcgpmdiframewnd](../../mfc/reference/cmdiframewndex-class.md)abgeleiteten Klasse.

### <a name="remarks"></a>Hinweise

Wenn Sie nicht verarbeiten `OnShowMDITabContextMenu`, wird das Kontextmenü nicht angezeigt. Diese Funktion wird vom **MFC-Anwendungs-Assistenten** generiert, wenn Sie die MDI-Funktion für Gruppen im Registerkarten Format aktivieren.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `OnShowMDITabContextMenu` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#14](../../mfc/codesnippet/cpp/cmdiframewndex-class_13.cpp)]

##  <a name="onshowpanes"></a>CMDIFrameWndEx:: onshowbereiche

Wird von Framework aufgerufen, um Bereiche anzuzeigen oder auszublenden.

```
virtual BOOL OnShowPanes(BOOL bShow);
```

### <a name="parameters"></a>Parameter

*bShow*<br/>
in TRUE, um Bereiche anzuzeigen, false, um Bereiche auszublenden.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn sich der Zustand der Bereiche aufgrund des Aufrufs dieser Methode ändert, false, wenn sich die Bereiche bereits in dem von *bShow*angegebenen Zustand befinden. Wenn die Bereiche z. b. ausgeblendet sind und *bShow* den Wert false hat, ist der Rückgabewert false.

### <a name="remarks"></a>Hinweise

Die Standard Implementierung entfernt die Symbolleiste aus dem Rahmen Fenster der obersten Ebene.

Wenn [cdockingmanager:: m_bHideDockingBarsInContainerMode](../../mfc/reference/cdockingmanager-class.md#m_bhidedockingbarsincontainermode) den Wert true hat (Standardeinstellung), werden alle andockbaren Bereiche ausgeblendet.

##  <a name="onshowpopupmenu"></a>CMDIFrameWndEx:: onshowpopupmenu

Wird vom Framework aufgerufen, wenn ein Popup Menü geöffnet wird.

```
virtual BOOL OnShowPopupMenu(CMFCPopupMenu*);
```

### <a name="return-value"></a>Rückgabewert

TRUE, wenn das Popup Menü angezeigt werden soll. Andernfalls false. Die Standard Implementierung gibt true zurück.

### <a name="remarks"></a>Hinweise

Überschreiben Sie diese Methode, wenn Sie bei der Aktivierung des Popup Menüs eine spezielle Verarbeitung implementieren möchten. Wenn Sie z. b. reguläre Menü Elemente in Farb Menü Schaltflächen ändern möchten, richten Sie abtrenn leisten ein usw.

Bei der Standardimplementierung wird keine Aktion ausgeführt.

##  <a name="onsizemdiclient"></a>CMDIFrameWndEx:: onsizemdiclient

Wird von Framework aufgerufen, wenn die Größe des Client-MDI-Fensters geändert wird.

```
virtual void OnSizeMDIClient(
    const CRect& rectOld,
    const CRect& rectNew);
```

### <a name="parameters"></a>Parameter

*rectOld*<br/>
in Die aktuelle Größe des MDI-Client Fensters.

*neu (neu)*<br/>
in Die neue Größe des MDI-Client Fensters.

### <a name="remarks"></a>Hinweise

##  <a name="ontearoffmenu"></a>CMDIFrameWndEx:: ontearoffmenu

Wird vom Framework aufgerufen, wenn ein Menü mit abtrennbarer Leiste aktiviert wird.

```
virtual BOOL OnTearOffMenu(
    CMFCPopupMenu* pMenuPopup,
    CPane* pBar);
```

### <a name="parameters"></a>Parameter

*pMenuPopup*<br/>
in Ein Zeiger auf das Popup Menü.

*pBar*<br/>
in Ein Zeiger auf die abtrenn Leiste.

### <a name="return-value"></a>Rückgabewert

TRUE, damit das Popup Menü mit der abzurufenden Leiste aktiviert werden kann. andernfalls false. Der Standardwert ist "true".

### <a name="remarks"></a>Hinweise

Überschreiben Sie diese Funktion, wenn Sie ein spezielles Setup für die abzurufende Leiste implementieren möchten. Bei der Standardimplementierung wird keine Aktion ausgeführt.

##  <a name="onupdateframemenu"></a>CMDIFrameWndEx:: onupdateframemenu

Wird von Framework aufgerufen, um das Frame Menü zu aktualisieren.

```
virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
```

### <a name="parameters"></a>Parameter

*hmenualt*<br/>
in Ein Handle für ein Menü.

##  <a name="panefrompoint"></a>CMDIFrameWndEx::P anefrompoint

Gibt den andockbaren Bereich zurück, der den angegebenen Punkt enthält.

```
CBasePane* PaneFromPoint(
    CPoint point,
    int nSensitivity,
    bool bExactBar,
    CRuntimeClass* pRTCBarType) const;

CBasePane* PaneFromPoint(
    CPoint point,
    int nSensitivity,
    DWORD& dwAlignment,
    CRuntimeClass* pRTCBarType) const;
```

### <a name="parameters"></a>Parameter

*point*<br/>
in Der Punkt (in Bildschirm Koordinaten).

*nsensitivität*<br/>
in Das Fenster Rechteck der einzelnen aktivierten Bereiche wird durch diesen Wert in alle Richtungen vergrößert.

*bExactBar*<br/>
in TRUE gibt an, dass der *nsensitivität* -Parameter ignoriert wird.

*pRTCBarType*<br/>
in Wenn der Wert nicht NULL ist, durchläuft die Methode nur die Bereiche des angegebenen Typs.

*dwAlignment*<br/>
vorgenommen Wenn ein Bereich gefunden wird, gibt dieser Parameter an, welche Seite des Bereichs dem angegebenen Punkt am nächsten ist.

### <a name="return-value"></a>Rückgabewert

Ein Zeiger auf einen andockbaren Bereich oder NULL, wenn kein Steuerelement den durch *Punkt*angegebenen Punkt enthält.

### <a name="remarks"></a>Hinweise

Der-Befehl wird an die [cdockingmanager-Klasse](../../mfc/reference/cdockingmanager-class.md)umgeleitet. Weitere Informationen finden Sie unter [cdockingmanager:: controlbarfrompoint](../../mfc/reference/cdockingmanager-class.md#panefrompoint) .

##  <a name="recalclayout"></a>CMDIFrameWndEx:: Neuberechnung

Wird von Framework aufgerufen, um das Layout des Rahmen Fensters neu zu berechnen.

```
virtual void RecalcLayout(BOOL bNotify = TRUE);
```

### <a name="parameters"></a>Parameter

*bNotify*<br/>
in Bestimmt, ob das aktive direkte Element für das Rahmen Fenster eine Benachrichtigung über die Layoutänderung empfängt. TRUE gibt an, dass das Element benachrichtigt wird. andernfalls false.

### <a name="remarks"></a>Hinweise

Diese Methode überschreibt [CFrameWnd:: neu](../../mfc/reference/cframewnd-class.md#recalclayout).

##  <a name="removepanefromdockmanager"></a>CMDIFrameWndEx:: removepanefromdockmanager

Hebt die Registrierung eines Bereichs auf und entfernt ihn aus dem Docking-Manager.

```
void RemovePaneFromDockManager(
    CBasePane* pControlBar,
    BOOL bDestroy,
    BOOL bAdjustLayout,
    BOOL bAutoHide,
    CBasePane* pBarReplacement);
```

### <a name="parameters"></a>Parameter

*pControlBar*<br/>
in Ein Zeiger auf einen Bereich, der entfernt werden soll.

*bDestroy*<br/>
in TRUE, wenn der entfernte Bereich zerstört werden soll. FALSE, wenn es nicht zerstört werden soll.

*bAdjustLayout*<br/>
in TRUE, wenn das Andock Layout sofort angepasst werden soll. Wenn der Wert false ist, wird die Anpassung nur dann durchgeführt, wenn ein neu zeichnen-Ereignis aus anderen Gründen auftritt (der Benutzer ändert die Größe des Fensters, zieht den Hauptframe, usw.).

*bAutoHide*<br/>
in "True", um den Bereich aus der Liste der Bereiche für das automatische ausblenden zu entfernen. FALSE, um den Bereich aus der Liste der regulären Bereiche zu entfernen.

*pBarReplacement*<br/>
in Ein Zeiger auf einen Bereich, der den entfernten Bereich ersetzt.

### <a name="remarks"></a>Hinweise

Sie müssen jeden Bereich beim Docking-Manager registrieren, um am Docking-Layout teilnehmen zu können. Verwenden Sie [CMDIFrameWndEx:: addpane](#addpane) oder [CMDIFrameWndEx:: insertpane](#insertpane) , um Bereiche zu registrieren.

Verwenden Sie diese Methode, wenn ein Bereich nicht mehr Teil des Andock Layouts des Rahmen Fensters ist.

##  <a name="savemdistate"></a>CMDIFrameWndEx:: savemdistate

Speichert das aktuelle Layout der MDI-Gruppen im Registerkarten Format und die Liste der zuvor geöffneten Dokumente.

```
virtual BOOL SaveMDIState(LPCTSTR lpszProfileName);
```

### <a name="parameters"></a>Parameter

*lpszProfileName*<br/>
in Gibt den Namen des Profils an.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn der Speichervorgang erfolgreich war. FALSE, wenn beim Speichern ein Fehler aufgetreten ist.

### <a name="remarks"></a>Hinweise

Gehen Sie folgendermaßen vor, um den Status von MDI-Registerkarten und-Gruppen und die Liste der geöffneten Dokumente zu laden oder zu speichern:

- Wird `SaveMDIState` aufgerufen, wenn der Hauptrahmen geschlossen wird.

- Wenn der Hauptframe erstellt wird, wird [CMDIFrameWndEx:: loadmdistate](#loadmdistate) aufgerufen. Der empfohlene Speicherort für diesen Aufruf ist, bevor der Hauptframe zum ersten Mal angezeigt wird.

- Anrufen `CWinAppEx::EnableLoadWindowPlacement(FALSE);` vor`pMainFrame->LoadFrame (IDR_MAINFRAME);`

- Aufrufen `CWinAppEx::ReloadWindowPlacement(pMainFrame)` nach`LoadMDIState` , um den Hauptframe an der in der Registrierung gespeicherten Position anzuzeigen.

- Über `GetDocumentName` schreiben Sie `CMDIChildWndEx`in der von abgeleiteten Klasse, wenn in der Anwendung Dokumente angezeigt werden, die nicht als Dateien gespeichert sind. Die zurückgegebene Zeichenfolge wird in der Registrierung als Dokument Bezeichner gespeichert. Weitere Informationen finden Sie unter [CMDIChildWndEx:: getdocumentname](../../mfc/reference/cmdichildwndex-class.md#getdocumentname).

- Überschreiben Sie [CMDIFrameWndEx:: | atedocumentwindow](#createdocumentwindow) , damit Dokumente beim Laden aus der Registrierung ordnungsgemäß erstellt werden. Der-Parameter `CreateDocumentWindow` für ist die Zeichen `GetDocumentName` Folge, die zuvor zurückgegeben wurde.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `SaveMDIState` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#15](../../mfc/codesnippet/cpp/cmdiframewndex-class_14.cpp)]

##  <a name="setprintpreviewframe"></a>CMDIFrameWndEx:: setprintpreviewframe

Legt das Rahmen Fenster der Druckvorschau fest.

```
void SetPrintPreviewFrame(CFrameWnd* pWnd);
```

### <a name="parameters"></a>Parameter

*pWnd*<br/>
in Zeiger auf ein Druck Ansichts Rahmen Fenster.

### <a name="remarks"></a>Hinweise

##  <a name="setuptoolbarmenu"></a>CMDIFrameWndEx:: setuptoolbarmenu

Ändert ein Symbolleisten Objekt, indem dummyelemente durch benutzerdefinierte Elemente ersetzt werden.

```
void SetupToolbarMenu(
    CMenu& menu,
    const UINT uiViewUserToolbarCmdFirst,
    const UINT uiViewUserToolbarCmdLast);
```

### <a name="parameters"></a>Parameter

*menu*<br/>
in Ein Verweis auf ein zu ändernde [CMenu-Klassen](../../mfc/reference/cmenu-class.md) Objekt.

*uiViewUserToolbarCmdFirst*<br/>
in Gibt den ersten benutzerdefinierten Befehl an.

*uiViewUserToolbarCmdLast*<br/>
in Gibt den letzten benutzerdefinierten Befehl an.

##  <a name="showfullscreen"></a>CMDIFrameWndEx:: showFullscreen

Schaltet den Hauptframe vom regulären zum Vollbildmodus.

```
void ShowFullScreen();
```

### <a name="remarks"></a>Hinweise

##  <a name="showpane"></a>CMDIFrameWndEx:: ShowPane

Blendet den angegebenen Bereich ein oder aus.

```
void ShowPane(
    CBasePane* pBar,
    BOOL bShow,
    BOOL bDelay,
    BOOL bActivate);
```

### <a name="parameters"></a>Parameter

*pBar*<br/>
in Ein Zeiger auf den Bereich, der angezeigt oder ausgeblendet werden soll.

*bShow*<br/>
in TRUE, um den Bereich anzuzeigen. FALSE, um den Bereich auszublenden.

*bDelay*<br/>
in TRUE, wenn die Neuberechnung des Andock Layouts verzögert werden soll. FALSE, um das Andock Layout sofort neu zu berechnen.

*bactivate*<br/>
in TRUE, um anzuzeigen, dass der Bereich als aktiv angezeigt werden soll. FALSE, um den Bereich als inaktiv anzuzeigen.

### <a name="remarks"></a>Hinweise

Diese Methode wird aufgerufen, um den Bereich anzuzeigen oder auszublenden. Nicht für andockbare Bereiche verwenden `ShowWindow` .

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `ShowPane` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#16](../../mfc/codesnippet/cpp/cmdiframewndex-class_15.cpp)]

##  <a name="showwindowsdialog"></a>CMDIFrameWndEx:: showwindowsdialog

Erstellt ein [cmfcwindowsmanagerdialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md) -Feld und öffnet es.

```
void ShowWindowsDialog();
```

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `ShowWindowsDialog` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#18](../../mfc/codesnippet/cpp/cmdiframewndex-class_16.cpp)]

##  <a name="tabbeddocumenttocontrolbar"></a>CMDIFrameWndEx:: tabbeddocumentbackcontrolbar

Konvertiert das angegebene Dokument im Registerkarten Format in einen Andock Bereich.

```
virtual BOOL TabbedDocumentToControlBar(CMDIChildWndEx* pMDIChildWnd);
```

### <a name="parameters"></a>Parameter

*pMDIChildWnd*<br/>
Ein Zeiger auf ein untergeordnetes MDI-Fenster, das einen andockbaren Bereich enthält.

### <a name="return-value"></a>Rückgabewert

TRUE, wenn die Methode erfolgreich war, false bei Fehler.

### <a name="remarks"></a>Hinweise

Verwenden Sie diese Methode, um ein Dokument im Registerkarten Format in einen Docking Bereich zu konvertieren. Das Dokument im Registerkarten Format muss mithilfe von [CMDIFrameWndEx:: controlbartotabbeddocument](#controlbartotabbeddocument)erstellt worden sein.

### <a name="example"></a>Beispiel

Im folgenden Beispiel wird gezeigt `TabbedDocumentToControlBar` , wie im visualstudiodemo-Beispielverwendetwird:[ MFC-Visual Studio](../../overview/visual-cpp-samples.md)-Anwendung.

[!code-cpp[NVC_MFC_VisualStudioDemo#19](../../mfc/codesnippet/cpp/cmdiframewndex-class_17.cpp)]

##  <a name="updatecaption"></a>CMDIFrameWndEx:: updatecaption

Wird von Framework aufgerufen, um die Fensterrahmen Beschriftung zu aktualisieren.

```
void UpdateCaption();
```

### <a name="remarks"></a>Hinweise

##  <a name="updatemditabbedbarsicons"></a>CMDIFrameWndEx:: updatemditabbedbarsicons

Legt das Symbol für jedes MDI-Fenster im Registerkarten Format fest.

```
void UpdateMDITabbedBarsIcons();
```

##  <a name="winhelp"></a>CMDIFrameWndEx:: WinHelp

Wird vom Framework aufgerufen, um die WinHelp-Anwendung oder die Kontexthilfe zu initiieren.

```
virtual void WinHelp(
    DWORD dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>Parameter

*dwData*<br/>
in Gibt Daten an, die für den von *ncmd*angegebenen Hilfstyp erforderlich sind.

*nCmd*<br/>
in Gibt den Typ der angeforderten Hilfe an. Eine Liste möglicher Werte und deren Auswirkung auf den *dwdata* -Parameter finden Sie unter der [WinHelp-Funktion](/windows/win32/api/winuser/nf-winuser-winhelpw) im Windows SDK.

### <a name="remarks"></a>Hinweise

Diese Methode überschreibt [CWnd::WinHelp](../../mfc/reference/cwnd-class.md#winhelp).

## <a name="see-also"></a>Siehe auch

[Hierarchiediagramm](../../mfc/hierarchy-chart.md)<br/>
[Klassen](../../mfc/reference/mfc-classes.md)<br/>
[CMDIFrameWnd](../../mfc/reference/cframewnd-class.md)<br/>
[CMDIChildWndEx-Klasse](../../mfc/reference/cmdichildwndex-class.md)
