---
title: 1.3 Ausführungsmodell
ms.date: 11/04/2016
ms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716
ms.openlocfilehash: 291bf71159cc681916d19649cfa12298d0929cc3
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/31/2018
ms.locfileid: "50491572"
---
# <a name="13-execution-model"></a>1.3 Ausführungsmodell

OpenMP verwendet das Fork / Join-Modell der parallelen Ausführung. Obwohl dieses Fork / Join-Modell zur Lösung verschiedener Probleme hilfreich sein kann, ist es eher für große Array-basierte Anwendungen zugeschnitten. OpenMP ist vorgesehen, Support-Programme, die korrekt sowohl als parallele (mehrere Ausführungsthreads und eine vollständige Bibliothek von OpenMP-Unterstützung) Programme ausgeführt wird und wie sequenzielle Programme (Anweisungen ignoriert, und eine einfache OpenMP-Stubs-Bibliothek). Allerdings es ist möglich und zulässig, um ein Programm zu entwickeln, die Codefunktionen bei sequenzieller Ausführung nicht ordnungsgemäß verhält. Darüber hinaus können verschiedene Grade der Parallelität aufgrund von Änderungen an der Zuordnung von numerischen Operationen verschiedene numerische Ergebnisse führen. Z. B. möglicherweise eine Verringerung der seriellen außerdem ein anderes Muster von Zuordnungen hinzufügen, als eine parallele Reduzierung. Diese anderen Zuordnungen können es sich um die Ergebnisse der gleitkommaaddition ändern.

Ein Programm geschrieben, mit der OpenMP-C-/C++-API startet die Ausführung als einzelner Thread der Ausführung mit der Bezeichnung der *master-Thread*. Die master-Thread wird bis das erste parallele-Konstrukt in einer seriellen Region ausgeführt. In der OpenMP-C-/C++-API die **parallele** Richtlinie stellt eine parallele Konstrukt dar. Bei ein paralleles Konstrukts auftreten der master-Thread erstellt, ein Team von Threads, und der Master wird master des Teams. Jeder Thread im Team, das die Anweisungen in der dynamischen Wertebereich eines parallelen Bereichs ist, mit Ausnahme der Arbeitsteilungskonstrukte ausgeführt. Arbeitsteilungskonstrukte müssen von allen Threads im Team, das in der gleichen Reihenfolge auftreten und die Anweisungen in einem zugehörigen strukturierten Block von einer oder mehreren Threads ausgeführt werden. Die Grenze, die am Ende eines Konstrukts ohne Freigabe von Arbeit impliziert eine `nowait` -Klausel von allen Threads im Team, das ausgeführt wird.

Wenn ein Thread auf ein freigegebenes Objekt ändert, wird nicht nur ihrer eigenen ausführungsumgebung, sondern auch die anderen Threads in der Anwendung beeinträchtigt. Die Änderung ist garantiert abgeschlossen ist, aus der Perspektive eines anderen Threads, am nächsten Sequenz (wie in der Basissprache definiert) werden nur dann, wenn das Objekt als flüchtig deklariert ist. Andernfalls wird die Änderung abgeschlossen sein, nach dem ersten thread die ändern, garantiert und anschließend (oder parallel) auftreten, die anderen Threads eine **leeren** -Direktive, die das Objekt (entweder implizit oder explizit) angibt. Hinweis: Wenn die **leeren** Direktiven, die durch andere OpenMP-Anweisungen impliziert werden sind nicht ausreichend, um sicherzustellen, dass die gewünschte Reihenfolge der Nebeneffekte, die es dem Programmierer ist dafür verantwortlich, geben Sie zusätzliche, explizite  **leeren** Anweisungen.

Nach Abschluss das parallele Konstrukt wird die Threads im Team synchronisieren, um eine implizite Barriere, und nur die master-Thread wird die Ausführung fortgesetzt. Eine beliebige Anzahl von parallelen Konstrukten kann in einem einzelnen Programm angegeben werden. Daher kann ein Programm erstellen Sie eine Verzweigung und verknüpfen oft während der Ausführung.

OpenMP C-/C++-API ermöglicht es Programmierern, verwenden Sie die Anweisungen in Funktionen, die aus den parallelen Konstrukten aufgerufen. Anweisungen, die erscheinen nicht im lexikalischen Block eines parallelen Konstrukts jedoch möglicherweise liegen in der dynamischen Block heißen *verwaiste* Anweisungen. Verwaiste Anweisungen bieten Programmierer die Möglichkeit, wichtige Teile ihres Programms parallel mit nur minimalen Änderungen an das Programm sequenziell ausgeführt werden. Mithilfe dieser Funktion können Benutzer den parallele Konstrukten auf den oberen Ebenen der Aufrufstruktur der Anwendung code und verwenden Direktiven, um die Ausführung in der aufgerufenen Funktionen zu steuern.

Nicht synchronisierte Aufrufe von C- und C++ ausgegeben, dass Funktionen, die in der gleichen Datei Schreiben in Ausgabe führen können, in dem Daten geschrieben, wenn unterschiedliche Threads nicht deterministischen Reihenfolge angezeigt wird. Auf ähnliche Weise können nicht synchronisierte Aufrufe von Funktionen zu geben, die von der gleichen Datei gelesen, Daten in nicht deterministischen Reihenfolge lesen. Nicht synchronisierte Verwenden von e/a, so, dass jeder Thread eine andere Datei, greift auf die gleichen Ergebnisse wie die serielle Ausführung der e/a-Funktionen erstellt.