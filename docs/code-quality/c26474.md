---
title: C26474
ms.date: 08/11/2020
ms.topic: conceptual
f1_keywords:
- C26474
helpviewer_keywords:
- C26474
ms.assetid: 1e23a8e6-97fa-47f5-a279-b52aa2efafa4
ms.openlocfilehash: 91e3e5f9d84491d82366a0b125853de271c57173
ms.sourcegitcommit: 8140647370017b885432349ce89f187c3068b46a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/12/2020
ms.locfileid: "88144151"
---
# <a name="c26474-no_implicit_cast"></a>C26474 NO_IMPLICIT_CAST

"Keine Umwandlung zwischen Zeiger Typen, wenn die Konvertierung implizit sein könnte."

**C++ Core Guidelines**: \
Type. 1: Vermeiden von Umwandlungen

In einigen Fällen sind implizite Umwandlungen zwischen Zeiger Typen sicher und erfordern nicht, dass Sie einen bestimmten Umwandlungs Ausdruck schreiben müssen. Mit dieser Regel werden die Instanzen unnötiger Umwandlungen gefunden, die Sie sicher entfernen können.

## <a name="remarks"></a>Bemerkungen

Die Regel-ID sollte so interpretiert werden, dass eine implizite Umwandlung nicht verwendet wird, wenn Sie zulässig ist.

Diese Regel gilt nur für Zeiger. Es überprüft statische Umwandlungen und interpretiert Umwandlungen neu.

Diese Fälle sind akzeptable Zeiger Konvertierungen, die keine expliziten Umwandlungs Ausdrücke verwenden sollten:
- Konvertierung in `nullptr_t` ;
- Konvertierung in `void*` ;
- Konvertierung eines abgeleiteten Typs in seine Basis, wenn eine Basiselement Funktion aufgerufen wird, die nicht vom abgeleiteten Typ ausgeblendet ist. 

## <a name="example-1"></a>Beispiel 1

Eine unnötige Konvertierung verbirgt einen logischen Fehler in diesem Beispiel:

```cpp
template<class T>
bool register_buffer(T buffer) {
    auto p = reinterpret_cast<void*>(buffer); // C26474, also 26490 NO_REINTERPRET_CAST
    // To fix, declare buffer as T*, and use this to define p:
    // auto p = buffer;
    return buffers_.insert(p).second;
}

void merge_bytes(std::uint8_t *left, std::uint8_t *right)
{
    if (left && register_buffer(*left)) { // Unintended dereference!
        // ...
        if (right && register_buffer(right)) {
            // ...
        }
    }
}
```

## <a name="example-2"></a>Beispiel 2

Dieses Beispiel veranschaulicht die Verwendung von Umwandlungen für den Zugriff auf die Funktionen der Basisklasse.

```cpp
struct struct_1
{
    void foo();
    void bar();
};

struct struct_2 : struct_1
{
    void foo(); // this definition hides struct_1::foo
};

void fn(struct_2* ps2)
{
    static_cast<struct_1*>(ps2)->foo(); // This cast is necessary to access struct_1::foo
                                        // Alternatively, use ps2->struct_1::foo();
    static_cast<struct_1*>(ps2)->bar(); // This cast is unnecessary and can be done implicitly
}
```
