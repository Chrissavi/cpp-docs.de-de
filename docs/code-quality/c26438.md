---
title: C26438
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26438
helpviewer_keywords:
- C26438
ms.assetid: c7b3f59c-fb2f-4816-bda4-0fad23c80d83
ms.openlocfilehash: 655b22f3a39b7f97d02ec27a3f1e5e93524e444f
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/27/2020
ms.locfileid: "87233872"
---
# <a name="c26438-no_goto"></a>C26438 NO_GOTO

"Vermeiden **`goto`** ".

**C++ Core Guidelines**: \
ES. 76: Vermeiden von "goto"

Die Verwendung von **`goto`** ist weitgehend gefährlich und fehleranfällig. Dies ist nur in generiertem Code akzeptabel, z. b. in einem von einer Grammatik generierten Parser. Mit modernen C++-Funktionen und-Hilfsprogrammen, die von der Guidelines-Unterstützungs Bibliothek bereitgestellt werden, sollte es ganz einfach zu vermeiden sein **`goto`** .

## <a name="remarks"></a>Bemerkungen

- Diese Regel warnt vor jedem Vorkommen von **`goto`** , auch wenn Sie in einem unzustellbaren Code auftritt, mit Ausnahme von Vorlagen Code, der niemals verwendet und folglich vom Compiler ignoriert wird.
- Warnungen können multipliziert werden, wenn ein Makro enthält **`goto`** . Aktuelle Berichterstattungs Mechanismen zeigen auf alle Instanzen, bei denen ein solches Makro erweitert wird. Sie kann häufig an einem Ort korrigiert werden, indem das Makro geändert wird, oder es wird vermieden, dass die Verwendung besser verwallegbar ist.

## <a name="example"></a>Beispiel

"goto Cleanup" in Makro

```cpp
#define ENSURE(E, L) if (!(E)) goto L;

void poll(connection &c)
{
    ENSURE(c.open(), end);                  // C26438

    while (c.wait())
    {
        connection::header h{};
        connection::signature s{};
        ENSURE(c.read_header(h), end);      // C26438
        ENSURE(c.read_signature(s), end);   // C26438
        // ...
    }

end:
    c.close();
}
```

"goto Cleanup" in einem Makro ersetzt durch "gsl:: endlich"

```cpp
void poll(connection &c)
{
    auto end = gsl::finally([&c] { c.close(); });

    if (!c.open())
        return;

    while (c.wait())
    {
        connection::header h{};
        connection::signature s{};
        if(!c.read_header(h))
            return;
       if(!c.read_signature(s))
            return;
        // ...
    }
}
```
